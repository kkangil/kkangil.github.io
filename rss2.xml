<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kkangil&#39;s Blog</title>
    <link>https://kkangil.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>공부와 유익한 개발 정보들을 기록하기 위한 블로그입니다.</description>
    <pubDate>Sun, 13 Sep 2020 07:22:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>컴포지션과 파이프라인</title>
      <link>https://kkangil.github.io/2020/09/13/%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EA%B3%BC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/</link>
      <guid>https://kkangil.github.io/2020/09/13/%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EA%B3%BC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/</guid>
      <pubDate>Sun, 13 Sep 2020 04:31:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;함수형 컴포지션(functional composition) 이란 간단히 함수형 프로그래밍에서 컴포지션이라 일컫는다.&lt;br&gt;컴포지션 아이디어의 이론과 간단한 예제를 살펴본 후 compose 함수를 작성해본다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>함수형 컴포지션(functional composition) 이란 간단히 함수형 프로그래밍에서 컴포지션이라 일컫는다.<br>컴포지션 아이디어의 이론과 간단한 예제를 살펴본 후 compose 함수를 작성해본다.</p><a id="more"></a><h2 id="함수형-컴포지션"><a href="#함수형-컴포지션" class="headerlink" title="함수형 컴포지션"></a>함수형 컴포지션</h2><h3 id="map-filter-다시-살펴보기"><a href="#map-filter-다시-살펴보기" class="headerlink" title="map, filter 다시 살펴보기"></a>map, filter 다시 살펴보기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addressBooks = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">title</span>: <span class="string">"C# 6.0"</span>, <span class="attr">author</span>: <span class="string">"ANDREW TROELSEN"</span>, <span class="attr">rating</span>: [<span class="number">4.7</span>], <span class="attr">reviews</span>: [&#123;<span class="attr">good</span>: <span class="number">4</span>, <span class="attr">excellent</span>: <span class="number">12</span>&#125;]&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">222</span>, <span class="attr">title</span>: <span class="string">"Efficient Learning Machines"</span>, <span class="attr">author</span>: <span class="string">"Rahul Khanna"</span>, <span class="attr">rating</span>: [<span class="number">4.5</span>], <span class="attr">reviews</span>: []&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">333</span>, <span class="attr">title</span>: <span class="string">"Pro Angular JS"</span>, <span class="attr">author</span>: <span class="string">"Adam Freeman"</span>, <span class="attr">rating</span>: [<span class="number">4.0</span>], <span class="attr">reviews</span>: []&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">444</span>, <span class="attr">title</span>: <span class="string">"Pro ASP.NET"</span>, <span class="attr">author</span>: <span class="string">"Adam Freeman"</span>, <span class="attr">rating</span>: [<span class="number">4.2</span>], <span class="attr">reviews</span>: [&#123;<span class="attr">good</span>: <span class="number">14</span>, <span class="attr">excellent</span>: <span class="number">12</span>&#125;]&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>위와 같은 구조의 배열 객체가 있을때 review 값이 4.5 이상인 addressBooks 객체에서 title 과 author 를 뽑아내려고 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function">(<span class="params">array, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">    results.push(fn(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filter = <span class="function">(<span class="params">array, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn(value)) results.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map(filter(addressBooks, book =&gt; book.rating[<span class="number">0</span>] &gt; <span class="number">4.5</span>), book =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">title</span>: book.title, <span class="attr">author</span>: book.author&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    title: "C# 6.0",</span></span><br><span class="line"><span class="comment">    author: "ANDREW TROELSEN"</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>filter 함수에서 온 데이터는 map 함수에 입력 인자로 전달된다.<br>compose 함수를 사용하여 함수의 출력을 다른 함수의 입력으로 전달해 두 함수를 연결하는 함수를 만들 수 있다.</p><h3 id="compose-함수"><a href="#compose-함수" class="headerlink" title="compose 함수"></a>compose 함수</h3><p>compose 함수의 생성은 쉽고 직관적이다. compose 함수는 함수의 출력을 받아 다른 함수에 입력한다.</p><figure class="highlight javascript"><figcaption><span>간단한 compopse 함수 정의</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function"><span class="params">c</span> =&gt;</span> a(b(c))</span><br></pre></td></tr></table></figure><p>compose 함수는 간단하고 필요한 처리를 한다. 두 함수 a와 b를 받아 하나의 인자 c를 갖는 함수를 반환한다.<br>c에 값을 넣어 compose 함수를 호출하면 c의 입력을 갖는 함수 b를 호출하고, 함수 b의 출력은 함수 a의 입력으로 간다.<br>이것이 바로 compose 함수의 정의다.</p><h2 id="compose-함수-다루기"><a href="#compose-함수-다루기" class="headerlink" title="compose 함수 다루기"></a>compose 함수 다루기</h2><p>주어진 수를 반올림한다고 해보자. 이 수는 실수이므로, 수를 실수형으로 변환한 후 Math.rorund 를 호출한다.<br>compose 없이 다음과 같이 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="built_in">parseFloat</span>(<span class="string">"3.56"</span>);</span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Math</span>.round(data);</span><br></pre></td></tr></table></figure><p>위에서 보듯이 data 는 Math.round 에 입력으로 전달된다. 이를 compose 함수를 사용하면 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = compose(<span class="built_in">Math</span>.round, <span class="built_in">parseFloat</span>);</span><br><span class="line"><span class="comment">// number = c =&gt; Math.round(parseFloat(c))</span></span><br></pre></td></tr></table></figure><p>이것이 바로 함수형 컴포지션이다. 두 함수를 구성해 새로운 함수를 구현했다.<br>여기서 중요한 것은 Math.round 와 parseFloat 함수는 number 함수가 호출되기 전까지 실행되지 않는다.</p><h3 id="구원자-curry와-partial"><a href="#구원자-curry와-partial" class="headerlink" title="구원자: curry와 partial"></a>구원자: curry와 partial</h3><p>함수가 하나의 인자를 입력으로 취할 때 두 함수를 합성할 수 있다. 하지만 여러 인자를 갖는 함수가 있으므로 항상 그렇지는 않다.<br>이러한 함수는 curry와 partial 함수 중 하나를 사용해 합성할 수 있다.</p><p>위에서 addressBooks 의 평점 코드를 다시 확인해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(filter(addressBooks, book =&gt; book.rating[<span class="number">0</span>] &gt; <span class="number">4.5</span>), book =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">title</span>: book.title, <span class="attr">author</span>: book.author&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>map 과 filter 함수 모두 두 인자를 취하는 함수다. 첫 번째 인자는 배열이고 두 번째 인자는 이 배열을 연산하는 함수다.<br>따라서 이 두 함수를 직접 합성할 수는 없다. </p><p>하지만 partial 함수에서 도움을 받을 수 있다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addressBooks = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">title</span>: <span class="string">"C# 6.0"</span>, <span class="attr">author</span>: <span class="string">"ANDREW TROELSEN"</span>, <span class="attr">rating</span>: [<span class="number">4.7</span>], <span class="attr">reviews</span>: [&#123;<span class="attr">good</span>: <span class="number">4</span>, <span class="attr">excellent</span>: <span class="number">12</span>&#125;]&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">222</span>, <span class="attr">title</span>: <span class="string">"Efficient Learning Machines"</span>, <span class="attr">author</span>: <span class="string">"Rahul Khanna"</span>, <span class="attr">rating</span>: [<span class="number">4.5</span>], <span class="attr">reviews</span>: []&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">333</span>, <span class="attr">title</span>: <span class="string">"Pro Angular JS"</span>, <span class="attr">author</span>: <span class="string">"Adam Freeman"</span>, <span class="attr">rating</span>: [<span class="number">4.0</span>], <span class="attr">reviews</span>: []&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">444</span>, <span class="attr">title</span>: <span class="string">"Pro ASP.NET"</span>, <span class="attr">author</span>: <span class="string">"Adam Freeman"</span>, <span class="attr">rating</span>: [<span class="number">4.2</span>], <span class="attr">reviews</span>: [&#123;<span class="attr">good</span>: <span class="number">14</span>, <span class="attr">excellent</span>: <span class="number">12</span>&#125;]&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filterOutStandingBooks = <span class="function"><span class="params">book</span> =&gt;</span> book.rating[<span class="number">0</span>] === <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> filterGoodBooks = <span class="function"><span class="params">book</span> =&gt;</span> book.rating[<span class="number">0</span>] &gt; <span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">let</span> filterBadBooks = <span class="function"><span class="params">book</span> =&gt;</span> book.rating[<span class="number">0</span>] &lt; <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> projectTitleAndAuthor = <span class="function"><span class="params">book</span> =&gt;</span> (&#123;<span class="attr">title</span>: book.title, <span class="attr">author</span>: book.author&#125;);</span><br><span class="line"><span class="keyword">let</span> projectAuthor = <span class="function"><span class="params">book</span> =&gt;</span> (&#123;<span class="attr">author</span>: book.author&#125;);</span><br><span class="line"><span class="keyword">let</span> projectTitle = <span class="function"><span class="params">book</span> =&gt;</span> (&#123;<span class="attr">title</span>: book.title&#125;);</span><br></pre></td></tr></table></figure><p>위 코드와 같이 rating 을 기반으로 도서를 필터링하는 여러 작은 함수와 결과를 도출해내는 함수를 만들었다.<br>이제 문제를 해결하는 데 다음과 같이 compose 와 partial 을 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queryGoodBooks = partial(filter, <span class="literal">undefined</span>, filterGoodBooks);</span><br><span class="line"><span class="keyword">let</span> mapTitleAndAuthor = partial(map, <span class="literal">undefined</span>, projectTitleAndAuthor);</span><br><span class="line"><span class="keyword">let</span> titleAndAuthorForGoodBooks = compose(mapTitleAndAuthor, queryGoodBooks);</span><br></pre></td></tr></table></figure><p>compose 함수는 하나의 인자를 갖는 함수를 합성한다. 하지만 filter 와 map 둘 다 인자 두 개를 취하고, 직접적으로 이를 합성할 수 없다.</p><p>여기서 보듯이 이것이 바로 map 과 filter 의 두 번째 인자에 부분적으로 적용하고자 partial 함수를 사용한 이유다.<br>이제 compose 함수를 사용하여 반환된 함수를 실행하여 결과를 확인한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">titleAndAuthorForGoodBooks(addressBooks);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    title: "C# 6.0",</span></span><br><span class="line"><span class="comment">    author: "ANDREW TROELSEN"</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>compose 함수 없이도 원하는 것을 정확히 얻을 수 있었다. 하지만 최종 합성된 버전인 titleAndAuthorForGoodBooks 는 훨씬 가독성이 높고 간결하다.<br>필요에 따라 compose 를 사용해 재구성할 수 있는 작은 함수 단위를 생성하는 것이 중요하다.</p><h3 id="여러-함수-합성"><a href="#여러-함수-합성" class="headerlink" title="여러 함수 합성"></a>여러 함수 합성</h3><p>현재 compose 함수 형태는 주어진 두 함수만 합성한다. compose 를 다시 작성하여 함수가 세 개, 네 개 이상 합성해보려 한다.</p><p>각 함수의 출력을 다른 함수의 입력으로 전달해야 한다고 해보자. n개의 함수 호출을 한 번으로 축소하는 reduce 함수를 사용해 compose 함수를 작성해본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduce = <span class="function">(<span class="params">array, fn, initialValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> accumlator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initialValue !== <span class="literal">undefined</span>) accumlator = initialValue;</span><br><span class="line">  <span class="keyword">else</span> accumlator = array[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (initialValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">      accumlator = fn(accumlator, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">      accumlator = fn(accumlator, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> accumlator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">value</span> =&gt;</span> reduce(fns.reverse(), (acc, fn) =&gt; fn(acc), value);</span><br></pre></td></tr></table></figure><p>fns.reverse() 를 통해 함수 배열을 뒤집고, acc 값을 인자로 전달하면 각 함수에서 다른 함수로 호출하는<br>(acc, fn) =&gt; fn(acc) 로 함수를 전달한다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> splitIntoSpaces = <span class="function"><span class="params">str</span> =&gt;</span> str.split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">let</span> count = <span class="function"><span class="params">array</span> =&gt;</span> array.length;</span><br><span class="line"><span class="keyword">const</span> countWords = _compose(count, splitIntoSpaces);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countWords(<span class="string">"hello your reading about composition"</span>)) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oddOrEven = <span class="function"><span class="params">ip</span> =&gt;</span> ip % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">"even"</span> : <span class="string">"odd"</span>;</span><br><span class="line"><span class="keyword">const</span> oddOrEvenWords = _compose(oddOrEven, count, splitIntoSpaces);</span><br><span class="line"><span class="built_in">console</span>.log(oddOrEvenWords(<span class="string">"hello your reading about composition"</span>)); <span class="comment">// "odd"</span></span><br></pre></td></tr></table></figure><h2 id="파이프라인과-시퀀스"><a href="#파이프라인과-시퀀스" class="headerlink" title="파이프라인과 시퀀스"></a>파이프라인과 시퀀스</h2><p>함수가 오른쪽부터 먼저 실행돼 가장 왼쪽의 함수가 마지막으로 실행될 때까지 다음 함수에 데이터를 전달하므로,<br>compose 의 데이터 플로우가 오른쪽에서 왼쪽임을 살펴봤다.</p><p>일부 사람은 가장 왼쪽의 함수가 먼저 실행되고 오른쪽 함수가 마지막에 실행되는 방법을 선호한다.<br>compose 함수와 동일한 동작을 하지만 데이터 플로우가 반대인 pipe 라는 새로운 함수를 구현할 것이다.</p><blockquote><p>데이터를 왼쪽에서 오른쪽으로 이동하는 과정을 파이프라인 또는 짝수 시퀀스(even sequences) 라 부른다.<br>파이프 라인이나 시퀀스라고 편하게 부를 수도 있다.</p></blockquote><h3 id="파이프-구현"><a href="#파이프-구현" class="headerlink" title="파이프 구현"></a>파이프 구현</h3><p>pipe 함수는 compose 함수의 복제 형태다. 변경된 부분은 데이터 플로우 뿐이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">value</span> =&gt;</span> reduce(fns, (acc,fn) =&gt; fn(acc), value);</span><br></pre></td></tr></table></figure><p>compose 와의 차이는 reverse 함수를 쓰지 않는다는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">value</span> =&gt;</span> reduce(fns, (acc,fn) =&gt; fn(acc), value);</span><br><span class="line"><span class="keyword">const</span> oddOrEvenWords = pipe(splitIntoSpaces, count, oddOrEven);</span><br><span class="line"><span class="built_in">console</span>.log(oddOrEvenWords(<span class="string">"hello your reading about composition"</span>)); <span class="comment">// "odd"</span></span><br></pre></td></tr></table></figure><h3 id="컴포지션은-결합-법칙이-성립한다"><a href="#컴포지션은-결합-법칙이-성립한다" class="headerlink" title="컴포지션은 결합 법칙이 성립한다."></a>컴포지션은 결합 법칙이 성립한다.</h3><p>함수형 컴포짓션은 항상 결합 법칙을 따른다. 예를 들어 일반적으로 결합 법칙은 표현의 결과를<br>괄호 순서에 상관없이 동일하게 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x * (y * z) = (x * y) * z = xyz</span><br><span class="line">compose(f, compose(g, h)) == compose(compose(f, g), h)</span><br></pre></td></tr></table></figure><p>함수형 컴포지션은 결합이 가능하다. 따라서 compose 를 결합해 함수를 그룹화할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> countWords = compose(count, splitIntoSpaces);</span><br><span class="line"><span class="keyword">let</span> oddOrEvenWords = compose(oddOrEven, countWords);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> countOddOrEven = compose(oddOrEven, count);</span><br><span class="line"><span class="keyword">let</span> oddOrEvenWords = compose(countOddOrEven, splitIntoSpaces);</span><br></pre></td></tr></table></figure><p>작은 함수를 생성하는 것은 컴포지션의 핵심이다. compose 는 결합할 수 있으므로 동일한 결과로 걱정 없이<br>컴포지션을 통해 작은 함수를 생성할 수 있다.</p><h3 id="파이프라인-연산자"><a href="#파이프라인-연산자" class="headerlink" title="파이프라인 연산자"></a>파이프라인 연산자</h3><p>기본 함수를 합성하고 연결하는 또 다른 방법은 파이프라인 연산자를 사용하는 것이다.<br>새로운 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Pipeline_operator">파이프라인 연산자</a>는 자바스크립트 함수 코드의 가독성과 확장성을 높인다.</p><p>단일 문자열 인자를 연산하는 다음 수학 함수를 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> increment = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ntimes = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure><p>모든 숫자로 이 함수를 호출하려면 일반적으로 다음 문장을 작성해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntimes(double(increment(double(double(<span class="number">5</span>)))));</span><br></pre></td></tr></table></figure><p>위의 결과 값은 1764 이다. 이 문장의 문제는 가독성인데, 연산자의 시퀀스와 연산자의 개수는 가독성을 떨어뜨린다.<br>코드 가독성을 높이고자 유사한 연산자가 추가됐다. 이 연산자의 이름은 파이프라인(또는 이항 연산자) 이며 <code>|&gt;</code> 이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> |&gt; double |&gt; double |&gt; increment |&gt; double |&gt; ntimes</span><br></pre></td></tr></table></figure><p>파이프라인 연산자가 단항 함수에서만 동작하지만, 다항 인자 함수에서도 사용할 수 있는 방법이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">let</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x + x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파이프 연산자 없이</span></span><br><span class="line">add(<span class="number">10</span>, double(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파이프 연산자 사용</span></span><br><span class="line"><span class="number">7</span> |&gt; double |&gt; (<span class="function"><span class="params">_</span> =&gt;</span> add(<span class="number">10</span>, _));</span><br></pre></td></tr></table></figure><h3 id="compose-디버깅"><a href="#compose-디버깅" class="headerlink" title="compose 디버깅"></a>compose 디버깅</h3><p>identity 라는 간단한 함수를 만들어 인자를 받고 동일한 인자를 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity = <span class="function"><span class="params">it</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(it);</span><br><span class="line">  <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단하게 console.log을 추가해 값을 출력하고 이를 다시 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose(oddOrEven, count, splitIntoSpaces)(<span class="string">"Test string"</span>);</span><br></pre></td></tr></table></figure><p>위와 같은 compose 함수가 있다고 했을때 identity 를 플로우 내에 추가하여 디버깅할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose(oddOrEven, count, identity, splitIntoSpaces)(<span class="string">"Test string"</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/09/13/%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EA%B3%BC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>커링과 부분 적용</title>
      <link>https://kkangil.github.io/2020/09/06/%EC%BB%A4%EB%A7%81%EA%B3%BC-%EB%B6%80%EB%B6%84-%EC%A0%81%EC%9A%A9/</link>
      <guid>https://kkangil.github.io/2020/09/06/%EC%BB%A4%EB%A7%81%EA%B3%BC-%EB%B6%80%EB%B6%84-%EC%A0%81%EC%9A%A9/</guid>
      <pubDate>Sun, 06 Sep 2020 06:22:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;커링(currying)이 어떤 의미이며 어디서 사용되는지 이해한 후 부분 적용(partial application) 이라는&lt;br&gt;또 다른 함수형 프로그래밍 개념을 살펴본다. 커링과 부분 적용 모두 함수 합성을 사용할 때 이해해야 한다.&lt;/p&gt;
&lt;h2 id=&quot;용어-정리&quot;&gt;&lt;a href=&quot;#용어-정리&quot; class=&quot;headerlink&quot; title=&quot;용어 정리&quot;&gt;&lt;/a&gt;용어 정리&lt;/h2&gt;&lt;h3 id=&quot;단항-함수&quot;&gt;&lt;a href=&quot;#단항-함수&quot; class=&quot;headerlink&quot; title=&quot;단항 함수&quot;&gt;&lt;/a&gt;단항 함수&lt;/h3&gt;&lt;p&gt;함수 인자를 하나만 취하는 함수를 단항 함수(unary function) 라 한다. &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; identity = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>커링(currying)이 어떤 의미이며 어디서 사용되는지 이해한 후 부분 적용(partial application) 이라는<br>또 다른 함수형 프로그래밍 개념을 살펴본다. 커링과 부분 적용 모두 함수 합성을 사용할 때 이해해야 한다.</p><h2 id="용어-정리"><a href="#용어-정리" class="headerlink" title="용어 정리"></a>용어 정리</h2><h3 id="단항-함수"><a href="#단항-함수" class="headerlink" title="단항 함수"></a>단항 함수</h3><p>함수 인자를 하나만 취하는 함수를 단항 함수(unary function) 라 한다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity = <span class="function"><span class="params">x</span> =&gt;</span> x;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="이항-함수"><a href="#이항-함수" class="headerlink" title="이항 함수"></a>이항 함수</h3><p>두 개의 인자를 취하는 함수를 이항 함수(binary function) 라 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><h3 id="가변-인자-함수"><a href="#가변-인자-함수" class="headerlink" title="가변 인자 함수"></a>가변 인자 함수</h3><p>가변 인자 함수란 다양한 개수의 인자를 취하는 함수다. 이전 자바스크립트 버전에서는<br>arguments 를 사용해 인자의 가변 개수를 알 수 있었다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">variadic</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arguments 를 사용해 추가적인 인자를 알아서 함수로 호출할 수 있다. 이 기술을 사용해 ES5 버전에서<br>가변 인자 함수를 사용할 수 있다. 하지만 ES6 를 사용하면 동일한 결과를 얻는데 전개 연산자(spread operator) 를<br>사용해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> variadic = <span class="function">(<span class="params">a, ...variadic</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(variadic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="커링"><a href="#커링" class="headerlink" title="커링"></a>커링</h2><p>커링을 간단하게 얘기하자면 n개 인자의 함수를 중첩된 단항 함수로 변화시키는 과정이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><p>간단한 add 함수다. 이 함수를 add(1,1) 처럼 사용해 2라는 결과를 도출할 수 있다.<br>아래는 커링된 add 함수 형태이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addCurried = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><p>addCurried 함수는 add 의 커링 버전이다. addCurried 를 단일 인자로 호출하면 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addCurried(<span class="number">4</span>)</span><br><span class="line">=&gt; fn = <span class="function"><span class="params">y</span> =&gt;</span> <span class="number">4</span> + y</span><br></pre></td></tr></table></figure><p>클로저 개념으로 x 값을 가져와 함수를 반환한다.</p><p>원하는 결과를 얻으려면 다음과 같이 addCurried 함수를 호출할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addCurrried(<span class="number">4</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>일부러 add 함수를 변경해 addCurried 함수로 두 개의 인자를 받고 중첩된 단항 함수로 만들었다.<br>두 인자를 취하는 함수에서 하나의 인자를 취하는 함수로 바꾸는 과정을 커링이라고 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="params">binaryFn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">firstArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">secondArg</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> binaryFn(firstArg, secondArg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 curry 함수를 사용해 add 함수를 다음과 같은 형태로 변환할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> autoCurriedAdd = curry(add);</span><br><span class="line">autoCurriedAdd(<span class="number">2</span>)(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>커링은 n 개 인자의 함수를 중첩된 단항 함수로 변환하는 과정이다.</p><p>curry 함수 정의를 살펴보면 이항 함수를 중첩된 함수로 변환해 하나의 인자만 취하므로, 중첩된 단항 함수를 반환한다.</p><h3 id="커링을-사용하는-경우"><a href="#커링을-사용하는-경우" class="headerlink" title="커링을 사용하는 경우"></a>커링을 사용하는 경우</h3><p>테이블을 만드는 함수를 생성한다고 해본다. 예를 들어 tableOf2, tableOf3, tableOf4 를 생성한다.</p><figure class="highlight javascript"><figcaption><span>커링이 없는 테이블 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tableOf2 = <span class="function"><span class="params">y</span> =&gt;</span> <span class="number">2</span> * y;</span><br><span class="line"><span class="keyword">const</span> tableOf3 = <span class="function"><span class="params">y</span> =&gt;</span> <span class="number">3</span> * y;</span><br><span class="line"><span class="keyword">const</span> tableOf4 = <span class="function"><span class="params">y</span> =&gt;</span> <span class="number">4</span> * y;</span><br><span class="line"></span><br><span class="line">tableOf2(<span class="number">4</span>) <span class="comment">// 8</span></span><br><span class="line">tableOf3(<span class="number">4</span>) <span class="comment">// 12</span></span><br><span class="line">tableOf4(<span class="number">4</span>) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>이제 테이블의 개념을 다음과 같이 단일 함수로 일반화 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> genericTable = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x * y;</span><br></pre></td></tr></table></figure><p>다음과 같이 tableOf2 를 얻고자 genericTable 을 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">genericTable(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">genericTable(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">genericTable(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>tableOf3 과 tableOf4 도 동일하다. 패턴을 인식했으면 tableOf2 에는 첫 번째 인자로 2,<br>tableOf3 에는 3처럼 계속 채운다. 커링을 이용해 문제를 해결한다고 생각할 수 있다.</p><figure class="highlight javascript"><figcaption><span>커링을 이용한 테이블 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tableOf2 = curry(genericTable)(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> tableOf3 = curry(genericTable)(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> tableOf4 = curry(genericTable)(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="커링-다시-살펴보기"><a href="#커링-다시-살펴보기" class="headerlink" title="커링 다시 살펴보기"></a>커링 다시 살펴보기</h3><p>앞에서 정의했던 curry 는 함수 하나에만 적용했다. 여러 개의 함수에 적용하는 방법은 간단하지만<br>curry 를 구현하는 데 있어 중요하다. 우선 아래의 코드처럼 첫 번째 규칙을 추가한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curry = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"No function provided"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드에서 2와 같은 정수를 가진 curry 함수를 호출하면 에러가 발생한다.<br>커링된 함수에 다음으로 필요한 것은 커링된 함수에 모든 인자를 제공받았다면<br>전달된 인자로 실제 함수를 호출하는 기능이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curry = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"No function provided"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curriedFn</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 다음과 같은 multiply 라는 하무가 있다면 다음과 같이 새로운 curry 함수를 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">x,y,z</span>) =&gt;</span> x * y * z;</span><br><span class="line">curry(multiply)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line">curry(multiply)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>curry(multiply)(1,2,3) 에서 args 는 [1,2,3] 을 기라키며, fn 에서 apply를 호출하므로<br>결과는 다음 호출과 동등하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiply(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>이제 n개 인자 함수를 중첩된 단항 함수로 변환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curry = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"No function provided"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curriedFn</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...curryArgs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curriedFn.apply(<span class="literal">null</span>, args.concat(curryArgs));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.length &lt; fn.length) &#123; <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...curryArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curriedFn.apply(</span><br><span class="line">      <span class="literal">null</span>, args.concat(curryArgs) <span class="comment">// 3</span></span><br><span class="line">    ); <span class="comment">// 2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드 어떻게 동작하는지 살펴본다.</p><ol><li>…args 를 통해 전달된 인자 길이가 함수 인자 리스트 length 보다 작은지 확인한다. 작다면 if 블록으로 진입하며<br>그렇지 않다면 이전과 같이 전체 함수 호출로 돌아간다.</li><li>if 블록에 들어가면 apply 함수를 사용해 curriedFn 을 재귀적으로 호출한다.</li><li>concat 함수를 사용해 전달된 인자를 한 번에 연결시키고 curriedFn 을 재귀적으로 호출한다. 전달된 모든 인자가<br>연결돼 있고 재귀적으로 호출되므로 1번 조건문에 도달하지 못한다.</li></ol><p>이를 이해하면 curry 함수를 사용해 multiply 함수를 실행할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curry(multiply)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> curriedMul3 = curry(multiply)(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> curriedMul2 = curriedMul3(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> curriedMul1 = curriedMul2(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>주의할 부분은 curry 함수가 n개 인자의 함수를 예제에서 보듯이 단항 함수로 호출되는 함수로 변환한다는 점이다.</p><h2 id="커링의-실제-사용"><a href="#커링의-실제-사용" class="headerlink" title="커링의 실제 사용"></a>커링의 실제 사용</h2><p>일상적으로 커링을 어떻게 사용하는지 알아본다.</p><h3 id="배열-요소에서-숫자-검색"><a href="#배열-요소에서-숫자-검색" class="headerlink" title="배열 요소에서 숫자 검색"></a>배열 요소에서 숫자 검색</h3><p>숫자를 요소로 갖는 배열을 검색해본다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> match = curry(<span class="function"><span class="keyword">function</span>(<span class="params">expr, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.match(expr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>반환된 match 함수는 커링된 함수다. 첫 번째 인자 expr 을 요소가 숫자를 갖고 있는지 확인하는<br>정규 표현식인 /[0-9]+/ 로 나타낼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasNumber = match(<span class="regexp">/[0-9]+/</span>);</span><br></pre></td></tr></table></figure><p>다음으로 커링된 filter 함수를 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filter = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(f);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>hasNumber 와 filter 를 사용해 findNumbersInArray 라는 새로운 함수를 만들 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> findNumbersInArray = filter(hasNumber);</span><br><span class="line">findNumbersInArray([<span class="string">"js"</span>, <span class="string">"number1"</span>]);</span><br><span class="line"><span class="comment">// ["number1"]</span></span><br></pre></td></tr></table></figure><h3 id="배열-제곱"><a href="#배열-제곱" class="headerlink" title="배열 제곱"></a>배열 제곱</h3><p>배열의 요소를 제곱하는 함수를 curry 를 사용해 만들어 본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = curry(<span class="function"><span class="keyword">function</span> (<span class="params">f, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(f);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> squareAll = map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line">squareAll([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><h2 id="데이터-플로우"><a href="#데이터-플로우" class="headerlink" title="데이터 플로우"></a>데이터 플로우</h2><p>배열 같은 자료 구조를 다루면서 최종 인자가 squareAll, findNumbersInArray 와 같은 코드<br>전체에 사용할 수 있는 재사용 가능한 함수를 생성할 수 있게 해야한다.</p><h3 id="부분-적용"><a href="#부분-적용" class="headerlink" title="부분 적용"></a>부분 적용</h3><p>함수 인자를 부분적으로 적용할 수 있는 partial 이라는 다른 함수를 살펴본다.</p><p>10ms 마다 일련의 연산을 처리한다고 가정해본다. 다음과 같이 setTimeout 함수를 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do X task"</span>), <span class="number">10</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do Y task"</span>), <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>보다시피 setTimeout 함수가 호출될 때마다 10을 전달한다. curry 함수는 가장 왼쪽에서 가장 오른쪽의 리스트로<br>인자를 적용하기 때문에 이 문제에 curry 를 사용할 수 없다. 다른 해결 방법은 setTimeout 함수를 감싸 함수 인자의<br>오른쪽이 최우선으로 되게 하는것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setTimeoutWrapper = <span class="function">(<span class="params">time, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(fn, time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> delayTenMs = curry(setTimeoutWrapper)(<span class="number">1000</span>);</span><br><span class="line">delayTenMs(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do X task"</span>));</span><br><span class="line">delayTenMs(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do Y task"</span>));</span><br></pre></td></tr></table></figure><p>이는 필요에 따라 적용된다. 하지만 이 문제는 setTimeoutWrapper 라는 래퍼를 한 단계 위에 작성해야 한다.<br>여기가 부분 적용 기술이 사용되는 곳이다.</p><h3 id="부분-함수-구현"><a href="#부분-함수-구현" class="headerlink" title="부분 함수 구현"></a>부분 함수 구현</h3><p>부분 적용 기술이 어떻게 작동되는지 완전히 이해하기 위해 partial 함수를 작성해본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> partial = <span class="function"><span class="keyword">function</span> (<span class="params">fn, ...partialArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = partialArgs;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...fullArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; args.length &amp;&amp; arg &lt; fullArgs.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (args[i] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        args[i] = fullArgs[arg++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setTimeout 문제에 partial을 적용해본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> delayTenMs = partial(setTimeout, <span class="literal">undefined</span>, <span class="number">10</span>);</span><br><span class="line">delayTenMs(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do Y task"</span>));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partial(setTimeout, <span class="literal">undefined</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다음</span></span><br><span class="line"><span class="keyword">let</span> args = partialArgs</span><br><span class="line">=&gt; args = [<span class="literal">undefined</span>, <span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>args 값을 기억하는 클로저 함수를 반환한다. 반환된 함수는<br>fullArgs 라는 인자를 받고 이 인자를 전달해서 delayTenMs 와 같은 함수를 호출한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delayTenMs(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do Y task"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// fullArgs 는 다음을 가리킨다.</span></span><br><span class="line"><span class="comment">// [() =&gt; console.log("Do Y task")]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 클로저를 사용하는 args 는 다음을 가진다.</span></span><br><span class="line"><span class="comment">// args = [undefined, 10]</span></span><br></pre></td></tr></table></figure><p>이제 for 루프 안에서는 함수에 필요한 인자 배열을 생성하고 반복한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; args.length &amp;&amp; arg &lt; fullArgs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (args[i] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    args[i] = fullArgs[arg++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// args = [undefined, 10]</span></span><br><span class="line"><span class="comment">// fullArgs = [() =&gt; console.log("Do Y task")]</span></span><br><span class="line">args[<span class="number">0</span>] =&gt; <span class="literal">undefined</span> === <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if 루프 내부</span></span><br><span class="line">args[<span class="number">0</span>] = fullArgs[<span class="number">0</span>]</span><br><span class="line">=&gt; args[<span class="number">0</span>] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do Y task"</span>)</span><br><span class="line">=&gt; args = [<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Do Y task"</span>), <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>args 안에 필요한 인자가 있으면 fn.apply(null, args) 로 함수를 호출한다.<br>n개 인자의 모든 함수에 partial 을 적용할 수 있다.</p><p>참조: <a href="http://www.acornpub.co.kr/book/functional-javascript-2e#description">함수형 자바스크립트 입문 2/e</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/09/06/%EC%BB%A4%EB%A7%81%EA%B3%BC-%EB%B6%80%EB%B6%84-%EC%A0%81%EC%9A%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클로저와 고차 함수</title>
      <link>https://kkangil.github.io/2020/08/30/%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/</link>
      <guid>https://kkangil.github.io/2020/08/30/%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/</guid>
      <pubDate>Sun, 30 Aug 2020 07:12:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;함수형 프로그래밍 개념을 알기 전에 자바스크립트에서 클로저를 이해해야 한다.&lt;/p&gt;
&lt;h2 id=&quot;클로저의-이해&quot;&gt;&lt;a href=&quot;#클로저의-이해&quot; class=&quot;headerlink&quot; title=&quot;클로저의 이해&quot;&gt;&lt;/a&gt;클로저의 이해&lt;/h2&gt;&lt;h3 id=&quot;클로저&quot;&gt;&lt;a href=&quot;#클로저&quot; class=&quot;headerlink&quot; title=&quot;클로저&quot;&gt;&lt;/a&gt;클로저&lt;/h3&gt;&lt;p&gt;간단히 얘기해 클로저는 내부 함수다. 내부 함수란 간단히 다음과 같이 다른 함수 내에 있는 함수다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inner&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>함수형 프로그래밍 개념을 알기 전에 자바스크립트에서 클로저를 이해해야 한다.</p><h2 id="클로저의-이해"><a href="#클로저의-이해" class="headerlink" title="클로저의 이해"></a>클로저의 이해</h2><h3 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h3><p>간단히 얘기해 클로저는 내부 함수다. 내부 함수란 간단히 다음과 같이 다른 함수 내에 있는 함수다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>이것이 클로저다. inner 함수를 클로저 함수라고 부른다. 클로저는 스코프 사슬(scope chain) 에 접근할 수 있어 유용하다.<br>기술적으로 클로저는 세 개의 스코프를 갖고 있다.</p><ol><li>자체 선언 내에서 선언된 변수</li><li>전역 변수에 접근</li><li>외부 함수의 변수에 접근</li></ol><p>간단한 예제를 통해 세 부분을 각각 알아본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inner 함수가 호출되면 콘솔에 5가 출력된다. 이는 첫 번째에 살펴본 관점 때문이다. 클로저 함수는 각기 선언된 변수에<br>모두 접근할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> global = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(global);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inner 함수가 실행되면 global 변수가 출력된다. 따라서 클로저는 전역 변수에 접근할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> global = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> outer = <span class="string">"outer"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(outer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inner 함수가 실행되면 outer 값을 출력한다. 적절한 결과인 것 같지만, 클로저의 중요한 속성이다.<br>클로저는 외부 함수의 변수에 접근했다. 여기서 외부 함수는 클로저 함수를 감싸는 함수다.</p><h3 id="어디서부터-생겨났을까"><a href="#어디서부터-생겨났을까" class="headerlink" title="어디서부터 생겨났을까?"></a>어디서부터 생겨났을까?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> outer = <span class="string">"Visible"</span>;</span><br><span class="line">  <span class="keyword">let</span> innerFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(outer);</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> innerFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드는 간단하다. innerFn 은 fn 에 대한 클로저 함수이고, fn 이 호출되면 innerFn 울 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closureFn = fn(<span class="number">5</span>);</span><br><span class="line">closureFn();</span><br><span class="line"><span class="comment">// Visible</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>동작되는 과정을 살펴보면 다음과 같다.</p><ol><li>var closureFn = fn(5); 코드가 호출되면 fn 은 인자 5를 받고 호출된다. fn 정의가 이뤄지면 innerFn 을 반환한다.</li><li>innerFn 이 반환되면 자바스크립트 실행 엔진은 innerFn 을 클로저로 보며, 그에 따라 스코프를 지정한다. 앞에서 살펴 봤듯이 클로저는 세 개의 스코프 레벨에 접근할 수 있다. 반환된 함수 참조는 closureFn 내에 저장된다.</li></ol><h3 id="sortBy-함수-살펴보기"><a href="#sortBy-함수-살펴보기" class="headerlink" title="sortBy 함수 살펴보기"></a>sortBy 함수 살펴보기</h3><figure class="highlight javascript"><figcaption><span>sortBy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortBy = <span class="function">(<span class="params">property</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = (a[property] &lt; b[property]) ? <span class="number">-1</span> :</span><br><span class="line">      (a[property] &gt; b[property]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;<span class="attr">firstname</span>: <span class="string">"lee"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">firstname</span>: <span class="string">"park"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">firstname</span>: <span class="string">"kim"</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(people.sort(sortBy(<span class="string">"firstname"</span>)));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123;firstname: "kim"&#125;,</span></span><br><span class="line"><span class="comment">  &#123;firstname: "lee"&#125;,</span></span><br><span class="line"><span class="comment">  &#123;firstname: "park"&#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.acornpub.co.kr/book/functional-javascript-2e#description">함수형 자바스크립트 입문 2/e</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/08/30/%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>고차 함수</title>
      <link>https://kkangil.github.io/2020/08/30/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/</link>
      <guid>https://kkangil.github.io/2020/08/30/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/</guid>
      <pubDate>Sun, 30 Aug 2020 06:00:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;언어로서의 자바스크르빝는 함수를 데이터로 다룬다. 데이터 영역에서 함수를 전달할 수 있는 강력한 개념도 있다.&lt;br&gt;인자로 다른 함수를 전달받는 함수를 고차 함수라고 한다.&lt;/p&gt;
&lt;h2 id=&quot;데이터의-이해&quot;&gt;&lt;a href=&quot;#데이터의-이해&quot; class=&quot;headerlink&quot; title=&quot;데이터의 이해&quot;&gt;&lt;/a&gt;데이터의 이해&lt;/h2&gt;&lt;p&gt;프로그래머로서 데이터로 동작되는 프로그램을 알아야한다. 데이터는 실행할 프로그램을 작성하는 과정에 있어 중요하다.&lt;br&gt;따라서 모든 프로그래밍 언어는 프로그래머가 작업할 데이터를 제공한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>언어로서의 자바스크르빝는 함수를 데이터로 다룬다. 데이터 영역에서 함수를 전달할 수 있는 강력한 개념도 있다.<br>인자로 다른 함수를 전달받는 함수를 고차 함수라고 한다.</p><h2 id="데이터의-이해"><a href="#데이터의-이해" class="headerlink" title="데이터의 이해"></a>데이터의 이해</h2><p>프로그래머로서 데이터로 동작되는 프로그램을 알아야한다. 데이터는 실행할 프로그램을 작성하는 과정에 있어 중요하다.<br>따라서 모든 프로그래밍 언어는 프로그래머가 작업할 데이터를 제공한다.</p><a id="more"></a><h3 id="자바스크립트-데이터형-이해"><a href="#자바스크립트-데이터형-이해" class="headerlink" title="자바스크립트 데이터형 이해"></a>자바스크립트 데이터형 이해</h3><p>자바스크립트는 다음과 같은 데이터형을 지원한다.</p><ul><li>숫자 number</li><li>문자열 string</li><li>불리언 boolean</li><li>객체 object</li><li>널 null</li><li>정의되지 않은 undefined</li></ul><p>자바스크립트에서는 함수군의 데이터형도 있다. function 데이터형의 경우 string 과 유사하므로, 변수를 전달하고<br>저장 등을 할 수 있다. 함수는 프로그래밍 언어가 다른 데이터형으로 사용하게 허용하게 하는 경우 중요하므로, 변수로 지정되고,<br>인자를 전달하고, 문자열 및 숫자 데이터와 유사하게 다른 함수에서 반환될 수 있다.</p><h3 id="함수-저장"><a href="#함수-저장" class="headerlink" title="함수 저장"></a>함수 저장</h3><p>함수는 데이터다. 즉 변수로 저장할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>fn 은 함수 데이터형을 가리키는 변수다. 다음 코드를 실행해서 fn 이 function 형인 것을 확인할 수 있다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> fn</span><br><span class="line">=&gt; <span class="string">"function"</span></span><br></pre></td></tr></table></figure><h3 id="함수-전달"><a href="#함수-전달" class="headerlink" title="함수 전달"></a>함수 전달</h3><p>인자의 데이터형을 콘솔에 출력하는 함수를 만들어 본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tellType = <span class="function"><span class="params">arg</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> arg);</span><br></pre></td></tr></table></figure><p>tellType 함수에 인자를 하나 전달해본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="number">1</span>;</span><br><span class="line">tellType(data);</span><br><span class="line">=&gt; number</span><br></pre></td></tr></table></figure><p>이번에는 함수에 대한 참조를 변수로 전달해본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataFn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'function'</span>);</span><br><span class="line">tellType(dataFn);</span><br><span class="line">=&gt; <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><p>마지막으로 tellType 이 전달된 인자를 실행하게 변경해본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tellType = <span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> arg === <span class="string">'function'</span>) &#123;</span><br><span class="line">        arg();        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data: '</span>, arg);    </span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전달된 arg 변수가 function 형인지 확인해서 function 형이라면 호출한다.</p><h2 id="함수-반환"><a href="#함수-반환" class="headerlink" title="함수 반환"></a>함수 반환</h2><p>자바스크립트에서 함수는 간단한 데이터이므로, 다른 함수로도 반환이 가능하다.</p><figure class="highlight javascript"><figcaption><span>문자열을 반환하는 crazy 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> crazy = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="built_in">String</span>; &#125;</span><br></pre></td></tr></table></figure><p>crazy 함수는 String 함수를 가리키는 함수 참조를 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crazy();</span><br><span class="line">=&gt; <span class="built_in">String</span>() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure><p>crazy 함수 호출은 String 함수를 반환한다. 단순히 함수 참조를 반환하며, 함수를 실행하지는 않는다.<br>반환된 함수 참조로 다음과 같이 호출할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">let</span> fn = crazy();</span><br><span class="line">fn(<span class="string">"HOC"</span>);</span><br><span class="line">=&gt; <span class="string">"HOC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">crazy()(<span class="string">"HOC"</span>);</span><br><span class="line">=&gt; <span class="string">"HOC"</span></span><br></pre></td></tr></table></figure><h2 id="추상화와-고차-함수"><a href="#추상화와-고차-함수" class="headerlink" title="추상화와 고차 함수"></a>추상화와 고차 함수</h2><p>일반적으로, 고차 함수는 일반적인 문제를 추출하고자 작성된다. 다시 말해 고차 함수는 추상화를 정의하는 것이다.</p><h3 id="고차-함수를-통한-추상화"><a href="#고차-함수를-통한-추상화" class="headerlink" title="고차 함수를 통한 추상화"></a>고차 함수를 통한 추상화</h3><p>forEach 를 고차 함수를 사용하여 만든 예제 코드를 살펴본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forEach = <span class="function">(<span class="params">array, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    fn(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 forEach 함수는 배열을 순회하는 문제를 추상화했다. forEach API 사용자는 forEach 함수에서 순회 부분이<br>어떻게 구현됐는지 이해할 필요가 없으므로, 이 문제를 추상화했다.</p><p>forEach 는 기본적으로 배열을 순회한다.<br>배열 말고 객체를 순회하는 단계는 다음과 같다.</p><ol><li>주어진 객체의 모든 키를 반복</li><li>키에 해당하는 각 객체를 확인</li><li>2단계가 확인되면 키의 값을 얻음.</li></ol><figure class="highlight javascript"><figcaption><span>forEachObject 추상화</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forEachObject = <span class="function">(<span class="params">obj, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(property)) &#123;</span><br><span class="line">      fn(property, obj[property]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>forEachObject 실행</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">forEachObject(object, (k,v) =&gt; <span class="built_in">console</span>.log(k + <span class="string">":"</span> + v));</span><br><span class="line">=&gt; a:<span class="number">1</span></span><br><span class="line">=&gt; b:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>forEach 와 forEachObject 함수 모두 고차 함수이므로, 개발자가 순회 부분을 추상화해 함수를 전달받아 작업할 수 있다.<br>이러한 순회 함수를 추상화했으므로, 간결한 코드로 철저히 테스트할 수 있다.<br>이번에는 제어 흐름을 다루는 추상화 방법을 구현해본다.</p><p>unless 함수는 참이나 거짓인 논리형을 취하는 간단한 함수다.</p><figure class="highlight javascript"><figcaption><span>unless</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unless = <span class="function">(<span class="params">predicate, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!predicate) fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unless 함수를 활용하여 배열에서 짝수를 찾고자 간단한 코드를 작성할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">forEach(array, number =&gt; &#123;</span><br><span class="line">  unless(<span class="function">(<span class="params">number % <span class="number">2</span></span>), <span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(number, <span class="string">' is even'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>데이터를 저장하는 모든 곳에서 함수를 이용할 수 있다. 다시 말해 함수는 저장할 수도, 전달될 수도, 다른 데이터형처럼 재할당될 수도 있다.<br>자바스크립트의 이 강력한 특징은 함수가 다른 함수에 전달되는 고차 함수를 가능케한다. 고차 함수란 다른 함수를 인자로 취하고<br>함수를 반환하는 함수라는 것을 기억해야 한다.</p><p>참조: <a href="http://www.acornpub.co.kr/book/functional-javascript-2e#description">함수형 자바스크립트 입문 2/e</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/08/30/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수형 프로그래밍</title>
      <link>https://kkangil.github.io/2020/08/23/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <guid>https://kkangil.github.io/2020/08/23/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <pubDate>Sun, 23 Aug 2020 06:13:30 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;함수형-프로그래밍이란-무엇이고-왜-중요한가&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍이란-무엇이고-왜-중요한가&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍이란 무엇이고, 왜 중요한가?&quot;&gt;&lt;/a&gt;함수형 프로그래밍이란 무엇이고, 왜 중요한가?&lt;/h2&gt;&lt;p&gt;수학에서 함수란 무엇인가? 수학에서 함수는 다음과 같이 나타낼 수 있다.&lt;/p&gt;
&lt;p&gt;f(X) = Y&lt;/p&gt;
&lt;p&gt;이 수식은 “X 를 인자로 하는 함수 f 가 있으며, 출력 Y 를 반환한다” 라고 할 수 있다. X 와 Y 에는 모든 수가 가능하다.&lt;br&gt;매우 간단한 정의지만 다음과 같은 중요한 점이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수는 인자를 가져야 한다.&lt;/li&gt;
&lt;li&gt;함수는 값을 반환해야 한다.&lt;/li&gt;
&lt;li&gt;함수는 외부가 아닌 자체 인자를 받아서만 동작한다.&lt;/li&gt;
&lt;li&gt;주어진 X 하나에 Y 는 오직 하나다.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="함수형-프로그래밍이란-무엇이고-왜-중요한가"><a href="#함수형-프로그래밍이란-무엇이고-왜-중요한가" class="headerlink" title="함수형 프로그래밍이란 무엇이고, 왜 중요한가?"></a>함수형 프로그래밍이란 무엇이고, 왜 중요한가?</h2><p>수학에서 함수란 무엇인가? 수학에서 함수는 다음과 같이 나타낼 수 있다.</p><p>f(X) = Y</p><p>이 수식은 “X 를 인자로 하는 함수 f 가 있으며, 출력 Y 를 반환한다” 라고 할 수 있다. X 와 Y 에는 모든 수가 가능하다.<br>매우 간단한 정의지만 다음과 같은 중요한 점이 있다.</p><ul><li>함수는 인자를 가져야 한다.</li><li>함수는 값을 반환해야 한다.</li><li>함수는 외부가 아닌 자체 인자를 받아서만 동작한다.</li><li>주어진 X 하나에 Y 는 오직 하나다.</li></ul><a id="more"></a><p>함수형 프로그래밍 기술은 수학에서의 함수와 그 아이디어에서 발생했다. 위 정의를 가져와 자바스크립트 함수 예제를<br>살펴본다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 세금 계산 함수</span></span><br><span class="line"><span class="keyword">var</span> percentValue = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> calculateTax = <span class="function"><span class="params">value</span> =&gt;</span> value / <span class="number">100</span> * (<span class="number">100</span> + percentValue);</span><br></pre></td></tr></table></figure><p>calculateTax 함수의 경우 원하는 계산을 정확히 수행한다. 즉, 값을 통해 이 함수를 호출할 수 있고, 계산된 값을 반환한다.<br>수학에서 함수의 핵심 정의는 함수 논리가 외부에 의존하지 않는다는 점이다. 하지만 calculateTax 함수는 전역 변수인<br>percentValue 에 의존한다. 따라서 이 함수는 수학적으로는 실제 함수라고 할 수 없다. percentValue 변수를 함수 인자로 이동시킨다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculateTax = <span class="function">(<span class="params">value, percentValue</span>) =&gt;</span> value / <span class="number">100</span> * (<span class="number">100</span> + percentValue);</span><br></pre></td></tr></table></figure><p>이제 calculateTax 함수를 실제 함수라 할 수 있다. 수정해서 얻은 것은 calculateTax 함수 안에 있는 전역 변수의 접근을<br>막을 수 있다. 즉, 함수 안에 있는 전역 변수의 접근을 없애 테스팅을 좀 더 쉽게 할 수 있다.</p><p>함수형 프로그래밍이란 각 함수의 입력에 의존해 동작하는 함수를 생성하는 형태다. 이는 함수를 여러 번 호출했을 때도 동일한 결과를 반환할 수 있게 한다.<br>또한 함수 외부의 데이터 변경이 불가하므로 캐시할 수 있고, 테스트할 수 있는 코드를 작성할 수 있게 한다.</p><h2 id="참조-투명성"><a href="#참조-투명성" class="headerlink" title="참조 투명성"></a>참조 투명성</h2><p>함수의 정의에서 모든 함수가 동일한 입력에 대해 동일한 값을 반환받도록 선언했다. 함수의 이러한 속성을 <code>참조 투명성</code> 이라 한다.</p><figure class="highlight javascript"><figcaption><span>참조 투명성 예제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identity = <span class="function"><span class="params">i</span> =&gt;</span> i;</span><br></pre></td></tr></table></figure><p>간단한 identity 함수를 정의헀다. 이 함수는 무조건 입력한 값을 전달받아 반환한다. 이 함수는 입력 인자 i에 의해서만 동작하며, 함수 내의 전역 참조는 없다.<br>이 함수는 참조 투명성 조건을 충족한다.</p><h2 id="명령형-선언형-추상화"><a href="#명령형-선언형-추상화" class="headerlink" title="명령형, 선언형, 추상화"></a>명령형, 선언형, 추상화</h2><p>함수형 프로그래밍은 선언 가능하고, 추상화된 코드 작성에 관한 것이다. 이 두 개념을 이해해야 한다.</p><p>리스트와 배열이 있으며, 배열을 통해 반복적으로 콘솔에 값을 출력한다고 해보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>정상적으로 동작하지만 문제에 접근하려고 구현했는지 정확히 알아야 한다. 예를 들어 배열 길이의 인덱스를 계산하고 내용을 출력하고자 for 문을 암묵적으로 작성했다.<br>여기서 작업은 배열 요소를 출력하는 것이다. 하지만 컴파일러에게 어떤 작업을 해야하는지 알려주는 것처럼 보인다. 이 경우 컴파일러에게 “배열의 길이를 가져온 후 배열을<br>반복하면서 인덱스를 사용해 배열의 각 요소를 얻어오라” 라고 알려주고 있다. 이를 명령형 방법이라 한다. 명령형(imperative) 프로그래밍이란 컴파일러에게 특정 작업을<br>어떻게 해야 하는지 알려주는 것이다.</p><p>선언형(declartive) 프로그래밍에서는 컴파일러가 어떻게 작업해야 하는지보다 어떤 것이 필요한지가 중요하다. “어떻게” 라는 부분은 일반적인 함수내에 추상화된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">array.forEach(<span class="function"><span class="params">element</span> =&gt;</span> <span class="built_in">console</span>.log(element));</span><br></pre></td></tr></table></figure><p>위의 코드는 명령형 코드와 동일한 출력을 보여준다. 하지만 여기서 “배열의 길이를 가져온 후 배열을 반복하면서 인덱스를 사용해 배열의 각 요소를 얻어오라”에서 “어떻게”<br>부분이 생략됐다. 추상화된 함수를 사용해서 개발자가 “어떻게” 라는 부분을 다루고, 직접 문제를 걱정할 필요가 없게 됐다. </p><p>함수형 프로그래밍은 코드의 다른 부분을 재사용하는 추상적인 방법으로 함수를 생성하는 것이다. </p><h2 id="순수-함수"><a href="#순수-함수" class="headerlink" title="순수 함수"></a>순수 함수</h2><p>순수 함수(pure function) 란 주어진 입력에 대해 동일한 출력을 반환하는 함수다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> double = <span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>double 함수는 주어진 입력에 대해 항상 동일한 출력을 반환하므로 순수 함수다. 순수 함수는 참조 투명성을 만족한다. 따라서 망설임 없이 double(5) 를 10으로 바꿀 수 있다.</p><h3 id="순수-함수는-테스트하기-편한-코드다"><a href="#순수-함수는-테스트하기-편한-코드다" class="headerlink" title="순수 함수는 테스트하기 편한 코드다."></a>순수 함수는 테스트하기 편한 코드다.</h3><p>순수하지 않은 함수는 문제를 일으킬 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 세금 계산 함수</span></span><br><span class="line"><span class="keyword">var</span> percentValue = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> calculateTax = <span class="function"><span class="params">value</span> =&gt;</span> value / <span class="number">100</span> * (<span class="number">100</span> + percentValue);</span><br></pre></td></tr></table></figure><p>외부 환경에 의존해 논리를 계산하므로, calculateTax 함수는 순수하지 않은 함수다. 함수는 동작하지만 테스트하기는 어렵다.<br>percentValue 에 의존하기 때문에 이 값이 변경되면 테스트를 통과할 수 없게 될 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculateTax = <span class="function">(<span class="params">value, percentValue</span>) =&gt;</span> value / <span class="number">100</span> * (<span class="number">100</span> + percentValue);</span><br></pre></td></tr></table></figure><p>위의 함수처럼 외부 환경 종속성을 제거해서 이 문제를 해결할 수 있다.</p><p>순수 함수는 외부 환경 변수를 바꿔서는 안 된다. 순수 함수는 외부 변수에 의존해서는 안 되고 외부 변수도 변경해서는 안된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="string">"globalValue"</span>;</span><br><span class="line"><span class="keyword">var</span> badFunction = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  global = <span class="string">"changed"</span>;</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>badFunction 함수가 전역 변수 global 값을 changed 로 바꿔서 호출하면 문제가 생길 수 있다. global 변수에 의존하는<br>다른 함수가 있다고 하면, badFunction 호출은 다른 함수의 동작에 영향을 줄 수 있다. 이러한 함수는 코드 테스트를 힘들게 한다.<br>테스트 외에도 시스템에 영향을 주어 디버깅을 어렵게 한다.</p><h3 id="이상적인-코드"><a href="#이상적인-코드" class="headerlink" title="이상적인 코드"></a>이상적인 코드</h3><p>순수 함수를 사용하면 이상적인 코드를 간단히 만들 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> double = <span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>함수 이름에서 알 수 있듯이 주어진 수를 두 배로 하는 함수다. 사실상 참조 투명성 개념을 사용해 double 함수 호출을 동일한 결과로 대체할 수 있다.<br>코드상 부수 효과가 있는 함수라면 다른 개발자가 이해하기 어렵다. 순수 함수 기반 코드는 읽고, 이해하고 테스트하기 쉽다.<br>순수 함수든 어떤 함수든 항상 의미 있는 이름이어야 한다.</p><h3 id="병렬-코드"><a href="#병렬-코드" class="headerlink" title="병렬 코드"></a>병렬 코드</h3><p>순수 함수는 병렬로 코드를 실행할 수 있게 한다. 순수 함수는 해당 환경을 전혀 변동시키지 않으므로 동기화를 걱정할 필요가 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> global = <span class="string">"something"</span>;</span><br><span class="line"><span class="keyword">let</span> function1 = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  global = <span class="string">"somethingFalse"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> function2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (global === <span class="string">"something"</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function1 과 function2 를 병렬로 실행하게 된다면 두 함수 모두 전역 변수인 global 에 의존하므로, 병렬로 이 함수를 실행하면<br>문제가 발생할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> function1 = <span class="function">(<span class="params">input, global</span>) =&gt;</span> &#123;</span><br><span class="line">  global = <span class="string">"somethingFalse"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> function2 = <span class="function"><span class="params">global</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (global === <span class="string">"something"</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 함수의 global 변수를 인자로 옮겨 순수 함수로 만들었다. 이제 아무 문제 없이 두 함수를 동시에 실행할 수 있다.</p><h3 id="캐시"><a href="#캐시" class="headerlink" title="캐시"></a>캐시</h3><p>순수 함수는 항상 주어지니 입력에 대해 동일한 출력을 반환하므로, 함수 출력을 캐시할 수 있다. 시간이 많이 소요되는 연산을 처리하는<br>함수가 있다고 해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longRunningFunction = <span class="function"><span class="params">ip</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같이 longRunningFunction 함수의 호출 결과를 모두 유지하는 저장 객체를 갖고 있다고 가정해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longRunningFnBookKeeper = &#123;<span class="number">2</span>: <span class="number">3</span>, <span class="number">4</span>: <span class="number">5</span> ...&#125;</span><br></pre></td></tr></table></figure><p>longRunningFnBookKeeper 는 간단한 자바스크립트 객체로, longRunningFunction 함수를 호출해 입력과 출력 값을 모두 보유하게 된다.<br>이제 기존 함수를 실행하기 전에 longRunningFnBookKeeper 에 키가 있는지 확인할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longRunningFnBookKeeper = &#123;<span class="number">2</span>: <span class="number">3</span>, <span class="number">4</span>: <span class="number">5</span>&#125;;</span><br><span class="line">longRunningFnBookKeeper.hasOwnProperty(ip) ? longRunningFnBookKeeper[ip] : longRunningFnBookKeeper[ip] = longRunningFunction(ip);</span><br></pre></td></tr></table></figure><p>실제 함수를 호출하기 전에 해당 ip 와 함께 함수의 결과가 저장 객체에 있는지 확인한다. 함수 결과가 저장 객체에 있다면 반환하고, 그렇지 않으면 기존 함수를 호출해 저장 객체에서도<br>결과를 갱신한다. 적은 코드로도 쉽게 캐시할 수 있는 함수 호출을 만들 수 있다는 것을 살펴봤다. 이것이 바로 순수 함수의 역할이다.</p><p>참조: <a href="http://www.acornpub.co.kr/book/functional-javascript-2e#description">함수형 자바스크립트 입문 2/e</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/08/23/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>deno oak framework</title>
      <link>https://kkangil.github.io/2020/07/05/deno-oak-framework/</link>
      <guid>https://kkangil.github.io/2020/07/05/deno-oak-framework/</guid>
      <pubDate>Sun, 05 Jul 2020 02:20:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;Deno 의 framework 를 사용하여 API 서버를 구축해보려한다. 현재 기준(2020/07/05) 수 많은 framework 가 있지만&lt;br&gt;oak 가 제일 인기 많고 잘 만들어져 있다고 한다. 사용법이 express 와 비슷해서 인기가 많아진 것 같지만&lt;br&gt;oak 에서 제공해주는 example 을 직접 구현해 보려 한다. &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Deno 의 framework 를 사용하여 API 서버를 구축해보려한다. 현재 기준(2020/07/05) 수 많은 framework 가 있지만<br>oak 가 제일 인기 많고 잘 만들어져 있다고 한다. 사용법이 express 와 비슷해서 인기가 많아진 것 같지만<br>oak 에서 제공해주는 example 을 직접 구현해 보려 한다. </p><a id="more"></a><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Application,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Application();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Server is listening on port 8000`</span>);</span><br><span class="line"><span class="keyword">await</span> app.listen(&#123; port: <span class="number">8000</span> &#125;);</span><br></pre></td></tr></table></figure><p>oak 에서 제공해주는 Application 을 사용하여 서버를 실행한다. 이때 listen 함수는 promise 기 때문에<br>await 을 붙여줘서 실행하면 된다.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-net server.ts</span><br></pre></td></tr></table></figure><p>이렇게 서버를 실행해보면 에러가 발생한다. 이 에러는 현재 request 에 대한 처리나 route 가 없어서 발생하는<br>에러이므로 일단 다음 단계로 넘어가서 추가해주면 된다.</p><h2 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Router,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line">  context.response.body = <span class="string">"Hello deno, oak"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>oak 에서 Router 를 가져와 router 를 생성해준다. 이후 app middleware 에 등록해 주는것이다.<br>이때 app.use 를 사용해서 등록하는데 express 와 동일하다.</p><p>router.routes() 는 router 의 path 를 등록해주는 것이고, allowedMethods() 는 해당 path 의 모든 http method 를<br>허용해 주는 것이다.</p><p>이후 express 의 router 와 동일하게 router.get 함수를 이용하여 router 를 등록해 줄 수 있다.<br>차이점은 두번째 parameter 함수다. 기존에는 (req, res, next) 형식의 parameter 를 사용했었는데, oak 는 이것을<br>context 하나의 객체로 사용한다. destructuring 을 사용하여 쓸 수도 있어 더 편해진것 같다.</p><p>이제 다시 서버를 시작해보면 에러가 사라지고 8000번에 접속해보면 정상 작동하는것을 확인할 수 있다.</p><p>route 와 server 분리를 위해 routes.ts 파일을 생성해준다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Router,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line">  context.response.body = <span class="string">"Hello deno, oak"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>이후 server.ts 에서 해당 router 를 import 해준다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Application,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">"./routes.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Application();</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Server is listening on port 8000`</span>);</span><br><span class="line"><span class="keyword">await</span> app.listen(&#123; port: <span class="number">8000</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="route-method"><a href="#route-method" class="headerlink" title="route method"></a>route method</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Book &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  author: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> books: Book[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"1"</span>,</span><br><span class="line">    title: <span class="string">"Book 1"</span>,</span><br><span class="line">    author: <span class="string">"one"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"2"</span>,</span><br><span class="line">    title: <span class="string">"Book 2"</span>,</span><br><span class="line">    author: <span class="string">"two"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"3"</span>,</span><br><span class="line">    title: <span class="string">"Book 3"</span>,</span><br><span class="line">    author: <span class="string">"three"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>위 interface 구조를 가진 책 데이터를 사용하여 진행하려고 한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router</span><br><span class="line">    .get(<span class="string">"/"</span>, <span class="function">(<span class="params">&#123; response &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        response.body = <span class="string">"Hello deno, oak"</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .get(<span class="string">"/books"</span>, <span class="function">(<span class="params">&#123; response &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        response.body = books;</span><br><span class="line">    &#125;)</span><br><span class="line">    .get(<span class="string">"/books/:id"</span>, <span class="function">(<span class="params">&#123; params, response &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> book: Book | <span class="literal">undefined</span> = books.find(<span class="function">(<span class="params">book</span>) =&gt;</span> book.id === params.id);</span><br><span class="line">        <span class="keyword">if</span> (book) &#123;</span><br><span class="line">          response.body = book;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          response.body = <span class="string">"존재하지 않는 책"</span>;</span><br><span class="line">          response.status = <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><code>/books</code> 로 get 요청이 들어오면 전체 책을 return 해준다. body 에 담아주면 된다.</p><p><code>/books/:id</code> 로 get 요청이 들어오면 params 의 id 에 맞는 책을 찾아 return 해준다.<br>이때 express 와 다른점은 request 에 params 정보가 들어있는 것이 아니라 context 에서 따로 제공해주기 때문에<br>request 를 사용할 필요가 없다. </p><p>id 에 맞는 책을 찾아 리턴해주는데 존재하지 않은 책이면 status 를 404 로 리턴해준다.</p><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.post(<span class="string">"/books"</span>, <span class="keyword">async</span> (&#123; request, response &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="keyword">await</span> request.body();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!request.hasBody) &#123;</span><br><span class="line">      response.status = <span class="number">400</span>;</span><br><span class="line">      response.body = <span class="string">"데이터 없음"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> book: Book = body.value;</span><br><span class="line">      book.id = v4.generate();</span><br><span class="line">      books.push(book);</span><br><span class="line">      response.status = <span class="number">201</span>;</span><br><span class="line">      response.body = book;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>express 에서는 body-parser 를 사용하여 request.body 로 body 데이터를 받아오지만, oak 는 request.body promise<br>로 제공해준다. 또한 request.hasBody 를 사용하여 body 데이터가 있는지 확인할 수 있다.</p><p>DB 를 사용하는 경우 id 생성을 자동으로 해줄 수 있지만 지금은 std 의 uuid 를 사용하여 id 를 생성해줬다.</p><p>postman 으로 테스트해보면 정상 동작 하는것을 확인할 수 있다.</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.put(<span class="string">"/books/:id"</span>, <span class="keyword">async</span> (&#123; params, request, response &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> bookIndex: <span class="built_in">number</span> = books.findIndex(<span class="function">(<span class="params">book</span>) =&gt;</span> book.id === params.id);</span><br><span class="line">    <span class="keyword">if</span> (bookIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      response.body = <span class="string">"존재하지 않는 책"</span>;</span><br><span class="line">      response.status = <span class="number">404</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!request.hasBody) &#123;</span><br><span class="line">        response.status = <span class="number">400</span>;</span><br><span class="line">        response.body = <span class="string">"데이터 없음"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> body = <span class="keyword">await</span> request.body();</span><br><span class="line">        <span class="keyword">const</span> book: Book = body.value;</span><br><span class="line">        <span class="keyword">const</span> preBook: Book = books[bookIndex];</span><br><span class="line">        books.splice(bookIndex, <span class="number">1</span>, &#123; ...preBook, ...book &#125;);</span><br><span class="line">        response.status = <span class="number">201</span>;</span><br><span class="line">        response.body = books[bookIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Array.findIndex 를 사용하여 책을 찾아주고 수정해 주었다.</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.delete(<span class="string">"/books/:id"</span>, <span class="keyword">async</span> (&#123; params, response &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> bookIndex: <span class="built_in">number</span> = books.findIndex(<span class="function">(<span class="params">book</span>) =&gt;</span> book.id === params.id);</span><br><span class="line">    <span class="keyword">if</span> (bookIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      response.body = <span class="string">"존재하지 않는 책"</span>;</span><br><span class="line">      response.status = <span class="number">404</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      books.splice(bookIndex, <span class="number">1</span>);</span><br><span class="line">      response.status = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>delete method 도 express 와 동일한 방식으로 사용가능 하다.</p><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  green,</span><br><span class="line">  cyan,</span><br><span class="line">  bold,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std@0.60.0/fmt/colors.ts"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Context,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">async</span> (context: Context, next: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> rt = context.response.headers.get(<span class="string">"X-Response-Time"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;green(context.request.method)&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      cyan(<span class="built_in">decodeURIComponent</span>(context.request.url.pathname))</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span> - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      bold(</span></span></span><br><span class="line"><span class="string"><span class="subst">        <span class="built_in">String</span>(rt),</span></span></span><br><span class="line"><span class="string"><span class="subst">      )</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>`</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> logger;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Context,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> responseTime = <span class="keyword">async</span> (context: Context, next: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  context.response.headers.set(<span class="string">"X-Response-Time"</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> responseTime;</span><br></pre></td></tr></table></figure><p>console 에 기록을 남기는 Logger 함수와 응답시간을 추적하는 ResponseTime 함수를 생성해 준 후<br>express middleware 등록과 같이 app.use 를 사용해서 등록해준다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(logger);</span><br><span class="line">app.use(responseTime);</span><br></pre></td></tr></table></figure><h3 id="404-not-found"><a href="#404-not-found" class="headerlink" title="404 (not found)"></a>404 (not found)</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Status,</span><br><span class="line">  Context,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> notFound = <span class="function">(<span class="params">&#123; request, response &#125;: Context</span>) =&gt;</span> &#123;</span><br><span class="line">  response.status = Status.NotFound;</span><br><span class="line">  response.body =</span><br><span class="line">    <span class="string">`&lt;html&gt;&lt;body&gt;&lt;h1&gt;404 - Not Found&lt;/h1&gt;&lt;p&gt;Path &lt;code&gt;<span class="subst">$&#123;request.url&#125;</span>&lt;/code&gt; not found.`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> notFound;</span><br></pre></td></tr></table></figure><p>존재하지 않는 페이지에 접근했을때 실행되는 함수이다. route middleware 밑에 등록해주면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"><span class="comment">// A basic 404 page</span></span><br><span class="line">app.use(notFound);</span><br></pre></td></tr></table></figure><h3 id="error-handler"><a href="#error-handler" class="headerlink" title="error handler"></a>error handler</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  isHttpError,</span><br><span class="line">  Context,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/x/oak/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="keyword">async</span> (</span><br><span class="line">  &#123; request, response &#125;: Context,</span><br><span class="line">  next: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isHttpError(err)) &#123;</span><br><span class="line">      response.status = err.status;</span><br><span class="line">      <span class="keyword">const</span> &#123; message, status, stack &#125; = err;</span><br><span class="line">      <span class="keyword">if</span> (request.accepts(<span class="string">"json"</span>)) &#123;</span><br><span class="line">        response.body = &#123; message, status, stack &#125;;</span><br><span class="line">        response.type = <span class="string">"json"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.body = <span class="string">`<span class="subst">$&#123;status&#125;</span> <span class="subst">$&#123;message&#125;</span>\n\n<span class="subst">$&#123;stack ?? <span class="string">""</span>&#125;</span>`</span>;</span><br><span class="line">        response.type = <span class="string">"text/plain"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> errorHandler;</span><br></pre></td></tr></table></figure><p>errorHandler 함수를 만들어서 middleware 에 등록시켜준다.<br>추가로 router context 에 throw 라는 함수를 제공해준다. 이 함수를 실행하여 에러를 발생 시킬 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.throw(Status.NotFound, <span class="string">"존재하지 않는 책"</span>);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kkangil/deno-oak-app">Github code 보기</a><br><a href="https://deno.land/x/oak/examples/routingServer.ts">oak routing server</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/07/05/deno-oak-framework/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Deno 스탠다드 라이브러리 사용해보기</title>
      <link>https://kkangil.github.io/2020/07/05/Deno-%EC%8A%A4%ED%83%A0%EB%8B%A4%EB%93%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/</link>
      <guid>https://kkangil.github.io/2020/07/05/Deno-%EC%8A%A4%ED%83%A0%EB%8B%A4%EB%93%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/</guid>
      <pubDate>Sun, 05 Jul 2020 00:58:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;최근 Node 의 단점들을 보완한 Deno 가 정식 릴리즈 되었다. 아직 1 버전 으로 실제 회사나 프로젝트에서 쓰기는&lt;br&gt;무리가 있겠지만, 버전이 올라가면서 안정적으로 되면 Node 를 대체할 수도 있을거라고 생각한다.&lt;/p&gt;
&lt;p&gt;Deno 가 왜 좋은지, 어떤 장점과 이점이 있는지는 검색해보면 많이 있다. 나는 이런 이론 말고 직접 한번 써보고 싶었다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>최근 Node 의 단점들을 보완한 Deno 가 정식 릴리즈 되었다. 아직 1 버전 으로 실제 회사나 프로젝트에서 쓰기는<br>무리가 있겠지만, 버전이 올라가면서 안정적으로 되면 Node 를 대체할 수도 있을거라고 생각한다.</p><p>Deno 가 왜 좋은지, 어떤 장점과 이점이 있는지는 검색해보면 많이 있다. 나는 이런 이론 말고 직접 한번 써보고 싶었다.</p><a id="more"></a><p>Deno 는 <code>standard Library(이하 std)</code> 라고 직접 몇몇 기능을 가진 함수들을 제공한다. 예를 들면 date 관련 utils,<br>uuid 관련 utils 함수를 제공해준다. 오늘은 이 std 기능들 중 유용한 것들을 직접 구현해보려 한다.</p><p>들어가기 앞서 Deno 는 기본적으로 ts 를 쓸 수 있으며 <code>top-level-await</code> 를 제공해 주므로 async 없이 await 쓰는걸<br>많이 볼 것이다.</p><p><a href="https://github.com/tc39/proposal-top-level-await">top-level-await 참고</a></p><h2 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h2><p>Node 와 비교하여 가장 큰 특징으로 꼽히는 것이 바로 이 Permission 이다. Node 는 파일 실행시 모든 권한이 허용 되어<br>있다. 하지만 Deno 는 상황에 맞는 권한을 항상 허용해 주어야 한다. deno 는 deno run [flag] [파일명] 으로 실행한다.</p><table><thead><tr><th>flag</th><th>description</th></tr></thead><tbody><tr><td>–allow-read</td><td>읽기 권한 허용</td></tr><tr><td>–allow-write</td><td>쓰기 권한 허용</td></tr><tr><td>–allow-net</td><td>network 권한 허용(ex. port 열기)</td></tr><tr><td>–allow-env</td><td>환경 접근 권한 허용</td></tr><tr><td>–allow-run</td><td>실행 중인 하위 프로세스 허용</td></tr><tr><td>–allow-all(-A)</td><td>모든 권한 허용</td></tr></tbody></table><h2 id="file-생성-복사"><a href="#file-생성-복사" class="headerlink" title="file 생성, 복사"></a>file 생성, 복사</h2><p>std 말고 Deno 가 기본적으로 내장하고 있는 기능이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"><span class="keyword">const</span> text = encoder.encode(<span class="string">"hello deno!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> Deno.writeFile(<span class="string">"hello.txt"</span>, text);</span><br></pre></td></tr></table></figure><ul><li>Deno 의 writeFile 을 사용하여 file 을 생성한다.</li><li>Deno 함수는 기본적으로 promise 로 이루어져 있다.</li></ul><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-write createFile.ts</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> file = <span class="keyword">await</span> Deno.open(<span class="string">"hello.txt"</span>);</span><br><span class="line"><span class="keyword">await</span> Deno.copy(file, Deno.stdout);</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure><ul><li>위에서 생성한 file 을 복사한다. 실행해보면 console 에 hello deno! 가 찍힌다.</li></ul><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-read copyFile.ts</span><br></pre></td></tr></table></figure><h2 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h2><p>archive 는 <code>tar</code> 와 <code>untar</code> 기능을 갖고있다.</p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Tar &#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std/archive/tar.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tar = <span class="keyword">new</span> Tar();</span><br><span class="line"><span class="keyword">const</span> content = <span class="keyword">new</span> TextEncoder().encode(<span class="string">"Deno.land"</span>);</span><br><span class="line"><span class="keyword">await</span> tar.append(<span class="string">"deno.txt"</span>, &#123;</span><br><span class="line">  reader: <span class="keyword">new</span> Deno.Buffer(content),</span><br><span class="line">  contentSize: content.byteLength,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> writer = <span class="keyword">await</span> Deno.open(<span class="string">"./out.tar"</span>, &#123; write: <span class="literal">true</span>, create: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">await</span> Deno.copy(tar.getReader(), writer);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><ul><li>Deno.land 라는 text 파일을 생성 후 같은 경로에 이 파일을 포함하고 있는 out.tar 를 생성한다.</li><li>writer open 을 한 후 마지막에 close 를 해줘야한다.</li><li>위 코드에서는 파일을 생성해 주기 때문에 <code>--allow-write</code> 를 해주어야 한다.<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-write tar.ts</span><br></pre></td></tr></table></figure></li></ul><h3 id="untar"><a href="#untar" class="headerlink" title="untar"></a>untar</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Untar &#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std/archive/tar.ts"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ensureFile &#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std/fs/ensure_file.ts"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ensureDir &#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std/fs/ensure_dir.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reader = <span class="keyword">await</span> Deno.open(<span class="string">"./out.tar"</span>, &#123; read: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> untar = <span class="keyword">new</span> Untar(reader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> entry of untar) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry); <span class="comment">// metadata</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    TarEntry &#123;</span></span><br><span class="line"><span class="comment">      fileName: "deno.txt",</span></span><br><span class="line"><span class="comment">      fileMode: 511,</span></span><br><span class="line"><span class="comment">      mtime: 1593911999,</span></span><br><span class="line"><span class="comment">      uid: 0,</span></span><br><span class="line"><span class="comment">      gid: 0,</span></span><br><span class="line"><span class="comment">      type: "file",</span></span><br><span class="line"><span class="comment">      fileSize: 9</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (entry.type === <span class="string">"directory"</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> ensureDir(entry.fileName);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> ensureFile(entry.fileName);</span><br><span class="line">  <span class="keyword">const</span> file = <span class="keyword">await</span> Deno.open(entry.fileName, &#123; write: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="comment">// &lt;entry&gt; is a reader</span></span><br><span class="line">  <span class="keyword">await</span> Deno.copy(entry, file);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure><ul><li>tar.ts 에서 생성한 out.tar 를 압축 해제하는 기능이다.</li><li>untar 과정은 out.tar untar -&gt; 파일들을 읽어옴 -&gt; 파일을 같은 경로에 생성 순으로 이루어 진다. 이 순으로 인해<br>읽기와 쓰기 권한을 허용해 주어야 한다.</li></ul><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-read --allow-write untar.ts</span><br></pre></td></tr></table></figure><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p>string data 를 Date 객체로 변환해주는 간단한 날짜 관련 기능이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  parseDate,</span><br><span class="line">  parseDateTime,</span><br><span class="line">  dayOfYear,</span><br><span class="line">  currentDayOfYear,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std/datetime/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parseDate(<span class="string">"20-01-2019"</span>, <span class="string">"dd-mm-yyyy"</span>)); <span class="comment">// output : new Date(2019, 0, 20)</span></span><br><span class="line"><span class="built_in">console</span>.log(parseDate(<span class="string">"2019-01-20"</span>, <span class="string">"yyyy-mm-dd"</span>)); <span class="comment">// output : new Date(2019, 0, 20)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parseDateTime(<span class="string">"01-20-2019 16:34"</span>, <span class="string">"mm-dd-yyyy hh:mm"</span>)); <span class="comment">// output : new Date(2019, 0, 20, 16, 34)</span></span><br><span class="line"><span class="built_in">console</span>.log(parseDateTime(<span class="string">"16:34 01-20-2019"</span>, <span class="string">"hh:mm mm-dd-yyyy"</span>)); <span class="comment">// output : new Date(2019, 0, 20, 16, 34)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dayOfYear(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2020-05-05T10:24:00"</span>))); <span class="comment">// output: 126</span></span><br><span class="line"><span class="built_in">console</span>.log(currentDayOfYear()); <span class="comment">// output: ** depends on when you run it :) **</span></span><br></pre></td></tr></table></figure><ul><li>parseDate: 날짜까지만 Date 객체로 변환한다. (DateFormat)</li><li>parseDateTime: 시간까지 Date 객체로 변환한다. (DateTimeFormat)</li><li>dayOfYear: 1월 1일을 기준으로 넘겨준 날짜가 몇일이 지났는지 리턴해준다.</li><li>currentDayOfYear: 1월 1일을 기준으로 현재 몇일이 지났는지 리턴해준다.</li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>port 를 사용하여 server 를 실행시켜주거나, cookie 등 http 와 관련된 함수들을 제공한다.</p><h3 id="serve"><a href="#serve" class="headerlink" title="serve"></a>serve</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; serve &#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std/http/server.ts"</span>;</span><br><span class="line"><span class="keyword">const</span> server = serve(&#123; port: <span class="number">8000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"http://localhost:8000/"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> req of server) &#123;</span><br><span class="line">  req.respond(&#123; body: <span class="string">"Hello World\n"</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-net serve.ts</span><br></pre></td></tr></table></figure><ul><li>serve 함수를 실행하여 server 를 시작한다. 현재는 option 으로 port 만 넘겨주었지만, hostname, HTTPS 를 위한<br>certFile, keyFile 도 제공해 준다.</li><li>server 의 req 를 잡아와 respond 함수를 실행해 줌으로써 8000 번 port 에 접속해보면 해당 문구가 찍히는 것을<br>확인할 수 있다.</li></ul><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>uuid (v1, v4, v5) 생성 함수를 제공한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; v4 &#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std/uuid/mod.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate a v4 uuid</span></span><br><span class="line"><span class="keyword">const</span> myUUID = v4.generate();</span><br><span class="line"><span class="built_in">console</span>.log(myUUID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate a v4 uuid</span></span><br><span class="line"><span class="keyword">const</span> isValid = v4.validate(myUUID);</span><br><span class="line"><span class="built_in">console</span>.log(isValid); <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run uuid.ts</span><br></pre></td></tr></table></figure><h2 id="ws"><a href="#ws" class="headerlink" title="ws"></a>ws</h2><p>웹 소켓 기능도 제공해준다. std 의 코드 양이 많으므로 std 에서 제공해주는 코드를 실행해보는것으로 대체해 보려한다.<br>deno 는 현재 경로의 파일 뿐만 아니라 http 요청을 통해서도 실행이 가능하다.</p><p>우선 ws server 를 실행시켜보자.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-net https://deno.land/std/ws/example_server.ts</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">실행시켜보면 socket connected! 라는 문구가 뜨면 성공이다. 이 후 터미널을 새로 열어 client server 를 실행해준다.</span><br><span class="line"></span><br><span class="line">```shell script</span><br><span class="line">deno run --allow-net https://deno.land/std/ws/example_client.ts</span><br></pre></td></tr></table></figure><p>ws connected! 가 뜨면 성공이다. 이제 client 에서 text 를 입력하고 엔터를 눌러보면 server console 에 해당 문구가<br>찍히는것을 확인할 수 있다.</p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>위의 스탠다드 라이브러리는 deno 에서 제공해주는것에 일부분에 불과하다. 자주 사용될 것만 우선 정리해둔 것이다.<br>직접 공식문서를 확인해 보는것을 추천한다.</p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/07/05/Deno-%EC%8A%A4%ED%83%A0%EB%8B%A4%EB%93%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Canvas의 기초-3</title>
      <link>https://kkangil.github.io/2020/06/07/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-3/</link>
      <guid>https://kkangil.github.io/2020/06/07/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-3/</guid>
      <pubDate>Sun, 07 Jun 2020 04:55:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 글에 이어서 canvas 의 기초에 대해 더 알아보려한다. 이번 포스트에는 애니메이션, 이벤트에 대해서 알아본다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이전 글에 이어서 canvas 의 기초에 대해 더 알아보려한다. 이번 포스트에는 애니메이션, 이벤트에 대해서 알아본다.</p><a id="more"></a><h2 id="애니메이션-만들기"><a href="#애니메이션-만들기" class="headerlink" title="애니메이션 만들기"></a>애니메이션 만들기</h2><p>캔버스 화면에서 이미지가 움직이는 애니메이션을 만드는 방법을 알아보려한다. setInterval 함수를 사용해서 구현해본다.</p><h3 id="사각형을-x-축으로-왼쪽에서-오른쪽으로-움직이기"><a href="#사각형을-x-축으로-왼쪽에서-오른쪽으로-움직이기" class="headerlink" title="사각형을 x 축으로 왼쪽에서 오른쪽으로 움직이기"></a>사각형을 x 축으로 왼쪽에서 오른쪽으로 움직이기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> ctxWidth = canvas.width;</span><br><span class="line"><span class="keyword">var</span> ctxHeight = canvas.height;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, ctxWidth, ctxHeight);</span><br><span class="line">    ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">    ctx.fillRect(x, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-animation1.png" alt="사각형을 x축으로 이동"></p><p>interval 에서 제일 먼저 <code>clearRect</code> 를 사용하여 캔버스를 깨끗이 지워줘야 한다. 이 부분이 없으면 빨간색 선이<br>그려진다.</p><h3 id="두개의-사각형을-만들고-애니메이션을-멈추게-하기"><a href="#두개의-사각형을-만들고-애니메이션을-멈추게-하기" class="headerlink" title="두개의 사각형을 만들고 애니메이션을 멈추게 하기"></a>두개의 사각형을 만들고 애니메이션을 멈추게 하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> ctxWidth = canvas.width;</span><br><span class="line"><span class="keyword">var</span> ctxHeight = canvas.height;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, ctxWidth, ctxHeight);</span><br><span class="line">    ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">    ctx.fillRect(x, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">10</span>, y, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    x++;</span><br><span class="line">    y++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 영역 제한</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; ctxWidth) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; ctxHeight) &#123;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(animateInterval);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>조건을 추가하여 x,y 값이 canvas 의 넓이, 높이값 보다 클 경우 0 으로 초기화 시켜준다.</li><li>canvas 에 이벤트를 추가하여 클릭했을때 애니메이션이 멈추게 했다.</li></ul><p><img src="/images/canvas-animation2.png" alt="사각형을 x, y축으로 이동"></p><h2 id="클릭한-곳에-사각형-그리기"><a href="#클릭한-곳에-사각형-그리기" class="headerlink" title="클릭한 곳에 사각형 그리기"></a>클릭한 곳에 사각형 그리기</h2><p>여기서부터는 게임을 만드는 것의 기본을 간단한 소스를 통해 확인해 본다. </p><p>마우스를 클릭한 곳으로 이동한다든지, 마우스를 클릭한 곳에 건물을 지을때 자주 볼 수 있다. 먼저 캔버스 위에<br>마우스로 클릭한 곳의 좌표를 얻어, 그 곳에 사각형을 그리는 것을 확인해 보자.</p><h3 id="마우스로-클릭한-곳의-좌표-얻기"><a href="#마우스로-클릭한-곳의-좌표-얻기" class="headerlink" title="마우스로 클릭한 곳의 좌표 얻기"></a>마우스로 클릭한 곳의 좌표 얻기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mouseX = e.clientX;</span><br><span class="line">    <span class="keyword">var</span> mouseY = e.clientY;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`x: <span class="subst">$&#123;mouseX&#125;</span> / y: <span class="subst">$&#123;mouseY&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-clickXY.png" alt="클릭한 곳의 x, y, 좌표"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mouseX = e.clientX - ctx.canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> mouseY = e.clientY - ctx.canvas.offsetTop;</span><br><span class="line">    ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">    <span class="comment">// 마우스 클릭한 곳에서 사각형의 중심이 되어 생성</span></span><br><span class="line">    ctx.fillRect(mouseX - <span class="number">10</span>, mouseY - <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-clickRect.png" alt="클릭한 곳에 사각형 그리기"></p><h2 id="백그라운드-이미지-애니메이션-만들기"><a href="#백그라운드-이미지-애니메이션-만들기" class="headerlink" title="백그라운드 이미지 애니메이션 만들기"></a>백그라운드 이미지 애니메이션 만들기</h2><p>이미지 애니메이션을 만들어보자. 스크롤 게임이나 기타 여러 게임에서 배경의 움직임은 공간을 넓게 쓰는 효과를<br>주기 위해 사용하는 방법이다.</p><h3 id="이미지-애니메이션-만들기"><a href="#이미지-애니메이션-만들기" class="headerlink" title="이미지 애니메이션 만들기"></a>이미지 애니메이션 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> bgImages = <span class="keyword">new</span> Image();</span><br><span class="line">bgImages.src = <span class="string">'images/space.png'</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(bgImages, x-- ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">-600</span>) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-movingImage.png" alt="이미지 애니메이션"></p><ul><li>위 이미지는 넓이가 1200px 이다. 이미지가 절반 지나갔을 때 x 좌표값을 초기화 한다.</li></ul><h2 id="이미지를-키보드로-움직이기"><a href="#이미지를-키보드로-움직이기" class="headerlink" title="이미지를 키보드로 움직이기"></a>이미지를 키보드로 움직이기</h2><h3 id="위-배경에-이어서-비행기-만들어보기"><a href="#위-배경에-이어서-비행기-만들어보기" class="headerlink" title="위 배경에 이어서 비행기 만들어보기"></a>위 배경에 이어서 비행기 만들어보기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.src = <span class="string">'images/space.png'</span>;</span><br><span class="line"><span class="keyword">var</span> fighterImage = <span class="keyword">new</span> Image();</span><br><span class="line">fighterImage.src = <span class="string">'images/fighter.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Background</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = bgImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = bgImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(bgImage, <span class="keyword">this</span>.x--, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">-600</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = fighterImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = fighterImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(fighterImage, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> background = <span class="keyword">new</span> Background();</span><br><span class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.x = <span class="number">30</span>;</span><br><span class="line">player.y = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    background.render();</span><br><span class="line">    player.render();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-fighter1.png" alt="배경과 비행기"></p><ul><li>배경 움직이는 소스(Background) 비행기 그리는 소스(Player) 로 만들어 render 함수로 그려준다.</li></ul><h3 id="키보드를-눌렀을-때-비행기가-움직이도록-하기"><a href="#키보드를-눌렀을-때-비행기가-움직이도록-하기" class="headerlink" title="키보드를 눌렀을 때 비행기가 움직이도록 하기"></a>키보드를 눌렀을 때 비행기가 움직이도록 하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.src = <span class="string">'images/space.png'</span>;</span><br><span class="line"><span class="keyword">var</span> fighterImage = <span class="keyword">new</span> Image();</span><br><span class="line">fighterImage.src = <span class="string">'images/fighter.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> speed = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> keyCodeValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Background</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = bgImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = bgImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(bgImage, <span class="keyword">this</span>.x--, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">-600</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = fighterImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = fighterImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(fighterImage, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> background = <span class="keyword">new</span> Background();</span><br><span class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.x = <span class="number">30</span>;</span><br><span class="line">player.y = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// animate 함수에서 매 시간당 업데이트 되는 것을 체크한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (keyCodeValue) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">            player.y -= speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">            player.y += speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">            player.x -= speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            player.x += speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    background.render();</span><br><span class="line">    player.render();</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 키보드를 클릭하였을때 반응</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'keydown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 키보드의 키값을 가져온다.</span></span><br><span class="line">    keyCodeValue = <span class="built_in">String</span>.fromCharCode(e.keyCode);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 키보드 해제</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    keyCodeValue = <span class="string">''</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-fighter2.png" alt="움직이는 비행기"></p><ul><li>비행기가 화면에서 움직일 속도를 speed 변수로 선언한다.</li><li>update 함수를 실행하는 동안에 키보드를 누르면 wasd 키를 확인하여 비행기의 좌표값에 속도를 더해서 변경한다.</li></ul><h2 id="JSON-객체와-배열-처리하기"><a href="#JSON-객체와-배열-처리하기" class="headerlink" title="JSON 객체와 배열 처리하기"></a>JSON 객체와 배열 처리하기</h2><h3 id="JSON-객체를-배열로-처리하여-사각형을-캔버스에-그리기"><a href="#JSON-객체를-배열로-처리하여-사각형을-캔버스에-그리기" class="headerlink" title="JSON 객체를 배열로 처리하여 사각형을 캔버스에 그리기"></a>JSON 객체를 배열로 처리하여 사각형을 캔버스에 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> buildings = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"house"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">100</span>, <span class="attr">w</span>:<span class="number">50</span>, <span class="attr">h</span>:<span class="number">50</span>, <span class="attr">bg</span>: <span class="string">'magenta'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"hospital"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">100</span>, <span class="attr">w</span>:<span class="number">50</span>, <span class="attr">h</span>:<span class="number">50</span>, <span class="attr">bg</span>: <span class="string">'green'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"firestation"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">100</span>, <span class="attr">w</span>:<span class="number">50</span>, <span class="attr">h</span>:<span class="number">50</span>, <span class="attr">bg</span>: <span class="string">'orange'</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = buildings[i];</span><br><span class="line">    ctx.fillStyle = b.bg;</span><br><span class="line">    ctx.fillRect(b.x, b.y, b.w, b.h);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-jsonArray.png" alt="json 배열"></p><h3 id="JSON-객체를-배열로-처리하여-이미지-그리기"><a href="#JSON-객체를-배열로-처리하여-이미지-그리기" class="headerlink" title="JSON 객체를 배열로 처리하여 이미지 그리기"></a>JSON 객체를 배열로 처리하여 이미지 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> buildings = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Airport"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">0</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Bank"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">100</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"CarRepair"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">200</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"GasStation"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">300</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Hospital"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">400</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Temple"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">500</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buildingImage = <span class="keyword">new</span> Image();</span><br><span class="line">buildingImage.src = <span class="string">'images/buildings.png'</span>;</span><br><span class="line"></span><br><span class="line">buildingImage.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = buildings[i];</span><br><span class="line">        ctx.drawImage(buildingImage, b.sx, b.sy, b.w, b.h, b.x, b.y, b.w, b.h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-jsonArrayImage.png" alt="json 배열 이미지"></p><h2 id="마우스-충돌-체크하기"><a href="#마우스-충돌-체크하기" class="headerlink" title="마우스 충돌 체크하기"></a>마우스 충돌 체크하기</h2><p>위의 빌딩 소스를 이어서 진행한다.</p><p>결과 화면에서 빌딩의 위치를 가지고 있는 json 객체 데이터의 좌표를 체크하여 마우스를 클릭한 좌표와 비교하고<br>빌딩의 이름을 가져와 화면에 출력한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> buildings = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Airport"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">0</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Bank"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">100</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"CarRepair"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">200</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"GasStation"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">300</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Hospital"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">400</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Temple"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">500</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배경 이미지</span></span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.src = <span class="string">'images/background.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 빌딩 이미지</span></span><br><span class="line"><span class="keyword">var</span> buildingImage = <span class="keyword">new</span> Image();</span><br><span class="line">buildingImage.src = <span class="string">'images/buildings.png'</span>;</span><br><span class="line"></span><br><span class="line">buildingImage.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(bgImage, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = buildings[i];</span><br><span class="line">        ctx.drawImage(buildingImage, b.sx, b.sy, b.w, b.h, b.x, b.y, b.w, b.h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mouseX = e.clientX - ctx.canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> mouseY = e.clientY - ctx.canvas.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> bData = buildings[i];</span><br><span class="line">        <span class="comment">// 마우스 좌표를 체크하여 빌딩의 이름을 가져온다.</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            mouseX &gt;= bData.x &amp;&amp;</span><br><span class="line">            mouseX &lt; bData.x + bData.w &amp;&amp;</span><br><span class="line">            mouseY &gt;= bData.y &amp;&amp;</span><br><span class="line">            mouseY &lt; bData.y + bData.h</span><br><span class="line">        ) &#123;</span><br><span class="line">            ctx.clearRect(<span class="number">100</span>, <span class="number">260</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">            ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">            ctx.fillRect(<span class="number">100</span>, <span class="number">260</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">            ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">            ctx.textAlign = <span class="string">'center'</span>;</span><br><span class="line">            ctx.font = <span class="string">'bold 20px Arial, sans-serif'</span>;</span><br><span class="line">            ctx.fillText(bData.id, <span class="number">200</span>, <span class="number">280</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-clickBuilding.png" alt="화면에서 공항을 클릭한 화면"></p><p>참조: <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11228559">HTML5 캔버스</a><br><a href="https://github.com/kkangil/canvas-practice">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/06/07/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Canvas의 기초-2</title>
      <link>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-2/</link>
      <guid>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-2/</guid>
      <pubDate>Sun, 31 May 2020 06:40:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 포스트에 이어 Canvas의 기초에 대해 더 알아보려 한다.&lt;/p&gt;
&lt;h2 id=&quot;글씨-쓰기&quot;&gt;&lt;a href=&quot;#글씨-쓰기&quot; class=&quot;headerlink&quot; title=&quot;글씨 쓰기&quot;&gt;&lt;/a&gt;글씨 쓰기&lt;/h2&gt;&lt;h3 id=&quot;글씨-그리기&quot;&gt;&lt;a href=&quot;#글씨-그리기&quot; class=&quot;headerlink&quot; title=&quot;글씨 그리기&quot;&gt;&lt;/a&gt;글씨 그리기&lt;/h3&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이전 포스트에 이어 Canvas의 기초에 대해 더 알아보려 한다.</p><h2 id="글씨-쓰기"><a href="#글씨-쓰기" class="headerlink" title="글씨 쓰기"></a>글씨 쓰기</h2><h3 id="글씨-그리기"><a href="#글씨-그리기" class="headerlink" title="글씨 그리기"></a>글씨 그리기</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">120</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">140</span>, <span class="number">200</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">160</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-fillText.png" alt="글씨 그리기"></p><blockquote><p>context.fillText(text, x, y, maxWidth)<br>text: 화면에 표시될 글씨<br>x: x 좌표<br>y: y 좌표<br>maxWidth: 화면에 표시될 최대 폭(선택 사항)</p></blockquote><h3 id="글씨-크기를-크게-변경하기"><a href="#글씨-크기를-크게-변경하기" class="headerlink" title="글씨 크기를 크게 변경하기"></a>글씨 크기를 크게 변경하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 28px Arial, sans-serif'</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello Canvas World!"</span>, <span class="number">50</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-font.png" alt="글씨 크기 변경"></p><h3 id="글씨의-외곽선-그리기"><a href="#글씨의-외곽선-그리기" class="headerlink" title="글씨의 외곽선 그리기"></a>글씨의 외곽선 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 40px Arial, sans-serif'</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello Canvas World!"</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">2</span>;</span><br><span class="line">ctx.strokeText(<span class="string">"Hello Canvas World!"</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>strokeText</code> 함수로 외곽선만 있는 글씨를 표시한다.</p><p><img src="/images/canvas-strokeText.png" alt="글씨의 외곽선"></p><h3 id="글씨의-좌우-정렬-알아보기"><a href="#글씨의-좌우-정렬-알아보기" class="headerlink" title="글씨의 좌우 정렬 알아보기"></a>글씨의 좌우 정렬 알아보기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 30px Arial, sans-serif'</span>;</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"start"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"end"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"left"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"right"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"center"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.moveTo(<span class="number">200</span>, <span class="number">20</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">370</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-textAlign.png" alt="글씨 정렬"></p><p>textAlign</p><ul><li>start: 시작점 기준(기본)</li><li>end: 끝점 기준</li><li>left: 글씨의 왼쪽 기준</li><li>right: 글씨의 오른쪽 기준</li><li>center: 중심 기준</li></ul><h3 id="글씨의-상하정렬"><a href="#글씨의-상하정렬" class="headerlink" title="글씨의 상하정렬"></a>글씨의 상하정렬</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 22px Arial, sans-serif'</span>;</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"top"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"top!"</span>, <span class="number">10</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"bottom"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"bottom!"</span>, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"middle"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"middle!"</span>, <span class="number">130</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"alphabetic"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"alphabetic!"</span>, <span class="number">220</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"hanging"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"hanging!"</span>, <span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.moveTo(<span class="number">0</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">400</span>, <span class="number">150</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-textBaseline.png" alt="글씨 상하정렬"></p><p>textBaseline (베이스 라인 기준)</p><ul><li>top: 글씨의 위에 정렬</li><li>bottom: 글씨의 바닥에 정렬</li><li>center: 글씨의 중간에 정렬</li><li>alphabetic: 기본값</li><li>hanging: 글씨의 바로 위에 정렬</li></ul><h2 id="그림자-그리기"><a href="#그림자-그리기" class="headerlink" title="그림자 그리기"></a>그림자 그리기</h2><h3 id="사각형의-그림자"><a href="#사각형의-그림자" class="headerlink" title="사각형의 그림자"></a>사각형의 그림자</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.shadowColor = <span class="string">'rgba(0, 0, 0, 0.3)'</span>;</span><br><span class="line">ctx.shadowOffsetX = <span class="number">5</span>;</span><br><span class="line">ctx.shadowOffsetY = <span class="number">5</span>;</span><br><span class="line">ctx.shadowBlur = <span class="number">3</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-shadow.png" alt="그림자"></p><ul><li>shadowColor: 그림자의 색상</li><li>shadowOffsetX: 그림자의 간격을 x: 5 만큼 이동</li><li>shadowOffsetY: 그림자의 간격을 y: 5 만큼 이동</li><li>shadowBlur: 그림자의 흐림도</li></ul><h2 id="이동-회전-스케일-변형하기"><a href="#이동-회전-스케일-변형하기" class="headerlink" title="이동, 회전, 스케일, 변형하기"></a>이동, 회전, 스케일, 변형하기</h2><h3 id="위치-이동시키기"><a href="#위치-이동시키기" class="headerlink" title="위치 이동시키기"></a>위치 이동시키기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.translate(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-translate.png" alt="위치 이동"></p><p><code>translate</code> 를 사용하여 다음에 나오는 객체를 이동시킨다. css 의 translate 같다.</p><h3 id="크기-변형하기"><a href="#크기-변형하기" class="headerlink" title="크기 변형하기"></a>크기 변형하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.scale(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-scale.png" alt="크기 이동"></p><p>위의 예제에서는 크기를 절반으로 줄였다. 기준점(0,0)으로 하여 크기를 줄이기 때문에 제자리에서 크기가 줄지 않고,<br>위치가 상단(25,25)으로 이동한다.</p><h3 id="회전시키기"><a href="#회전시키기" class="headerlink" title="회전시키기"></a>회전시키기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">3</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.rotate(<span class="number">5</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.rotate(<span class="number">5</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-rotate.png" alt="회전"></p><h3 id="사각형-형태-변형하기"><a href="#사각형-형태-변형하기" class="headerlink" title="사각형 형태 변형하기"></a>사각형 형태 변형하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">3</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.transform(<span class="number">1.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.5</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-transform.png" alt="변형하기"></p><blockquote><p>context.transform(s1, sk1, sk2, s2, m1, m2)<br>s1: 수평으로 확대<br>sk1: 수평으로 기울임<br>sk2: 수직으로 기울임<br>s2: 수직으로 확대<br>m1: 수평으로 이동<br>m2: 수직으로 이동</p></blockquote><h4 id="기울기"><a href="#기울기" class="headerlink" title="기울기"></a>기울기</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">ctx.transform(<span class="number">1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><img src="/images/canvas-transform2.png" alt="기울기"></p><h4 id="transform-vs-setTransform"><a href="#transform-vs-setTransform" class="headerlink" title="transform vs setTransform"></a>transform vs setTransform</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">3</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.transform(<span class="number">1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.setTransform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-setTransform.png" alt="setTransform"></p><h2 id="색상-보정하기"><a href="#색상-보정하기" class="headerlink" title="색상 보정하기"></a>색상 보정하기</h2><p>캔버스에서 일부분을 가져와서 색상을 바꾸어 그린다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.putImageData(src, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">200</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-getImageData.png" alt="일부분 잘라오기"></p><h3 id="getImageData"><a href="#getImageData" class="headerlink" title="getImageData"></a>getImageData</h3><p>context.getImageData(x, y, width, height)</p><ul><li>x: 왼쪽 상단의 x 좌표</li><li>y: 왼쪽 상단의 y 좌표</li><li>width: 사각형 영역의 폭</li><li>height: 사각형 영역의 높이</li></ul><h3 id="putImageData"><a href="#putImageData" class="headerlink" title="putImageData"></a>putImageData</h3><p>context.putImageData(imgData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight)</p><ul><li>imgData: getImageData 로 가져온 이미지 값</li><li>x: 왼쪽 상단의 X 좌표</li><li>y: 왼쪽 상단의 y 좌표</li><li>dirtyX: 가져올 이미지의 x 좌표</li><li>dirtyY: 가져올 이미지의 y 좌표</li><li>dirtyWidth: 가져와서 그릴 사각형 영역의 폭</li><li>dirtyHeight: 가져와서 그릴 사각형 영역의 높이</li></ul><h3 id="지정한-부분의-색상을-흑백으로-바꾸어-출력하기"><a href="#지정한-부분의-색상을-흑백으로-바꾸어-출력하기" class="headerlink" title="지정한 부분의 색상을 흑백으로 바꾸어 출력하기"></a>지정한 부분의 색상을 흑백으로 바꾸어 출력하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> pixels = src.data;</span><br><span class="line"><span class="keyword">var</span> numPixels = pixels.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; numPixels; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> avg = (pixels[i*<span class="number">4</span>] + pixels[i*<span class="number">4</span>+<span class="number">1</span>] + pixels[i*<span class="number">4</span>+<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line">    pixels[i*<span class="number">4</span>] = avg; <span class="comment">// Red;</span></span><br><span class="line">    pixels[i*<span class="number">4</span>+<span class="number">1</span>] = avg; <span class="comment">// Green;</span></span><br><span class="line">    pixels[i*<span class="number">4</span>+<span class="number">2</span>] = avg; <span class="comment">// Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx.putImageData(src, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">200</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-imageDataToBlack.png" alt="흑백으로 변경"></p><p>이미지를 data 로 가져와 확인해보면 rgba 배열로 되어 있다. 각 픽셀의 색상 값을 흑백으로 변경하여 다시 저장한다.</p><h2 id="합성하기"><a href="#합성하기" class="headerlink" title="합성하기"></a>합성하기</h2><p>두 개 이상의 이미지를 합성하여 새로운 이미지를 만들거나 효과를 주는 방법을 알아본다.</p><p>합성에는 다양한 방법이 있는데, 대표적인 방법은 알파값을 이용하여 투명한 이미지를 기존 이미지 위에 올려서<br>색상에 간섭하여 그리는 것이다.</p><h3 id="알파값-적용하기"><a href="#알파값-적용하기" class="headerlink" title="알파값 적용하기"></a>알파값 적용하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'rgba(63, 169, 245, 1)'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.globalAlpha = <span class="number">0.5</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-alpha.png" alt="알파값 적용"></p><p><code>globalAlpha</code> 값이 0.5 적용된 파란색 사각형을 겹쳐서 그리게 적용한다.</p><h3 id="두-개의-이미지를-합성하여-그리기"><a href="#두-개의-이미지를-합성하여-그리기" class="headerlink" title="두 개의 이미지를 합성하여 그리기"></a>두 개의 이미지를 합성하여 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.globalCompositeOperation = <span class="string">'source-over'</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-composite.png" alt="이미지 합성"></p><h4 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h4><ul><li>source-over: 이미지 위에 겹쳐 그린다. (기본)</li><li>source-atop: 첫 번째 이미지를 그리고 두 번째 이미지의 겹치는 부분만 그린다.</li><li>source-in: 첫 번째 이미지를 그리지 않고 두 번째 이미지의 겹치지 않는 부분만 그린다.</li><li>source-out: 첫 번째 이미지를 그리지 않고 그 영역 안에 두 번째 이미지만 그린다.</li><li>destination-atop: 첫 번째 이미지를 위로 올리고 두 번째 이미지 전체를 그린다.</li><li>destination-in: 첫 번째 이미지를 위로 올리고 두 번째와 겹치는 부분만 그린다.</li><li>destination-out: 첫 번째 이미지만 그리고 두 번째 이미지와 겹치는 부분을 지운다.</li><li>destination-over: 첫 번째 이미지를 위로 올려 그리고 두 번째 이미지를 아래로 그린다.</li><li>lighter: 전체를 그리고 겹친 부분을 가산 혼합한다.</li><li>copy: 두 번째 이미지만 남기고 다른 부분은 제거한다.</li><li>xor: 전체를 그리고 겹친 부분을 지운다.</li></ul><p><img src="/images/canvas-compositeType.png" alt="이미지 합성 type"></p><p>참조: <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11228559">HTML5 캔버스</a><br><a href="https://github.com/kkangil/canvas-practice">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Canvas의 기초 - 1</title>
      <link>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88/</link>
      <guid>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88/</guid>
      <pubDate>Sun, 31 May 2020 04:36:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;HTML 에서는 태그를 중심으로 화면에 글자, 그림 등을 배치하고 CSS 를 이용하여 레이아웃을 그리지만, 캔버스는&lt;br&gt;하나의 화면에 자바스크립트에서 지원하는 캔버스 함수를 이용하여 그린다.&lt;/p&gt;
&lt;p&gt;캔버스의 기본적인 사용법은 소스와 같이 html 태그 안에 넣으면 된다. 캔버스 내에서는 css 가 제어되지 않기 때문에&lt;br&gt;자바스크립트를 이용하여 코드를 구성해야 한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>HTML 에서는 태그를 중심으로 화면에 글자, 그림 등을 배치하고 CSS 를 이용하여 레이아웃을 그리지만, 캔버스는<br>하나의 화면에 자바스크립트에서 지원하는 캔버스 함수를 이용하여 그린다.</p><p>캔버스의 기본적인 사용법은 소스와 같이 html 태그 안에 넣으면 된다. 캔버스 내에서는 css 가 제어되지 않기 때문에<br>자바스크립트를 이용하여 코드를 구성해야 한다.</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"ko"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas 01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span>CANVAS를 지원하지 않습니다.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>만약 캔버스가 지원되지 않는 브라우저이면, 캔버스 태그 안의 문구가 표시된다. script 태그에 캔버스 코드를 넣는다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>getContext</code> 함수에 2d를 그린다고 선언하여, ctx 변수에 적용한다. 3d는 캔버스가 아닌 WebGL 과 같은 기능을 사용해야<br>한다.</p><h2 id="선-그리기"><a href="#선-그리기" class="headerlink" title="선 그리기"></a>선 그리기</h2><h3 id="선-그리기-1"><a href="#선-그리기-1" class="headerlink" title="선 그리기"></a>선 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>3: 선 그리기를 시작한다.<br>4: 시작점으로 이동한다.<br>5: 선의 끝점으로 이동한다.<br>6: 선을 그린다.</p><p><img src="/images/canvas-선그리기.png" alt="선그리기"></p><h3 id="사각형-그리기"><a href="#사각형-그리기" class="headerlink" title="사각형 그리기"></a>사각형 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형그리기.png" alt="사각형그리기"></p><h3 id="내부에-색-채우기"><a href="#내부에-색-채우기" class="headerlink" title="내부에 색 채우기"></a>내부에 색 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">ctx.stroke();</span><br><span class="line">ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p>fillStyle 을 사용해 내부의 색을 지정해 줄 수 있다. fillStyle 없이 fill 함수만 실행할 경우 검정색으로 채워진다.</p><p><img src="/images/canvas-색채우기.png" alt="색 채우기"></p><h3 id="선의-색을-다른-색으로-채우고-두께-변경하기"><a href="#선의-색을-다른-색으로-채우고-두께-변경하기" class="headerlink" title="선의 색을 다른 색으로 채우고 두께 변경하기"></a>선의 색을 다른 색으로 채우고 두께 변경하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선의 색 변경</span></span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 색 채우기</span></span><br><span class="line">ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-선색변경.png" alt="선의 색 변경"></p><h3 id="선의-끝-부분-처리하기"><a href="#선의-끝-부분-처리하기" class="headerlink" title="선의 끝 부분 처리하기"></a>선의 끝 부분 처리하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineCap = <span class="string">"butt"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineCap = <span class="string">"round"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineCap = <span class="string">"square"</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-선의끝부분처리.png" alt="선의 끝부분 처리"></p><p><code>lineCap</code> 을 사용하면 선의 끝 부분을 처리할 수 있다.</p><ul><li>butt: 선의 끝 부분을 좌표에 맞추어 마무리한다. 기본값</li><li>round: 선의 끝을 둥글린다. 선 두께를 반지름으로 한다.</li><li>square: 선의 끝을 사각형으로 처리한다. 선 두께만큼 길어진다.</li></ul><h3 id="선의-꺾인-부분-처리하기"><a href="#선의-꺾인-부분-처리하기" class="headerlink" title="선의 꺾인 부분 처리하기"></a>선의 꺾인 부분 처리하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineJoin = <span class="string">'miter'</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">ctx.lineJoin = <span class="string">"round"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">290</span>);</span><br><span class="line">ctx.lineJoin = <span class="string">"bevel"</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-선의꺾인부분처리.png" alt="선의 꺾인 부분 처리하기"></p><p><code>lineJoin</code> 를 사용하면 꺾인 부분을 처리할 수 있다.</p><ul><li>miter: 각진 모서리 형태로 기본값이다.</li><li>round: 둥근 모서리 형태</li><li>bevel: 잘려나간 모서리 형태 </li></ul><h3 id="선의-간격을-조정하여-점선-만들기"><a href="#선의-간격을-조정하여-점선-만들기" class="headerlink" title="선의 간격을 조정하여 점선 만들기"></a>선의 간격을 조정하여 점선 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">ctx.setLineDash([<span class="number">20</span>]);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">ctx.setLineDash([<span class="number">20</span>, <span class="number">10</span>]);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">290</span>);</span><br><span class="line">ctx.setLineDash([<span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">10</span>]);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-점선처리.png" alt="점선 만들기"></p><p><code>setLineDash</code> 를 사용하여 점선을 만든다.</p><ol><li>선의 간격이 20씩 벌어져 있다.</li><li>선의 길이: 20, 간격: 10 만큼 벌어져 있다.</li><li>선의 길이: 20, 간격: 10 과 선의 길이: 50, 간격: 10 이 번갈아 가면서 그려진다.</li></ol><h2 id="사각형-그리기-1"><a href="#사각형-그리기-1" class="headerlink" title="사각형 그리기"></a>사각형 그리기</h2><p>이전에는 선(line)을 이용하여 사각형을 그렸었는데 Rect 함수를 이용하여 사각형을 그릴 수 있다.</p><h3 id="사각형-그리기-2"><a href="#사각형-그리기-2" class="headerlink" title="사각형 그리기"></a>사각형 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">150</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형.png" alt="사각형"></p><p><code>strokeRect</code> 함수를 사용하면 사각형을 쉽게 그릴 수 있다.</p><blockquote><p>strokeRect(x, y, width, height);</p></blockquote><h3 id="사각형-색-채우기"><a href="#사각형-색-채우기" class="headerlink" title="사각형 색 채우기"></a>사각형 색 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">"magenta"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">"green"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">150</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">150</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형색채우기.png" alt="사각형 색 채우기"></p><h3 id="내부를-사각형으로-지우기"><a href="#내부를-사각형으로-지우기" class="headerlink" title="내부를 사각형으로 지우기"></a>내부를 사각형으로 지우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.clearRect(<span class="number">70</span>, <span class="number">70</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형내부지우기.png" alt="내부를 사각형으로 지우기"></p><h2 id="원-그리기"><a href="#원-그리기" class="headerlink" title="원 그리기"></a>원 그리기</h2><h3 id="기본-원-그리기"><a href="#기본-원-그리기" class="headerlink" title="기본 원 그리기"></a>기본 원 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.arc(<span class="number">150</span>, <span class="number">150</span>, <span class="number">100</span>,<span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-원그리기.png" alt="원 그리기"></p><p><code>arc</code> 함수를 실행하여 원을 그릴 수 있다.</p><blockquote><p>context.arc(x, y, r, sAngle, eAngle, counterclockwise);<br>x: x 좌표<br>y: y 좌표<br>r: 반지름<br>sAngle: 시작하는 각도<br>eAngle: 끝나는 각도<br>counterclockwise: 시계 방향으로 회전</p></blockquote><h3 id="선과-호를-연결하여-라운드-코너-그리기"><a href="#선과-호를-연결하여-라운드-코너-그리기" class="headerlink" title="선과 호를 연결하여 라운드 코너 그리기"></a>선과 호를 연결하여 라운드 코너 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.arcTo(<span class="number">350</span>, <span class="number">50</span>, <span class="number">350</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">350</span>, <span class="number">200</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-호그리기.png" alt="호 그리기"></p><p><code>arcTo</code> 함수를 사용하여 호를 그릴 수 있다.</p><blockquote><p>context.arcTo(x1, y1, x2, y2, r)<br>x1: 시작하는 점의 x 좌표<br>y1: 시작하는 점의 y 좌표<br>x2: 끝나는 점의 x 좌표<br>y2: 끝나는 점의 y 좌표<br>r: 호의 반지름</p></blockquote><h3 id="quadraticCurve-그리기"><a href="#quadraticCurve-그리기" class="headerlink" title="quadraticCurve 그리기"></a>quadraticCurve 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.quadraticCurveTo(<span class="number">200</span>, <span class="number">100</span>, <span class="number">350</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">350</span>, <span class="number">200</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-quadraticCurve.png" alt="quadraticCurveTo"></p><p><code>quadraticCurveTo</code> 함수를 이용하여 하나의 조절점의 커브를 그린다.</p><blockquote><p>context.quadraticCurve(cpx, cpy, x, y)<br>cpx: 조절하는 점의 x 좌표<br>cpy: 조절하는 점의 y 좌표<br>x: 끝나는 점의 x 좌표<br>y: 끝나는 점의 y 좌표</p></blockquote><h3 id="bezierCurve-그리기"><a href="#bezierCurve-그리기" class="headerlink" title="bezierCurve 그리기"></a>bezierCurve 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.bezierCurveTo(<span class="number">200</span>,<span class="number">70</span>, <span class="number">100</span>,<span class="number">150</span>, <span class="number">350</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">350</span>, <span class="number">200</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-bezierCurve.png" alt="bezierCurveTo"></p><p><code>bezierCurveTo</code> 함수를 이용하여 두 조절점의 커브를 그린다.</p><blockquote><p>context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)<br>cp1x: 조절하는 점 1번째의 x 좌표<br>cp1y: 조절하는 점 1번째의 y 좌표<br>cp2x: 조절하는 점 2번째의 x 좌표<br>cp2y: 조절하는 점 2번째의 y 좌표<br>x: 끝나는 점의 x 좌표<br>y: 끝나는 점의 y 좌표</p></blockquote><h2 id="내부-채우기"><a href="#내부-채우기" class="headerlink" title="내부 채우기"></a>내부 채우기</h2><h3 id="Gradient-로-내부-채우기"><a href="#Gradient-로-내부-채우기" class="headerlink" title="Gradient 로 내부 채우기"></a>Gradient 로 내부 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> grad = ctx.createLinearGradient(<span class="number">50</span>, <span class="number">50</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">grad.addColorStop(<span class="number">0</span>, <span class="string">'red'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">1</span>/<span class="number">6</span>, <span class="string">'orange'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">2</span>/<span class="number">6</span>, <span class="string">'yellow'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">3</span>/<span class="number">6</span>, <span class="string">'green'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">4</span>/<span class="number">6</span>, <span class="string">'aqua'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">5</span>/<span class="number">6</span>, <span class="string">'blue'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">1</span>, <span class="string">'purple'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">5</span>;</span><br><span class="line">ctx.fillStyle = grad;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-gradient.png" alt="gradient"></p><p>그라데이션으로 색을 채우기 위해 <code>createLinearGradient</code> 함수를 사용했다.</p><blockquote><p>ctx.createLinearGradient(x0, y0, x1, y1);<br>x0: 시작하는 점의 x 좌표<br>y0: 시작하는 점의 y 좌표<br>x1: 끝나는 점의 x 좌표<br>y1: 끝나는 점의 y 좌표</p></blockquote><h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial gradient"></a>radial gradient</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> grad = ctx.createRadialGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>);</span><br><span class="line">grad.addColorStop(<span class="number">0</span>, <span class="string">'red'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">0.5</span>, <span class="string">'yellow'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">1</span>, <span class="string">'black'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">5</span>;</span><br><span class="line">ctx.fillStyle = grad;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-radialGradient.png" alt="radial gradient"></p><blockquote><p>ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);<br>x0: 시작하는 점의 x 좌표<br>y0: 시작하는 점의 y 좌표<br>r0: 시작하는 곳의 반지름<br>x1: 끝나는 점의 x 좌표<br>y1: 끝나는 점의 y 좌표<br>r1: 끝 나는 곳의 반지름</p></blockquote><h3 id="패턴으로-사각형-채우기"><a href="#패턴으로-사각형-채우기" class="headerlink" title="패턴으로 사각형 채우기"></a>패턴으로 사각형 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> flower = <span class="keyword">new</span> Image();</span><br><span class="line">flower.src = <span class="string">"images/flower.png"</span>;</span><br><span class="line">flower.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pattern = ctx.createPattern(flower, <span class="string">"repeat"</span>);</span><br><span class="line">    ctx.fillStyle = pattern;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-pattern.png" alt="createPattern"></p><p><code>createPattern</code> 를 이미지를 넘겨주어 실행한다.</p><p>context.createPattern(image, “repeat”);</p><ul><li>repeat: 패턴을 반복하여 채운다.</li><li>repeat-x: x축으로 반복하여 채운다.</li><li>repeat-y: y축으로 반복하여 채운다.</li><li>no-repeat: 반복하지 않는다.</li></ul><h2 id="이미지-그리기"><a href="#이미지-그리기" class="headerlink" title="이미지 그리기"></a>이미지 그리기</h2><h3 id="이미지를-원래-크기대로-그리기"><a href="#이미지를-원래-크기대로-그리기" class="headerlink" title="이미지를 원래 크기대로 그리기"></a>이미지를 원래 크기대로 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> myPic = <span class="keyword">new</span> Image();</span><br><span class="line">myPic.src = <span class="string">'images/duck.jpg'</span>;</span><br><span class="line">myPic.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(myPic, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-image.png" alt="이미지 그리기"></p><blockquote><p>context.drawImage(img, x, y)</p></blockquote><h3 id="이미지의-크기를-변형하여-그리기"><a href="#이미지의-크기를-변형하여-그리기" class="headerlink" title="이미지의 크기를 변형하여 그리기"></a>이미지의 크기를 변형하여 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> myPic = <span class="keyword">new</span> Image();</span><br><span class="line">myPic.src = <span class="string">'images/duck.jpg'</span>;</span><br><span class="line">myPic.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(myPic, <span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-image2.png" alt="이미지 크기 변형"></p><blockquote><p>context.drawImage(img, x, y, width, height)</p></blockquote><h3 id="이미지를-잘라-일부만-그리기"><a href="#이미지를-잘라-일부만-그리기" class="headerlink" title="이미지를 잘라 일부만 그리기"></a>이미지를 잘라 일부만 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> myPic = <span class="keyword">new</span> Image();</span><br><span class="line">myPic.src = <span class="string">'images/duck.jpg'</span>;</span><br><span class="line">myPic.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(myPic, <span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-image3.png" alt="이미지 일부만 그리기"></p><blockquote><p>context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height)<br>sx: 소스 이미지에서 잘라 가져올 시작점의 x 좌표<br>sy: 소스 이미지에서 잘라 가져올 시작점의 y 좌표<br>swidth: 소스 이미지에서 잘라 가져올 시작점 기준의 이미지 폭<br>sheight: 소스 이미지에서 잘라 가져올 시작점 기준의 이미지 높이</p></blockquote><p>참조: <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11228559">HTML5 캔버스</a><br><a href="https://github.com/kkangil/canvas-practice">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React recoiljs 알아보기</title>
      <link>https://kkangil.github.io/2020/05/24/React-recoiljs-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/</link>
      <guid>https://kkangil.github.io/2020/05/24/React-recoiljs-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/</guid>
      <pubDate>Sun, 24 May 2020 07:51:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;최근 react 에서 새로운 상태관리 라이브러리를 발표했다. 주요 컨셉으로는 atom,selector 라는 단위를 통해&lt;br&gt;derived state 를 효과적으로 처리하고 상태의 코드 분할이 가능하게 한다고 한다.&lt;/p&gt;
&lt;p&gt;리액트의 기본 설정은 create-react-app 을 사용하려고 한다. react-app 생성 후 recoiljs 를 설치해주면&lt;br&gt;사용 준비가 끝난것이다.&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;figcaption&gt;&lt;span&gt;script&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm i recoil&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>최근 react 에서 새로운 상태관리 라이브러리를 발표했다. 주요 컨셉으로는 atom,selector 라는 단위를 통해<br>derived state 를 효과적으로 처리하고 상태의 코드 분할이 가능하게 한다고 한다.</p><p>리액트의 기본 설정은 create-react-app 을 사용하려고 한다. react-app 생성 후 recoiljs 를 설치해주면<br>사용 준비가 끝난것이다.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i recoil</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p>아직 나온지 얼마 되지 않은 라이브러리라서 구조화에 대한 내용이 많이 없다. 현재는 src 내부에<br><code>recoil</code> 이라는 폴더를 만들고 component 단위 별로 파일을 생성하려고 한다.</p><h2 id="RecoilRoot"><a href="#RecoilRoot" class="headerlink" title="RecoilRoot"></a>RecoilRoot</h2><p>redux, mobx 등 다른 상태관리 라이브러리에도 provider 가 있듯이 recoil 도 RecoilRoot 라는 hoc 가 존재한다.<br><code>props</code> 로 <code>initializeState</code> 를 전달해 줄 수 있지만 지금은 일단 넘어가려 한다.</p><p>create-react-app 으로 생성한 app 기준 index.js 에 App 을 RecoilRoot 로 감싸주면 된다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;RecoilRoot&#125; <span class="keyword">from</span> <span class="string">'recoil'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">      &lt;RecoilRoot&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">      &lt;<span class="regexp">/RecoilRoot&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>React.StrictMode&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://recoiljs.org/docs/api-reference/core/RecoilRoot">RecoilRoot 공식 문서</a></p><h2 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h2><p>리액트의 state 와 같다라고 생각해도 된다. 즉, 상태 값이라는 것이다. 기본적으로 <code>atom</code> 함수를 실행하고<br>이때 인자로 option 을 넘겨준다. option 중 <code>key</code> 와 <code>default</code> 는 필수 값이다.</p><p>key 는 unique 한 id 여야 하고 default 는 이름에서 유추할 수 있듯이 해당 상태 값의 초기값이다.</p><p>count component 를 만들면서 확인해 보자.</p><p>우선 recoil 폴더에 count.js 파일을 만든 후 아래와 같이 atom state 를 생성해 줬다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> countState = atom(&#123;</span><br><span class="line">    key: <span class="string">"countState"</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이후 Count Component 를 아래와 같이 생성했다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useRecoilState&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;countState&#125; <span class="keyword">from</span> <span class="string">"../recoil/count"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useRecoilState(countState);</span><br><span class="line">    <span class="keyword">const</span> incrementByOne = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            Count: &#123;count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOne&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure><p>위의  <code>useRecoilState</code> 훅은 밑에서 자세히 설명하도록 하겠다.</p><h2 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h2><p><code>selector</code> 도 <code>atom</code> 과 마찬가지로 값으로 쓰인다. 차이점은 atom 은 오로지 현재 값만 가져오고<br>setState 할때도 넘겨주는 값만을 사용할 수 있다. 하지만 selector 는 option 에 <code>get</code> 과 <code>set</code> 을 넘겨줘서<br>사용할 수 있다.</p><p>option 에 역시 key 는 필수이며 unique 해야한다. get 또한 필수로 넘겨줘야 하며 set 은 optional 이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> countEvenState = selector(&#123;</span><br><span class="line">    key: <span class="string">"countEvenState"</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(countState) % 2 === 0,</span><br><span class="line">    <span class="keyword">set</span>: (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt; <span class="keyword">set</span>(countState, newValue)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>먼저 selector recoil state 를 생성했다. 위 값을 불러올때 짝수면 true, 홀수면 false 를 가져온다.</p><p><code>get</code> 은 함수를 전달해줘야한다. 이때 인자 객체에 get 이라는 함수가 있는데, 이 함수를 사용하여 상태값을<br>불러와 사용한다. 이때 get 에 전달해줘야 하는 값은 recoil state 여야 한다.</p><p>위의 예제에서는 <code>set</code> 이 필요 없을 수 있으나, 어떤 식으로 사용해야 하는지 알 수 있게 추가한 것이다.<br>set 은 첫번째 인자로 객체, 두번째 인자로 새로운 값이 넘어오고, 첫번째 인자 객체의 set 을 사용하여<br>state 값을 바꾼다. 이때 첫번째 인자는 역시 recoil state 여야 하고 두번째 인자로 바뀔 값을 넘겨준다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useRecoilState(countState);</span><br><span class="line">    <span class="keyword">const</span> [evenCount, setEvenCount] = useRecoilState(countEvenState);</span><br><span class="line">    <span class="keyword">const</span> incrementByOne = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> incrementByOneEvenCount = <span class="function"><span class="params">()</span> =&gt;</span> setEvenCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            Count: &#123;count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOne&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;br /</span>&gt;</span><br><span class="line">            Even Count: &#123;evenCount ? <span class="string">'짝수'</span> : <span class="string">'홀수'</span>&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOneEvenCount&#125;&gt;Even Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Count component 를 위와 같이 변경하였다. Even Increment 버튼을 클릭하면 count 의 값도 같이 바뀌는 것을<br>확인할 수 있다. set 에서 count 의 값을 변경해 주기 때문이다.</p><h2 id="recoil-hooks"><a href="#recoil-hooks" class="headerlink" title="recoil hooks"></a>recoil hooks</h2><h3 id="recoil-state-값-사용"><a href="#recoil-state-값-사용" class="headerlink" title="recoil state 값 사용"></a>recoil state 값 사용</h3><p>recoil state 는 훅을 이용하여 사용해야 한다. 위 예제의 <code>useRecoilState</code> 같은 훅이다. 현재까지 세가지 방법의<br>recoil state 사용법이 있다.</p><ul><li>useRecoilValue: 값만을 불러올 수 있다. 즉 이 훅은 set 함수를 반환하지 않는다.</li><li>useSetRecoilState: set 함수만을 불러올 수 있다.</li><li>useRecoilState: 값, set 함수 두가지 다 불러올 수 있다.</li></ul><p>위 예제에서는 useRecoilState 만을 사용하였는데 현재 setCount 는 사용하지 않으므로 <code>useRecoilValue</code> 로 리팩토링<br>하는 것이 좋을 것 같다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useRecoilValue(countState);</span><br><span class="line">    <span class="keyword">const</span> [evenCount, setEvenCount] = useRecoilState(countEvenState);</span><br><span class="line">    <span class="keyword">const</span> incrementByOneEvenCount = <span class="function"><span class="params">()</span> =&gt;</span> setEvenCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            Count: &#123;count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            Even Count: &#123;evenCount ? <span class="string">'짝수'</span> : <span class="string">'홀수'</span>&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOneEvenCount&#125;&gt;Even Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useResetRecoilState"><a href="#useResetRecoilState" class="headerlink" title="useResetRecoilState"></a>useResetRecoilState</h3><p>recoil state 를 default 값으로 초기화 시킬때 사용한다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resetCount = useResetRecoilState(countState);</span><br><span class="line">&lt;button onClick=&#123;resetCount&#125;&gt;reset&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="useRecoilValueLoadable"><a href="#useRecoilValueLoadable" class="headerlink" title="useRecoilValueLoadable"></a>useRecoilValueLoadable</h3><p>밑에서 다시 언급하겠지만 이 훅은 주로 비동기 selector 를 쓸때 사용된다. React.Suspense 로 loading 처리를 할 수 있지만<br>위 훅을 사용하면 현재 상태(state) 와 값(contents)을 반환해준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countLoadable = useRecoilValueLoadable(countEvenState);</span><br><span class="line"><span class="built_in">console</span>.log(countLoadable);</span><br></pre></td></tr></table></figure><h3 id="useRecoilCallback"><a href="#useRecoilCallback" class="headerlink" title="useRecoilCallback"></a>useRecoilCallback</h3><p>recoil state 를 불러오지 않았을때도 callback 함수를 전달해주어 해당 callback 에서 recoil state 에 접근 가능하도록<br>해준다.</p><p>아래는 공식 문서의 예제이다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, useRecoilCallback&#125; <span class="keyword">from</span> <span class="string">'recoil'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> itemsInCart = atom(&#123;</span><br><span class="line">  key: <span class="string">'itemsInCart'</span>,</span><br><span class="line">  <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CartInfoDebug</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> logCartItems = useRecoilCallback(<span class="keyword">async</span> (&#123;getPromise&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> numItemsInCart = <span class="keyword">await</span> getPromise(itemsInCart);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Items in cart: '</span>, numItemsInCart);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;logCartItems&#125;&gt;Log Cart Items&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="비동기-처리"><a href="#비동기-처리" class="headerlink" title="비동기 처리"></a>비동기 처리</h2><p>프로젝트를 진행함에 있어 API 호출과 같은 비동기 처리가 중요하다. recoil 에서도 역시 비동기 처리에 대한<br>가이드를 전달해준다.</p><p>recoil 폴더에 name.js 라는 파일을 추가한 후 아래와 같이 recoil state 를 생성했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, selector&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = <span class="function"><span class="params">name</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123;name&#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> currentUserNameState = atom(&#123;</span><br><span class="line">    key: <span class="string">'currentUserNameState'</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">"Kkangil"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> currentUserName = selector(&#123;</span><br><span class="line">    key: <span class="string">'currentUserName'</span>,</span><br><span class="line">    <span class="keyword">get</span>: async (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> getName(<span class="keyword">get</span>(currentUserNameState));</span><br><span class="line">        return response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>selector</code> 의 get option 에서 async/await 처리가 가능하다. 이후 UserName 이라는 Component 를 생성해줬다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useRecoilValue&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;currentUserName&#125; <span class="keyword">from</span> <span class="string">"../recoil/name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserName);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> UserName;</span><br></pre></td></tr></table></figure><p>이렇게 Component 를 생성해 준 후 확인해보면 React.Suspense 를 사용해야 한다는 에러가 발생한다.<br>index.js 에 React.Suspense 를 추가해주자.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">      &lt;RecoilRoot&gt;</span><br><span class="line">          &lt;React.Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;App /</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/React.Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>RecoilRoot&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.StrictMode&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="유틸리티"><a href="#유틸리티" class="headerlink" title="유틸리티"></a>유틸리티</h2><p>아쉽지만 현재 버전 0.0.7 에서는 제공하고 있지 않은것 같다. 추후 버전 업이 됐을때 기대해봐도 좋을것 같다.</p><h3 id="atomFamily"><a href="#atomFamily" class="headerlink" title="atomFamily"></a>atomFamily</h3><p>atom 을 사용하다가 한가지 의문이 들었다. 초기값을 설정해 주는것은 알겠는데 동적으로 초기값을 설정해 줄 수는<br>없을까? 역시 존재했다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">atomFamily</span>&lt;<span class="title">T</span>, <span class="title">Parameter</span>&gt;(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">default</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">    | RecoilValue&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Promise</span>&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | T</span></span></span><br><span class="line"><span class="function"><span class="params">    | (Parameter =&gt; T | RecoilValue&lt;T&gt; | <span class="built_in">Promise</span>&lt;T&gt;),</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dangerouslyAllowMutability?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>): <span class="title">RecoilState</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><p>공식 문서에서 제공해주고 있는 atomFamily 의 type 정의이다. default 부분을 보면 RecoilValue, Promise 그리고 함수로<br>정의되어 있는것을 확인할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> countStateByFamily = atomFamily(&#123;</span><br><span class="line">    key: <span class="string">"countState"</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">defaultValue</span> =&gt;</span> defaultValue</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count2</span>(<span class="params">&#123;number&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = useRecoilValue(countStateByFamily(number));</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="selectorFamily"><a href="#selectorFamily" class="headerlink" title="selectorFamily"></a>selectorFamily</h3><p>atom 과 마찬가지로 selector 도 값을 넘겨주어 사용할 수 있다. atom 과 다른점은 selector 의 get 과 set 은<br>이미 함수를 사용하고 있었다. 값을 넘겨주기 위해 함수가 함수를 리턴해주는 형식이 된다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myNumberState = atom(&#123;</span><br><span class="line">  key: <span class="string">'MyNumber'</span>,</span><br><span class="line">  <span class="keyword">default</span>: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMultipliedState = selectorFamily(&#123;</span><br><span class="line">  key: <span class="string">'MyMultipliedNumber'</span>,</span><br><span class="line">  <span class="keyword">get</span>: (multiplier) =&gt; (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(myNumberState) * multiplier;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>: (multiplier) =&gt; (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt; &#123;</span><br><span class="line">    <span class="keyword">set</span>(myNumberState, newValue / multiplier);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  <span class="keyword">const</span> number = useRecoilValue(myNumberState);</span><br><span class="line">  <span class="keyword">const</span> multipliedNumber = useRecoilValue(myMultipliedState(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;number&#125; / &#123;multipliedNumber&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>아직 버전이 0.0.7 이고 개발이 더 필요해 보인다. 언제 정식 출시 될지도 모르곘지만 기존에 주로 사용되던<br>redux, mobx 와 비교를 해보자면 훨씬 더 간단하고 간결하게 사용할 수 있을것 같다. redux 에서의 action, reducer,<br>middleware 등 작업에 걸리는 시간을 줄일 수 있을것 같다. 그리고 함수형 컴포넌트와 잘 어울릴것 같다.</p><p>참고: <a href="https://recoiljs.org/docs/introduction/installation">RecoilRoot 공식 문서</a><br>Github: <a href="https://github.com/kkangil/react-recoiljs">kkangil</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/24/React-recoiljs-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Storybook 마크다운으로 작성하기</title>
      <link>https://kkangil.github.io/2020/05/17/Storybook-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/</link>
      <guid>https://kkangil.github.io/2020/05/17/Storybook-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Sun, 17 May 2020 07:23:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;우선 이 글에서는 리액트, 타입스크립트를 사용하는 스토리북 세팅이 다 갖춰졌다는 것을 가정하고 써보려고 한다.&lt;br&gt;스토리북은 단위 컴포넌트 테스트를 가능하게 해주고 협업에 있어 엄청난 장점을 갖는다고 생각한다.&lt;br&gt;하지만, 스토리북에서 제공해 주는 Canvas 만 사용했었다. 이로 인해 디테일한 설명, Props 의 type 등 불편한 점이&lt;br&gt;많았다. 이 문제를 어떻게 해결할 수 있을까 라는 고민을 하며 찾아보니 마크다운 문법으로 스토리북을 작성할 수 있다는&lt;br&gt;것을 알게 되었다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>우선 이 글에서는 리액트, 타입스크립트를 사용하는 스토리북 세팅이 다 갖춰졌다는 것을 가정하고 써보려고 한다.<br>스토리북은 단위 컴포넌트 테스트를 가능하게 해주고 협업에 있어 엄청난 장점을 갖는다고 생각한다.<br>하지만, 스토리북에서 제공해 주는 Canvas 만 사용했었다. 이로 인해 디테일한 설명, Props 의 type 등 불편한 점이<br>많았다. 이 문제를 어떻게 해결할 수 있을까 라는 고민을 하며 찾아보니 마크다운 문법으로 스토리북을 작성할 수 있다는<br>것을 알게 되었다.</p><a id="more"></a><h2 id="addon-docs"><a href="#addon-docs" class="headerlink" title="addon-docs"></a>addon-docs</h2><p>우선 .storybook 폴더에 main.js 파일이 존재한다. 이 파일은 스토리북에 대한 설정을 잡아주는 파일이라고 생각하면 된다.</p><p><code>addons</code>, <code>webpack</code> 등의 설정을 해줄 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    addons: [</span><br><span class="line">        <span class="string">'@storybook/addon-knobs/register'</span>,</span><br><span class="line">        <span class="string">'@storybook/addon-actions/register'</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    webpackFinal: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">        config.module.rules.push(&#123;</span><br><span class="line">            test: <span class="regexp">/\.(ts|tsx)$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [[<span class="string">'react-app'</span>, &#123; <span class="attr">flow</span>: <span class="literal">false</span>, <span class="attr">typescript</span>: <span class="literal">true</span> &#125;]],</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="built_in">require</span>.resolve(<span class="string">"react-docgen-typescript-loader"</span>),</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        tsconfigPath: path.join(__dirname, <span class="string">"../tsconfig.json"</span>),</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        config.resolve.extensions.push(<span class="string">'.js'</span>, <span class="string">'.ts'</span>, <span class="string">'.tsx'</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>기존 main.js 의 설정이었다. 사실 스토리북에서 마크다운으로 작성하기 위한 설정은 쉬웠다.</p><p><code>@storybook/addon-docs</code> 를 install 해주고 <code>addons</code> 에 넣어주면 거의 끝났다고 보면 된다.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @storybook/addon-docs</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    addons: [</span><br><span class="line">        <span class="string">'@storybook/addon-docs/preset'</span>,</span><br><span class="line">        <span class="string">'@storybook/addon-knobs/register'</span>,</span><br><span class="line">        <span class="string">'@storybook/addon-actions/register'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이제 마지막 한가지만 더 추가해주면 된다. 본인은 .storybook 폴더 내부에 config.js 파일이 존재하고 해당 파일에서<br><code>path</code> 와 <code>filter</code> 를 설정해준다. 이때 mdx 도 <code>filter</code> 파일 조건에 추가만 해주면 된다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure(<span class="built_in">require</span>.context(<span class="string">'../`stories`'</span>, <span class="literal">true</span>, /\.stories\.(mdx|tsx)$/), <span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><h2 id="mdx-작성"><a href="#mdx-작성" class="headerlink" title="mdx 작성"></a>mdx 작성</h2><p>이제 기존 storybook 파일을 .jsx 또는 .tsx 에서 .mdx 로 바꾸면 된다.<br>addon-docs 문서를 보면 다른 좋은 기능들이 많지만 본인은 거의 아래의 것들만 사용했다.</p><ul><li>Meta</li><li>Title</li><li>Subtitle</li><li>Story</li><li>Preview</li><li>Props</li></ul><h3 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Meta title=<span class="string">"components/Button"</span> component=&#123;Button&#125; decorators=&#123;[withKnobs]&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li><code>title</code> 은 스토리북 상의 경로에 해당한다. component 라는 폴더 밑에 Button 을 생성한다.</li><li><code>component</code> 는 import 한 리액트 컴포넌트를 전달해주면 된다.</li><li><code>decorators</code> 는 여러개 넘겨줄 수 있는데 addon-knobs 를 사용하기 때문에 withKnobs 만 넘겨주었다.</li></ul><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Title&gt;Button&lt;<span class="regexp">/Title&gt;</span></span><br></pre></td></tr></table></figure><p><code>Title</code> 은 해당 문서의 제목 즉, h1 태그가 된다. (#)</p><h3 id="Subtitle"><a href="#Subtitle" class="headerlink" title="Subtitle"></a>Subtitle</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Subtitle&gt;Button Component&lt;<span class="regexp">/Subtitle&gt;</span></span><br></pre></td></tr></table></figure><p><code>Subtitle</code> 은 h2 태그에 해당한다. (##)</p><h3 id="Preview-Story"><a href="#Preview-Story" class="headerlink" title="Preview, Story"></a>Preview, Story</h3><p><code>Preview</code> 와  <code>Story</code> 는 거의 세트로 사용했다. <code>Preview</code> 를 사용하면 문서에 영역이 생기는데 이 영역에<br><code>Story</code>가 들어가게 된다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Preview&gt;</span><br><span class="line">    &lt;Story name=<span class="string">"default"</span>&gt;</span><br><span class="line">        &lt;Button/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Story&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Preview&gt;</span><br></pre></td></tr></table></figure><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p>마지막으로 Props 는 컴포넌트에 <code>defaultProps</code> 가 존재하거나 <code>interface</code> 가 정의되어 있다면 해당 컴포넌트의<br>타입과 필수값들을 테이블로 나열해 준다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Props <span class="keyword">of</span>=&#123;Button&#125;/&gt;</span><br></pre></td></tr></table></figure><h2 id="스토리북에서-리액트-문법-사용하기"><a href="#스토리북에서-리액트-문법-사용하기" class="headerlink" title="스토리북에서 리액트 문법 사용하기"></a>스토리북에서 리액트 문법 사용하기</h2><p>추가로 스토리북에서 리액트의 기능 <code>useState</code>, <code>useEffect</code> 또는 함수를 만들어서 사용할 수 없을까에 대한<br>고민을 하게 되었고 역시나 사용할 수 있었다.</p><p>Story 태그에 js 문법을 이용하여 함수를 사용하고 컴포넌트를 리턴해주면 된다. </p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Preview&gt;</span><br><span class="line">    &lt;Story name=<span class="string">"default"</span>&gt;</span><br><span class="line">        &#123;() =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> [state, setState] = useState([]);</span><br><span class="line">            <span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;Button</span><br><span class="line">                    handleClick=&#123;handleClick&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/Story&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Preview&gt;</span><br></pre></td></tr></table></figure><p>아직 풀리지 않는 이상한 점도 있다. Story 태그에 함수를 사용할때 공백줄이 있으면 에러가 발생한다.<br>이 문제에 대해 구글링 해본 결과 이슈로 올라오고 있는데 아직까지 해결되지는 않은것 같다.</p><p>즉 이 코드는 동작하지만,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState([]);</span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 코드에서는 에러가 발생한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState([]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.npmjs.com/package/@storybook/addon-docs">@storybook/addon-docs</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/17/Storybook-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jest 메서드-toBe</title>
      <link>https://kkangil.github.io/2020/02/23/jest-%EB%A9%94%EC%84%9C%EB%93%9C-toBe/</link>
      <guid>https://kkangil.github.io/2020/02/23/jest-%EB%A9%94%EC%84%9C%EB%93%9C-toBe/</guid>
      <pubDate>Sun, 23 Feb 2020 06:46:45 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;toBe-value&quot;&gt;&lt;a href=&quot;#toBe-value&quot; class=&quot;headerlink&quot; title=&quot;.toBe(value)&quot;&gt;&lt;/a&gt;.toBe(value)&lt;/h2&gt;&lt;p&gt;.toBe(value) 메서드는 expect 의 값과 비교할때 사용한다. 이것은 Object.is() 를 사용하여 비교하는데 === 연산자를 사용하는 것보다 테스트하기에 더 좋다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; can = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&#39;pamplemousse&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ounces: &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;describe(&lt;span class=&quot;string&quot;&gt;&#39;the can&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  test(&lt;span class=&quot;string&quot;&gt;&#39;has 12 ounces&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expect(can.ounces).toBe(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  test(&lt;span class=&quot;string&quot;&gt;&#39;has a sophisticated name&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expect(can.name).toBe(&lt;span class=&quot;string&quot;&gt;&#39;pamplemousse&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="toBe-value"><a href="#toBe-value" class="headerlink" title=".toBe(value)"></a>.toBe(value)</h2><p>.toBe(value) 메서드는 expect 의 값과 비교할때 사용한다. 이것은 Object.is() 를 사용하여 비교하는데 === 연산자를 사용하는 것보다 테스트하기에 더 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> can = &#123;</span><br><span class="line">  name: <span class="string">'pamplemousse'</span>,</span><br><span class="line">  ounces: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'the can'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'has 12 ounces'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can.ounces).toBe(<span class="number">12</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'has a sophisticated name'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can.name).toBe(<span class="string">'pamplemousse'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>.toBe(value) 메서드에는 소수를 쓰지 않는것이 좋다. 예를 들면 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="number">0.1</span> + <span class="number">0.2</span>).toBe(<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p>위와 같은 경우이다. 자바스크립트에서는 0.1 + 0.2 가 0.3이 아니기 때문이다.</p><h2 id="toHaveBeenCalled"><a href="#toHaveBeenCalled" class="headerlink" title=".toHaveBeenCalled()"></a>.toHaveBeenCalled()</h2><p>mock 함수가 실행됐는지를 테스트하는 메서드이다.<br>mock 함수가 실행됐으면 테스트에 성공하는데 반대로 해당 함수를 실행하지 않는 것이 원하는 결과라면 .not 을 사용해서 테스트 코드를 구성하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drinkAll</span>(<span class="params">callback, flavour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flavour !== <span class="string">'octopus'</span>) &#123;</span><br><span class="line">    callback(flavour);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'drinkAll'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drinks something lemon-flavoured'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>);</span><br><span class="line">    expect(drink).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'does not drink something octopus-flavoured'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>);</span><br><span class="line">    expect(drink).not.toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenCalledTimes-number"><a href="#toHaveBeenCalledTimes-number" class="headerlink" title=".toHaveBeenCalledTimes(number)"></a>.toHaveBeenCalledTimes(number)</h2><p>mock 함수가 몇번 실행됐는지를 확인할때 사용하는 메서드이다. 인자의 number 만큼 실행됐으면 테스트는 성공한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenCalledTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenCalledWith-arg1-arg2-…"><a href="#toHaveBeenCalledWith-arg1-arg2-…" class="headerlink" title="toHaveBeenCalledWith(arg1, arg2, …)"></a>toHaveBeenCalledWith(arg1, arg2, …)</h2><p>mock 함수가 실행됐을때 인자값을 테스트할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'registration applies correctly to orange La Croix'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage = <span class="keyword">new</span> LaCroix(<span class="string">'orange'</span>);</span><br><span class="line">  register(beverage);</span><br><span class="line">  <span class="keyword">const</span> f = jest.fn();</span><br><span class="line">  applyToAll(f);</span><br><span class="line">  expect(f).toHaveBeenCalledWith(beverage);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenLastCalledWith-arg1-arg2-…"><a href="#toHaveBeenLastCalledWith-arg1-arg2-…" class="headerlink" title="toHaveBeenLastCalledWith(arg1, arg2, …)"></a>toHaveBeenLastCalledWith(arg1, arg2, …)</h2><p>mock 함수가 여러번 실행되었을때 마지막 실행의 인자값을 비교할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'applying to all flavors does mango last'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  applyToAllFlavors(drink);</span><br><span class="line">  expect(drink).toHaveBeenLastCalledWith(<span class="string">'mango'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenNthCalledWith-nthCall-arg1-arg2-…"><a href="#toHaveBeenNthCalledWith-nthCall-arg1-arg2-…" class="headerlink" title=".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)"></a>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)</h2><p>mock 함수가 여러번 실행되었을때 순서를 지정하여 인자값을 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveReturned"><a href="#toHaveReturned" class="headerlink" title=".toHaveReturned()"></a>.toHaveReturned()</h2><p>mock 함수가 실행되었고 return 이 되었는지를 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinks returns'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  drink();</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturned();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveReturnedTimes-number"><a href="#toHaveReturnedTimes-number" class="headerlink" title=".toHaveReturnedTimes(number)"></a>.toHaveReturnedTimes(number)</h2><p>mock 함수가 실행되었고 몇번 return 이 되었는지를 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns twice'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  drink();</span><br><span class="line">  drink();</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturnedTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveReturnedWith-value"><a href="#toHaveReturnedWith-value" class="headerlink" title=".toHaveReturnedWith(value)"></a>.toHaveReturnedWith(value)</h2><p>mock 함수가 실행되었고 어떤 값이 리턴되었는지 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns La Croix'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage = &#123;<span class="attr">name</span>: <span class="string">'La Croix'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">beverage</span> =&gt;</span> beverage.name);</span><br><span class="line"></span><br><span class="line">  drink(beverage);</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturnedWith(<span class="string">'La Croix'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveLastReturnedWith-value"><a href="#toHaveLastReturnedWith-value" class="headerlink" title=".toHaveLastReturnedWith(value)"></a>.toHaveLastReturnedWith(value)</h2><p>마지막으로 실행된 mock 함수의 return 값을 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns La Croix (Orange) last'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage1 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Lemon)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> beverage2 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Orange)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">beverage</span> =&gt;</span> beverage.name);</span><br><span class="line"></span><br><span class="line">  drink(beverage1);</span><br><span class="line">  drink(beverage2);</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveLastReturnedWith(<span class="string">'La Croix (Orange)'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveNthReturnedWith-nthCall-value"><a href="#toHaveNthReturnedWith-nthCall-value" class="headerlink" title=".toHaveNthReturnedWith(nthCall, value)"></a>.toHaveNthReturnedWith(nthCall, value)</h2><p>mock 함수가 여러번 실행되었을때 순서를 지정하여 return 값을 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns expected nth calls'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage1 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Lemon)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> beverage2 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Orange)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">beverage</span> =&gt;</span> beverage.name);</span><br><span class="line"></span><br><span class="line">  drink(beverage1);</span><br><span class="line">  drink(beverage2);</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveNthReturnedWith(<span class="number">1</span>, <span class="string">'La Croix (Lemon)'</span>);</span><br><span class="line">  expect(drink).toHaveNthReturnedWith(<span class="number">2</span>, <span class="string">'La Croix (Orange)'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveLength-number"><a href="#toHaveLength-number" class="headerlink" title=".toHaveLength(number)"></a>.toHaveLength(number)</h2><p>length 속성을 가진 객체에서 길이를 비교할때 사용한다. array 와 string 의 길이를 비교할 때 유용하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">'abc'</span>).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">''</span>).not.toHaveLength(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="toHaveProperty-keyPath-value"><a href="#toHaveProperty-keyPath-value" class="headerlink" title=".toHaveProperty(keyPath, value?)"></a>.toHaveProperty(keyPath, value?)</h2><p>객체에 keyPath 의 속성이 있는지 테스트할때 사용한다. 두번째 인자 value 는 인자값으로 keyPath 만 사용했을 경우에는 해당 속성이 있는지만 확인하지만 value 까지 사용하면 keyPath 속성의 값도 같이 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">    <span class="string">'nice.oven'</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'ceiling.height'</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'this house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Example Referencing</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bath'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bedrooms'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'pool'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deep referencing using dot notation</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.area'</span>, <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.amenities'</span>, [</span><br><span class="line">    <span class="string">'oven'</span>,</span><br><span class="line">    <span class="string">'stove'</span>,</span><br><span class="line">    <span class="string">'washer'</span>,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'kitchen.open'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deep referencing using an array containing the keyPath</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'area'</span>], <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(</span><br><span class="line">    [<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>],</span><br><span class="line">    [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">  );</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>, <span class="number">0</span>], <span class="string">'oven'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'nice.oven'</span>]);</span><br><span class="line">  expect(houseForSale).not.toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'open'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Referencing keys with dot in the key itself</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'ceiling.height'</span>], <span class="string">'tall'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeCloseTo-number-numDigits"><a href="#toBeCloseTo-number-numDigits" class="headerlink" title=".toBeCloseTo(number, numDigits?)"></a>.toBeCloseTo(number, numDigits?)</h2><p>소수를 비교할때 근사치로 비교한다. numDigits 를 사용하면 소수 몇번째 자리까지만 비교할 수 있다.<br>자바스크립트에서 0.1 + 0.2 는 0.3 이 아닌 0.30000000000000004 이므로 이 메서드를 사용하면 테스트가 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'adding works sanely with decimals'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">0.2</span> + <span class="number">0.1</span>).toBeCloseTo(<span class="number">0.3</span>, <span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeDefined"><a href="#toBeDefined" class="headerlink" title="toBeDefined()"></a>toBeDefined()</h2><p>expect 의 값이 정의 되어있는지를 확인한다. 즉, undefined 이 아닌지 확인한다. (null 도 true)<br>.not 을 붙이면 undefined 인지 확인할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeDefined'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">null</span>).toBeDefined();</span><br><span class="line">  expect(<span class="literal">undefined</span>).not.toBeDefined();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeFalsy"><a href="#toBeFalsy" class="headerlink" title=".toBeFalsy()"></a>.toBeFalsy()</h2><p>자바스크립트에서 다음 6개의 부정값에 대해서 테스트하는 메서드이다.<br><code>false</code>, <code>0</code>, <code>&#39;&#39;</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">".toBeFalsy()"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">0</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">false</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">null</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">undefined</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="string">''</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">NaN</span>).toBeFalsy();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeTruthy"><a href="#toBeTruthy" class="headerlink" title=".toBeTruthy()"></a>.toBeTruthy()</h2><p>.toBeFalsy 에서 사용되는 6개의 부정값 이외의 값은 truthy 하다.</p><h2 id="toBeGreaterThan-number-bigint"><a href="#toBeGreaterThan-number-bigint" class="headerlink" title=".toBeGreaterThan(number | bigint)"></a>.toBeGreaterThan(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 큰지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeGreaterThan"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">11</span>).toBeGreaterThan(<span class="number">10</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeGreaterThanOrEqual-number-bigint"><a href="#toBeGreaterThanOrEqual-number-bigint" class="headerlink" title=".toBeGreaterThanOrEqual(number | bigint)"></a>.toBeGreaterThanOrEqual(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 크거나 같은지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeGreaterThanOrEqual"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">11</span>).toBeGreaterThanOrEqual(<span class="number">11</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeLessThan-number-bigint"><a href="#toBeLessThan-number-bigint" class="headerlink" title=".toBeLessThan(number | bigint)"></a>.toBeLessThan(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 작은지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeLessThan"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">9</span>).toBeLessThan(<span class="number">10</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeLessThanOrEqual-number-bigint"><a href="#toBeLessThanOrEqual-number-bigint" class="headerlink" title=".toBeLessThanOrEqual(number | bigint)"></a>.toBeLessThanOrEqual(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 작거나 같은지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeLessThanOrEqual"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">11</span>).toBeLessThanOrEqual(<span class="number">11</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeInstanceOf-Class"><a href="#toBeInstanceOf-Class" class="headerlink" title=".toBeInstanceOf(Class)"></a>.toBeInstanceOf(Class)</h2><p>instance 객체를 비교할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(A);</span><br><span class="line">expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).toBeInstanceOf(<span class="built_in">Function</span>);</span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(<span class="built_in">Function</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h2 id="toBeNull"><a href="#toBeNull" class="headerlink" title=".toBeNull()"></a>.toBeNull()</h2><p>expect 값이 null 인지 확인하는 메서드이다.<br>.toBe(null) 을 사용하는 것과 동일하지만 테스트가 실패했을때 에러 메시지가 조금 더 보기 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bloop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'bloop returns null'</span>, () =&gt; &#123;</span><br><span class="line">  expect(bloop()).toBeNull();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeUndefined"><a href="#toBeUndefined" class="headerlink" title=".toBeUndefined()"></a>.toBeUndefined()</h2><p>expect 값이 undefined 인지 확인하는 메서드이다.<br>toBeNull 과 마찬가지로 toBe(undefined)를 사용할 수도 있지만 에러 메시지가 조금 더 좋다고 한다.</p><h2 id="toBeNaN"><a href="#toBeNaN" class="headerlink" title=".toBeNaN()"></a>.toBeNaN()</h2><p>expect 값이 NaN 확인하는 메서드이다.</p><h2 id="toContain-item"><a href="#toContain-item" class="headerlink" title=".toContain(item)"></a>.toContain(item)</h2><p>배열 또는 문자에서 item 을 포함하고 있는지 확인하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toContain"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>];</span><br><span class="line">  <span class="keyword">const</span> b = <span class="string">"foo_bar"</span></span><br><span class="line"></span><br><span class="line">  expect(a).toContain(<span class="string">"bar"</span>);</span><br><span class="line">  expect(a).not.toContain(<span class="string">"baz"</span>);</span><br><span class="line">  expect(b).toContain(<span class="string">"bar"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toContainEqual-item"><a href="#toContainEqual-item" class="headerlink" title="toContainEqual(item)"></a>toContainEqual(item)</h2><p>배열에서 일반 특별한 구조를 가진 value (ex. JSON) 를 포함하고 있는지 확인할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toContain"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, &#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;];</span><br><span class="line"></span><br><span class="line">  expect(a).toContain(&#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>toContain 메서드를 사용하면 위의 테스트는 실패되지만 이 경우 toContainEqual 메서드를 사용하면 성공한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toContainEqual"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, &#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;];</span><br><span class="line">  </span><br><span class="line">  expect(a).toContainEqual(&#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toEqual-value"><a href="#toEqual-value" class="headerlink" title="toEqual(value)"></a>toEqual(value)</h2><p>toBe 는 정확하게 테스트하기 위해 Object.is 를 사용한다. 만약 오브젝트의 값을 체크하기를 원한다면 대신 toEqual 를 사용해야한다. toEqual 는 오브젝트 또는 배열의 모든 필드 값을 재귀적으로 체크한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> can1 = &#123;</span><br><span class="line">  flavor: <span class="string">'grapefruit'</span>,</span><br><span class="line">  ounces: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> can2 = &#123;</span><br><span class="line">  flavor: <span class="string">'grapefruit'</span>,</span><br><span class="line">  ounces: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'the La Croix cans on my desk'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'have all the same properties'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can1).toEqual(can2);</span><br><span class="line">  &#125;);</span><br><span class="line">  test(<span class="string">'are not the exact same can'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can1).not.toBe(can2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>toBe 를 사용한 expect(can1).not.toBe(can2); 의 경우 can1 의 객체와 can2 의 객체가 동일한 객체가 아니기 때문에 테스트에 성공한다.</p><h2 id="toMatch-regexpOrString"><a href="#toMatch-regexpOrString" class="headerlink" title=".toMatch(regexpOrString)"></a>.toMatch(regexpOrString)</h2><p>정규식에 대해 문자열을 테스트 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'an essay on the best flavor'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'mentions grapefruit'</span>, () =&gt; &#123;</span><br><span class="line">    expect(essayOnTheBestFlavor()).toMatch(<span class="regexp">/grapefruit/</span>);</span><br><span class="line">    expect(essayOnTheBestFlavor()).toMatch(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'grapefruit'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toMatchObject-object"><a href="#toMatchObject-object" class="headerlink" title=".toMatchObject(object)"></a>.toMatchObject(object)</h2><p>객체 부분 속성에 대해 일치하는지 테스트한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> desiredHouse = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    wallColor: expect.stringMatching(<span class="regexp">/white|yellow/</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  expect(houseForSale).toMatchObject(desiredHouse);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="toThrow-error"><a href="#toThrow-error" class="headerlink" title=".toThrow(error?)"></a>.toThrow(error?)</h2><p>특정 함수가 호출될 때 에러를 던진다는 것을 테스트하려면 toThrow를 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'throws on octopus'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    drinkFlavor(<span class="string">'octopus'</span>);</span><br><span class="line">  &#125;).toThrow();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>참조: <a href="https://jestjs.io/docs/en/expect#tobevalue">Jest 공식 문서</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/23/jest-%EB%A9%94%EC%84%9C%EB%93%9C-toBe/#disqus_thread</comments>
    </item>
    
    <item>
      <title>렌더링</title>
      <link>https://kkangil.github.io/2020/02/16/%EB%A0%8C%EB%8D%94%EB%A7%81/</link>
      <guid>https://kkangil.github.io/2020/02/16/%EB%A0%8C%EB%8D%94%EB%A7%81/</guid>
      <pubDate>Sun, 16 Feb 2020 08:07:24 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;렌더링-과정&quot;&gt;&lt;a href=&quot;#렌더링-과정&quot; class=&quot;headerlink&quot; title=&quot;렌더링 과정&quot;&gt;&lt;/a&gt;렌더링 과정&lt;/h2&gt;&lt;p&gt;렌더링이란 논리적인 문서(DOM)의 표현식을 그래픽 표현식으로 변형시키는 과정이다. 이 과정은 다음과 같이 크게 2단계를 거쳐 이뤄진다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM 요소와 스타일에 기반을 둔 레이아웃 계산&lt;/li&gt;
&lt;li&gt;계산된 요소의 화면 표현&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;일반적인 전체 흐름은 브라우저에 문서가 로딩됨에 따라 DOM 트리의 구성이 진행되면 레이아웃을 계산한 후 문서에 요소를 그린다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="렌더링-과정"><a href="#렌더링-과정" class="headerlink" title="렌더링 과정"></a>렌더링 과정</h2><p>렌더링이란 논리적인 문서(DOM)의 표현식을 그래픽 표현식으로 변형시키는 과정이다. 이 과정은 다음과 같이 크게 2단계를 거쳐 이뤄진다.</p><ol><li>DOM 요소와 스타일에 기반을 둔 레이아웃 계산</li><li>계산된 요소의 화면 표현</li></ol><p>일반적인 전체 흐름은 브라우저에 문서가 로딩됨에 따라 DOM 트리의 구성이 진행되면 레이아웃을 계산한 후 문서에 요소를 그린다.</p><a id="more"></a><h3 id="렌더링이-진행되는-과정"><a href="#렌더링이-진행되는-과정" class="headerlink" title="렌더링이 진행되는 과정"></a>렌더링이 진행되는 과정</h3><h4 id="DOM-트리-생성"><a href="#DOM-트리-생성" class="headerlink" title="DOM 트리 생성"></a>DOM 트리 생성</h4><p>브라우저는 HTML 태그를 파싱해 DOM 트리를 구성한다. DOM은 데이터의 표현식으로 모든 HTML 태그에는 그에 상응하는 노드가 있으며, 태그 사이에는 텍스트 데이터가 포함될 수 있는데 이 또한 텍스트 노드의 표현식이다.</p><p>각 태그는 태그 데이터의 표현식인 DOM 요소로 1:1로 대응해 표현되며, DOM 요소 노드는 트리 형태로 구성된다. 이를 DOM 트리라 한다.</p><h4 id="스타일-구조체-생성"><a href="#스타일-구조체-생성" class="headerlink" title="스타일 구조체 생성"></a>스타일 구조체 생성</h4><p>스타일 정보를 통해 스타일 구조체를 생성한다. 스타일 정보는 단계적으로 처리되며, 가장 마지막 단계의 스타일 정보가 이전 스타일보다 우선으로 적용된다. 스타일 정보는 다음과 같이 3단계로 나누어 처리된다.</p><ol><li>브라우저 자체에 포함된 기본 스타일 정보</li><li>사용자 정의 스타일</li><li>HTML 인라인 스타일</li></ol><h4 id="렌더-트리-생성"><a href="#렌더-트리-생성" class="headerlink" title="렌더 트리 생성"></a>렌더 트리 생성</h4><p>DOM 트리와 스타일 구조를 통해 렌더 트리를 생성한다.<br>렌더 트리는 DOM 트리와는 다르게 각 노드에 스타일 정보가 설정되어 있고 화면에 표현되는 노드로 구성된다. 어떤 노드의 스타일이 ‘display: none’ 으로 설정되어 있으면 해당 노드는 렌더 트리에 포함되지 않는다. 그렇기 때문에 DOM 트리와 렌더 트리의 노드는 서로 1:1로 대응되지 않는다. head, title, script 등과 같이 화면에 표현되는 노드가 아니므로 DOM 트리에는 포함되어 있지만 렌더 트리에는 포함되어 있지 않다.</p><h4 id="레이아웃-처리"><a href="#레이아웃-처리" class="headerlink" title="레이아웃 처리"></a>레이아웃 처리</h4><p>렌더 트리의 각 노드의 크기가 계산되고 문서에서 정확한 위치에 배치되도록 위치를 계산한다. 루트에서 하위 노드로 반복되며 진행한다.</p><h4 id="페인트"><a href="#페인트" class="headerlink" title="페인트"></a>페인트</h4><p>렌더 트리를 순회하면서 페인트 함수를 호출해 노드를 화면에 표현한다.</p><hr/><h3 id="리플로우-reflow-와-리페인트-repaint"><a href="#리플로우-reflow-와-리페인트-repaint" class="headerlink" title="리플로우(reflow) 와 리페인트(repaint)"></a>리플로우(reflow) 와 리페인트(repaint)</h3><p>렌더링이 모두 완료된 상태에서 사용자의 인터랙션 또는 기능에 따라 화면의 일부 영역에 변경 요인이 발생한다. 이러한 작업이 발생하면 구성돼 있는 렌더 트리가 변경되어야 하며 리플로우 또는 리페인트가 발생한다.</p><h4 id="리플로우"><a href="#리플로우" class="headerlink" title="리플로우"></a>리플로우</h4><p>변경이 필요한 렌더 트리에 대한 유효성 확인 작업과 함께 노드의 크기와 위치를 다시 계산한다. 노드의 ‘크기’ 또는 ‘위치’가 바뀌어 현재 레이아웃에 영향을 미쳐 배치를 <code>다시</code> 해야 할 때 리플로우가 발생한다.</p><p>특정 요소에 리플로우가 발생하면 요소의 DOM 구조에 따라 자식 요소와 부모 요소 역시 다시 계산될 수 있으며, 경우에 따라서는 문서 전체에 리플로우가 발생할 수도 있다.</p><h4 id="리페인트"><a href="#리페인트" class="headerlink" title="리페인트"></a>리페인트</h4><p>변경 영역의 결과를 표현하기 위해 화면이 업데이트 되는것을 의미한다. 리플로우각 발생하거나 배경색 변경 등의 단순한 스타일 변경과 같은 작업이 발생하는 경우다.</p><p>리플로우와 리페인트 모두 처리 비용이 발생하지만 리페인트보다 리플로우의 비용이 훨씬 높다. 리플로우는 변경 범위에 따라 전체 페이지의 레이아웃을 변경해야 할 수도 있기 때문이다. 어느 경우든 리플로우와 리페인트는 코드를 작성할 때 최소화해야 한다.</p><h4 id="발생-요인"><a href="#발생-요인" class="headerlink" title="발생 요인"></a>발생 요인</h4><ul><li>DOM 노드의 변경</li><li>DOM 노드의 노출 속성을 통한 변경: display: none 은 리플로우와 리페인트를 발생시키지만 비슷한 속성인 visibility: hidden 은 요소가 차지한 영역을 유지해 레이아웃에 영향을 주지 않으므로 리페인트만 발생한다.</li><li>스크립트 애니메이션: 애니메이션은 DOM 노드의 이동과 스타일 변경이 짧은 시간 내에 수차례 반복해 발생되는 작업이다.</li><li>스타일</li><li>사용자의 액션</li></ul><hr/><h2 id="리플로우-최소화-방법"><a href="#리플로우-최소화-방법" class="headerlink" title="리플로우 최소화 방법"></a>리플로우 최소화 방법</h2><h3 id="작업-그룹핑"><a href="#작업-그룹핑" class="headerlink" title="작업 그룹핑"></a>작업 그룹핑</h3><p>DOM 요소의 정보를 요청하고 변경하는 코드는 같은 형태의 작업끼리 그룹으로 묶어 실행시키는 것이 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width = <span class="built_in">document</span>.getElementById(<span class="string">"layer1"</span>).style.width;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer2"</span>).style.width = width;</span><br><span class="line">  <span class="keyword">var</span> height = <span class="built_in">document</span>.getElementById(<span class="string">"layer3"</span>).style.height;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer4"</span>).style.height = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 요소의 스타일 정보를 요청하고, 반환된 값을 다른 요소의 스타일 변경하는 데 사용한다. 그 후 다시 다른 요소에 동일한 형태의 작업이 반복된다. 이 코드를 실행하면 리플로우가 여러 번 발생할 수 있다.<br>스타일 조회 -&gt; 변경 -&gt; 리플로우 -&gt; 스타일 조회 -&gt; 변경 -&gt; 리플로우</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width = <span class="built_in">document</span>.getElementById(<span class="string">"layer1"</span>).style.width;</span><br><span class="line">  <span class="keyword">var</span> height = <span class="built_in">document</span>.getElementById(<span class="string">"layer3"</span>).style.height;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer2"</span>).style.width = width;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer4"</span>).style.height = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 비슷한 형태의 작업 끼리 그룹으로 묶어 실행되도록 순서를 변경하면 렌더링 처리를 향상시킬 수 있다.</p><p>스타일 조회 -&gt; 스타일 조회 -&gt; 변경 -&gt; 변경 -&gt; 리플로우</p><h3 id="실행-사이클"><a href="#실행-사이클" class="headerlink" title="실행 사이클"></a>실행 사이클</h3><p>브라우저에서 자바스크립트 실행은 <code>이벤트 루프</code> 모델을 따른다. 기본적으로 브라우저는 이벤트가 발생하면 바로 처리가 가능하도록 유휴(idle) 상태에 머무른다. 그러다 어떤 요청에 의해 유휴 상태가 해제되면 작업이 실행된다. 작업이 실행되면 브라우저는 작업의 실행 결과에 따른 리페인트가 완료될 때까지 기다린다. 이러한 실행 사이클로 인해 타이머를 사용하면 수차례의 리플로우와 리페인트가 발생될 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).style.height = <span class="string">"50px"</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"box2"</span>).style.height = <span class="string">"70px"</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>타이머의 설정 시간을 0으로 설정해도 브라우저가 유휴 상태(stack 이 비워져 있는 상태)가 아니면 그 상태가 되기까지 실행되지 않는다. 첫 번째 요소에 대한 작업이 한 사이클 내에서 실행되고, 타이머의 실행은 먼저 실행된 사이클이 끝난 다음에 진행된다. 이로 인해 결과적으로는 리플로우와 리페인트가 두 번 발생하게 된다. 이와 같이 리플로우와 리페인트가 일어날 수 있는 작업은 가능하면 한 실행 사이클 안에서 실행하도록 처리하는 편이 효과적이다.</p><h3 id="노출-제어를-통한-리플로우-최소화-방법"><a href="#노출-제어를-통한-리플로우-최소화-방법" class="headerlink" title="노출 제어를 통한 리플로우 최소화 방법"></a>노출 제어를 통한 리플로우 최소화 방법</h3><p>요소의 스타일을 변경하면 리페인트는 반드시 일어나며, 변경 형태에 따라 리플로우도 일어난다.</p><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>기본적으로 리플로우와 리페인트는 모두 화면에 변경된 사항이 반영되는 시점에 발생한다. 여러 속성의 스타일을 변경하는 중간 단계에서는 화면에 표시하지 않고, 작업이 완료되고 최종 결과가 반영되는 마지막 시점에 요소를 다시 표시한다면 리플로우와 리페인트의 발생 횟수를 크게 줄일 수 있다.</p><p>이 코드는 값을 여러번 변경하며 값이 변경될 때마다 리플로우와 리페인트가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">50</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  element.style.width = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  element.style.borderWidth = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 다음과 같이 요소를 보이지 않게 하고 모든 변경이 반영된 이후에 표시하면 처음과 마지막 시점 두 번으로 리플로우 발생 횟수가 줄어든다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span><br><span class="line"></span><br><span class="line">element.style.display = <span class="string">"none"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">50</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  element.style.width = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  element.style.borderWidth = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.style.display = <span class="string">"block"</span>;</span><br></pre></td></tr></table></figure><p>display 의 none, block 을 이용한 최소화 방법이다.</p><h4 id="노드-복제"><a href="#노드-복제" class="headerlink" title="노드 복제"></a>노드 복제</h4><p>변경하려는 요소의 노드를 복제한 후 복제된 노드에 필요한 작업을 실행하는 방법이다. 복제된 노드는 DOM 트리에 추가된 상태가 아니므로 렌더링 성능에 영향을 줄 수 있는 작업을 실행하더라도 리플로우나 리페인트가 발생하지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span><br><span class="line"><span class="keyword">var</span> clone = element.cloneNode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  clone.style.width = i + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentNode.replaceChild(clone, element);</span><br></pre></td></tr></table></figure><p>작업이 모두 완료된 이후 복제된 노드를 원래 노드와 치환해 DOM 트리에 변경된 사항이 적용되게 한다. 그러면 치환 시점에만 리플로우와 리페인트가 발생하는 것이므로 display 속성을 사용하는것 보다 적게 발생한다.</p><h4 id="캐싱"><a href="#캐싱" class="headerlink" title="캐싱"></a>캐싱</h4><p>여기서의 캐싱은 별도의 변수에 자주 사용하는 값을 저장하는 것이다. 특정 속성과 메서드를 사용하기만 해도 리플로우 발생하는 경우가 있다. 자주 사용하는 속성의 값이나 메서드의 반환값을 변수에 저장하면 직접 속성이나 메서드를 호출하는 횟수를 줄여 성능을 향상 시킬 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (condition) &#123;</span><br><span class="line">  el.style.width = el.scrollWidth + <span class="string">"px"</span>;</span><br><span class="line">  el.style.height = el.scrollHeight + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scrollWidth 와 scrollHeight 메서드는 호출하기만 해도 리플로우가 발생한다. 이 경우 값을 최대한 별도의 변수에 캐싱해 자주 호출되지 않게 하면 리플로우의 발생 빈도를 낮출 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollWidth = el.scrollWidth;</span><br><span class="line"><span class="keyword">var</span> scrollHeight = el.scrollHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (condition) &#123;</span><br><span class="line">  el.style.width = scrollWidth + <span class="string">"px"</span>;</span><br><span class="line">  el.style.height = scrollHeight + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="하드웨어-가속-렌더링"><a href="#하드웨어-가속-렌더링" class="headerlink" title="하드웨어 가속 렌더링"></a>하드웨어 가속 렌더링</h2><p>브라우저는 웹 페이지 컨텐츠 렌더링 작업의 대부분을 CPU 에 의존해 왔다. 하지만 모바일 기기에도 GPU 가 기본으로 포함되고, 비디오, 3D 그래픽 등과 같이 화려하고 용량이 큰 컨텐트의 소비가 늘어 이를 활용하는 방법에 대한 고민도 커졌다.</p><p>GPU를 렌더링에 활용하면 성능에 이점이 있다. 일반적인 렌더링은 CPU 에서 렌더링 요소에 대한 연산 작업을 처리하면 그 결과값을 사용해 GPU 가 출력하는 과정을 거친다. 그러나 CPU 에서 처리되던 작업이 GPU 에 위임되면 처리 결과값을 GPU 로 전달하는 과정이 생략될 수 있고 CPU 도 다른 작업에 더 집중할 수 있다.</p><p>GPU 의 기본적인 하드웨어 디자인은 대용량의 픽셀 데이터를 조합하고 그리는 작업을 하게 되어 있으므로 CPU 보다 GPU 가 렌더링 작업을 최적으로 실행할 수 있다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/16/%EB%A0%8C%EB%8D%94%EB%A7%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jest 메서드 - expect</title>
      <link>https://kkangil.github.io/2020/02/16/jest-%EB%A9%94%EC%84%9C%EB%93%9C-expect/</link>
      <guid>https://kkangil.github.io/2020/02/16/jest-%EB%A9%94%EC%84%9C%EB%93%9C-expect/</guid>
      <pubDate>Sun, 16 Feb 2020 05:59:50 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;expect-value&quot;&gt;&lt;a href=&quot;#expect-value&quot; class=&quot;headerlink&quot; title=&quot;expect(value)&quot;&gt;&lt;/a&gt;expect(value)&lt;/h3&gt;&lt;p&gt;expect 함수는 값을 테스트 하고 싶을 때 사용한다. 드물게 expect 함수만 사용해서 테스트를 할 수 있지만 값을 테스트하기 위해 &lt;code&gt;matcher&lt;/code&gt; 함수를 함께 사용한다.&lt;/p&gt;
&lt;h3 id=&quot;expect-extend-matchers&quot;&gt;&lt;a href=&quot;#expect-extend-matchers&quot; class=&quot;headerlink&quot; title=&quot;expect.extend(matchers)&quot;&gt;&lt;/a&gt;expect.extend(matchers)&lt;/h3&gt;&lt;p&gt;expect.extend 함수를 사용하여 Jest 에서 제공하는 matcher 가 아닌 직접 만들어서 사용할 수 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="expect-value"><a href="#expect-value" class="headerlink" title="expect(value)"></a>expect(value)</h3><p>expect 함수는 값을 테스트 하고 싶을 때 사용한다. 드물게 expect 함수만 사용해서 테스트를 할 수 있지만 값을 테스트하기 위해 <code>matcher</code> 함수를 함께 사용한다.</p><h3 id="expect-extend-matchers"><a href="#expect-extend-matchers" class="headerlink" title="expect.extend(matchers)"></a>expect.extend(matchers)</h3><p>expect.extend 함수를 사용하여 Jest 에서 제공하는 matcher 가 아닌 직접 만들어서 사용할 수 있다.</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">expect.extend(&#123;</span><br><span class="line">  toBeWithinRange(received, floor, ceiling) &#123;</span><br><span class="line">    <span class="keyword">const</span> pass = received &gt;= floor &amp;&amp; received &lt;= ceiling;</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> not to be within range <span class="subst">$&#123;floor&#125;</span> - <span class="subst">$&#123;ceiling&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">true</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> to be within range <span class="subst">$&#123;floor&#125;</span> - <span class="subst">$&#123;ceiling&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">false</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'numeric ranges'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">100</span>).toBeWithinRange(<span class="number">90</span>, <span class="number">110</span>);</span><br><span class="line">  expect(<span class="number">101</span>).not.toBeWithinRange(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">  expect(&#123; <span class="attr">apples</span>: <span class="number">6</span>, <span class="attr">bananas</span>: <span class="number">3</span> &#125;).toEqual(&#123;</span><br><span class="line">    apples: expect.toBeWithinRange(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    bananas: expect.not.toBeWithinRange(<span class="number">11</span>, <span class="number">20</span>),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>toBeWithinRange</code> 라는 matcher 를 만드는 방법이다. expect 의 값이 첫번째 인자로 넘어간다. 성공 했을경우 성공 사유 message 와 pass를 true로 return 해준다. 살패 했을경우는 반대로 실패 사유 message 와 pass 를 false 로 return 해준다.</p><p>expect.extend 는 비동기 함수 호출도 지원한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">expect.extend(&#123;</span><br><span class="line">  <span class="keyword">async</span> toBeDivisibleByExternalValue(received) &#123;</span><br><span class="line">    <span class="keyword">const</span> externalValue = <span class="keyword">await</span> getExternalValueFromRemoteSource();</span><br><span class="line">    <span class="keyword">const</span> pass = received % externalValue == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> not to be divisible by <span class="subst">$&#123;externalValue&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">true</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> to be divisible by <span class="subst">$&#123;externalValue&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">false</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'is divisible by external value'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="number">100</span>).toBeDivisibleByExternalValue();</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="number">101</span>).not.toBeDivisibleByExternalValue();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Custom-Matchers-API"><a href="#Custom-Matchers-API" class="headerlink" title="Custom Matchers API"></a>Custom Matchers API</h4><p>Macher 들은 항상 두개의 key 를 포함하고 있는 객체를 리턴해야한다. pass 는 성공/실패 여부이고 message 는 테스트가 실패 했을 경우 보여진다. .not() 메서드를 사용하면 실패 했을때 pass: true 의 message 가 보여진다.</p><h3 id="expect-anything"><a href="#expect-anything" class="headerlink" title="expect.anything"></a>expect.anything</h3><p>null 과 undefined 을 제외한 모든 값들과 일치한다. 즉, null 과 undefined 외의 모든 값들은 동일하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'map calls its argument with a non-null argument'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">  [<span class="number">1</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> mock(x));</span><br><span class="line">  expect(mock).toBeCalledWith(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위의 테스트 코드는 성공할 것이다. 하지만 <code>expect(mock).toBeCalledWith(2);</code> 로 바꾸게 된다면 배열의 length 가 1 이므로 실패할 것이다. 만약 mock() 함수가 몇번 실행이 되는지 상관없이 테스트 케이스를 성공 처리 하고 싶을때 anything 을 사용하는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(mock).toBeCalledWith(expect.anything());</span><br></pre></td></tr></table></figure><h3 id="expect-any-constructor"><a href="#expect-any-constructor" class="headerlink" title="expect.any(constructor)"></a>expect.any(constructor)</h3><p>expect.any(constructor) matches anything that was created with the given constructor</p><p>expect.any 는 주어진 생성자와 값이 해당 생성자에 일치하는 지를 테스트 한다. <code>toEqual</code> 과 <code>toBeCalledWith</code> 함수에 값대신 해당 메서드를 사용할 수 있다.</p><p>randocall 함수의 return 값이 Number 인지 테스트하는 코드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randocall</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">6</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'randocall calls its callback with a number'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">  randocall(mock);</span><br><span class="line">  expect(mock).toBeCalledWith(expect.any(<span class="built_in">Number</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="expect-arrayContaining-array"><a href="#expect-arrayContaining-array" class="headerlink" title="expect.arrayContaining(array)"></a>expect.arrayContaining(array)</h3><p>기대값이 expect.arrayContaining(array) 메서드에 주어지는 배열의 요소를 모두 포함하고 있는지 확인할 때 사용하는 메서드이다. <code>toEqual</code> 과 <code>toBeCalledWith</code> 함수에 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>];</span><br><span class="line">  it(<span class="string">'matches even if received contains additional elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'does not match if received does not contain expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">  expect([<span class="string">'Alice'</span>, <span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>첫번째 테스트의 경우 기대값 요소에 ‘Alice’, ‘Bob’ 이 포함되어 있기 때문에 성공한다. 두번째의 경우는 ‘Alice’ 를 포함하고 있지 않기 때문에 실패한다. 세번째 테스트 경우처럼 배열 요소에 중복이 있어도 상관없이 테스트는 성공한다.</p><p>expect.not.arrayContaining(array) 메서드도 사용 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="string">'Samantha'</span>];</span><br><span class="line">  it(<span class="string">'matches if the actual array does not contain the expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).toEqual(</span><br><span class="line">      expect.not.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="expect-objectContaining-object"><a href="#expect-objectContaining-object" class="headerlink" title="expect.objectContaining(object)"></a>expect.objectContaining(object)</h3><p>객체의 key 와 value 를 포함하고 있는지 테스트할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'objectContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'matches if the actual object does contain expected key: value pairs'</span>, () =&gt; &#123;</span><br><span class="line">    expect(&#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;).toEqual(expect.objectContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>foo</code> 라는 key 가 없어서 위 테스트는 실패한다. 만약 { bar: ‘baz’ } 를 { foo: ‘baz’ } 객체로 변경해서 테스트 해보면 실패하는것을 확인할 수 있다. objectContaining 는 key/value 쌍으로 동일해야 성공한다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'onPress gets called with the right thing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onPress = jest.fn();</span><br><span class="line">  simulatePresses(onPress);</span><br><span class="line">  expect(onPress).toBeCalledWith(</span><br><span class="line">    expect.objectContaining(&#123;</span><br><span class="line">      x: expect.any(<span class="built_in">Number</span>),</span><br><span class="line">      y: expect.any(<span class="built_in">Number</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>objectContaining 객체의 value 에 특정한 값이 아니라 any, anything 도 사용할 수 있다. expect.not.objectContaining(object) 메서드도 사용 가능하다.</p><h3 id="expect-stringContaining-string"><a href="#expect-stringContaining-string" class="headerlink" title="expect.stringContaining(string)"></a>expect.stringContaining(string)</h3><p>expect.stringContaining(string) 은 주어지는 문자를 포함하고 있는지 테스트한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'stringContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'matches if the received value does contain the expected substring'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'Hello world!'</span>).toEqual(expect.stringContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>expect.not.stringContaining(string) 도 사용 가능하다.</p><h3 id="expect-stringMatching-string-regexp"><a href="#expect-stringMatching-string-regexp" class="headerlink" title="expect.stringMatching(string | regexp)"></a>expect.stringMatching(string | regexp)</h3><p>주어진 string 이나 정규식에 일치하는지 테스트할 때 사용한다. string 이 주어지는 경우 완전하게 일치 해야하며 정규식을 사용하는 경우는 해당 정규식에 일치하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'stringMatching in arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^Alic/</span>),</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^[BR]ob/</span>),</span><br><span class="line">  ];</span><br><span class="line">  it(<span class="string">'matches even if received contains additional elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alicia'</span>, <span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'does not match if received does not contain expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).not.toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="expect-assertions-number"><a href="#expect-assertions-number" class="headerlink" title="expect.assertions(number)"></a>expect.assertions(number)</h3><p>test 함수의 callback 함수 내부에서 테스트가 몇번이 일어나는지 확인하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'assertions count'</span>, () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">2</span>);</span><br><span class="line">  expect(<span class="literal">true</span>).toBeTruthy();</span><br><span class="line">  expect(<span class="literal">null</span>).toBeFalsy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 테스트코드에서 expect.assertions 을 제외하고 두개의 테스트를 하고있다.</p><h3 id="expect-hasAssertions"><a href="#expect-hasAssertions" class="headerlink" title="expect.hasAssertions()"></a>expect.hasAssertions()</h3><p>expect.hasAssertions() 함수는 test 함수의 callback 함수 내부에서 테스트가 최소 한번 실행되고 있는지 테스트하는 함수다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'has assertions'</span>, () =&gt; &#123;</span><br><span class="line">  expect.hasAssertions();</span><br><span class="line">  expect(<span class="literal">null</span>).toBeFalsy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="resolves"><a href="#resolves" class="headerlink" title="resolves"></a>resolves</h3><p>성공된 Promise 의 value 를 가져올때 사용한다. resolves 를 사용하지 않으면 received value 는 {} 가 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>async/await 과도 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'async/await resolves to lemon'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.not.toBe(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="rejects"><a href="#rejects" class="headerlink" title="rejects"></a>rejects</h3><p>rejects 는 resolves 와는 반대로 실패된 Promise 의 reason 을 가져올 때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(</span><br><span class="line">    <span class="string">'octopus'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>참조: <a href="https://jestjs.io/docs/en/expect">Jest 공식 문서</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/16/jest-%EB%A9%94%EC%84%9C%EB%93%9C-expect/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jest 메서드 - globals</title>
      <link>https://kkangil.github.io/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/</link>
      <guid>https://kkangil.github.io/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/</guid>
      <pubDate>Sun, 09 Feb 2020 08:01:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;Jest 제공 메서드들 중 Globals 메서드에 대해서 정리해보려 한다. Jest 공식 문서에 나와 있는 Globals 메서드 정의는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Globals 메서드를 사용해서 전역 환경을 설정한다. 이것은 필수로 설정해 줄 필요는 없다.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Jest 제공 메서드들 중 Globals 메서드에 대해서 정리해보려 한다. Jest 공식 문서에 나와 있는 Globals 메서드 정의는 다음과 같다.</p><blockquote><p>Globals 메서드를 사용해서 전역 환경을 설정한다. 이것은 필수로 설정해 줄 필요는 없다.</p></blockquote><a id="more"></a><h3 id="afterAll-fn-timeout"><a href="#afterAll-fn-timeout" class="headerlink" title="afterAll(fn, timeout)"></a>afterAll(fn, timeout)</h3><p>이름에서 유추할 수 있듯이 테스트가 진행되는 동안 매번 실행되는 것이 아니라 모든 테스트가 완료 되었을 때 실행된다. 만약 인자의 함수가 Promise 이거나 generator 일 경우, Jest 는 완료를 기다린다.</p><p>다른 테스트와 공유되는 전역 환경 상태를 초기화 할때 주로 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanUpDatabase</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  db.cleanUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  cleanUpDatabase(globalDatabase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트가 모두 완료될 때 실행된다.</p><h3 id="afterEach-fn-timeout"><a href="#afterEach-fn-timeout" class="headerlink" title="afterEach(fn, timeout)"></a>afterEach(fn, timeout)</h3><p>afterAll 메서드와 달리 afterEach는 하나의 테스트가 완료될 때마다 실행된다. 각 테스트에 의해 생성된 임시 상태 또는 변수를 초기화 하는 경우 주로 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanUpDatabase</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  db.cleanUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  cleanUpDatabase(globalDatabase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 완료될 때 실행된다.</p><h3 id="beforeAll-fn-timeout"><a href="#beforeAll-fn-timeout" class="headerlink" title="beforeAll(fn, timeout)"></a>beforeAll(fn, timeout)</h3><p>afterAll과 정반대라고 생각하면 된다. 이 메서드는 테스트가 실행되기전 최초에 한번 실행된다. 각 테스트를 진행하기 위해 데이터를 설정해 줄때 주로 사용된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Clears the database and adds some testing data.</span></span><br><span class="line">  <span class="comment">// Jest will wait for this promise to resolve before running tests.</span></span><br><span class="line">  <span class="keyword">return</span> globalDatabase.clear().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> globalDatabase.insert(&#123;<span class="attr">testData</span>: <span class="string">'foo'</span>&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트를 하기전에 실행된다.</p><h3 id="beforeEach-fn-timeout"><a href="#beforeEach-fn-timeout" class="headerlink" title="beforeEach(fn, timeout)"></a>beforeEach(fn, timeout)</h3><p>하나의 테스트가 시작되기 전에 실행된다. descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 시작되기 전 실행된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Clears the database and adds some testing data.</span></span><br><span class="line">  <span class="comment">// Jest will wait for this promise to resolve before running tests.</span></span><br><span class="line">  <span class="keyword">return</span> globalDatabase.clear().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> globalDatabase.insert(&#123;<span class="attr">testData</span>: <span class="string">'foo'</span>&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>중복된 코드를 제거할때 유용하게 사용할 수 있다.</p><h3 id="describe-name-fn"><a href="#describe-name-fn" class="headerlink" title="describe(name, fn)"></a>describe(name, fn)</h3><p>describe 메서드는 몇몇의 관계가 있는 테스트들을 그룹으로 묶어 생성할 때 사용한다. test 메서드를 최상위에서 바로 실행시킬 수 있지만, describe 메서드로 관련있는 테스트 끼리 묶어서 작성하게 되면 가독성이 높아진다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myBeverage = &#123;</span><br><span class="line">  delicious: <span class="literal">true</span>,</span><br><span class="line">  sour: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'my beverage'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'is delicious'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'is not sour'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>describe 메서드 함수 내부에서 다시 describe로 그룹화를 할 수 있다.</p><h3 id="describe-each-table-name-fn-timeout"><a href="#describe-each-table-name-fn-timeout" class="headerlink" title="describe.each(table)(name, fn, timeout)"></a>describe.each(table)(name, fn, timeout)</h3><p>여러가지 다른 데이터로 중복되는 테스트를 수행할때 describe.each를 활용할 수 있다. 하나의 테스트 케이스로  값이 다른 데이터들로 테스를 수행하는 것이다.</p><ul><li>table: 인자로 배열을 넘기면 fn 함수의 인자로 사용 가능하다.</li><li>name: 테스트의 이름 printf formatting 기법을 사용할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe.each([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">])(<span class="string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; &#123;</span><br><span class="line">  test(<span class="string">`returns <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).toBe(expected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be greater than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeGreaterThan(expected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be less than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeLessThan(expected);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>describe.each<code>table</code> 형식으로도 사용 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe.each<span class="string">`</span></span><br><span class="line"><span class="string">  a    | b    | expected</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="describe-only-name-fn"><a href="#describe-only-name-fn" class="headerlink" title="describe.only(name, fn)"></a>describe.only(name, fn)</h3><p>오직 하나의 describe 그룹의 테스트만 수행하고 싶을 때 사용한다. 다른 describe 테스트들은 skip 된다.<br><code>describe.only.each</code> 메서드도 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe.only(<span class="string">'my beverage'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'is delicious'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'is not sour'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'my other beverage'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... will be skipped</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="describe-skip-name-fn"><a href="#describe-skip-name-fn" class="headerlink" title="describe.skip(name, fn)"></a>describe.skip(name, fn)</h3><p>특정한 describe 그룹을 테스트 하고 싶지 않을때 사용한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'my beverage'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'is delicious'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'is not sour'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe.skip(<span class="string">'my other beverage'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... will be skipped</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>describe.skip.each(table)(name, fn)</code> 메서드도 사용가능하다.</p><h3 id="test-name-fn-timeout"><a href="#test-name-fn-timeout" class="headerlink" title="test(name, fn, timeout)"></a>test(name, fn, timeout)</h3><p>test 메서드를 사용하여 테스트를 수행할 수 있다. Promise나 비동기 방법을 지원한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'did not rain'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'has lemon in it'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetchBeverageList().then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    expect(list).toContain(<span class="string">'lemon'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="test-each-table-name-fn-timeout"><a href="#test-each-table-name-fn-timeout" class="headerlink" title="test.each(table)(name, fn, timeout)"></a>test.each(table)(name, fn, timeout)</h3><p>describe.each(table)(name, fn, timeout)와 개념은 동일하다. 하지만 describe는 그룹화이기 때문에 여러가지 테스트를 동시에 수행할 수 있지만 test.each는 단일 테스트에 대한 each 이다.</p><h3 id="test-only-name-fn-timeout"><a href="#test-only-name-fn-timeout" class="headerlink" title="test.only(name, fn, timeout)"></a>test.only(name, fn, timeout)</h3><p>describe.only 와 개념은 동일하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.only(<span class="string">'it is raining'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBeGreaterThan(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'it is not snowing'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfSnow()).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>오직 한가지의 test만 수행되며 describe 내부의 test들도 수행되지 않는다.</p><p><code>test.only.each(table)(name, fn)</code> 메서드도 사용할 수 있다.</p><h3 id="test-skip-name-fn"><a href="#test-skip-name-fn" class="headerlink" title="test.skip(name, fn)"></a>test.skip(name, fn)</h3><p>수행하고 싶지 않은 테스트를 건너뛰게 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'it is raining'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBeGreaterThan(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test.skip(<span class="string">'it is not snowing'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfSnow()).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>test.skip.each(table)(name, fn)</code> 도 사용가능하다.</p><h3 id="test-todo-name"><a href="#test-todo-name" class="headerlink" title="test.todo(name)"></a>test.todo(name)</h3><p>추가되어야할 테스트 TODO를 남겨놓을 수 있다. 해당 메서드를 사용하면 다른 테스트들과 달리 강조되어 표시된다. 인자로 callback을 넘기면 에러가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">test.todo(<span class="string">'add should be associative'</span>);</span><br></pre></td></tr></table></figure><p>참조: <a href="https://jestjs.io/docs/en/api">Jest 공식 문서</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/#disqus_thread</comments>
    </item>
    
    <item>
      <title>성능을 높이는 코드 스타일</title>
      <link>https://kkangil.github.io/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/</link>
      <guid>https://kkangil.github.io/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/</guid>
      <pubDate>Sun, 09 Feb 2020 05:58:17 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;객체의-생성-초기화-성능&quot;&gt;&lt;a href=&quot;#객체의-생성-초기화-성능&quot; class=&quot;headerlink&quot; title=&quot;객체의 생성, 초기화 성능&quot;&gt;&lt;/a&gt;객체의 생성, 초기화 성능&lt;/h2&gt;&lt;p&gt;많이 사용하지만 성능을 생각하지 않고 작성하는 코드에 객체 선언과 초기화 구문이 있다. 배열(Array) 형식의 객체와 오브젝트(Object) 형식의 객체를 생성하고 초기화하는 방법의 성능을 측정해 보고 두 코드 사이에 어떤 차이점이 있는지 비교해 보고자 한다.&lt;/p&gt;
&lt;h3 id=&quot;배열의-생성-초기화-성능-비교&quot;&gt;&lt;a href=&quot;#배열의-생성-초기화-성능-비교&quot; class=&quot;headerlink&quot; title=&quot;배열의 생성, 초기화 성능 비교&quot;&gt;&lt;/a&gt;배열의 생성, 초기화 성능 비교&lt;/h3&gt;&lt;p&gt;배열을 생성자 혹인 리터럴([]) 형식을 사용해 객체를 생성할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Array() 생성자 사용&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 리터럴 형식으로 배열 생성&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="객체의-생성-초기화-성능"><a href="#객체의-생성-초기화-성능" class="headerlink" title="객체의 생성, 초기화 성능"></a>객체의 생성, 초기화 성능</h2><p>많이 사용하지만 성능을 생각하지 않고 작성하는 코드에 객체 선언과 초기화 구문이 있다. 배열(Array) 형식의 객체와 오브젝트(Object) 형식의 객체를 생성하고 초기화하는 방법의 성능을 측정해 보고 두 코드 사이에 어떤 차이점이 있는지 비교해 보고자 한다.</p><h3 id="배열의-생성-초기화-성능-비교"><a href="#배열의-생성-초기화-성능-비교" class="headerlink" title="배열의 생성, 초기화 성능 비교"></a>배열의 생성, 초기화 성능 비교</h3><p>배열을 생성자 혹인 리터럴([]) 형식을 사용해 객체를 생성할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array() 생성자 사용</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리터럴 형식으로 배열 생성</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>성능 비교 방법은 <a href="http://jindo.dev.naver.com/jsMatch/index.html">http://jindo.dev.naver.com/jsMatch/index.html</a> 사이트를 이용한다. (Chrome 79 버전 기준)</p></blockquote><p>두 방법의 성능을 비교한 결과는 생성자를 사용했을때는 0.111s, 리터럴 형식으로 사용했을 경우 0.100s 의 시간이 걸렸다.</p><p>배열을 사용하려면 배열의 각 요소에 데이터를 할당해 초기화해야한다.<br>배열의 각 요소에 데이터를 할당하는 방법에도 여러가지가 있다. 그 가운데 가장 많이 볼 수 있는 방법인 접근자 []를 사용하는 방법과 push() 메서드를 사용하는 방법의 성능을 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 접근자 사용</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push() 메서드 사용</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과: 접근자 사용 0.100s / push 사용 0.123s</p><p>push 메서드를 사용하는것 보다 접근자를 사용하는 것이 빠르다는 것을 확인할 수 있다. 배열의 생성과 초기화 방법을 비교한 결과, 배열을 사용할 때는 리터럴 형식으로 객체를 생성하고 Array.push() 메서드보다 접근자 []를 사용해 데이터를 추가하는 코드를 작성하는 것이 좀 더 최적화된 배열 사용법이라는 사실을 확인할 수 있다.</p><h3 id="오브젝트-Object-객체의-생성-초기화-성능-비교"><a href="#오브젝트-Object-객체의-생성-초기화-성능-비교" class="headerlink" title="오브젝트(Object) 객체의 생성, 초기화 성능 비교"></a>오브젝트(Object) 객체의 생성, 초기화 성능 비교</h3><p>오브젝트(Object) 객체도 배열처럼 객체를 생성하고 초기화하는 다양한 방법이 있다. 가장 많이 사용하는 방법인 리터럴({})을 사용하는 방법과 생성자를 사용하는 방법의 성능을 테스트해보고 어떤 방법으로 객체를 생성하고 초기화하는 것이 효과적인지 살펴보고자 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리터럴 사용</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 사용</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>결과: 리터럴 사용 0.104s / 생성자 사용 0.100s</p><p>배열과 다르게 생성자를 사용하는 것이 시간이 적게 걸리지만 차이가 적으므로 어떤 방법이 성능이 월등히 좋다고 판가름하기 어렵다. 리터럴 형식이 코드 크기를 좀 더 줄일 수 있는 방법이기 때문에 코드를 다운로드 하는 시간 관점에서 성능에 더 좋다고 볼 수는 있다.</p><p>객체 초기화 방법에는 연산자를 이용한 데이터 삽입과 []를 이용한 데이터 삽입이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 연산자 이용</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br><span class="line">obj.b = <span class="number">2</span>;</span><br><span class="line">obj.c = <span class="number">3</span>;</span><br><span class="line">obj.d = <span class="number">4</span>;</span><br><span class="line">obj.e = <span class="number">5</span>;</span><br><span class="line">obj.f = <span class="number">6</span>;</span><br><span class="line">obj.g = <span class="number">7</span>;</span><br><span class="line">obj.h = <span class="number">8</span>;</span><br><span class="line">obj.i = <span class="number">9</span>;</span><br><span class="line">obj.j = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [] 이용</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="string">"a"</span>] = <span class="number">1</span>;</span><br><span class="line">obj[<span class="string">"b"</span>] = <span class="number">2</span>;</span><br><span class="line">obj[<span class="string">"c"</span>] = <span class="number">3</span>;</span><br><span class="line">obj[<span class="string">"d"</span>] = <span class="number">4</span>;</span><br><span class="line">obj[<span class="string">"e"</span>] = <span class="number">5</span>;</span><br><span class="line">obj[<span class="string">"f"</span>] = <span class="number">6</span>;</span><br><span class="line">obj[<span class="string">"g"</span>] = <span class="number">7</span>;</span><br><span class="line">obj[<span class="string">"h"</span>] = <span class="number">8</span>;</span><br><span class="line">obj[<span class="string">"i"</span>] = <span class="number">9</span>;</span><br><span class="line">obj[<span class="string">"j"</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>결과: 연산자 이용 0.102s / [] 이용 0.100s</p><p>Object 객체에 데이터를 삽입하는 초기화 방법에 대한 성능 테스트 결과도 Object 객체 생성에 대한 테스트 결과와 유사헀다. 객체의 초기화도 생성과 마찬가지로 한 가지 방식이 더 성능이 좋다고 판단할 수 없으며, 작성하는 코드의 크기와 주요 대상 브라우저 및 코드의 가독성과 유지 보수를 감안해 적절한 방식을 택하면 되겠다.</p><h2 id="스코프-체인-탐색과-성능"><a href="#스코프-체인-탐색과-성능" class="headerlink" title="스코프 체인 탐색과 성능"></a>스코프 체인 탐색과 성능</h2><p>자바스크립트 성능을 다루는 책에서 항상 빠지지 않는 부분이 스코프 체인이다. 개발자가 작성한 코드 자체의 성능이 런타임 성능에도 많은 영향을 준다. 런타임 환경에서 가장 많이 발생하는 브라우저의 작업 가운데 자바스크립트의 실행 성능을 저해하는 요인이 변수, 객체, 함수 등의 메모리상의 위치를 찾는 <code>탐색 작업</code>이다.</p><h3 id="스코프-체인이란"><a href="#스코프-체인이란" class="headerlink" title="스코프 체인이란?"></a>스코프 체인이란?</h3><p>자바스크립트의 함수를 실행하면서 어떤 속성(변수, 객체 등)에 접근해야 할 때 해당 속성을 효율적으로 탐색하도록 속성을 일정한 객체 단위로 분류하고 각 객체에 접근하기 위한 객체의 참조를 특정한 공간에 저장해 둔다. 이 공간이 바로 스코프 체인이다.</p><p>스코프 체인의 구성 요소에는 활성화 객체와 전역 객체가 있다. 함수에서 접근할 수 있는 모든 속성 가운데 함수 내부에서만 접근할 수 있는 함수의 지역변수나 this, arguments 객체 등의 속성은 스코프 체인의 활성화 객체에 포함돼 관리 된다. 함수 외부에서도 접근할 수 있는 window, document, 전역함수, 전역변수와 같은 속성은 스코프 체인의 전역 객체에 포함돼 관리 된다.<br>전역 객체는 자바스크립트 동작시 어디서나 항상 접근 가능한 데이터를 포함하고 있기 때문에 동작하는 모든 시간 동안 존재하지만, 활성화 객체는 실행 중인 함수 내부 데이터를 포함하기 때문에 함수가 실행되는 동안에만 존재한다.</p><p>실행 문맥(Execution Context)은 <code>함수가 동작하는 환경</code>을 나타내며, 브라우저 내부에서 사용되는 객체다. 실행 문맥은 함수가 실행될 때 새로 생성되고  함수가 종료될 때 소멸되며 함수의 스코프 체인에 대한 참조를 가지고 있게 된다. 실행 문맥은 자신과 연관된 함수의 스코프 체인을 참조하고 있으며, 함수에서 접근해야할 어떤 속성의 탐색 경로는 실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체 &gt; 스코프 체인 &gt; 전역 객체 와 같이 구성된다.</p><h3 id="지역변수를-활용한-스코프-체인-탐색-성능-개선"><a href="#지역변수를-활용한-스코프-체인-탐색-성능-개선" class="headerlink" title="지역변수를 활용한 스코프 체인 탐색 성능 개선"></a>지역변수를 활용한 스코프 체인 탐색 성능 개선</h3><p>스코프 체인의 탐색 방법을 살펴보면 여러 개의 활성화 객체와 전역 객체를 탐색하면서 접근하려는 속성이 있는지 확인하는 과정이 반복된다. 그렇다면 첫 번째로 탐색하는 활성화 객체에 찾고자 하는 속성이 있는 경우 추가로 발생할 수 있는 다른 활성화 객체, 전역 객체를 탐색하는 과정을 줄여 성능을 향상시킬 수 있을 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 내에서 전역 스코프 변수에 직접 접근하는 방법</span></span><br><span class="line"><span class="built_in">window</span>.htmlstring = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  htmlstring.push(<span class="string">"&lt;ul&gt;"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    htmlstring.push(<span class="string">`&lt;li&gt;value: <span class="subst">$&#123;i&#125;</span>&lt;/li&gt;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  htmlstring.push(<span class="string">"&lt;/ul&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 지역변수로 참조해 전역 스코프 변수에 접근하는 방법</span></span><br><span class="line"><span class="built_in">window</span>.htmlstring = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> htmlstr = htmlstring;</span><br><span class="line">  htmlstr.push(<span class="string">"&lt;ul&gt;"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    htmlstr.push(<span class="string">`&lt;li&gt;value: <span class="subst">$&#123;i&#125;</span>&lt;/li&gt;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  htmlstr.push(<span class="string">"&lt;/ul&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeList();</span><br></pre></td></tr></table></figure><p>결과: 전역 스코프 변수 접근 0.119s / 지역변수 참조 0.100s</p><p>전역 객체에 존재하는 htmlstring 속성을 makeList() 함수의 지역변수에 저장해 활성화 객체에서 바로 찾을 수 있게 한것이다. 최초 한 번은 활성화 객체와 전역 객체를 모두 탐색해야한다. 하지만 그 이후에는 활성화 객체에 저장된 htmlstr 속성으로 전역변수인 htmlstring 객체에 접근할 수 있으니 활성화 객체를 거쳐 전역 객체까지 탐색할 필요가 없어진다.</p><h2 id="반복문과-성능"><a href="#반복문과-성능" class="headerlink" title="반복문과 성능"></a>반복문과 성능</h2><p>자바스크립트의 반복문인 for, for-in, while, do-while 구문에도 성능 차이가 있다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 성능 테스트 전에 배열 초기화</span></span><br><span class="line">arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">400</span>; i++) &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do-while</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; len);</span><br></pre></td></tr></table></figure><p>결과: for 0.113s / for-in 0.505s / while 0.108s / do-while 0.100s</p><p>for-in의 성능이 압도적으로 떨어지는 것을 확인할 수 있다. for-in 이외의 반복문은 주어진 배열 객체를 배열의 특성에 맞게 순차적으로 모든 요소를 탐색한다. 반면 for-in 구문은 인자로 주어진 배열을 배열이 아닌 일반 객체로 취급하며, 반복 시점마자 객체의 모든 속성을 무작위로 탐색한다. 이러한 탐색 방법의 차이로 다른 반복문에 비해 배열 탐색에서 현저하게 느리다.</p><h2 id="조건문과-성능"><a href="#조건문과-성능" class="headerlink" title="조건문과 성능"></a>조건문과 성능</h2><p>반복문만큼이나 조건문 또한 자바스크립트를 포함한 프로그래밍 전반에서 필수적으로 사용하는 요소다. 자바스크립트에는 if, if-else, switch, 삼항연산자 등의 조건문이 있다.</p><h3 id="조건문의-성능-비교"><a href="#조건문의-성능-비교" class="headerlink" title="조건문의 성능 비교"></a>조건문의 성능 비교</h3><p>먼저 true와 false만 판단하는 최소한의 조건 분기를 처리하는 코드로 if, switch, 삼항연산자의 성능을 측정했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-else</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toEnglish</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="string">"zero"</span>;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="number">1</span>) &#123;</span><br><span class="line">    number = <span class="string">"one"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">2</span>) &#123;</span><br><span class="line">    number = <span class="string">"two"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">3</span>) &#123;</span><br><span class="line">    number = <span class="string">"three"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">4</span>) &#123;</span><br><span class="line">    number = <span class="string">"four"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">5</span>) &#123;</span><br><span class="line">    number = <span class="string">"five"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">6</span>) &#123;</span><br><span class="line">    number = <span class="string">"six"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">7</span>) &#123;</span><br><span class="line">    number = <span class="string">"seven"</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">8</span>) &#123;</span><br><span class="line">    number = <span class="string">"eight"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">9</span>) &#123;</span><br><span class="line">    number = <span class="string">"nine"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">10</span>) &#123;</span><br><span class="line">    number = <span class="string">"ten"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    number = <span class="string">"null"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch-case</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toEnglish</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="string">"zero"</span>;</span><br><span class="line">  <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      number = <span class="string">"one"</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      number = <span class="string">"two"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      number = <span class="string">"three"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">      number = <span class="string">"four"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      number = <span class="string">"five"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      number = <span class="string">"six"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      number = <span class="string">"seven"</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      number = <span class="string">"eight"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">      number = <span class="string">"nine"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      number = <span class="string">"ten"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      number = <span class="string">"null"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 삼항연산자</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toEnglish</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="literal">false</span>;</span><br><span class="line">  number = (value === <span class="number">1</span>) ?</span><br><span class="line">    <span class="string">"one"</span> : (value === <span class="number">2</span>) ?</span><br><span class="line">    <span class="string">"two"</span> : (value === <span class="number">3</span>) ?</span><br><span class="line">    <span class="string">"three"</span> : (value === <span class="number">4</span>) ?</span><br><span class="line">    <span class="string">"four"</span> : (value === <span class="number">5</span>) ?</span><br><span class="line">    <span class="string">"five"</span> : (value === <span class="number">6</span>) ?</span><br><span class="line">    <span class="string">"six"</span> : (value === <span class="number">7</span>) ?</span><br><span class="line">    <span class="string">"seven"</span> : (value === <span class="number">8</span>) ?</span><br><span class="line">    <span class="string">"eight"</span> : (value === <span class="number">9</span>) ?</span><br><span class="line">    <span class="string">"nine"</span> : (value === <span class="number">10</span>) ?</span><br><span class="line">    <span class="string">"ten"</span> : <span class="string">"null"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과: if-else 0.111s / switch 0.111s / 삼항연산자 0.100s</p><p>조건의 개수가 많지 않으므로 조건문 사이에 별다른 성능 차이가 없다. 단지, 일반적으로 조건 판단 요소가 많아질수록 switch-case 구문의 성능이 좀 더 좋다는 점은 알아두는 것이 좋다.</p><h2 id="문자열-연산과-성능"><a href="#문자열-연산과-성능" class="headerlink" title="문자열 연산과 성능"></a>문자열 연산과 성능</h2><h3 id="문자열-생성-비교"><a href="#문자열-생성-비교" class="headerlink" title="문자열 생성 비교"></a>문자열 생성 비교</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 객체 이용</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리터럴 이용</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>결과: String 객체 0.103s / 리터럴 이용 0.100s</p><p>측정한 시간이 지극히 짧지만 String 객체보다는 리터럴을 사용하는 것이 좋다.</p><h3 id="문자열-연산-성능-비교"><a href="#문자열-연산-성능-비교" class="headerlink" title="문자열 연산 성능 비교"></a>문자열 연산 성능 비교</h3><p>여러가지 데이터를 조합해 긴 문자열을 생성해야 할 때가 많다. 이때 가장 많이 사용하는 방법이 +, += 연산자를 이용하거나 Array.join() 메서드를 이용하는 방법이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// += 연신자</span></span><br><span class="line">str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  str += <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.join</span></span><br><span class="line">arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  arr[i] = <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr.join(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>결과: += 연산자 0.398s / Array.join 0.100s</p><p>Array.join() 메서드를 이용하는것이 월등한 성능을 낸다는 것을 확인할 수 있다. += 연산자는 두 문자열을 합친 새로운 문자열을 만들고 새로운 메모리 위치에 저장함과 동시에 기존 문자열에 대한 참조를 변경하는 연산을 반복적으로 실행해야 한다. 하지만 Array.join() 메서드로 연산하면 비교적 메모리에 효율적으로 접근할 수 있는 배열을 사용한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>배열은 리터럴([])방식으로 생성하고 push() 메서드가 아닌 접근자([])로 데이터를 할당하는 코드의 성능이 더 좋다.</li><li>객체는 어떤 방식이든지 비슷한 성능을 낸다. 가독성과 유지보수의 편리성을 고려해 적절한 방식으로 사용하면 된다.</li><li>반복문 가운데 for-in의 성능이 월등히 낮다.</li><li>조건문의 종류에 따른 성능 차이는 거의 없지만 조건이 많아지면 switch-case 성능이 좀 더 좋다.</li><li>문자열을 연산할 때는 += 연산자 보다는 Array.join()을 이용하는 방법이 더 좋다.</li></ul><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>기본적인 웹 사이트 최적화 방법</title>
      <link>https://kkangil.github.io/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/</link>
      <guid>https://kkangil.github.io/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/</guid>
      <pubDate>Sun, 02 Feb 2020 07:57:35 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;HTTP-요청-최소화&quot;&gt;&lt;a href=&quot;#HTTP-요청-최소화&quot; class=&quot;headerlink&quot; title=&quot;HTTP 요청 최소화&quot;&gt;&lt;/a&gt;HTTP 요청 최소화&lt;/h2&gt;&lt;p&gt;HTTP 요청 최소화는 최적화에서 가장 기본이면서도 중요한 부분이다. 웹 사이트는 주로 마크업, 이미지, 스타일시트, 자바스크립트 등으로 구성된다. 각 구성 요소는 모두 웹 서버에 있다. 이 구성 요소를 사용자의 컴퓨터로 가져오는 데는 네트워크 비용이 든다. 네트워크 비용은 곧 응답 시간으로 이어진다. 그러므로 다운로드 해야 하는 구성 요소의 개수를 줄이는 것은 가장 효과가 크고 중요한 최적화 방법이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="HTTP-요청-최소화"><a href="#HTTP-요청-최소화" class="headerlink" title="HTTP 요청 최소화"></a>HTTP 요청 최소화</h2><p>HTTP 요청 최소화는 최적화에서 가장 기본이면서도 중요한 부분이다. 웹 사이트는 주로 마크업, 이미지, 스타일시트, 자바스크립트 등으로 구성된다. 각 구성 요소는 모두 웹 서버에 있다. 이 구성 요소를 사용자의 컴퓨터로 가져오는 데는 네트워크 비용이 든다. 네트워크 비용은 곧 응답 시간으로 이어진다. 그러므로 다운로드 해야 하는 구성 요소의 개수를 줄이는 것은 가장 효과가 크고 중요한 최적화 방법이다.</p><a id="more"></a><h3 id="CSS-스프라이트"><a href="#CSS-스프라이트" class="headerlink" title="CSS 스프라이트"></a>CSS 스프라이트</h3><p>순수한 HTML 마크업만으로는 표현에 한계가 있기 때문에 어쩔 수 없이 이미지를 사용한다. 하지만 이미지를 많이 사용하면 HTTP 요청이 많아질 수 밖에 없다. 이미지를 많이 사용하면서도 HTTP 요청을 최소화하는 방법 가운데 하나가 CSS 스프라이트 기법이다.</p><p>CSS 스프라이트 기법은 이미지 여러 개를 하나로 만들고 스타일시트에서 <code>background-position</code> 속성을 설정해 필요한 부분의 이미지만 보여 주는 기술이다. 여러 이미지를 하나의 이미지로 합치기 때문에 HTTP 요청 횟수를 줄일 수 있고, 이미지의 컬러 테이블과 같은 메타데이터를 하나로 합칠 수 있어 파일 크기가 줄어든다.</p><p>CSS 스프라이트 기법은 이미지를 관리하기 어렵고 웹 접근성을 나쁘게 하는 요소가 있다는 단점이 있다. 하지만 많은 양의 이미지를 사용한다면 많은 시간을 줄일 수 있다.</p><h3 id="헤더에-만료-날짜-추가"><a href="#헤더에-만료-날짜-추가" class="headerlink" title="헤더에 만료 날짜 추가"></a>헤더에 만료 날짜 추가</h3><p>헤더에 만료 날짜를 추가하는 이유는 웹 페이지를 구성하는 여러 요소들을 사용자의 컴퓨터의 캐시에 저장해서 재사용하기 위해서다. 사용자가 처음 웹 페이지에 방문하면 만료 날짜가 설정된 요소를 사용자 컴퓨터에 저장한다. 이후 같은 웹 페이지에 다시 방문하면 유효한 요소는 서버에 요청하지 않고 사용자 컴퓨터에서 바로 읽어 온다.</p><h4 id="사용자-컴퓨터에-저장된-캐시-파일"><a href="#사용자-컴퓨터에-저장된-캐시-파일" class="headerlink" title="사용자 컴퓨터에 저장된 캐시 파일"></a>사용자 컴퓨터에 저장된 캐시 파일</h4><p>캐시에 저장된 파일에는 만료 날짜가 없는 파일도 있고 만료 날짜가 있는 파일도 있다. 모든 구성 요소에 무조건 만료 날짜를 설정하는 것이 아니라 특정 기간까지 변경되지 않아도 서비스에 문제가 없는 요소에만 적용해야 한다.<br>만약 만료 날짜 전에 수정 사항이 있어 파일을 변경해야 한다면 파일 이름을 변경하거나 파일 이름 뒤에 쿼리스트링을 추가해 새로 추가된 파일임을 알려야 바로 반영된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 파일 이름을 변경</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test_0202.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 쿼리스트링 추가</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test?0202.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>브라우저에서 캐싱된 파일을 이용할지 서버에 요청할지 판단하는 기준은 컬럼 이름을 기준으로 이름과 인터넷 주소다. 그렇기 때문에 파일 이름이나 파일의 주소를 바꾸지 않으면 계속 같은 파일로 인식하고 사용자 컴퓨터에 있는 파일을 로딩한다.</p><h4 id="자바스크립트-파일-통합"><a href="#자바스크립트-파일-통합" class="headerlink" title="자바스크립트 파일 통합"></a>자바스크립트 파일 통합</h4><p>기능이 향상됨에 따라 자바스크립트 파일은 개수도 많아지고 크기도 커지고 있다. 이럴 때 성능을 높이는 방법은 여러 개의 자바스크립트 파일을 하나의 파일로 합쳐 파일 개수를 최소화하는 것이다. 웹 사이트의 성능을 개선할 때는 파일의 용량보다 파일의 개수가 중요하다. 아주 용량이 작은 파일이라도 원격 서버에서 가져와야 한다면 네트워크 비용이 든다.</p><h3 id="파일-크기-최소화"><a href="#파일-크기-최소화" class="headerlink" title="파일 크기 최소화"></a>파일 크기 최소화</h3><h4 id="Gzip-압축을-이용한-파일-크기-최소화"><a href="#Gzip-압축을-이용한-파일-크기-최소화" class="headerlink" title="Gzip 압축을 이용한 파일 크기 최소화"></a>Gzip 압축을 이용한 파일 크기 최소화</h4><p>점점 커지는 자바스크립트 파일과 스타일시트 파일의 크기를 줄이는 가장 효과적이고 쉬운 방법은 파일을 압축하는 것이다. 아파치 웹 서버에서 파일을 압축하는 대표적인 인코딩 방식에는 Gzip과 deflate 두 가지가 있는데, deflate 방식은 지원하지 않는 브라우저가 많고 효과도 떨어지기 때문에 대부분 Gzip 방식을 사용한다.</p><h5 id="압축-전송-흐름-및-확인"><a href="#압축-전송-흐름-및-확인" class="headerlink" title="압축 전송 흐름 및 확인"></a>압축 전송 흐름 및 확인</h5><p>압축 전송은 다음과 같은 순서로 진행된다. 클라이언트에서 some.js 라는 파일을 만났을 때를 가정해보자.</p><ol><li>클라이언트에서 헤더 정보로 인코딩 여부를 물어본다.<blockquote><p>Accept-Encoding: gzip, deflate (Header)</p></blockquote></li><li>서버에서 헤더 정보로 인코딩 여부를 알려준다. 인코딩된 요소라면 다음과 같이 응답이 온다.<blockquote><p>Content-Encoding: gzip</p></blockquote></li><li>클라이언트에서 인코딩된 요소를 받음과 동시에 압축을 해제한다. 이때 추가적인 CPU 연산 비용이 들어간다. 여기서 발생하는 CPU 연산 비용도 무시할 수 없기 때문에 압축할 파일과 크기를 잘 설정해야한다. 보통 스타일시트 파일과 자바스크립트 파일을 압축한다. 그리고 파일 크기가 작으면 속도 개선 효과보다 CPU 연산 비용이 더 들기 때문에 파일 크기가 일정한 크기 이상인 경우에만 압축하는 것이 좋다. 파일 크기가 1~2KB 이상일때 압축할 것을 권장한다.</li></ol><h4 id="압축-전송의-효과"><a href="#압축-전송의-효과" class="headerlink" title="압축 전송의 효과"></a>압축 전송의 효과</h4><p>Gzip으로 압축해 전송하면 평균 70% 정도 파일 크기가 작아지는 효과를 볼 수 있다. 모바일 환경과 같이 네트워크 환경이 불안한 상황에서는 더욱 효과적인 기술일 것이다.<br>파일의 공백 및 주석을 제거하고 Gzip 으로 압축을 진행하면 파일 크기를 최소화 시킬 수 있다.</p><h3 id="쿠키-크기-최소화"><a href="#쿠키-크기-최소화" class="headerlink" title="쿠키 크기 최소화"></a>쿠키 크기 최소화</h3><p>필요한 정보를 저장하는 가장 손쉬운 방법이 최상위 도메인을 이용해 쿠키를 설정하는 방법이다. 이렇게 되면 자바스크립트 파일이나 스타일시트, 이미지등 쿠키 정보가 필요 없는 구성 요소를 요청할 때도 헤더 정보에 쿠키가 포함된다. 즉 헤더를 전송할 때 데이터 크기가 커진다.</p><p>쿠키의 크기를 줄이는 기본적인 방법</p><ul><li>지속적인 관리로 사용하지 않는 쿠키는 삭제한다.</li><li>쿠키를 설정할 때 최상위 도메인은 되도록 사용하지 않는다.</li><li>쿠키 정보가 필요없는 파일은 별도의 도메인으로 서비스한다.</li></ul><hr/><h2 id="렌더링-성능-향상"><a href="#렌더링-성능-향상" class="headerlink" title="렌더링 성능 향상"></a>렌더링 성능 향상</h2><p>전체적인 로딩 속도는 동일한데 빈 페이지가 계속 보이다 갑자기 콘텐츠가 나타나는 페이지가 있고, 처음부터 콘텐츠가 조금씩 보이며 화면이 빠르게 나타나는 페이지가 있다. 렌더링 성능 향상의 목표는 페이지를 요청했을 때 사용자가 대기하는 시간을 최대한 줄여서 이 체감 속도를 높이는 것이다.</p><h3 id="브라우저-파싱-순서"><a href="#브라우저-파싱-순서" class="headerlink" title="브라우저 파싱 순서"></a>브라우저 파싱 순서</h3><ol><li><p>HTML 파싱과 DOM 트리 구성<br>사용자가 페이지를 요청하면 네트워크를 통해 마크업을 받아 온다. 그 후 마크업 문자열을 토큰 형태로 잘라서 트리를 구축하고 파싱 작업을 시작한다. 그런 다음 DOM 트리를 생성한다.</p></li><li><p>렌더트리 구성(DOM + 스타일규칙)<br>DOM 트리를 생성한 다음 바로 화면을 그리지는 않는다. 스타일시트의 정보를 적용해야 하기 떄문이다. DOM 트리 정보와 스타일시트의 스타일 규칙을 결합해 렌더 트리를 만든다. display:none 속성처럼 DOM 트리에는 있지만 화면에 보이면 안되는 요소를 걸러낸 결과가 렌더 트리다.</p></li><li><p>렌더 트리의 배치<br>스타일 규칙에 따라 각 요소를 화면의 어디에 배치할지 좌표를 설정한다.</p></li><li><p>렌더 트리 그리기<br>요소의 좌표가 설정되면 브라우저에 순차적으로 화면에 그린다. 이때 사용자는 화면을 조금씩 보게 된다.</p></li></ol><h3 id="스타일시트와-자바스크립트-배치를-이용한-성능-향상"><a href="#스타일시트와-자바스크립트-배치를-이용한-성능-향상" class="headerlink" title="스타일시트와 자바스크립트 배치를 이용한 성능 향상"></a>스타일시트와 자바스크립트 배치를 이용한 성능 향상</h3><p>스타일시트 파일은 페이지 제일 위쪽에, 자바스크립트 파일은 페이지 맨 아래쪽에 놓아야 한다.<br>브라우저 렌더링 단계에 따르면 사용자에게 화면을 보여 주기 전에 렌더 트리를 생성해야 하는데, 이때 스타일시트 파일이 반드시 필요하다. 스타일시트 파일을 최대한 빨리 다운로드 해야 하는 이유다.</p><p>자바스크립트 파일을 페이지 아래에 놓아야 하는 가장 큰 이유는 파일을 다운로드해서 실행하기 전까지 브라우저가 DOM 파싱도 중지하고 아무것도 렌더링하지 않기 때문이다. 자바스크립트에는 document.write() 메서드가 있어 마크업을 렌더링하는 도중에도 DOM을 추가할 수 있다. 이로 인해 이미 필요한 구성 요소를 모두 브라우저에 가져왔음에도 자바스크립트를 수행하느라 렌더링이 멈추게 된다. 이때 사용자에게는 마치 화면이 멈춘 것처럼 보여 체감 속도가 느려진다.</p><h3 id="초기-렌더링시-AJAX-요청-최소화"><a href="#초기-렌더링시-AJAX-요청-최소화" class="headerlink" title="초기 렌더링시 AJAX 요청 최소화"></a>초기 렌더링시 AJAX 요청 최소화</h3><p>동적인 웹 사이트에서 화면을 그리는 단계는 일반적으로 다음과 같다.</p><ol><li>사용자가 페이지를 요청</li><li>마크업을 다운로드해 렌더링 시작 (화면을 구성하는 레이아웃만 있고 실제로 보여줄 데이터는 나중에 AJAX 요청을 통해 받은 다음 그려야함)</li><li>자바스크립트 다운로드와 렌더링이 끝난 후 onload 이벤트가 발생</li><li>onload 이벤트가 발생한 다음에 AJAX 통신을 실행하고 데이터를 화면에 그린다.</li><li>화면 완성</li></ol><p>이 과정에는 두 가지 큰 문제점이 있다. AJAX 통신을 사용하지 않는 방법으로 페이지를 개발했다면 3번 단계에서 사용자는 화면을 보게 된다. 그런데 5번 단계가지 가서야 사용자는 최종 화면을 볼 수 있다. 또 다른 문제는 렌더링이 반복된다는 것이다. 1~3번 단계까지 전체 화면을 한 번 그리고 4~5번 단계에서 화면을 한 번 더 그린다.</p><p>초기 렌더링 시에 마크업 전체를 서버에서 보내는 방식으로 개발하여 체감 속도를 높일 수 있다. 1~3 단계에서 전체 화면과 데이터가 있는 화면을 모두 그리는 것이다. 그리고 사용자의 행동이 있을 때 AJAX 요청을 실행해서 데이터를 받은 다음 화면을 그리게 한다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>도구 다루기-3</title>
      <link>https://kkangil.github.io/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/</link>
      <guid>https://kkangil.github.io/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/</guid>
      <pubDate>Sun, 02 Feb 2020 05:36:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;의존성-주입이란&quot;&gt;&lt;a href=&quot;#의존성-주입이란&quot; class=&quot;headerlink&quot; title=&quot;의존성 주입이란?&quot;&gt;&lt;/a&gt;의존성 주입이란?&lt;/h2&gt;&lt;p&gt;ConferenceWebSvc 객체에 서비스를 캡슐화하고 메시지를 화면에 표시할 자바스크립트 객체 Messenger를 작성한다.&lt;/p&gt;
&lt;p&gt;참가자는 1인당 세션을 10개까지 등록할 수 있다. 참가자가 한 세션을 등록하면 그 결과를 성공/실패 메시지로 화면에 표시하는 함수를 개발해야 한다. 아래 코드는 해당 기능을 구현하기 위한 초기 버전이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="의존성-주입이란"><a href="#의존성-주입이란" class="headerlink" title="의존성 주입이란?"></a>의존성 주입이란?</h2><p>ConferenceWebSvc 객체에 서비스를 캡슐화하고 메시지를 화면에 표시할 자바스크립트 객체 Messenger를 작성한다.</p><p>참가자는 1인당 세션을 10개까지 등록할 수 있다. 참가자가 한 세션을 등록하면 그 결과를 성공/실패 메시지로 화면에 표시하는 함수를 개발해야 한다. 아래 코드는 해당 기능을 구현하기 위한 초기 버전이다.</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Attendee = <span class="function"><span class="keyword">function</span> (<span class="params">attendeeId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'new'로 생성하도록 강제</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Attendee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Attendee(attendeeId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attendeeId = attendeeId;</span><br><span class="line">  <span class="keyword">this</span>.service = <span class="keyword">new</span> ConferenceWebSvc();</span><br><span class="line">  <span class="keyword">this</span>.messenger = <span class="keyword">new</span> Messenger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 세션에 좌석 예약을 시도하고 성공/실패 여부를 메시지로 알려줌.</span></span><br><span class="line">Attendee.prototype.reserve = <span class="function"><span class="keyword">function</span> (<span class="params">sessionId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.service.reserve(<span class="keyword">this</span>.attendeeId, sessionId)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.success(</span><br><span class="line">      <span class="string">`좌석 예약이 완료되었습니다! 고객님은 <span class="subst">$&#123;<span class="keyword">this</span>.service.getRemainingReservations()&#125;</span> 좌석을 추가로 예약하실 수 있습니다.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.failure(<span class="string">'죄송합니다. 해당 좌석은 예약하실 수 없습니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 ConferenceWebSvc, Messenger, Attendee 객체가 각자 자신만의 임무를 갖고 모듈로 조화를 이룬것 처럼 보인다. Attendee.reserve는 너무 간단해서 굳이 단위 테스트를 하지 않아도 되는데, 어차피 그럴 수도 없다. ConferenceWebSvc 내부에는 HTTP 호출이 있다. Messenger는 메시지마다 OK 버튼이 있어야 하는데, 이 또한 이 모듈에서 단위 테스트할 대상은 아니다. 단위 테스트는 자바스크립트 코드를 바르게 작성하기 위한 핵심인데, 모든 단위가 미처 준비도 되기 전에 시스템 테스트의 늪으로 빠지는 게 싫다.</p><p>요는, Attendee 객체가 아니라 이 객체가 의존하는 코드다. 의존성을 주입하는 식으로 바꾸면 해결할 수 있다. 즉, ConferenceWebSvc와 Messenger와의 의존성을 하드 코딩하지 말고 이들을 Attendee에 주입하는 것이다. 실제 운영 환경에서는 진짜 의존성을 주입하겠지만, 단위 테스트용으로는 모의체(fake)나 재스민 스파이 같은 대체제를 주입하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 운영 환경:</span></span><br><span class="line"><span class="keyword">var</span> attendee: <span class="keyword">new</span> Attendee(<span class="keyword">new</span> ConferenceWebSvc(), <span class="keyword">new</span> Messenger(), id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 개발 환경:</span></span><br><span class="line"><span class="keyword">var</span> attendee = <span class="keyword">new</span> Attendee(fakeService, fakeMessenger, id);</span><br></pre></td></tr></table></figure><p>이처럼 의존성을 주입하는 것을 두고 ‘빈자의 의존성 주입’이라 한다. 아래 코드는 빈자의 의존성 주입 방식으로 작성한 Attendee 객체다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Attendee = <span class="function"><span class="keyword">function</span> (<span class="params">service, messenger, attendeeId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'new'로 생성하도록 강제</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Attendee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Attendee(attendeeId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attendeeId = attendeeId;</span><br><span class="line">  <span class="keyword">this</span>.service = service;</span><br><span class="line">  <span class="keyword">this</span>.messenger = messenger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="의존성을-주입하여-믿음직한-코드-만들기"><a href="#의존성을-주입하여-믿음직한-코드-만들기" class="headerlink" title="의존성을 주입하여 믿음직한 코드 만들기"></a>의존성을 주입하여 믿음직한 코드 만들기</h2><p>의존성을 주입하여 다른 방법으로는 할 수 없는 단위 테스트를 어떻게 하는지 알았다. 아무래도 테스트를 통과한, 자동화한 테스트 꾸러미로 계속 테스트할 수 있는 코드가 더 믿음직하다. 이 뿐만 아니라, 의존성 주입은 실제 객체보다 주입한 스파이나 모의 객체에 더 많은 제어권을 안겨주므로 다양한 에러 조건과 기이한 상황을 만들어내기 쉽다.</p><p>의존성 주입은 코드 재사용을 적극적으로 유도한다. 의존성을 품은, 하드 코딩한 모듈은 보통 재사용하기 어렵다. 초기 Attendee 모듈도 Messenger를 하드 코딩하여 쓴 탓에 서버 측에서 재사용할 수 없었다. 의존성 주입으로 바꾼 다음에는 성공/실패 메서드만 있으면 어떤 messenger 라도 사용할 수 있다.</p><h2 id="의존성-주입의-모든-것"><a href="#의존성-주입의-모든-것" class="headerlink" title="의존성 주입의 모든 것"></a>의존성 주입의 모든 것</h2><p>의존성 주입은 어렵지 않다. 몇 가지 개념만 기억하면 잘 활용할 수 있다.<br>어떤 객체를 코딩하든 어떤 객체를 생성하든 스스로 다음 질문을 해봤을때 한 가지라도 답변이 ‘예’ 라면 직접 인스턴스화 하지 말고 주입하는 방향으로 생각을 전환해야 한다.</p><ul><li>객체 또는 의존성 중 어느 하나라도 DB, 설정 파일, HTTP, 기타 인프라 등의 외부 자원에 의존 하는가</li><li>객체 내부에서 발생할지 모를 에러를 테스트에서 고려해야 하나</li><li>특정한 방향으로 객체를 작동시켜야 할 테스트가 있는가</li><li>서드파티 제공 객체가 아니라 온전히 내가 소유한 객체인가</li></ul><h2 id="경량급-의존성-주입-프레임워크-개발"><a href="#경량급-의존성-주입-프레임워크-개발" class="headerlink" title="경량급 의존성 주입 프레임워크 개발"></a>경량급 의존성 주입 프레임워크 개발</h2><p>지금까지는 의존성 주입을 하드 코딩했다. 전문가다운 의존성 주입 프레임워크는 이렇게 작동한다.</p><ol><li>애플리케이션이 시작되자마자 각 인젝터블(주입 가능한 모든 의존성을 집합적으로 일컫는 말) 명을 확인하고 의존성을 지칭하며 순서대로 DI 컨테이너에 등록한다.</li><li>객체가 필요하면 컨테이너에 요청한다.</li><li>컨테이너는 일단 요청받은 객체와 그 의존성을 모두 재귀적으로 인스턴스화한다. 그리고 요건에 따라 필요한 객체에 각각 주입한다.</li></ol><p>컨테이너는 인젝터블과 의존성을 등록하고 요청시 객체를 내어주는 두 가지 일을 한다. register 함수의 인자는 세 가지를 받는다.</p><ul><li>인젝터블 명</li><li>의존성 명을 담은 배열</li><li>인젝터블 객체를 반환하는 함수. 인젝터블 인스턴스를 요청하면 컨테이너는 이 함수를 호출하여 반환 값을 다시 그대로 반환한다.</li></ul><p>TDD는 단계마다 가급적 조금씩 코딩하는게 좋다. 먼저 빈 DiContainer와 register 함수를 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'DiContainer'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> container;</span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    container = <span class="keyword">new</span> DiContainer();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  describe(<span class="string">'register(name,dependencies,func)'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'인자가 하나라도 빠졌거나 타입이 잘못되면 예외를 던진다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> badArgs = [</span><br><span class="line">        <span class="comment">// 인자가 아예 없는 경우</span></span><br><span class="line">        [],</span><br><span class="line">        [<span class="string">'Name'</span>],</span><br><span class="line">        [<span class="string">'Name'</span>, [<span class="string">'Dependency1'</span>, <span class="string">'Dependency2'</span>]],</span><br><span class="line">        [<span class="string">'Name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;],</span><br><span class="line">        <span class="comment">// 타입이 잘못된 경우</span></span><br><span class="line">        [<span class="number">1</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;],</span><br><span class="line">        [<span class="string">'Name'</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;],</span><br><span class="line">        [<span class="string">'Name'</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'should be a function'</span>]</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      badArgs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        expect(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          container.register.apply(container, args);</span><br><span class="line">        &#125;).toThrowError(container.messages.registerRequiresArgs);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>container는 ‘테스트 대상’으로 beforeEach에서 생성된다. 테스트마다 인스턴스를 갓 구워내면 다른 테스트의 결과를 어지럽히지 않아도 된다.</li><li>TDD 순수주의자는 badArgs 원소마다 테스트를 따로 만들라고 하겠지만, 실제로 그렇게까지 개발자에게 부담을 주면 필요한 조건을 모두 테스트하기도 전에 질려버릴지도 모른다.</li></ul><p>위의 테스트는 당연히 실패한다. DiContainer에 수정이 필요하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> DiContainer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DiContainer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.messages = &#123;</span><br><span class="line">  registerRequiresArgs: <span class="string">'이 생성자 함수는 인자가 3개 있어야 합니다. 문자열, 문자열 배열, 함수'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span> (<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ix;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> name !== <span class="string">'string'</span> ||</span><br><span class="line">    !<span class="built_in">Array</span>.isArray(dependencies) ||</span><br><span class="line">    <span class="keyword">typeof</span> func !== <span class="string">'function'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.messages.registerRequiresArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ix = <span class="number">0</span>; ix &lt; dependencies.length; ++ix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dependencies[ix] !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.messages.registerRequiresArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>register 함수는 여전히 아무 일도 하지 않지만, 이 함수만으로는 의존성을 다시 끌어낼 방법이 없으므로 컨테이너에 의존성이 잘 들어갔는지 테스트하기 어렵다. 따라서 자연스레 나머지 반쪽 그림에 해당하는 get 함수에 관심이 쏠린다. 이 함수의 유일한 인자는 조회할 의존성 명이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DiContainer.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'get(name)'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'성명이 등록되어 있지 않으면 undefined를 반환한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      expect(container.get(<span class="string">'notDefined'</span>)).toBeUndefined();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>이제 get 함수 작성과 DiContainer 를 수정한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.registrations = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span> (<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.registrations[name] = &#123; <span class="attr">func</span>: func &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> registration = <span class="keyword">this</span>.registrations[name];</span><br><span class="line">  <span class="keyword">if</span> (registration === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> registration.func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'등록된 함수를 실행한 결과를 반환한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'MyName'</span>,</span><br><span class="line">    returnFromRegisteredFunction = <span class="string">"something"</span>;</span><br><span class="line"></span><br><span class="line">  container.register(name, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> returnFromRegisteredFunction;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(container.get(name)).toBe(returnFromRegisteredFunction);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이제 get은 자신이 반환하는 객체에 의존성을 제공할 수 있다. 아래 코드는 1개의 메인 객체와 2개의 의존성을 등록하는 테스트로, 메인 객체는 두 의존성의 반환값을 합한 값을 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span> (<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.registrations[name] = &#123; <span class="attr">dependencies</span>: dependencies, <span class="attr">func</span>: func &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>,</span><br><span class="line">    registration = <span class="keyword">this</span>.registrations[name],</span><br><span class="line">    dependencies = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (registration === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registration.dependencies.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">dependencyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dependency = self.get(dependencyName);</span><br><span class="line">    dependencies.push(dependency === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : dependency);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> registration.func.apply(<span class="literal">undefined</span>, dependencies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'등록된 함수에 의존성을 제공한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> main = <span class="string">'main'</span>,</span><br><span class="line">    mainFunc,</span><br><span class="line">    dep1 = <span class="string">'dep1'</span>,</span><br><span class="line">    dep2 = <span class="string">'dep2'</span>;</span><br><span class="line"></span><br><span class="line">  container.register(main, [dep1, dep2], <span class="function"><span class="keyword">function</span> (<span class="params">dep1Func, dep2Func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dep1Func() + dep2Func();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.register(dep1, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.register(dep2, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  mainFunc = container.get(main);</span><br><span class="line">  expect(mainFunc()).toBe(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/33211518?Acode=101">자바스크립트 패턴과 테스트</a><br><a href="https://github.com/kkangil/javascript-pattern-test">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>웹 사이트 최적화</title>
      <link>https://kkangil.github.io/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/</link>
      <guid>https://kkangil.github.io/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/</guid>
      <pubDate>Mon, 27 Jan 2020 07:06:16 GMT</pubDate>
      <description>
      
        &lt;p&gt;제이콥 닐슨의 웹 사이트인 “useit.com”은 웹 사이트의 반응 시간을 다음과 같이 평가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0.1초: 사용자의 동작에 해당 기능이 바로 반응한다고 느끼는 시간&lt;/li&gt;
&lt;li&gt;1초: 불필요하게 오래 기다리지 않았다고 느끼는 시간. 0.2~1초의 시간은 컴퓨터가 동작하는 시간으로 이해할 수 있는 시간이다. 시간이 1초 이상 걸리면 컴퓨터의 동작에 이상이 생겼다고 생각하게 된다.&lt;/li&gt;
&lt;li&gt;10초: 사용자가 집중력을 잃지 않는 최대 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 평가에 따르면 웹 페이지의 반응 시간이 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다. 웹 사이트의 기능이 점점 복잡해지고 많아지면서 느린 반응 속도 때문에 이용 중인 서비스를 떠나 다른 유사한 서비스를 이용하게 만드는 사이트가 있는 반면, 빠른 반응 속도로 웹 사이트를 탐색하는데 큰 불편함이 없는 서비스를 제공하는 사이트도 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>제이콥 닐슨의 웹 사이트인 “useit.com”은 웹 사이트의 반응 시간을 다음과 같이 평가한다.</p><ul><li>0.1초: 사용자의 동작에 해당 기능이 바로 반응한다고 느끼는 시간</li><li>1초: 불필요하게 오래 기다리지 않았다고 느끼는 시간. 0.2~1초의 시간은 컴퓨터가 동작하는 시간으로 이해할 수 있는 시간이다. 시간이 1초 이상 걸리면 컴퓨터의 동작에 이상이 생겼다고 생각하게 된다.</li><li>10초: 사용자가 집중력을 잃지 않는 최대 시간</li></ul><p>이 평가에 따르면 웹 페이지의 반응 시간이 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다. 웹 사이트의 기능이 점점 복잡해지고 많아지면서 느린 반응 속도 때문에 이용 중인 서비스를 떠나 다른 유사한 서비스를 이용하게 만드는 사이트가 있는 반면, 빠른 반응 속도로 웹 사이트를 탐색하는데 큰 불편함이 없는 서비스를 제공하는 사이트도 있다.</p><a id="more"></a><p>많은 포털과 서비스 업체에서는 이러한 사용자의 기대에 부응하기 위해 여러 가지 방법을 시도했다. 그러던 중에 웹 페이지 성능 최적화라는 개념이 생겨났다. 웹 서비스의 반응 속도를 개선할 수 있는 가장 효과적인 방법은 네트워크 속도의 개선이지만 이는 단기간에 이루기 힘든 과제이며 인터넷 서비스를 제공하는 업체에서는 불가능한 부분이다. 대신 반대로 네트워크 사용량을 줄이고 브라우저에서 웹 페이지의 실행 속도를 높여 웹 페이지의 반응 속도를 개선하고 있다.</p><h2 id="브라우저-동작-방식을-기반으로-한-최적화"><a href="#브라우저-동작-방식을-기반으로-한-최적화" class="headerlink" title="브라우저 동작 방식을 기반으로 한 최적화"></a>브라우저 동작 방식을 기반으로 한 최적화</h2><p>웹 페이지 최적화는 브라우저가 네트워크와 통신하는 과정은 물론 브라우저에서 페이지를 표시하는 과정에서의 응답 속도를 개선하는 것이다. 브라우저가 어떻게 동작하는지 이해해야 올바른 개선 방향을 잡을 수 있다.<br>사용자는 원하는 웹 사이트로 이동하기 위해 다음의 작업을 수행하고 브라우저의 동작 방식이다.</p><ol><li>브라우저의 주소창에 주소를 입력하고 Enter 키를 누르거나 링크를 클릭한다.</li><li>브라우저는 서버에 요청을 보내 페이지를 구성하는 자원을 다운로드한다.</li><li>다운로드 받은 자원을 이용해 요청 결과를 화면에 보여준다.</li></ol><p>이때 브라우저가 어떤 단계로 동작하는지, 단계별로 얼마나 시간이 걸리는지 정의한 연구 활동이 W3C의 네비게이션 타이밍(Navigation Timing) 명세다. 네비게이션 타이밍 명세의 가장 큰 목적은 정확한 단계별 소요 시간을 측정하는 것이지만 브라우저의 처리 단계를 정확하게 정의했다는 데도 큰 의미가 있다.</p><p>네비게이션 타이밍 명세에서 브라우저가 사용자의 요청을 처리하는 순서를 정리한 프로세싱 모델에서 웹 페이지 최적화와 관련 있는 단계를 정리한 것이다.</p><blockquote><p>서비스 이동 단계 -&gt; 리다이렉트 단계 -&gt; 애플리케이션 캐시 확인 단계 -&gt; 네트워크 통신 단계 -&gt; 브라우저 처리 단계</p></blockquote><ul><li>서비스 이동 단계: 사용자가 웹 서비스를 이용하다 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계. 프로세싱 모델의 Prompt for unload</li><li>리다이렉트 단계: 사용자가 요청한 URL에서 다른 URL로 다시 보내는 단계. 프로세싱 모델의 redirect</li><li>애플리케이션 캐시 확인 단계: 브라우저의 캐시에 데이터가 있는지 확인하는 단계. 프로세싱 모델의 App Cache</li><li>네트워크 통신 단계: 브라우저가 네트워크와 통신해서 웹 페이지와 구성 요소를 다운로드 하는 단계. 프로세싱 모델의 DNS, TCP, Request, Response 등</li><li>브라우저 처리 단계: 다운로드한 웹 페이지와 구성 요소로 웹 페이지를 화면에 그리는 단계. 프로세싱 모델의 Processing, onLoad</li></ul><h3 id="서비스-이동-단계"><a href="#서비스-이동-단계" class="headerlink" title="서비스 이동 단계"></a>서비스 이동 단계</h3><p>서비스 이동 단계는 웹 서비스를 이용하다가 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계다. 이 단계의 작업은 다른 주소로 이동하기 전에 보고 있던 페이지에서 실행하는데, 모두 브라우저 내부에서 처리하기 때문에 브라우저 성능과 직결된다.</p><p>웹 서비스를 이용하면 페이지가 표시될 때 우리도 모르게 이번트가 할당되고, 이때 메모리를 조금씩 사용한다. 그런데 이 메모리를 더 이상 사용하지 않을 때, 즉 페이지를 떠날 때는 메모리를 해제해야 한다. 이 <code>메모리 해제</code> 작업이 서비스 이동 단계에서 실행하는 작업 가운데 하나다.</p><p>필요 없는 메모리 해제를 담당하는 <code>가비지 컬렉션 기능</code>이 제대로 동작하지 않으면 브라우저가 응답 없음 상태가 되거나 실행 속도가 급격히 느려진다. 웹 페이지에서 동시에 많은 변수가 생성되고 처리되는 동안 브라우저에서 허용한 임계치를 넘었을 때 가비지 컬렉션이 동작하는데 가비지 컬렉션이 동작하면 스크립트 실행이 중단된다. 가비지 컬렉션이 완료되기 전까지는 스크립트가 동작하지 못해 페이지 느려지는 것이다.</p><p>서비스 이용 단계의 작업은 브라우저 내부에서 자동으로 실행한다. 만약 별도로 처리하려면 beforeunload 이벤트를 활용할 수 있다.</p><h3 id="리다이렉트-단계"><a href="#리다이렉트-단계" class="headerlink" title="리다이렉트 단계"></a>리다이렉트 단계</h3><p>쉽게 볼 수 있는 리다이렉트는 SNS에서 사용하는 단축 URL이다. SNS의 특성상 입력하는 글자 수에 제한이 있다. 쿼리가 긴 URL을 그대로 SNS에 입력하면 글자 수 제한 때문에 원하는 내용을 다 입력하지 못한다. 이때 단축 URL을 사용하면 SNS의 글자 수 제한을 피할 수 있다. 단축 URL로 접속하면 원본 URL로 리다이렉트 된다.</p><p>리다이렉트가 발생하면 상태 코드로 301이나 302를 반환하는데, 이는 HTTP 요청을 완수하기 위해서 추가로 뭔가를 해야 한다는 의미다. 이런 이유로 리다이렉트가 발생하면 어떤 자원도 다운로드 하지 않으며 브라우저에 일시적으로 빈 페이지가 보인다. 그렇기 때문에 특정한 목적으로 리다이렉트를 사용하는 것은 어쩔 수 없지만 의도치 않게 또는 실수로 리다이렉트가 발생한다면 웹 페이지의 성능 향상을 위해 바로 잡아야 한다.</p><p>리다이렉트와 관련해서 개발자가 흔히 저지르는 실수 가운데 하나는 URL 뒤에 슬래시를 넣지 않는 것이다. 주소창에 ‘naver.com’을 입력하고 Enter키를 누르면, 주소창에 입력한 주소가 <code>https://www.naver.com/&#39;</code>으로 바뀌면서 리다이렉트 된다. 이 과정을 개발자 도구로 확인해보면 302 redirect 가 발생하는 것을 확인할 수 있다. a 태그의 href 속성에 주소 뒤에 슬래시를 붙여 301, 302 로 인한 리다이렉트가 발생하지 않도록 막을 수 있다. (307 도 발생하고는 하는데 302와 의미하는바가 같다.)</p><p>두번째로 실수하는 부분은 웹 페이지를 이용한 리다이렉트다. 흔히 메타태그를 이용하는데 다음 코드는 1초 후에 페이지가 이동하는 코드다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;1; url&#x3D;https:&#x2F;&#x2F;www.naver.com&#x2F;&quot;&gt;</span><br></pre></td></tr></table></figure><br>이 코드에는 두 가지 성능 문제가 있다. 첫 번째는 이 코드를 실행시킬 별도의 페이지를 거쳐야 리다이렉트 된다는 점이다. 두 번째는 최종 페이지에 도착했을 때 캐시가 설정된 리소스임에도 불구하고 조건부 GET 요청이 이뤄진다는 점이다.</p><p>조건부 GET 요청은 브라우저에 캐싱된 리소스를 사용하기 전에 해당 리소스를 사용해도 되는지 서버에 물어 보는 것이다. 이때 헤더의 <code>If-Modified-Since</code> 정보를 이용해 서버에 요청을 보낸다. 리소스가 수정되지 않았다면 <code>304 Not Modified</code> 코드를 받아 캐시에 있는 리소스를 사용한다. 자원이 수정됐다면 서버로부터 리소스를 다운로드 한다.</p><p><code>캐시의 만료 날짜를 설정</code>했다면 서버의 확인을 거치지 않고 바로 캐싱된 리소스를 사용할 수 있는데, 메타태그로 리다이렉트하면 조건부 GET 요청으로 불필요한 서버 통신이 발생해 응답 속도가 느려진다.</p><p>웹 페이지의 주소뿐 아니라 이미자와 스타일시트, 자바스크립트와 같이 페이지를 구성하는 요소도 리다이렉트 될 수 있다. 301 이나 302 상태 코드가 발생하는 요소를 찾고 의도치 않게 리다이렉트가 발생하고 있다면 성능 향상을 위해서 바로 잡아야 한다.</p><h3 id="애플리케이션-캐시-확인-단계"><a href="#애플리케이션-캐시-확인-단계" class="headerlink" title="애플리케이션 캐시 확인 단계"></a>애플리케이션 캐시 확인 단계</h3><p>리다이렉트 작업을 마치고 HTTP 요청을 처리하기 위한 준비를 마쳤다면 브라우저는 먼저 서버로 요청을 보낸다. 서버에서 응답이 오면 개별 요소(이미지, 스타일시트, 자바스크립트 등)가 사용자 PC에 있는지 캐시 데이터를 찾는다. 캐시 데이터의 종류에는 쿠키, 이미지, 스크립트, 스타일시트 등이 있다.</p><p>캐시 데이터가 있는 이유는 무엇보다도 사용자가 동일한 페이지를 다시 방문했을 때 브라우저와 서버 사이에 통신을 하지 않고 캐시에 있는 자원을 사용하겠다는 것이다. 성능 향상을 위해 가장 효과적인 방법은 브라우저와 서버 사이의 통신을 최대한으로 줄이는 것이다. 그러므로 다시 방문한 사용자에게 좀 더 빠른 응답 속도를 제공하려면 애플리케이션 캐시를 잘 활용해야한다.</p><p>캐시를 다룰 때는 개별 요소들이 정말 유효한지, 사용해도 되는 것인지 검증하는 것이 중요하기 때문에 몇 가지 용어와 규칙이 필요하다.</p><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Last-Modified</td><td>서버에서 저장하고 있는 마지막 수정 날짜 예: Last-Modified Sun, 27 Jan 2020 17:00:00 GMT</td></tr><tr><td>If-Modified-Since</td><td>브라우저에서 저장하고 있는 마지막 수정 날짜 예: If-Modified-Since Sun, 27 Jan 2020 17:00:00 GMT</td></tr><tr><td>Expires</td><td>만료 날짜. 언제까지 유효한지 미리 지정해 놓은 시간 정보로, 특정 날짜까지는 사용할 수 있다는 정보. 예: Expires 17:00:00 Sunday, December 27, 2020 GMT</td></tr><tr><td>Cache-Control</td><td>Expires 정보의 한계를 극복하려고 HTTP/1.1 에서 소개된 캐시 설정 추가 정보</td></tr><tr><td>max-age</td><td>캐싱할 시간. Cache-Control 정보 가운데 하나로 캐싱할 시간을 초 단위까지 정할 수 있다. max-age 정보는 클라이언트 시간과 관계 없이 현재부터 며칠, 몇 년 등으로 지정할 수 있다.</td></tr></tbody></table><p>자원 요소를 다운로드할때 브라우저가 처리하는 과정이다.</p><p>Expires 정보 확인 (정보 없음)-&gt; If-Modified-Since 정보 확인(정보 있음) -&gt; If-Modified-Since 정보와 Last-Modified 정보 비교</p><ul><li>Expires 정보가 있고 기한이 남아 있으면 캐시에 저장된 요소를 사용한다.</li><li>If-Modified-Since가 없으면 서버에 요소를 요청한다.</li><li>If-Modified-Since 정보가 있으면 Last-Modifed 정보를 비교하고 날짜가 같으면 캐시에 저장된 요소를 사용하라는 응답 304 Not Modifed 을 보내주고, 날짜가 다른 경우 서버의 요소를 전송한다.</li></ul><p>사용자 PC에 캐시 파일이 있고 Expires 정보가 유효하다면 해당 파일을 서버에 요청하지 않고 캐시에 저장된 파일을 이용한다. 이러면 동적인 이미지 등을 제외한 나머지 정적인 요소는 별도로 서버에 요청하지 않기 때문에 로딩 속도를 크게 향상시킬 수 있다.</p><h3 id="네트워크-통신-단계"><a href="#네트워크-통신-단계" class="headerlink" title="네트워크 통신 단계"></a>네트워크 통신 단계</h3><p>네트워크 비용을 줄이는 첫 번째 방법은 Expires 설정이나 Cache Control 속성을 이용해 사용자 웹 페이지에 다시 왔을 때 캐시를 사용하는 방법이다. 두 번째 방법은 스타일시트나 자바스크립트와 같이 파일을 합쳐서 서비스해도 문제가 없는 리소스를 합쳐 하나의 링크로 제공해 요청 횟수를 줄이는 방법이다.</p><h5 id="DNS-DNS-Lookup"><a href="#DNS-DNS-Lookup" class="headerlink" title="DNS (DNS Lookup)"></a>DNS (DNS Lookup)</h5><p>호스트 이름으로 IP 주소를 조회한 시간이다. 보통 20~120ms 정도 소요된다. 이 작업이 완료되지 않으면 어떤 자원도 다운로드 하지 않는다. 브라우저에서 IP 주소를 조회할 때 동일한 호스트로 요청하는 요소는 다시 IP 주소를 확인하지 않아 시간이 추가로 걸리지 않는다. 그럼 하나의 호스트로 모든 리소스를 호출하면 시간을 줄일 수 있을 것 같지만, 대신 호스트별 동시 연결 기능은 포기해야 한다.</p><p>보통 이미지의 크기가 크고 개수가 많은 이미지 검색 서비스를 개발할 때 이런 부분을 많이 고려한다. 한 번에 보이는 이미지의 개수가 많을 때 호스트를 여러 개 만들어 동시에 다운로드하면 성능을 높일 수 있다고 생각하지만 실제로는 고려할 사항도 많다. DNS Lookup 단계에서 걸리는 시간도 무시할 수 없다. 때문에 여러 가지 가정을 세워서 테스트한 다음 최적의 호스트 개수를 찾아야한다.</p><h5 id="Request-Send"><a href="#Request-Send" class="headerlink" title="Request(Send)"></a>Request(Send)</h5><p>웹 서버와 TCP 연결이 이뤄지면 원하는 정보를 서버에 보내는 시간이다. 주로 요청 헤더 정보를 보내는 시간이 여기에 해당한다. Send 시간은 파일 올리기와 같이 보내야 할 정보가 많을수록 오래 걸린다.<br>일반적인 상황에서 Send 시간을 최적화하는 방법은 쿠키 정보를 포함하지 않는 별도 호스트를 사용해 서비스하는 것이다. 쿠키 정보가 필요 없는 파일(이미지, 스타일시트, 자바스크립트)에는 별도 호스트를 적용해 헤더 정보에서 쿠키 정보를 없애는 것이다.</p><h5 id="Response-Receive"><a href="#Response-Receive" class="headerlink" title="Response(Receive)"></a>Response(Receive)</h5><p>서버에서 보내는 응답 메시지를 받는 시간이다. 이 단계에서 성능을 개선하는 방법으로는 데이터 크기를 줄이기 위해 Gzip과 같은 파일 압축 기술을 사용하는 방법이 있다. 주석이나 공백을 없애 코드의 양을 줄이고, 코드의 양을 줄인 파일을 Gzip 등으로 압축해서 파일의 크기를 줄인다. Gzip으로 압축하면 원본 파일의 약 30% 정도로 크기가 줄어든다.</p><h3 id="브라우저-처리-단계"><a href="#브라우저-처리-단계" class="headerlink" title="브라우저 처리 단계"></a>브라우저 처리 단계</h3><p>프로세싱 모델의 Processing과 onLoad 에 해당하는 브라우저 처리 단계는 서버에서 받은 HTML과 이미지, 스타일시트를 조합해 사용자가 실제로 보는 화면을 만드는 단계다. 복잡한 UI를 개발할 때는 인라인 형태의 이벤트 바인딩 방법보다 이벤트 핸들러로 바인딩하는 방법을 사용한다. 이벤트 핸들러로 이벤트를 바인딩하려면 최우선 조건이 해당 DOM이 존재해야 한다. 모든 DOM이 존재하는 바로 그 시점이 DOMContentLoaded 이벤트나 onload 이벤트가 발생하는 시점이다.</p><blockquote><p>브라우저의 DOM 처리 절차에 따른 이벤트 발생 순서<br>domLoading -&gt; domInteractive -&gt; domContentLoaded -&gt; domComplete -&gt; onload</p></blockquote><p>onload 이벤트는 DOM 에서 기본으로 제공하는 이벤트로 문서에 있는 모든 이미지, 스타일시트, 자바스크립트 등이 모두 다운로드 될 때마다 발생한다. 이와 달리 DOMContentLoaded 이벤트는 기본적으로 DOM 생성에만 관련돼있다. 이미자나 다른 요소를 다운로드 하는것과 관계없이 DOM이 로딩되고 난 직후에 발생한다.</p><p>많은 양의 이벤트를 바인딩해야 하고 이미지나 스타일시트의 개수가 많은 페이지를 개발한다면 onload 이벤트보다는 DOMContentLoaded 이벤트를 이용하는게 좋다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
