<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkangil&#39;s Blog</title>
  
  <subtitle>kkangil&#39;s develop Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkangil.github.io/"/>
  <updated>2019-04-17T15:47:37.770Z</updated>
  <id>https://kkangil.github.io/</id>
  
  <author>
    <name>kkangil</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Next.js with pm2 ecosystem</title>
    <link href="https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/"/>
    <id>https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/</id>
    <published>2019-04-17T15:29:19.000Z</published>
    <updated>2019-04-17T15:47:37.770Z</updated>
    
    <content type="html"><![CDATA[<p><code>Next.js</code>는 Client-Side-Rendering 을 사용하는 react가 아닌 <code>SSR(Server-Side-Rendering)</code> 방식을 사용하는 react framework 이다.<br>해당 글은 <code>Next.js</code>에서 배포시 참고하면 좋을 내용으로 <code>Next.js</code>가 뿐만 아니라 react, Node 에서도 사용 가능하다.</p><a id="more"></a><h2 id="pm2-ecosystem"><a href="#pm2-ecosystem" class="headerlink" title="pm2 ecosystem"></a>pm2 ecosystem</h2><p>pm2 ecosystem이란, 실행할 인스턴스의 설정을 JSON 형식으로 관리할 수 있고, pm2 에서 제공해 주는 option 을 보다 쉽게 관리 할수 있도록 도와준다. pm2 명령어로 직접 실행시킬 수 있지만, ecosystem을 사용함으로써 어떤 서버나 환경에서도 같은 설정을 사용해서 서버를 실행할 수 있다는 점이 장점이다.</p><ol><li>ecosystem.config.js 를 최상위 폴더에 생성한다.</li><li>작성방법</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  apps: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;chungeoram&quot;,</span><br><span class="line">      script: &quot;./server.js&quot;,</span><br><span class="line">      watch: true,</span><br><span class="line">      interpreter: &apos;/home/ubuntu/.nvm/versions/node/v8.11.3/bin/node&apos;,</span><br><span class="line">      &quot;env_public-develop&quot;: &#123;</span><br><span class="line">        NODE_ENV: &quot;public-develop&quot;,</span><br><span class="line">        PORT: 1111,</span><br><span class="line">        API_END_POINT: &apos;http://endpoint/api&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      env_production: &#123;</span><br><span class="line">        NODE_ENV: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name: pm2 에서 관리하는 이름</li><li>script: 앱을 구동할 경로</li><li>watch: 파일이 변경되면 자동으로 재시작 유무</li><li>ignore_watch: 배열안에 있는 리스트는 watch 대상에서 무시한다.</li><li>exec_mode: 클러스터 모드로 구동instances: 클러스터로 구동될시 몇개까지 구동할것인지 선택(0 : cpu갯수)</li><li>merge_logs: 클러스터로 구동할시 로그를 한파일에 기록</li><li>interpreter: 해석기 절대 경로(default: node)</li><li>log_date_format: 로그에 출력될 날짜와 시간값의 형식</li><li>error_file: 에러 파일 위치</li><li>out_file: 기본 출력 로그 위치</li><li>env_{value}<ul><li>value는 <code>process.env.NODE_ENV</code> 값과 매칭된다. 예를 들어 현재 <code>process.env.NODE_ENV</code>가 <code>public-develop</code> 일때, <code>env_public-develop</code> 내부의 값이 사용된다. 내부의 값들은 <code>process.env</code> 객체 내로 값이 할당되며, <code>process.env.PORT</code> , <code>process.env.API_END_POINT</code> 로 값을 배포 환경의 따라 다르게 사용가능하다.</li></ul></li></ul><ol start="3"><li>pm2 구동방법<br>package.json script에 명령어를 추가해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;pm2 start ecosystem.config.js --env production&quot;,</span><br><span class="line">    &quot;start-public&quot;: &quot;pm2 start ecosystem.config.js --env public-develop&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon server.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>$ yarn build → $ yarn start</li><li>app 빌드 후 명령어를 사용해서, pm2를 구동시켜 준다. pm2 start {파일이름} –env {value} 와 같은 형식으로 명령어를 추가한다. 여기서 환경변수는 ecosystem.config.js 의 env_{value}와 매칭 된다.</li></ul><h2 id="Next-js-에서-process-env-변수-사용-주의사항"><a href="#Next-js-에서-process-env-변수-사용-주의사항" class="headerlink" title="Next.js 에서 process.env 변수 사용 주의사항"></a>Next.js 에서 process.env 변수 사용 주의사항</h2><p><code>Next.config.js</code> 에서 <code>sass</code>, <code>webpack</code> 등의 처리 후 export 하는 과정에서, process.env 객체가 비어있는 문제를 발견했다. 하지만, api.js config.js 등 환경 변수에 따라 값을 변경해줘야 하기 때문에 process.env 객체가 비어있으면 안된다. 해당 문제를 처리하기 위해 Next.js 에서 <code>publicRuntimeConfig</code> 라는 옵션을 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const withSass = require(&apos;@zeit/next-sass&apos;)</span><br><span class="line">const withCSS = require(&apos;@zeit/next-css&apos;)</span><br><span class="line"></span><br><span class="line">const publicRuntimeConfig = &#123;</span><br><span class="line">  API_END_POINT: process.env.API_END_POINT,</span><br><span class="line">  NODE_ENV: process.env.NODE_ENV,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = withCSS(withSass(&#123;</span><br><span class="line">  publicRuntimeConfig,</span><br><span class="line">  webpack: config =&gt; &#123;</span><br><span class="line">    // Fixes npm packages that depend on `fs` module</span><br><span class="line">    config.node = &#123;</span><br><span class="line">      fs: &apos;empty&apos;,</span><br><span class="line">      module: &apos;empty&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>필요한 process.env 의 값을 <code>publicRuntimeConfig</code> 객체에 담아주고 Next.js 의 옵션 값에 할당해준다.할당해 주게되면, Next.js 의 config 값으로 저장되게 된다.이후 Next.js의 config 값을 불러오는 함수를 추가해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import getConfig from &apos;next/config&apos;;</span><br><span class="line"></span><br><span class="line">export const getNodeEnv = () =&gt; &#123;</span><br><span class="line">  const &#123; publicRuntimeConfig &#125; = getConfig();</span><br><span class="line"></span><br><span class="line">  const realNodeEnv = publicRuntimeConfig.NODE_ENV || process.env.NODE_ENV;</span><br><span class="line">  const apiEndPoint = publicRuntimeConfig.API_END_POINT;</span><br><span class="line"></span><br><span class="line">  return &#123; realNodeEnv, apiEndPoint &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>해당 함수는 Next.js의 config에서 publicRuntimeConfig 를 가져와 return 해준다.이제 process.env 환경변수를 사용하고 싶다면, process.env.API_END_POINT 와 같이 직접적으로 사용하는것이 아닌, 해당 함수를 사용해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import config from &apos;./config&apos;</span><br><span class="line">import &#123; getNodeEnv &#125; from &apos;@/utils/env&apos;</span><br><span class="line"></span><br><span class="line">const env = getNodeEnv()</span><br><span class="line">const endPoint = env.apiEndPoint || config.apiEndPoint</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  AUTH_TOKEN: &#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    path: () =&gt; `$&#123;endPoint&#125;/auth/authenticate-token`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Next.js&lt;/code&gt;는 Client-Side-Rendering 을 사용하는 react가 아닌 &lt;code&gt;SSR(Server-Side-Rendering)&lt;/code&gt; 방식을 사용하는 react framework 이다.&lt;br&gt;해당 글은 &lt;code&gt;Next.js&lt;/code&gt;에서 배포시 참고하면 좋을 내용으로 &lt;code&gt;Next.js&lt;/code&gt;가 뿐만 아니라 react, Node 에서도 사용 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="Deploy" scheme="https://kkangil.github.io/categories/Deploy/"/>
    
    
      <category term="Next.js" scheme="https://kkangil.github.io/tags/Next-js/"/>
    
      <category term="deploy Next.js" scheme="https://kkangil.github.io/tags/deploy-Next-js/"/>
    
      <category term="pm2" scheme="https://kkangil.github.io/tags/pm2/"/>
    
      <category term="pm2-ecosystem" scheme="https://kkangil.github.io/tags/pm2-ecosystem/"/>
    
  </entry>
  
  <entry>
    <title>Deep clone</title>
    <link href="https://kkangil.github.io/2019/04/18/Deep-clone/"/>
    <id>https://kkangil.github.io/2019/04/18/Deep-clone/</id>
    <published>2019-04-17T15:01:31.000Z</published>
    <updated>2019-04-17T15:35:10.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a>이슈</h2><ol><li>react에서 setState를 하지 않았음에도 state가 변경되는 현상</li><li>api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상</li></ol><p>react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.<br>해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.<br>해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; a: 1, b: 2 &#125;</span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state = &#123;...this.state&#125;;</span><br><span class="line">  state[e.target.name] = e.target.value;</span><br><span class="line">  this.setState(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 본인이 input 의 onChange 이벤트 함수로 거의 복붙하면서 변형없이 사용하는 이벤트 함수이다.<br>최근 state 변수 선언 즉, state 객체를 복사하고 사용하는 과정에 있어 동일한 이슈가 많이 발생하고 있어, 해당 함수를 단순히 복사하는것이 아닌 이해가 필요하고 상황에 따라 변형해서 사용해야할 필요있다.</p><h2 id="Object-copy"><a href="#Object-copy" class="headerlink" title="Object copy"></a>Object copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;...this.state&#125;</span><br></pre></td></tr></table></figure><p>state 변수는 react state 객체를 복사한것이다. 해당 문법은 es9 문법으로 특정 값만 바꿀때 유용하다.<br>해당 문법의 es5 버전은 .assign() 메소드이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;&#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object3 = Object.assign(&#123; c: 3 &#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object4 = Object.assign(&#123;&#125;, object1);</span><br><span class="line">object4.a = 100</span><br><span class="line"></span><br><span class="line">const object5 = &#123;...object1&#125;</span><br><span class="line">object5.a = 100</span><br><span class="line"></span><br><span class="line">console.log(object2.a); //100</span><br><span class="line">console.log(object2.b); //2</span><br><span class="line">console.log(object3.a); //100</span><br><span class="line">console.log(object3.b); //2</span><br><span class="line">console.log(object3.c); //3</span><br><span class="line">console.log(object4.a); //100</span><br><span class="line">console.log(object5.a); //100</span><br></pre></td></tr></table></figure><ul><li>object2 : 빈 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object3: c: 3 값이 담겨있는 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object4: 현재 우리 회사에서 사용하는 handleChange를 es5로 바꾼 방법</li><li>object5: Spread syntax(…) es8 문법사용<br>하지만 state 내부에 객체를 변경하려고 할때 문제가 발생한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state &#123;...this.state&#125;</span><br><span class="line">  state.b.c = 3</span><br><span class="line">  this.setState(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2단계 이상 깊이의 object는 복사가 원활하지 않는것을 확인할 수 있다. 복사본의 값을 변경했는데 원본의 값도 변경되는 알수 없는 현상이 발생한다.<br>MDN: 깊은 클로닝에 대해서, Object.assign() 은 속성의 값을 복사하기때문에 다른 대안을 사용해야합니다. 출처 값이 객체에 대한 참조인 경우, 참조 값만을 복사합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(&#123;&#125;, org);</span><br><span class="line">obj.a.b = 100; </span><br><span class="line">console.log(obj.a.b);  //expected: 2 but actual: 100</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;...org&#125;;</span><br><span class="line">obj2.a.b = 100; </span><br><span class="line">console.log(org.a.b);  //expected: 2 but actual: 100</span><br></pre></td></tr></table></figure><p>해당 현상은 깊은 클로닝(deep cloning) 방식을 사용해야한다.<br>객체 복사 방식 변경 : 객체를 string 으로 변경하고 다시 파싱해주는 방법</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = JSON.parse(JSON.stringify(org)); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br><span class="line">lodash 메소드 사용</span><br><span class="line">import _ from &apos;lodash&apos;; const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = _.cloneDeep(org); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br></pre></td></tr></table></figure><h2 id="Array-copy"><a href="#Array-copy" class="headerlink" title="Array copy"></a>Array copy</h2><p>2단계 이상 깊이의 배열을 복사할때는 맵을 사용해서 객체 하나하나 복사해준 후 return 해주는 방식을 사용해서 에러발생을 막아야합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    a: [&#123;</span><br><span class="line">      b: 1</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">      b: 2</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj1 = &#123;...org&#125;</span><br><span class="line">const arr = org.obj.a // x</span><br><span class="line"></span><br><span class="line">const arr2 = org.obj.a.map(row =&gt; &#123;</span><br><span class="line">return &#123;...row&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>참고<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;이슈&quot;&gt;&lt;a href=&quot;#이슈&quot; class=&quot;headerlink&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;이슈&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;react에서 setState를 하지 않았음에도 state가 변경되는 현상&lt;/li&gt;
&lt;li&gt;api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.&lt;br&gt;해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.&lt;br&gt;해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://kkangil.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://kkangil.github.io/tags/Javascript/"/>
    
      <category term="syntax" scheme="https://kkangil.github.io/tags/syntax/"/>
    
      <category term="deep-clone" scheme="https://kkangil.github.io/tags/deep-clone/"/>
    
  </entry>
  
  <entry>
    <title>리액트 라이프사이클</title>
    <link href="https://kkangil.github.io/2019/04/17/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/"/>
    <id>https://kkangil.github.io/2019/04/17/리액트-라이프사이클/</id>
    <published>2019-04-17T14:48:33.000Z</published>
    <updated>2019-04-17T15:34:52.842Z</updated>
    
    <content type="html"><![CDATA[<p>React를 사용하기 전 <code>라이프사이클</code>에 대해 확실하게 알고 사용하는 것이 좋다.<br><code>라이프사이클</code> 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.<br>github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.<a href="https://github.com/kkangil/react-lifecycle" target="_blank" rel="noopener">code 보기</a></p><a id="more"></a><h2 id="주요-라이프사이클"><a href="#주요-라이프사이클" class="headerlink" title="주요 라이프사이클"></a>주요 라이프사이클</h2><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><ul><li>렌더가 된 이후 실행되는 라이프사이클로 최초 API 요청 사용에 적합한 라이프 사이클</li></ul><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><ul><li>component 의 상태값이 변경되었을때 render 직전에 호출되는 라이프 사이클</li><li>Boolean 값을 return 해야하며, false 를 return 하면 렌더를 하지 않음.</li><li>렌더를 하지 않으므로 이후 라이프사이클도 먹히지 않음.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><ul><li>component가 DOM 에서 삭제(해당 컴포넌트 미표시)할때 마지막으로 실행되는 메소드</li><li>interval 이나 비동기 API 제거에 주로 쓰임.</li></ul><h2 id="16-3-이후-변경된-라이프사이클"><a href="#16-3-이후-변경된-라이프사이클" class="headerlink" title="16.3 이후 변경된 라이프사이클"></a>16.3 이후 변경된 라이프사이클</h2><ul><li>렌더링 제어에 많은 방법이 있기때문에 라이프사이클 사용에 혼란이 생김.</li><li>실제 커뮤니티에서도 어떤 라이프사이클이 좋다 안좋다 성능 이슈가 많음. 대표적으로 componentWillMount 와 componentDidMount 둘중 어떤 라이프사이클에서 API를 호출해야하는지.</li><li>향후 componentWillMount, componentWillReceiveProps, componentWillUpdate 라이프사이클이 삭제되고 <code>UNSAFE_</code> 라이프사이클만 동작할것이라고 예고</li><li>이를 대체하기 위해 새로운 라이프사이클 추가</li></ul><h3 id="라이프사이클-동작-순서"><a href="#라이프사이클-동작-순서" class="headerlink" title="라이프사이클 동작 순서"></a>라이프사이클 동작 순서</h3><ul><li>최초 진입: <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code> 순으로 실행.</li><li>props 변경: <code>getDerivedStateFromProps</code> -&gt; <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li><li>state 변경: <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li></ul><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><ul><li>componentDidMount 보다 먼저 실행</li><li>window 객체 접근 가능(storage 사용 가능)</li><li>props 와 state가 변경되었을때는 최초 실행</li><li>파리미터로 변경될 props 와 state가 넘어옴. this.state 접근 불가능</li><li>return 되는 객체값으로 state 가 변경된다. (해당 라이프사이클에서는 state 변경만 해주는것이 바람직하다고 판단됨.) state를 변경해주고 싶지 않을때에는 null 을 return 해주면된다.</li><li>최초 페이지 진입시 <code>componentDidMount</code> 라이프사이클에서 fetch 실행</li><li>react 공식문서에서는 props 가 변경되었을때 fetch가 필요하다면 해당 라이프사이클에서 API(data fetching) 요청 하는것이 아닌 <code>componentDidUpdate</code> 라이프 사이클에서 fetch 하도록 유도하고 있음.</li></ul><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><ul><li><code>componentWillUpdate</code> 의 대체 라이프사이클</li><li>DOM이 업데이트 되기 직전이 실행</li><li><code>componentDidUpdate</code> 전에 실행되며 해당 라이프사이클의 return 값이 componentDidUpdate 3번째 파라미터로 전달됨.</li><li>기존 <code>componentWillUpdate</code> 와 같이 해당 라이프사이클 안에서 this.setState()를 사용하는 경우 무한루프에 빠지게 됨.</li><li>자주 사용되지는 않을것으로 판단됨.</li></ul><h2 id="Error-Boundary"><a href="#Error-Boundary" class="headerlink" title="Error Boundary"></a>Error Boundary</h2><ul><li>렌더 과정에서 에러가 생겼을경우 앱이 죽는것이 아니라 UI 변경과 같은 대안으로 앱이 죽지 않도록 하는 방식</li><li>해당 class를 최상단에 두고 라이프사이클을 이용해서 조작할 수 있다.</li></ul><h3 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError"></a>getDerivedStateFromError</h3><ul><li>16.6 버전에 추가된 라이프 사이클</li><li>해당 라이프 사이클은 렌더 중에 호출되며 fallback UI를 렌더링 하기 위한 메소드이다.</li><li>렌더 중에 호출되기 때문에 side effect(API call, 함수 호출) 을 사용하지 않는것이 좋다.</li><li>react 공식 문서에서는 componentDidCatch 라이프 사이클을 추천한다.</li><li>return 객체는 state 가 해당 객체로 변경된다.</li></ul><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><ul><li>해당 라이프사이클은 에러를 기록하거나 트래킹하기 위한 작업을 위해 주로 사용된다. (ex Sentry)</li><li>해당 라이프 사이클에서도 state 를 변경하여 UI 를 변경해줄수 있지만 추천되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React를 사용하기 전 &lt;code&gt;라이프사이클&lt;/code&gt;에 대해 확실하게 알고 사용하는 것이 좋다.&lt;br&gt;&lt;code&gt;라이프사이클&lt;/code&gt; 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.&lt;br&gt;github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.&lt;a href=&quot;https://github.com/kkangil/react-lifecycle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code 보기&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://kkangil.github.io/tags/React/"/>
    
      <category term="lifecycle" scheme="https://kkangil.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kkangil.github.io/2019/04/17/hello-world/"/>
    <id>https://kkangil.github.io/2019/04/17/hello-world/</id>
    <published>2019-04-17T11:51:34.545Z</published>
    <updated>2019-04-17T15:35:24.643Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><table><thead><tr><th>설정</th><th>설명</th><th>기본 값</th></tr></thead><tbody><tr><td>layout</td><td>레이아웃</td><td></td></tr><tr><td>title</td><td>타이틀</td><td></td></tr><tr><td>date</td><td>발행일</td><td>파일이 생성된 날짜</td></tr><tr><td>updated</td><td>갱신일</td><td>파일이 업로드된 날짜</td></tr><tr><td>tags</td><td>태그 (page에서는 사용 불가능)</td><td></td></tr><tr><td>categories</td><td>카테고리 (page에서는 사용 불가능)</td><td></td></tr><tr><td>permalink</td><td>포스트의 기본 permalink를 override합니다.</td><td></td></tr><tr><td>comments</td><td>포스트에서 comment 기능을 사용할지 여부</td><td>true</td></tr></tbody></table><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://kkangil.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://kkangil.github.io/tags/hexo/"/>
    
      <category term="hexo 시작" scheme="https://kkangil.github.io/tags/hexo-%EC%8B%9C%EC%9E%91/"/>
    
  </entry>
  
</feed>
