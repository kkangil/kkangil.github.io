<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkangil&#39;s Blog</title>
  
  <subtitle>kkangil&#39;s develop Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkangil.github.io/"/>
  <updated>2019-04-19T03:56:23.497Z</updated>
  <id>https://kkangil.github.io/</id>
  
  <author>
    <name>kkangil</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>리액트 Hooks: 3. 사용방법2</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-3-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%952/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-3-사용방법2/</id>
    <published>2019-04-19T03:54:04.000Z</published>
    <updated>2019-04-19T03:56:23.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const reducer = (state, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;INCREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count + 1 &#125;;</span><br><span class="line">    case &quot;DECREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count - 1 &#125;;</span><br><span class="line">    case &quot;HANDLE_CHANGE&quot;:</span><br><span class="line">      return &#123; ...state, [action.target.name]: action.target.value &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const CountReducer = () =&gt; &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, &#123;</span><br><span class="line">    count: 0,</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    nickname: &quot;&quot;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const handleChange = e =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &quot;HANDLE_CHANGE&quot;, target: e.target &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;INCREMENT&quot; &#125;)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;DECREMENT&quot; &#125;)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.name&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.nickname&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default CountReducer;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>이전에 useState로 구현했었던 count와 input 컴포넌트를 위의 코드와 같이 reducer를 사용해서 구현할 수 있다.</li><li>useState 또는 useReducer 어떤것이 더 좋다 안좋다는 없지만, 상황에 따라 유연하게 사용할 줄 알아야 할것같다.</li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>두번째 파라미터 배열 값을 전달받아 해당 값이 변경 될때만 첫번째 파라미터 함수를 실행한다. 해당 기능을 사용하면 불필요한 함수 호출을 줄일 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Sum = () =&gt; &#123;</span><br><span class="line">  const [num, setNum] = useState(&quot;&quot;);</span><br><span class="line">  const [numList, setNumList] = useState([]);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = () =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const sumValue = useMemo(() =&gt; &#123;</span><br><span class="line">    if (!numList.length) return 0;</span><br><span class="line">    const sum = numList.reduce((a, b) =&gt; a + b);</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;, [numList]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Sum</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;num&#125; onChange=&#123;e =&gt; setNum(e.target.value)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClickAdd&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number list: &#123;numList.join(&quot;, &quot;)&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number total: &#123;sumValue&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Sum;</span><br></pre></td></tr></table></figure><ul><li>sumValue 함수에 <code>useMemo</code>를 사용하지 않으면, input 값이 변경될때도 해당 로직이 불필요하게 실행된다.</li><li>useMemo를 사용해 줌으로써 불필요하게 실행되지 않도록 하고, <code>numList</code>의 값이 변경될때마다 해당 로직이 실행된다.</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useMemo와 거의 비슷한 기능으로 렌더링 성능을 최적화 하기위해 주로 사용된다. 쓰지 않아도 문제되지는 않지만 렌더링 해야할 컴포넌트 개수나 로직이 많아진다면 고려해 봐야한다. 해당 기능은 이벤트 함수를 필요할때만 생성해 주는 기능이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = useCallback(e =&gt; &#123;</span><br><span class="line">    setNum(e.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br></pre></td></tr></table></figure><ul><li>위의 onChange 함수와 handleClickAdd 함수를 useCallback을 사용하는 함수로 변경했다.</li><li>두번째 파라미터 배열은 해당 값이 변경될때만 함수를 생성해 주는것이다. 빈 배열이라면 최초에만 생성해주고 이후 다시 생성되지 않는다.</li><li>handleChange 는 빈배열, handleClickAdd 은 두개의 값을 판단하고 있는데, 이는 handleChange는 단순히 <code>num</code> 의 값만 변경해 주고 있어 초기에만 생성해 줘도 되는것이다. handleClickAdd 함수는 이벤트가 실행 될때마다 값을 가져와서 사용해 주고 있기때문에 배열에 해당 값들을 명시해줘야한다.</li></ul><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>useRef는 함수형 컴포넌트에서도 ref 기능을 사용할 수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const inputElement = useRef(null);</span><br><span class="line">const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">      inputElement.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br><span class="line">&lt;input value=&#123;num&#125; onChange=&#123;handleChange&#125; ref=&#123;inputElement&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li>useRef는 다른 Hook과 다르게 최초 선언을 배열 형태로 선언해 주지 않는다.</li><li>ref 값이 변경되어도 리렌더링 되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h2&gt;&lt;p&gt;redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import React, &amp;#123; useReducer &amp;#125; from &amp;quot;react&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const reducer = (state, action) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  switch (action.type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;INCREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count + 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;DECREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count - 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;HANDLE_CHANGE&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, [action.target.name]: action.target.value &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const CountReducer = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const [state, dispatch] = useReducer(reducer, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count: 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &amp;quot;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nickname: &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const handleChange = e =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch(&amp;#123; type: &amp;quot;HANDLE_CHANGE&amp;quot;, target: e.target &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;p&amp;gt;current count: &amp;#123;state.count&amp;#125;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;INCREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;increase&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;DECREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;decrease&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.name&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.nickname&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export default CountReducer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useReducer" scheme="https://kkangil.github.io/tags/useReducer/"/>
    
      <category term="useMemo" scheme="https://kkangil.github.io/tags/useMemo/"/>
    
      <category term="useCallback" scheme="https://kkangil.github.io/tags/useCallback/"/>
    
      <category term="useRef" scheme="https://kkangil.github.io/tags/useRef/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 2. 사용방법1</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-2-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%951/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-2-사용방법1/</id>
    <published>2019-04-19T03:52:51.000Z</published>
    <updated>2019-04-19T03:53:43.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h3><p>useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.</p><p>사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><ul><li>useState를 사용하여 count state를 생성해 주었으며 초기값은 0으로 맞춰 주었다.</li><li>state 사용은 기존의 class에서 사용하던 this.state.count가 아닌 count로만 사용해야 한다.</li><li>setCount 파라미터로 값을 넘겨주면 해당 값으로 state가 변경된다.</li></ul><h3 id="여러개의-state-사용"><a href="#여러개의-state-사용" class="headerlink" title="여러개의 state 사용"></a>여러개의 state 사용</h3><p>여러개의 state를 사용해야 한다면, 기존 class 방식에서는 state 객체 안에 키와 값을 설정해 주면 됐지만, 함수형 컴포넌트에서는 useState를 여러번 써줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;name ? `$&#123;name&#125;&apos;s` : &quot;&quot;&#125; current count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="재사용-가능한-useState-함수-컴포넌트"><a href="#재사용-가능한-useState-함수-컴포넌트" class="headerlink" title="재사용 가능한 useState 함수 컴포넌트"></a>재사용 가능한 useState 함수 컴포넌트</h3><p>동일한 stateful 로직을 사용한다면 컴포넌트를 분리해서 사용하는것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const useInputOption = props =&gt; &#123;</span><br><span class="line">  const [value, setValue] = useState(props || &quot;&quot;);</span><br><span class="line">  const onChange = e =&gt; &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const nameInputOption = useInputOption(&quot;&quot;);</span><br><span class="line">  const nickInputOption = useInputOption(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input &#123;...nameInputOption&#125; /&gt;</span><br><span class="line">      &lt;input &#123;...nickInputOption&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;nameInputOption.value ? `$&#123;nameInputOption.value&#125;&apos;s` : &quot;&quot;&#125; current</span><br><span class="line">        count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>input의 value와 onChange 이벤트 함수를 return 해주는 <code>useInputOption</code> 컴포넌트를 만들었다.</li><li>코드가 간결해지고 재사용성이 높아진다.</li></ul><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect는 함수형 컴포넌트에서도 라이프사이클과 같은 기능을 사용할 수 있게 해준다.<br><code>componentDidMount</code> 와 <code>componentDidUpdate</code>, <code>componentWillUnmount</code> 를 합쳐놓은 것이다.<br>useEffect 함수는 state 변수를 하나만 관리하는것이 좋다. 즉 여러개의 useEffect 함수를 사용하는것을 추천해주고 있다.</p><h3 id="사용방법-1"><a href="#사용방법-1" class="headerlink" title="사용방법"></a>사용방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const User = () =&gt; &#123;</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default User;</span><br></pre></td></tr></table></figure><ul><li>해당 코드를 확인해보면 render 가 될때마다 console.log 가 찍히는것을 확인할 수 있다. 이것은 <code>componentDidMount</code> 와 <code>componentDidUpdate</code> 라이프사이클과 일치한다.</li></ul><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><ul><li>useEffect 함수에 두번째 파라미터로 빈배열을 넣으면 최초 렌더링이 될때만 실행되고 name이 변경되더라도 실행되지 않는다.</li></ul><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>배열에 원하는 값을 넣어주면 해당 값이 변할때만 실행된다.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      console.log(&quot;unmount&quot;, name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>return 함수는 렌더링이 될때마다 실행되는 함수이다. name을 확인해보면 변경되기 이전의 값이 찍히는것을 확인할 수 있다.</li><li>두번째 파라미터에 빈 배열을 담아서 실행하면 unmount 될때만 return 함수가 실행된다.</li></ul><h2 id="Promise-처리"><a href="#Promise-처리" class="headerlink" title="Promise 처리"></a>Promise 처리</h2><p>useEffect와 useState를 사용하여 promise 컴포넌트 또한 재사용이 가능하도록 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const usePromise = (&#123; promise, initialData, arr &#125;) =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState(initialData);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(false);</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    try &#123;</span><br><span class="line">      const result = await promise();</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      setError(true);</span><br><span class="line">    &#125;</span><br><span class="line">    setLoading(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, arr || []);</span><br><span class="line"></span><br><span class="line">  return &#123; data, loading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getNames = async () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt;</span><br><span class="line">    setTimeout(() =&gt; resolve([&#123; name: &quot;kkangil&quot; &#125;, &#123; name: &quot;kkangil2&quot; &#125;]), 1000)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Names = () =&gt; &#123;</span><br><span class="line">  const &#123; data: names, loading, error &#125; = usePromise(&#123;</span><br><span class="line">    promise: getNames,</span><br><span class="line">    initialData: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (loading) return &lt;div&gt;로딩중...&lt;/div&gt;;</span><br><span class="line">  if (error) return &lt;div&gt;에러&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;names.map((row, index) =&gt; (</span><br><span class="line">        &lt;div key=&#123;index&#125;&gt;&#123;row.name&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="usePromise"><a href="#usePromise" class="headerlink" title="usePromise"></a>usePromise</h3><ul><li>파라미터로 호출해야하는 <code>promise</code> 함수, 최초 초기화 데이터 <code>initialData</code>, useEffect 함수 2번째 파라미터 배열 <code>arr</code>을 객체로 받는다.</li><li><code>useEffect</code> 함수에서 async/await을 사용하면 warning이 발생한다. 그렇기 때문에 async/await 함수를 따로 만들어 해당 함수를 useEffect에서 실행 시켜준다.</li></ul><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><ul><li>initialData에 빈배열을 넣어주지 않으면 return의 <code>names.map</code> 에서 에러가 발생한다. 해당 에러를 막기 위해 빈 배열로 초기화해줬다. <code>names</code> 값이 존재할때만 map 을 사용하는 방법도 있지만, 추후 재사용을 위해 데이터 초기값을 설정해줄 수 있도록 했다.</li></ul><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>useContext는 함수형 컴포넌트에서 Context를 쉽게 사용할 수 있게 해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const backgroundColorContext = createContext(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">const Context = () =&gt; &#123;</span><br><span class="line">  const backgroundColor = useContext(backgroundColorContext);</span><br><span class="line">  const style = &#123;</span><br><span class="line">    width: &quot;50px&quot;,</span><br><span class="line">    height: &quot;50px&quot;,</span><br><span class="line">    borderRadius: &quot;50%&quot;,</span><br><span class="line">    background: backgroundColor</span><br><span class="line">  &#125;;</span><br><span class="line">  return &lt;div style=&#123;style&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Context;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useState&quot;&gt;&lt;a href=&quot;#useState&quot; class=&quot;headerlink&quot; title=&quot;useState&quot;&gt;&lt;/a&gt;useState&lt;/h2&gt;&lt;h3 id=&quot;사용방법&quot;&gt;&lt;a href=&quot;#사용방법&quot; class=&quot;headerlink&quot; title=&quot;사용방법&quot;&gt;&lt;/a&gt;사용방법&lt;/h3&gt;&lt;p&gt;useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useState" scheme="https://kkangil.github.io/tags/useState/"/>
    
      <category term="useEffect" scheme="https://kkangil.github.io/tags/useEffect/"/>
    
      <category term="useContext" scheme="https://kkangil.github.io/tags/useContext/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 1. hooks 란?</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-1-hooks-%EB%9E%80/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-1-hooks-란/</id>
    <published>2019-04-19T03:48:12.000Z</published>
    <updated>2019-04-19T03:52:29.003Z</updated>
    
    <content type="html"><![CDATA[<p>리액트 16.8 버전에서 <code>Hooks</code> 라는 새로운 기능이 추가 되었다.<br>해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.<br>이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.</p><a id="more"></a><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-intro.html</a></p><h2 id="Hooks-특징"><a href="#Hooks-특징" class="headerlink" title="Hooks 특징"></a>Hooks 특징</h2><ul><li>현재 진행중인 프로젝트가 있다면 코드를 다시 짜지 않아도, 바로 사용할 수 있다. </li><li>어떠한 변화 없이 기능이 추가 되었기 때문에 이전 버전과의 호환성이 100%이다.</li><li>16.8.0 이후 버전에서 사용가능하다.</li></ul><blockquote><p>Hooks로 class를 대신할 수 있게됐지만, 리액트는 class를 제거할 계획이 없다고 밝혔다. 리액트에 대한 여러가지 컨셉(props, state, context, refs, and lifecycle)을 대체할 수 없는 대신, 더욱 직관적으로 제공한다고 한다.</p></blockquote><h2 id="Hooks가-나오게된-배경"><a href="#Hooks가-나오게된-배경" class="headerlink" title="Hooks가 나오게된 배경"></a>Hooks가 나오게된 배경</h2><h3 id="Component-사이에서-stateful-한-로직의-재사용이-어렵다"><a href="#Component-사이에서-stateful-한-로직의-재사용이-어렵다" class="headerlink" title="Component 사이에서 stateful 한 로직의 재사용이 어렵다."></a>Component 사이에서 stateful 한 로직의 재사용이 어렵다.</h3><ul><li>리액트는 컴포넌트에 재활용하는 방법인 “attach” 방법을 제공하지 않는다.</li><li>이런 문제들을 해결하기 위해 다양한 패턴이 사용되었다. (render propr, HOC …) 이런 패턴을 사용했을 때, 재구조화를 해야하고 이는 번거롭고 어려워질 수 있다. 또한 이런 패턴을 <code>DevTools</code> 에서 확인해 보면 wrapper 지옥에 빠져있는 수많은 컴포넌트를 볼 수 있다.</li><li>Hooks 는 컴포넌트로 부터 stateful 한 로직을 추출해 낼 수 있으며 이것은 의존성과 재사용성을 테스트할 수 있다. </li></ul><h3 id="이해하기-어려운-복잡한-컴포넌트"><a href="#이해하기-어려운-복잡한-컴포넌트" class="headerlink" title="이해하기 어려운 복잡한 컴포넌트"></a>이해하기 어려운 복잡한 컴포넌트</h3><ul><li>처음은 가벼운 컴포넌트였지만, 개발을 진행하다보면 수많은 side effects와 stateful 로직이 걷잡을 수 없이 많아진다.</li><li>각각의 라이프 사이클은 자주 연관성이 없는 로직을 섞어 사용하곤 한다. 예를 들어 컴포넌트는 <code>componentDidMount</code>와 <code>componentDidUpdate</code> 라이프사이클에서 데이터를 fetch 할 수 있다. 하지만 몇몇 <code>componentDidMount</code> 메소드는 이벤트를 설정하는 데 연관 없는 로직 들을 포함할 수 있으며 <code>componentWillUnmount</code>는 cleanup을 수행할 수도 있다. 함께 변경되는 관련 코드는 분리되지만 연관 없는 코드들은 단일 메소드로 결합한다. 이것은 버그와 무결성을 쉽게 발생시킨다.</li><li>많은 경우 컴포넌트들을 작게 만드는 것은 불가능하다. stateful 로직은 모든곳에 있기 때문이다. 또한 이것은 테스트하는 것도 어렵다. 이것이 사람들이 state 를 관리하는 라이브러리를 함께 사용하는것을 선호하는 이유중 하나이다. 그러나 너무 추상적이라고 소개하고 다른 파일 사이를 건너뛰는것을 요구하며 컴포넌트 재사용을 더욱 어렵게 만든다.</li><li>이러한 이슈들을 해결하기 위해 Hooks는 라이프사이클 메소드를 기초로한 분리에 초점을 맞추는 것보다는 컴포넌트들을 연관성을 기초로 더 작은 함수로 분리할 수 있게 한다.</li></ul><h3 id="사람과-기계를-혼란시키는-Classes"><a href="#사람과-기계를-혼란시키는-Classes" class="headerlink" title="사람과 기계를 혼란시키는 Classes"></a>사람과 기계를 혼란시키는 Classes</h3><ul><li>코드를 재사용성과 구조적으로 만드는 것은 어려울뿐만 아니라 리액트를 배울때 classes는 큰 진입장벽이다. 다른 대부분의 언어들과는 다른 Javascript가 어떻게 동작하는지 이해하고 있어야한다. 이벤트 핸들러는 항상 바인딩이 되어야 하는것을 기억해야 한다. 안정적인 문법의 제안이 없다면, 코드는 매우 장황해진다.</li><li>사람들은 props, state, 단방향 데이터 흐름에 대해 이해하고 있지만 여전히 classes는 어려워한다.</li><li>이러한 문제를 해결하기 위해서 Hooks는 classes 없이 리액트의 특징들을 사용할 수 있게 해준다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;리액트 16.8 버전에서 &lt;code&gt;Hooks&lt;/code&gt; 라는 새로운 기능이 추가 되었다.&lt;br&gt;해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.&lt;br&gt;이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 정의" scheme="https://kkangil.github.io/tags/hooks-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>Next.js with pm2 ecosystem</title>
    <link href="https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/"/>
    <id>https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/</id>
    <published>2019-04-17T15:29:19.000Z</published>
    <updated>2019-04-17T15:47:37.770Z</updated>
    
    <content type="html"><![CDATA[<p><code>Next.js</code>는 Client-Side-Rendering 을 사용하는 react가 아닌 <code>SSR(Server-Side-Rendering)</code> 방식을 사용하는 react framework 이다.<br>해당 글은 <code>Next.js</code>에서 배포시 참고하면 좋을 내용으로 <code>Next.js</code>가 뿐만 아니라 react, Node 에서도 사용 가능하다.</p><a id="more"></a><h2 id="pm2-ecosystem"><a href="#pm2-ecosystem" class="headerlink" title="pm2 ecosystem"></a>pm2 ecosystem</h2><p>pm2 ecosystem이란, 실행할 인스턴스의 설정을 JSON 형식으로 관리할 수 있고, pm2 에서 제공해 주는 option 을 보다 쉽게 관리 할수 있도록 도와준다. pm2 명령어로 직접 실행시킬 수 있지만, ecosystem을 사용함으로써 어떤 서버나 환경에서도 같은 설정을 사용해서 서버를 실행할 수 있다는 점이 장점이다.</p><ol><li>ecosystem.config.js 를 최상위 폴더에 생성한다.</li><li>작성방법</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  apps: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;chungeoram&quot;,</span><br><span class="line">      script: &quot;./server.js&quot;,</span><br><span class="line">      watch: true,</span><br><span class="line">      interpreter: &apos;/home/ubuntu/.nvm/versions/node/v8.11.3/bin/node&apos;,</span><br><span class="line">      &quot;env_public-develop&quot;: &#123;</span><br><span class="line">        NODE_ENV: &quot;public-develop&quot;,</span><br><span class="line">        PORT: 1111,</span><br><span class="line">        API_END_POINT: &apos;http://endpoint/api&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      env_production: &#123;</span><br><span class="line">        NODE_ENV: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name: pm2 에서 관리하는 이름</li><li>script: 앱을 구동할 경로</li><li>watch: 파일이 변경되면 자동으로 재시작 유무</li><li>ignore_watch: 배열안에 있는 리스트는 watch 대상에서 무시한다.</li><li>exec_mode: 클러스터 모드로 구동instances: 클러스터로 구동될시 몇개까지 구동할것인지 선택(0 : cpu갯수)</li><li>merge_logs: 클러스터로 구동할시 로그를 한파일에 기록</li><li>interpreter: 해석기 절대 경로(default: node)</li><li>log_date_format: 로그에 출력될 날짜와 시간값의 형식</li><li>error_file: 에러 파일 위치</li><li>out_file: 기본 출력 로그 위치</li><li>env_{value}<ul><li>value는 <code>process.env.NODE_ENV</code> 값과 매칭된다. 예를 들어 현재 <code>process.env.NODE_ENV</code>가 <code>public-develop</code> 일때, <code>env_public-develop</code> 내부의 값이 사용된다. 내부의 값들은 <code>process.env</code> 객체 내로 값이 할당되며, <code>process.env.PORT</code> , <code>process.env.API_END_POINT</code> 로 값을 배포 환경의 따라 다르게 사용가능하다.</li></ul></li></ul><ol start="3"><li>pm2 구동방법<br>package.json script에 명령어를 추가해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;pm2 start ecosystem.config.js --env production&quot;,</span><br><span class="line">    &quot;start-public&quot;: &quot;pm2 start ecosystem.config.js --env public-develop&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon server.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>$ yarn build → $ yarn start</li><li>app 빌드 후 명령어를 사용해서, pm2를 구동시켜 준다. pm2 start {파일이름} –env {value} 와 같은 형식으로 명령어를 추가한다. 여기서 환경변수는 ecosystem.config.js 의 env_{value}와 매칭 된다.</li></ul><h2 id="Next-js-에서-process-env-변수-사용-주의사항"><a href="#Next-js-에서-process-env-변수-사용-주의사항" class="headerlink" title="Next.js 에서 process.env 변수 사용 주의사항"></a>Next.js 에서 process.env 변수 사용 주의사항</h2><p><code>Next.config.js</code> 에서 <code>sass</code>, <code>webpack</code> 등의 처리 후 export 하는 과정에서, process.env 객체가 비어있는 문제를 발견했다. 하지만, api.js config.js 등 환경 변수에 따라 값을 변경해줘야 하기 때문에 process.env 객체가 비어있으면 안된다. 해당 문제를 처리하기 위해 Next.js 에서 <code>publicRuntimeConfig</code> 라는 옵션을 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const withSass = require(&apos;@zeit/next-sass&apos;)</span><br><span class="line">const withCSS = require(&apos;@zeit/next-css&apos;)</span><br><span class="line"></span><br><span class="line">const publicRuntimeConfig = &#123;</span><br><span class="line">  API_END_POINT: process.env.API_END_POINT,</span><br><span class="line">  NODE_ENV: process.env.NODE_ENV,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = withCSS(withSass(&#123;</span><br><span class="line">  publicRuntimeConfig,</span><br><span class="line">  webpack: config =&gt; &#123;</span><br><span class="line">    // Fixes npm packages that depend on `fs` module</span><br><span class="line">    config.node = &#123;</span><br><span class="line">      fs: &apos;empty&apos;,</span><br><span class="line">      module: &apos;empty&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>필요한 process.env 의 값을 <code>publicRuntimeConfig</code> 객체에 담아주고 Next.js 의 옵션 값에 할당해준다.할당해 주게되면, Next.js 의 config 값으로 저장되게 된다.이후 Next.js의 config 값을 불러오는 함수를 추가해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import getConfig from &apos;next/config&apos;;</span><br><span class="line"></span><br><span class="line">export const getNodeEnv = () =&gt; &#123;</span><br><span class="line">  const &#123; publicRuntimeConfig &#125; = getConfig();</span><br><span class="line"></span><br><span class="line">  const realNodeEnv = publicRuntimeConfig.NODE_ENV || process.env.NODE_ENV;</span><br><span class="line">  const apiEndPoint = publicRuntimeConfig.API_END_POINT;</span><br><span class="line"></span><br><span class="line">  return &#123; realNodeEnv, apiEndPoint &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>해당 함수는 Next.js의 config에서 publicRuntimeConfig 를 가져와 return 해준다.이제 process.env 환경변수를 사용하고 싶다면, process.env.API_END_POINT 와 같이 직접적으로 사용하는것이 아닌, 해당 함수를 사용해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import config from &apos;./config&apos;</span><br><span class="line">import &#123; getNodeEnv &#125; from &apos;@/utils/env&apos;</span><br><span class="line"></span><br><span class="line">const env = getNodeEnv()</span><br><span class="line">const endPoint = env.apiEndPoint || config.apiEndPoint</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  AUTH_TOKEN: &#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    path: () =&gt; `$&#123;endPoint&#125;/auth/authenticate-token`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Next.js&lt;/code&gt;는 Client-Side-Rendering 을 사용하는 react가 아닌 &lt;code&gt;SSR(Server-Side-Rendering)&lt;/code&gt; 방식을 사용하는 react framework 이다.&lt;br&gt;해당 글은 &lt;code&gt;Next.js&lt;/code&gt;에서 배포시 참고하면 좋을 내용으로 &lt;code&gt;Next.js&lt;/code&gt;가 뿐만 아니라 react, Node 에서도 사용 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="Deploy" scheme="https://kkangil.github.io/categories/Deploy/"/>
    
    
      <category term="Next.js" scheme="https://kkangil.github.io/tags/Next-js/"/>
    
      <category term="deploy Next.js" scheme="https://kkangil.github.io/tags/deploy-Next-js/"/>
    
      <category term="pm2" scheme="https://kkangil.github.io/tags/pm2/"/>
    
      <category term="pm2-ecosystem" scheme="https://kkangil.github.io/tags/pm2-ecosystem/"/>
    
  </entry>
  
  <entry>
    <title>Deep clone</title>
    <link href="https://kkangil.github.io/2019/04/18/Deep-clone/"/>
    <id>https://kkangil.github.io/2019/04/18/Deep-clone/</id>
    <published>2019-04-17T15:01:31.000Z</published>
    <updated>2019-04-17T15:35:10.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a>이슈</h2><ol><li>react에서 setState를 하지 않았음에도 state가 변경되는 현상</li><li>api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상</li></ol><p>react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.<br>해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.<br>해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; a: 1, b: 2 &#125;</span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state = &#123;...this.state&#125;;</span><br><span class="line">  state[e.target.name] = e.target.value;</span><br><span class="line">  this.setState(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 본인이 input 의 onChange 이벤트 함수로 거의 복붙하면서 변형없이 사용하는 이벤트 함수이다.<br>최근 state 변수 선언 즉, state 객체를 복사하고 사용하는 과정에 있어 동일한 이슈가 많이 발생하고 있어, 해당 함수를 단순히 복사하는것이 아닌 이해가 필요하고 상황에 따라 변형해서 사용해야할 필요있다.</p><h2 id="Object-copy"><a href="#Object-copy" class="headerlink" title="Object copy"></a>Object copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;...this.state&#125;</span><br></pre></td></tr></table></figure><p>state 변수는 react state 객체를 복사한것이다. 해당 문법은 es9 문법으로 특정 값만 바꿀때 유용하다.<br>해당 문법의 es5 버전은 .assign() 메소드이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;&#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object3 = Object.assign(&#123; c: 3 &#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object4 = Object.assign(&#123;&#125;, object1);</span><br><span class="line">object4.a = 100</span><br><span class="line"></span><br><span class="line">const object5 = &#123;...object1&#125;</span><br><span class="line">object5.a = 100</span><br><span class="line"></span><br><span class="line">console.log(object2.a); //100</span><br><span class="line">console.log(object2.b); //2</span><br><span class="line">console.log(object3.a); //100</span><br><span class="line">console.log(object3.b); //2</span><br><span class="line">console.log(object3.c); //3</span><br><span class="line">console.log(object4.a); //100</span><br><span class="line">console.log(object5.a); //100</span><br></pre></td></tr></table></figure><ul><li>object2 : 빈 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object3: c: 3 값이 담겨있는 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object4: 현재 우리 회사에서 사용하는 handleChange를 es5로 바꾼 방법</li><li>object5: Spread syntax(…) es8 문법사용<br>하지만 state 내부에 객체를 변경하려고 할때 문제가 발생한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state &#123;...this.state&#125;</span><br><span class="line">  state.b.c = 3</span><br><span class="line">  this.setState(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2단계 이상 깊이의 object는 복사가 원활하지 않는것을 확인할 수 있다. 복사본의 값을 변경했는데 원본의 값도 변경되는 알수 없는 현상이 발생한다.<br>MDN: 깊은 클로닝에 대해서, Object.assign() 은 속성의 값을 복사하기때문에 다른 대안을 사용해야합니다. 출처 값이 객체에 대한 참조인 경우, 참조 값만을 복사합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(&#123;&#125;, org);</span><br><span class="line">obj.a.b = 100; </span><br><span class="line">console.log(obj.a.b);  //expected: 2 but actual: 100</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;...org&#125;;</span><br><span class="line">obj2.a.b = 100; </span><br><span class="line">console.log(org.a.b);  //expected: 2 but actual: 100</span><br></pre></td></tr></table></figure><p>해당 현상은 깊은 클로닝(deep cloning) 방식을 사용해야한다.<br>객체 복사 방식 변경 : 객체를 string 으로 변경하고 다시 파싱해주는 방법</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = JSON.parse(JSON.stringify(org)); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br><span class="line">lodash 메소드 사용</span><br><span class="line">import _ from &apos;lodash&apos;; const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = _.cloneDeep(org); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br></pre></td></tr></table></figure><h2 id="Array-copy"><a href="#Array-copy" class="headerlink" title="Array copy"></a>Array copy</h2><p>2단계 이상 깊이의 배열을 복사할때는 맵을 사용해서 객체 하나하나 복사해준 후 return 해주는 방식을 사용해서 에러발생을 막아야합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    a: [&#123;</span><br><span class="line">      b: 1</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">      b: 2</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj1 = &#123;...org&#125;</span><br><span class="line">const arr = org.obj.a // x</span><br><span class="line"></span><br><span class="line">const arr2 = org.obj.a.map(row =&gt; &#123;</span><br><span class="line">return &#123;...row&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>참고<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;이슈&quot;&gt;&lt;a href=&quot;#이슈&quot; class=&quot;headerlink&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;이슈&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;react에서 setState를 하지 않았음에도 state가 변경되는 현상&lt;/li&gt;
&lt;li&gt;api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.&lt;br&gt;해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.&lt;br&gt;해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://kkangil.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://kkangil.github.io/tags/Javascript/"/>
    
      <category term="syntax" scheme="https://kkangil.github.io/tags/syntax/"/>
    
      <category term="deep-clone" scheme="https://kkangil.github.io/tags/deep-clone/"/>
    
  </entry>
  
  <entry>
    <title>리액트 라이프사이클</title>
    <link href="https://kkangil.github.io/2019/04/17/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/"/>
    <id>https://kkangil.github.io/2019/04/17/리액트-라이프사이클/</id>
    <published>2019-04-17T14:48:33.000Z</published>
    <updated>2019-04-17T15:34:52.842Z</updated>
    
    <content type="html"><![CDATA[<p>React를 사용하기 전 <code>라이프사이클</code>에 대해 확실하게 알고 사용하는 것이 좋다.<br><code>라이프사이클</code> 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.<br>github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.<a href="https://github.com/kkangil/react-lifecycle" target="_blank" rel="noopener">code 보기</a></p><a id="more"></a><h2 id="주요-라이프사이클"><a href="#주요-라이프사이클" class="headerlink" title="주요 라이프사이클"></a>주요 라이프사이클</h2><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><ul><li>렌더가 된 이후 실행되는 라이프사이클로 최초 API 요청 사용에 적합한 라이프 사이클</li></ul><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><ul><li>component 의 상태값이 변경되었을때 render 직전에 호출되는 라이프 사이클</li><li>Boolean 값을 return 해야하며, false 를 return 하면 렌더를 하지 않음.</li><li>렌더를 하지 않으므로 이후 라이프사이클도 먹히지 않음.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><ul><li>component가 DOM 에서 삭제(해당 컴포넌트 미표시)할때 마지막으로 실행되는 메소드</li><li>interval 이나 비동기 API 제거에 주로 쓰임.</li></ul><h2 id="16-3-이후-변경된-라이프사이클"><a href="#16-3-이후-변경된-라이프사이클" class="headerlink" title="16.3 이후 변경된 라이프사이클"></a>16.3 이후 변경된 라이프사이클</h2><ul><li>렌더링 제어에 많은 방법이 있기때문에 라이프사이클 사용에 혼란이 생김.</li><li>실제 커뮤니티에서도 어떤 라이프사이클이 좋다 안좋다 성능 이슈가 많음. 대표적으로 componentWillMount 와 componentDidMount 둘중 어떤 라이프사이클에서 API를 호출해야하는지.</li><li>향후 componentWillMount, componentWillReceiveProps, componentWillUpdate 라이프사이클이 삭제되고 <code>UNSAFE_</code> 라이프사이클만 동작할것이라고 예고</li><li>이를 대체하기 위해 새로운 라이프사이클 추가</li></ul><h3 id="라이프사이클-동작-순서"><a href="#라이프사이클-동작-순서" class="headerlink" title="라이프사이클 동작 순서"></a>라이프사이클 동작 순서</h3><ul><li>최초 진입: <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code> 순으로 실행.</li><li>props 변경: <code>getDerivedStateFromProps</code> -&gt; <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li><li>state 변경: <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li></ul><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><ul><li>componentDidMount 보다 먼저 실행</li><li>window 객체 접근 가능(storage 사용 가능)</li><li>props 와 state가 변경되었을때는 최초 실행</li><li>파리미터로 변경될 props 와 state가 넘어옴. this.state 접근 불가능</li><li>return 되는 객체값으로 state 가 변경된다. (해당 라이프사이클에서는 state 변경만 해주는것이 바람직하다고 판단됨.) state를 변경해주고 싶지 않을때에는 null 을 return 해주면된다.</li><li>최초 페이지 진입시 <code>componentDidMount</code> 라이프사이클에서 fetch 실행</li><li>react 공식문서에서는 props 가 변경되었을때 fetch가 필요하다면 해당 라이프사이클에서 API(data fetching) 요청 하는것이 아닌 <code>componentDidUpdate</code> 라이프 사이클에서 fetch 하도록 유도하고 있음.</li></ul><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><ul><li><code>componentWillUpdate</code> 의 대체 라이프사이클</li><li>DOM이 업데이트 되기 직전이 실행</li><li><code>componentDidUpdate</code> 전에 실행되며 해당 라이프사이클의 return 값이 componentDidUpdate 3번째 파라미터로 전달됨.</li><li>기존 <code>componentWillUpdate</code> 와 같이 해당 라이프사이클 안에서 this.setState()를 사용하는 경우 무한루프에 빠지게 됨.</li><li>자주 사용되지는 않을것으로 판단됨.</li></ul><h2 id="Error-Boundary"><a href="#Error-Boundary" class="headerlink" title="Error Boundary"></a>Error Boundary</h2><ul><li>렌더 과정에서 에러가 생겼을경우 앱이 죽는것이 아니라 UI 변경과 같은 대안으로 앱이 죽지 않도록 하는 방식</li><li>해당 class를 최상단에 두고 라이프사이클을 이용해서 조작할 수 있다.</li></ul><h3 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError"></a>getDerivedStateFromError</h3><ul><li>16.6 버전에 추가된 라이프 사이클</li><li>해당 라이프 사이클은 렌더 중에 호출되며 fallback UI를 렌더링 하기 위한 메소드이다.</li><li>렌더 중에 호출되기 때문에 side effect(API call, 함수 호출) 을 사용하지 않는것이 좋다.</li><li>react 공식 문서에서는 componentDidCatch 라이프 사이클을 추천한다.</li><li>return 객체는 state 가 해당 객체로 변경된다.</li></ul><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><ul><li>해당 라이프사이클은 에러를 기록하거나 트래킹하기 위한 작업을 위해 주로 사용된다. (ex Sentry)</li><li>해당 라이프 사이클에서도 state 를 변경하여 UI 를 변경해줄수 있지만 추천되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React를 사용하기 전 &lt;code&gt;라이프사이클&lt;/code&gt;에 대해 확실하게 알고 사용하는 것이 좋다.&lt;br&gt;&lt;code&gt;라이프사이클&lt;/code&gt; 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.&lt;br&gt;github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.&lt;a href=&quot;https://github.com/kkangil/react-lifecycle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code 보기&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://kkangil.github.io/tags/React/"/>
    
      <category term="lifecycle" scheme="https://kkangil.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kkangil.github.io/2019/04/17/hello-world/"/>
    <id>https://kkangil.github.io/2019/04/17/hello-world/</id>
    <published>2019-04-17T11:51:34.545Z</published>
    <updated>2019-04-17T15:35:24.643Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><table><thead><tr><th>설정</th><th>설명</th><th>기본 값</th></tr></thead><tbody><tr><td>layout</td><td>레이아웃</td><td></td></tr><tr><td>title</td><td>타이틀</td><td></td></tr><tr><td>date</td><td>발행일</td><td>파일이 생성된 날짜</td></tr><tr><td>updated</td><td>갱신일</td><td>파일이 업로드된 날짜</td></tr><tr><td>tags</td><td>태그 (page에서는 사용 불가능)</td><td></td></tr><tr><td>categories</td><td>카테고리 (page에서는 사용 불가능)</td><td></td></tr><tr><td>permalink</td><td>포스트의 기본 permalink를 override합니다.</td><td></td></tr><tr><td>comments</td><td>포스트에서 comment 기능을 사용할지 여부</td><td>true</td></tr></tbody></table><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://kkangil.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://kkangil.github.io/tags/hexo/"/>
    
      <category term="hexo 시작" scheme="https://kkangil.github.io/tags/hexo-%EC%8B%9C%EC%9E%91/"/>
    
  </entry>
  
</feed>
