<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkangil&#39;s Blog</title>
  
  <subtitle>kkangil&#39;s develop Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkangil.github.io/"/>
  <updated>2019-10-13T09:38:15.848Z</updated>
  <id>https://kkangil.github.io/</id>
  
  <author>
    <name>kkangil</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>함수형 자바스크립트를 위한 기초</title>
    <link href="https://kkangil.github.io/2019/10/13/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88/"/>
    <id>https://kkangil.github.io/2019/10/13/함수형-자바스크립트를-위한-기초/</id>
    <published>2019-10-13T06:52:02.000Z</published>
    <updated>2019-10-13T09:38:15.848Z</updated>
    
    <content type="html"><![CDATA[<p>함수형 자바스크립트를 잘 익히기 위해서는 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데 이를테면 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드 등이 있다.</p><a id="more"></a><h2 id="일급-함수"><a href="#일급-함수" class="headerlink" title="일급 함수"></a>일급 함수</h2><p>자바스크립트에서 함수는 일급 객체이자 일급 함수다. 자바스크립트에서 객체는 일급 객체다. 여기서 <code>일급</code>은 값으로 다룰 수 있다는 의미로, 아래와 같은 조건을 만족해야 한다.</p><ul><li>변수에 담을 수 있다.</li><li>함수나 메서드의 인자로 넘길 수 있다.</li><li>함수나 메서드에서 리턴할 수 있다.</li></ul><p>자바스크립트에서 모든 값은 일급이다. 자바스크립트에서 모든 객체는 일급 객체이며 함수도 객체이자 일급 객체다.<br>일급 함수는 아래와 같은 추가적인 조건을 더 만족한다.</p><ul><li>아무 때나(런타임에서도) 선언이 가능하다.</li><li>익명으로 선언할 수 있다.</li><li>익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123; &#125;</span><br><span class="line">var a = typeof f1 === &apos;function&apos; ? f1 : function () &#123; &#125;;</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line">  return function () &#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function (a, b) &#123; return a + b; &#125;)(10, 5);</span><br><span class="line"></span><br><span class="line">function callAndAdd(a, b) &#123;</span><br><span class="line">  return a() + b();</span><br><span class="line">&#125;</span><br><span class="line">callAndAdd(function () &#123; return 10; &#125;, function () &#123; return 5; &#125;)</span><br></pre></td></tr></table></figure><ul><li>f1은 함수를 값으로 다룰 수 있음을 보여준다.</li><li>f2는 함수를 리턴한다.</li><li>a와 b를 더하는 익명 함수를 선언하였으며, a와 b에 각각 10, 5를 전달하여 즉시 실행했다.</li><li>callAndAdd를 실행하면서 익명 함수들을 선언했고 바로 인자로 사용되었다. callAndAdd는 넘겨받은 함수 둘을 실행하여 결과들을 더한다.</li></ul><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p>스코프에 대한 개념을 잘 알고 있다면 이 글을 읽는 데 더욱 도움이 될 것 이다. 스코프란 변수를 어디에서 어떻게 찾을지를 정한 규칙으로, 여기에서 다루는 스코프는 함수 단위의 변수 참조에 대한 것이다.<br>함수는 변수 참조 범위를 결정하는 중요한 기준이다. 함수가 중첩되어 있다면 스코프들 역시 중첩되어 생겨난다.</p><p><i>클로저는 자신이 생성될 때의 환경을 기억하는 함수다.</i></p><p>이 말을 보다 실용적으로 표현해 보면 <strong>클로저는 자신의 상위 스코프의 변수를 참조할 수 있다</strong>고 할 수 있다.</p><p><i>클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다.</i></p><p>자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다. 자바스크립트의 모든 함수는 상위 스코프를 가지며 모든 함수는 자신이 정의되는 순간(정의되는 곳)의 실행 컨텍스트 안에 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">  var a = 5;</span><br><span class="line">  function myfn() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parent2() &#123;</span><br><span class="line">  var a = 5;</span><br><span class="line">  function parent1() &#123;</span><br><span class="line">    function myfn() &#123;</span><br><span class="line">      console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parent와 parent2의 myfn에서는 a라는 변수를 선언하지 않았지만 사용하고 있다. parent의 변수 a는 myfn을 생성하는 스코프에서 정의되었고 parent2의 변수 a는 myfn을 생성하는 스코프의 상위 스코프에 정의되었다.</p><p>위와 같은 조건을 충족시키지 않는다면 그 함수가 아무리 함수 안에서 선언되었다고 하더라도 일반 함수와 전혀 다를 바가 없다. 클로저가 기억할 환경이라는 것은 외부의 변수들밖에 없기 때문이다. 또한 자신의 상위 스코프에서 알 수 있는 변수를 자신이 사용하고 있지 않다면 그 환경을 기억해야 할 필요가 없다.<br>글로벌 스코프를 제외한 외부 스코프에 있었던 변수 중 클로저 혹은 다른 누군가가 참조하고 있지 않는 모든 변수는 실행 컨텍스트가 끝난 후 가비지 컬렉션 대상이 된다. 어떤 함수가 외부 스코프의 변수를 사용하지 않았고, 그래서 외부 스코프의 환경이 가비지 컬렉션 대상이 된다면 그렇게 내비려 두는 함수를 클로저라고 보기 어렵다.</p><p><i>클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.</i></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = 20;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f1은 클로저처럼 외부 변수를 참조하여 결과를 만든다. 게다가 상위 스코프의 변수를 사용하고 있으므로 앞서 강조했던 조건을 모두 충족시키고 있다. 그런데 왜 클로저가 아닐까?<br>글로벌 스코프에서 선언된 모든 변수는 그 변수를 사용하는 함수가 있는지 없는지와 관계없이 유지된다. a와 b 변수가 f1에 의해 사라지지 못하는 상황이 아니므로 f1은 클로저가 아니다.<br>그렇다면 클로저는 ‘함수 안에서 함수가 생성될 때’만 생성된다고 할 수 있을까? 그렇지 않다. 웹 브라우저에서는 함수 내부가 아니라면 모두 글로벌 스코프지만, 요즘 자바스크립트에서는 함수 내부가 아니면서 글로벌 스코프도 아닌 경우가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f2() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = 20;</span><br><span class="line">  function f3(c, d) &#123;</span><br><span class="line">    return c + d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f4 = f2();</span><br><span class="line">console.log(f4(5, 7));</span><br></pre></td></tr></table></figure><p>위 코드에서는 클로저가 있을까? 특히 f3처럼 함수 안에서 함수를 리턴하면 클로저처럼 보인다. 하지만 이 코드의 f4에 담긴 f3도 클로저가 아니다. f3은 f2 안에서 생성되었고 f3 바로 위에는 a, b라는 지역 변수도 있다. 하지만 f3 안에서 사용하고 있는 변수는 c,d이고 두 변수는 모두 f3에서 정의되었다. 자신이 생성될 때의 스코프가 알고 있는 변수 a, b는 사용하지 않았다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 자신이 스스로 정의한 c, d는 f3이 실행되고 나면 없어진다. 다시 실행되면 c, d를 다시 생성하고 리턴 후에 변수는 사라진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f4() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = 20;</span><br><span class="line">  function f5() &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f4());</span><br></pre></td></tr></table></figure><p>그렇다면 위 코드에서는 클로저가 있을까? 정확한 표현은 <code>있었다</code>이다. 결과적으로는 클로저는 없다고 볼 수 있다. f4가 실행되고 a, b가 할당된 후 f5가 정의된다. 그리고 f5에서는 a, b가 사용되고 있으므로 f5는 자신이 생성된 환경을 기억하는 클로저가 된다. 그런데 f4의 마지막 라인을 보면 f5를 실행하여 리턴한다. 결국 f5를 참조하고 있는 곳이 어디에도 없기 때문에 f5는 사라지고, f5가 사라지면 a, b도 결국 사라질 수 있기에 클로저는 f4가 실행되는 사이에만 생겼다가 사라진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f6() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  function f7(b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f8 = f6();</span><br><span class="line">console.log(f8(20));</span><br><span class="line">console.log(f8(10));</span><br></pre></td></tr></table></figure><p>드디어 클로저 코드를 사용했다. f7은 진짜 클로저다. 이제 a는 사라지지 않는다. f7이 a를 사용하기에 a를 기억해야 하고 f7이 f8에 담겼기 때문에 클로저가 되었다. 원래대로라면 f6의 지역 변수는 모두 사라져야 하지만 f6 실행이 끝났어도 f7이 a를 기억하는 클로저가 되었기 때문에 a는 사라지지 않으며, f8을 실행할 때마다 새로운 변수인 b와 함께 사용되어 결과를 만든다.</p><p>혹시 위 상황에 메모리 누수가 있다고 볼 수 있을까? 그렇지 않다. 메모리가 해제되지 않는 것과 메모리 누수는 다르다. 메모리 누수는 메모리가 해제되지 않을 때 일어나는 것은 맞지만, 위 상황을 메모리 누수라고 할 수는 없다. a는 한 번 생겨날 뿐, 계속해서 생겨나거나 하지 않는다. 메모리 누수란 개발자가 의도하지 않았는데 메모리가 해제되지 않고 계속 남는 것을 말하며, 메모리 누수가 지속적으로 반복될 때는 치명적인 문제를 만든다. f8이 아무리 많이 실행되더라도 이미 할당된 a가 그대로 유지되기 때문에 메모리 누수는 일어나지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f9() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var f10 = function (c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line">  var b = 20;</span><br><span class="line">  return f10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f11 = f9();</span><br><span class="line">console.log(f11(30));</span><br></pre></td></tr></table></figure><p>위 코드는 에러없이 정상 동작한다. 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수라고 했었는데, 여기서 ‘때’는 생각하는 것보다 조금 길다고 했었다.<br>f10에는 익명 함수를 담았다. f10이 생성되기 딱 이전 시점에는 b가 20으로 초기화되지 않았다. 클로저는 자신이 생성되는 스코프의 모든 라인, 어느곳에서 선언된 변수든지 참조하고 기억할 수 있다. 그리고 그것은 변수이기에 클로저가 생성된 이후 언제라도 그 값은 변경될 수 있다.</p><p>클로저는 자바스크립트에서 절차지향 프로그래밍, 객체지향 프로그래밍, 함수형 프로그매일 모두를 지탱하는 매우 중요한 기능이자 개념이다. 분명 클로저는 메모리 누수 같은 위험성을 가지고 있다. 그러나 메모리 누수나 성능 저하의 문제는 클로저의 단점이나 문제가 아니다.</p><h2 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h2><p>고차 함수란, 함수를 다루는 함수를 말한다.</p><ol><li>함수를 인자를 받아 대신 실행하는 함수</li><li>함수를 리턴하는 함수</li><li>함수를 인자를 받아서 또 다른 함수를 리턴하는 함수</li></ol><p>고차 함수을 시작하기전 정의를 보고 클로저와의 차이점이 궁금해져 검색해봤다. </p><blockquote><p><i>“Closures are also functions. But when a function captures state upon its creation, we call it a closure.”</i><br>즉, 클로저 역시 함수지만, 함수가 생성될 때 state를 점유하고 있다면 우리는 그것을 클로저라고 합니다.</p></blockquote><p>출처: <a href="https://azsha.tistory.com/100" target="_blank" rel="noopener">https://azsha.tistory.com/100</a> [Azsha’s Forge]</p><p>사실상 함수형 프로그래밍의 절반은 고차 함수를 적극적으로 활용하는 프로그래밍이라고도 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function callWith10(val, func) &#123;</span><br><span class="line">  return func(10, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(callWith10(20, add));</span><br><span class="line">console.log(callWith10(5, sub));</span><br></pre></td></tr></table></figure><p>여기서 add와 sub는 일반 함수다. 함수를 인자로 받거나 함수를 리턴하지 않기 때문이다. callWith10은 고차 함수다. 함수를 받아 내부에서 대신 실행하기 때문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function constant(val) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var always10 = constant(10);</span><br><span class="line">console.log(always10()); // 10</span><br><span class="line">console.log(always10()); // 10</span><br><span class="line">console.log(always10()); // 10</span><br></pre></td></tr></table></figure><p>constant 함수는 실행 당시 받았던 10이라는 값을 받아 내부에서 익명 함수를 클로저로 만들어 val를 기억하게 만든 수 리턴한다. 리턴된 함수에는 always10 이라는 이름을 지어주었다. always10을 실행하면 항상 10을 리턴한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function callWith(val1) &#123;</span><br><span class="line">  return function (val2, func) &#123;</span><br><span class="line">    return func(val1, val2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var callWith10 = callWith(10);</span><br><span class="line">console.log(callWith10(20, add)); // 30</span><br><span class="line"></span><br><span class="line">var callWith5 = callWith(5);</span><br><span class="line">console.log(callWith5(5, sub)); // 0</span><br></pre></td></tr></table></figure><p>callWith는 함수를 리턴하는 함수다. val1을 받아서 val1을 기억하는 함수를 리턴했다. 리턴된 함수는 이후에 val2와 func를 받아 대신 func를 실행해 준다. 함수를 리턴하는 함수를 사옹할 경우 다음처럼 변수에 담지 않고 바로 실행해도 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(callWith(30)(20, add));</span><br><span class="line">console.log(callWith(5)(5, sub));</span><br></pre></td></tr></table></figure><p>인자는 숫가자 아닌 값도 활용이 가능하다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_.get = function (list, index) &#123;</span><br><span class="line">  return list[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users = [</span><br><span class="line">  &#123; id: 2, name: &quot;HA&quot;, age: 25 &#125;,</span><br><span class="line">  &#123; id: 4, name: &quot;PJ&quot;, age: 28 &#125;,</span><br><span class="line">  &#123; id: 5, name: &quot;JE&quot;, age: 27 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var callWithUsers = callWith(users);</span><br><span class="line">console.log(callWithUsers(2, _.get));</span><br></pre></td></tr></table></figure></p><h2 id="콜백-함수라-잘못-불리는-보조-함수"><a href="#콜백-함수라-잘못-불리는-보조-함수" class="headerlink" title="콜백 함수라 잘못 불리는 보조 함수"></a>콜백 함수라 잘못 불리는 보조 함수</h2><p>콜백 함수를 받아 자신이 해야 할 일을 모두 끝낸 후 결과를 되돌려 주는 함수도 고차 함수다. 보통은 비동기가 일어나는 상황에서 사용되며 콜백 함수를 통해 다시 원래 위치로 돌아오기 위해 사용되는 패턴이다. 콜백 패턴은 클로저 등과 함께 사용할 수 있는 매우 강력한 표현이자 비동기 프로그래밍에 있어 없어서는 안 될 매우 중요한 패턴이다. 콜백 패턴은 끝이 나면 컨텍스트를 다시 돌려주는 단순한 협업 로직을 가진다.</p><p>button.click(function() {})과 같은 코드의 익명 함수도 콜백 함수라고 표현되는 것을 많이 보았지만, 이 익명 함수는 ‘이벤트 리스너’라고 칭하는 것이 적합하다. 함수가 고차 함수에서 쓰이는 역할의 이름으로 불러주면 된다. _.each([1,2,3], function() {})에서의 익명 함수는 callback이 아니라 <code>iteratee</code>이며 _.filter(users, function() {})에서의 익명 함수는 <code>predicate</code>다. callback은 종료가 되었을 때 단 한 번 실행되지만 <code>iteratee</code>나 <code>predicate</code>, <code>listener</code>등은 종료될 때 실행되지 않으며 상황에 따라 여러 번 실행되기도 하고 각각 다른 역할을 한다.</p><h2 id="함수를-리턴하는-함수와-부분-적용"><a href="#함수를-리턴하는-함수와-부분-적용" class="headerlink" title="함수를 리턴하는 함수와 부분 적용"></a>함수를 리턴하는 함수와 부분 적용</h2><p>앞서 곳곳에서 미리 필요한 인자를 넘겨 두고 그 인자를 기억하는 클로저를 리턴하는 함수들을 확인했다. 클로저로 만들어진 함수가 추가적으로 인자를 받아 로직을 완성해 나가는 패턴을 갖는다. 이와 유사한 기법들로 bind, curry, partial 등이 있다. 이런 기법들을 통틀어 칭하는 특별한 용어는 없지만 다음과 같은 공통점을 갖는다.</p><p><i>기억하는 인자 혹은 변수가 있는 클로저를 리턴한다.</i></p><p>bind는 this와 인자들이 부분적으로 적용된 함수를 리턴한다. bind의 경우 인자보다는 주로 함수 안에서 사용될 this를 적용해 두는데 많이 사용한다. 그 이유는 아마 this 적용을 스킵할 수 없다는 점과 인자의 부분 적용을 왼쪽에서 부터 순서대로 할 수 있는 점 때문일 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add10 = add.bind(null, 10);</span><br><span class="line">console.log(add10(20)); // 30</span><br></pre></td></tr></table></figure><p>bind는 첫 번째 인자로 bind가 리턴할 함수에서 사용될 this를 받는다. 두 번째 인자부터 함수에 미리 적용될 인자들이다. 인자를 미리 적용해 두기 위해 this로 사용될 첫 번째 인자에 null을 넣은 후 10을 넣었다. add10과 같이 this를 사용하지 않는 함수이면서 왼쪽에서 부터 순서대로만 인자를 적용하면 되는 상황에서는 원하는 결과를 얻을 수 있다. bind의 아쉬운 점은 두 가지다. 인자를 왼쪽에서 부터 순서대로만 적용할 수 있다는 점과 bind를 한 번 실행한 함수의 this는 무엇을 적용해 두었든 앞으로 바꿀 수 없다는 점이다.<br>bind는 왼쪽에서 부터 원하는 만큼의 인자를 지정해 둘 수 있지만 원하는 지점을 비워 두고 적용할 수는 없다. 예를 들어 어떤 함수가 필요로 하는 인자가 3개가 있는데 그 중 두 번째 인자만을 적용해 두고 싶다면 bind로는 이것을 할 수 없다. 이러한 점을 개선한 방식이 있는데 바로 partial 이다.</p><h3 id="존-레식의-partial"><a href="#존-레식의-partial" class="headerlink" title="존 레식의 partial"></a>존 레식의 partial</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.partial = function () &#123;</span><br><span class="line">  var fn = this, args = Array.prototype.slice.call(arguments); // 1</span><br><span class="line">  return function () &#123; // 2</span><br><span class="line">    var arg = 0;</span><br><span class="line">    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) // 5</span><br><span class="line">      if (args[i] === undefined) args[i] = arguments[arg++]; // 6</span><br><span class="line"></span><br><span class="line">    return fn.apply(this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function abc(a, b, c) &#123;</span><br><span class="line">  console.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ac = abc.partial(undefined, &apos;b&apos;, undefined); // 3 </span><br><span class="line">ac(&apos;a&apos;, &apos;c&apos;); // 4</span><br><span class="line">// a, b, c</span><br></pre></td></tr></table></figure><ol><li>우선 <code>partial</code>이 실행되면 fn에 자기 자신인 this를 담는다. 여기서 자기 자신은 abc 같은 함수다. args에는 partial이 실행될 때 넘어온 인자들을 배열로 변경하여 args에 담아 둔다.</li><li>fn과 args는 리턴된 익명 함수가 기억하게 되므로 지워지지 않는다.</li><li>abc.partial을 실행할 때 첫 번째 인자와 세 번쩨 인자로 넘긴 undefined 자리는 나중에 ac가 실행될 때 채워질 것이다. </li><li>ac를 실행하면서 넘긴 ‘a’와 ‘c’는 </li><li>리턴된 익명 함수의 arguments에 담겨 있다.</li><li>for를 돌면서 미리 받아 두었던 args에 undefined가 들어 있던 자리를 arguments의 앞에서 부터 꺼내면서 모두 채운다. 다 채우고 나면 미리 받아 두었던 fn을 apply로 실행하면서 인자들을 배열로 넘긴다.</li></ol><p>사실 partial은 구현이 잘 된 것은 아니다. 함수의 인자로 undefined를 사용하고 싶을 수도 있는데 undefined가 인자를 비워 두기 우한 구분자로 사용되고 있기 때문에, undefined를 미리 적용하고 싶다면 방법이 없다. 또한 초기에 partial을 실행할 때 나중에 실제로 실행될 함수에서 사용할 인자의 개수만큼 꼭 미리 채워 놓아야만 한다. 이 처럼 partial이 가진 제약은 ‘인자 개수 동적으로 사용하기’나 ‘arguments 객체 활용’과 같은 자바스크립트의 유연함을 반영하지 못한다는 점에서 특히 아쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">  var result = 0;</span><br><span class="line">  for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    result += arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 2, 3, 4, 5));</span><br><span class="line"></span><br><span class="line">var add2 = add.partial(undefined, 2);</span><br><span class="line">console.log(add2(1, 3, 4, 5)); // 3</span><br><span class="line"></span><br><span class="line">var add3 = add.partial(undefined, undefined, 3, undefined, undefined);</span><br><span class="line">console.log(add3(1, 2, 4, 5)); // 15</span><br><span class="line"></span><br><span class="line">console.log(add3(50, 50, 50, 50)); // 15 (bug)</span><br><span class="line">console.log(add3(100, 100, 100, 100)); // 15 (bug)</span><br></pre></td></tr></table></figure><p>위 상황에서 add2는 3, 4, 5 인자를 무시하게 된다. add3처럼 하면 1, 2, 4, 5를 모두 사용할 수 있게 되지만 undefined로라도 인자 개수를 채워놔야 해서 코드가 깔끔하지 못하고 partial 이후에는 역시 4개 이상의 인자를 사용할 수 없다는 단점이 생긴다.<br>위 코드에는 치명적인 문제가 있다. 의도한 것인지는 모르겠지만 그가 만든 partial 함수로 만든 함수는 재사용이 사실상 불가능하다. 한번 partial을 통해 만들어진 함수를 실행하고 나면 클로저로 생성된 args의 상태를 직접 변경하기 때문에, 다음번에 다시 실행해도 같은 args를 바라보고 이전에 적용된 인자가 남는다. 결과적으로 partial로 만들어진 함수는 단 한 번만 정상적으로 동작한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.partial = function () &#123;</span><br><span class="line">  var fn = this, _args = arguments;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(_args);</span><br><span class="line">    var arg = 0;</span><br><span class="line">    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++)</span><br><span class="line">      if (args[i] === undefined) args[i] = arguments[arg++];</span><br><span class="line"></span><br><span class="line">    return fn.apply(this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같이 두 줄만 변경하면 두 번 이상 실행해도 정상적으로 동작한다. 클로저가 기억할 변수에는 원본을 남기고 리턴된 함수가 실행될 때마다 복사하여 원본을 지키는 방식을 사용한다. </p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>오늘은 본격적인 함수형 프로그래밍 시작에 앞서 기본이 될 기능들을 확인해 봤다. 일급 함수 같은 처음 듣는 용어도 있었고, 고차 함수 같은 경우는 내가 실무에서도 사용하고 있지만 정확한 용어도 모르고 사용하고 있었다. 또한 클로저, callback의 존재?는 알고 있었지만 정확한 개념이 부족했다는 것을 느꼈다. 오늘 내용의 모든 기능들의 대한 설명이 이 포스트로는 부족하지만 실력 향상에 많은 도움이 될 것같다. 기록해 두고 자주 보면서 내 것으로 만들어야 할 것 같다. </p><p>partial 같은 함수를 보고 들었던 생각은 함수형 프로그래밍의 끝은 어디 일까가 궁금해졌다. 정말 나는 생각도 못했던 기능이고 저게 그래서 실무에서 필요할까? 라는 생각을 했다. 하지만 partial과 같은 helper 함수들을 구현해 놓고 사용하면 생산성이 눈에 띄게 좋아질 것 같다고 생각한다.</p><p>이제 1장의 내용이 끝났는데 다음 장의 내용은 함수형 자바스크립트를 위한 문법 다시보기 이다. 이미 알고 있던 내용일 지더라도 기초를 더 다지기 위해 소홀히 보지 않아야겠다. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수형 자바스크립트를 잘 익히기 위해서는 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데 이를테면 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드 등이 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="일급 함수" scheme="https://kkangil.github.io/tags/%EC%9D%BC%EA%B8%89-%ED%95%A8%EC%88%98/"/>
    
      <category term="클로저" scheme="https://kkangil.github.io/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"/>
    
      <category term="고차 함수" scheme="https://kkangil.github.io/tags/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/"/>
    
      <category term="partial function" scheme="https://kkangil.github.io/tags/partial-function/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 - 시작2</title>
    <link href="https://kkangil.github.io/2019/09/29/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%912/"/>
    <id>https://kkangil.github.io/2019/09/29/함수형-프로그래밍-시작2/</id>
    <published>2019-09-29T06:27:54.000Z</published>
    <updated>2019-09-29T08:59:54.209Z</updated>
    
    <content type="html"><![CDATA[<p>이전 포스트에서 함수형 프로그래밍의 간략한 소개와 몇가지 예제 코드를 구현했었다. 오늘은 이전 포스트에 이어 다음 내용을 진행하려고 한다.</p><h2 id="회원-목록-중-한명-찾기"><a href="#회원-목록-중-한명-찾기" class="headerlink" title="회원 목록 중 한명 찾기"></a>회원 목록 중 한명 찾기</h2><p>회원 목록 중 id 값으로 해당 id 값을 가진 회원 한 명을 찾고자 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  filter(users, function (user) &#123; return user.id === 3 &#125;)[0]</span><br><span class="line">)</span><br><span class="line">// &#123;id: 3, name: &quot;BJ&quot;, age: 32&#125;</span><br></pre></td></tr></table></figure><p>filter를 통해 걸러낸 후 [0]으로 user를 얻어냈고 원하는 결과를 얻어냈기는 했다. 위 처럼 filter를 사용하여 찾을 수 있지만 filter 함수는 무조건 list.length 만큼 predicate가 실행되기 때문에 효율적이지 못하고, 동일 조건에 값이 두 개 이상이라면 두 개 이상의 값을 찾는다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user;</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].id === 3) &#123;</span><br><span class="line">    user = users[i];</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(user);</span><br></pre></td></tr></table></figure><p>원하는 user를 찾은 후 break로 for문을 빠져나왔다. 앞선 filter를 통해 찾은 것보다 훨씬 효율적이다.<br>하지만 위 코드는 재사용이 불가능 하므로 위 코드를 함수로 만들어서 재사용 가능하도록 만들어 보려고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function findById(list, id) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].id === id) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findById(users, 3));</span><br><span class="line">console.log(findById(users, 5));</span><br></pre></td></tr></table></figure><p>findById는 list와 id를 받아 루프를 돌다가 id가 동일한 객체를 만나면 그 값을 리턴한다.<br>만약 동일한 객체를 찾지 못한다면 기본 리턴 값인 undefined 가 리턴된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findByName</span><br><span class="line"> */</span><br><span class="line">function findByName(list, name) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].name === name) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findByName(users, &apos;BJ&apos;));</span><br><span class="line">console.log(findByName(users, &apos;JE&apos;));</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * findByAge</span><br><span class="line"> */</span><br><span class="line">function findByAge(list, age) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].age === age) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findByAge(users, 28));</span><br><span class="line">console.log(findByAge(users, 25));</span><br></pre></td></tr></table></figure><p>findById 와 동일하게 이름과 나이로도 찾을 수 있는 함수를 만들었다. 하지만 위의 세 함수 사이에 중복이 있다는 점이 아쉽다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findBy</span><br><span class="line"> */</span><br><span class="line">function findBy(key, list, val) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i][key] === val) return list[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(findBy(&apos;name&apos;, users, &apos;BJ&apos;));</span><br><span class="line">console.log(findBy(&apos;id&apos;, users, 2));</span><br><span class="line">console.log(findBy(&apos;age&apos;, users, 28));</span><br></pre></td></tr></table></figure><p>위와 같이 함수에 key 라는 인자를 하나 추가함으로써 세 함수를 공통으로 사용할 수 있게됐다. 위 함수는 key로 value를 얻을 수 있는 객체들을 가진 배열이라면 무엇이든 받을 수 있다. 객체의 key 값이 무엇이든지 간에 찾아줄 수 있으므로 훨씬 많은 경우를 대응할 수 있는 함수가 되었다.<br>하지만 위 함수에서도 아직 아쉬운 점이 존재한다.</p><ul><li>key가 아닌 메서드를 통해 값을 얻어야 할 때</li><li>두 가지 이상의 조건이 필요할 때</li><li>===이 아닌 다른 조건으로 찾고자 할 때</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function User(id, name, age) &#123;</span><br><span class="line">  this.getId = function () &#123;</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">  this.getName = function () &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line">  this.getAge = function () &#123;</span><br><span class="line">    return age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users2 = [</span><br><span class="line">  new User(1, &quot;ID&quot;, 32),</span><br><span class="line">  new User(2, &quot;HA&quot;, 25),</span><br><span class="line">  new User(3, &quot;BJ&quot;, 32),</span><br><span class="line">  new User(4, &quot;PJ&quot;, 28),</span><br><span class="line">  new User(5, &quot;JE&quot;, 27),</span><br><span class="line">  new User(6, &quot;JM&quot;, 32),</span><br><span class="line">  new User(7, &quot;HI&quot;, 24),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">console.log(findBy(&apos;age&apos;, users2, 25));</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure><p>user의 나이를 .getAge() 로 얻어내야 하기 때문에 findBy 함수로는 위 상황을 대응할 수 없을을 알 수 있다. 이름에 ‘P’ 가 포함된 user를 찾고 싶다거나 아니가 32이면서 이름이 ‘JM’인 user를 찾고 싶다거나 하는 것도 불가능하다.</p><h2 id="값에서-함수로"><a href="#값에서-함수로" class="headerlink" title="값에서 함수로"></a>값에서 함수로</h2><p>앞서 만들었던 filter나 map처럼, 인자로 키와 값 대신 함수를 사용해 보려고 한다. 그렇게 하면 모든 상황에 대응 가능한 find 함수를 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function find(list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) return list[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  find(users2, function (u) &#123; return u.getAge() === 25 &#125;).getName()</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.name.indexOf(&apos;P&apos;) !== -1 &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.age === 32 &amp;&amp; u.name === &apos;JM&apos; &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users2, function (u) &#123; return u.getAge() &lt; 30 &#125;).getName()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>find의 인자로 key와 val 대신 predicate 함수 하나를 받았다. 값 대신 함수를 받았다. 덕분에 if 안쪽에서 할 수 있는 일이 정말 많아졌다. 메서드를 사용하거나 두가지 이상의 조건을 사용하는 것도 잘 동작한다.<br>find는 이제 배열에 어떤 값이 들어 있든 사용할 수 있게 되었다. <strong>함수형 자바스크립트는 이처럼 다형성이 높은 기법을 많이 사용하며 이러한 기법은 정말 실용적이다</strong></p><p>filter, map, find 함수들은 들어온 데이터가 무엇이든지 루프들 돌리거나 분기를 만들거나 push를 하거나 predicate를 실행하거나 등의 자기 할 일을 한다. find는 전달 받을 데이터와 데이터의 특성에 맞는 보조 함수(predicate)도 함께 전달받는다. 들어온 데이터의 특성은 보조 함수가 대응해 주기 때문에 find 함수는 데이터의 특성에서 완전히 분리될 수 있다. 이러한 방식은 다형성을 높이며 동시에 안정성도 높인다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 다형성</span><br><span class="line"> */</span><br><span class="line">console.log(</span><br><span class="line">  map(</span><br><span class="line">    filter(users, function (u) &#123; return u.age &gt;= 30 &#125;),</span><br><span class="line">    function (u) &#123; return u.name &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  map(</span><br><span class="line">    filter(users2, function (u) &#123; return u.getAge() &gt; 30 &#125;), // 메서드 실행으로 변경</span><br><span class="line">    function (u) &#123; return u.getName() &#125; // 메서드 실행으로 변경</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="함수를-만드는-함수와-find-filter-조합하기"><a href="#함수를-만드는-함수와-find-filter-조합하기" class="headerlink" title="함수를 만드는 함수와 find, filter 조합하기"></a>함수를 만드는 함수와 find, filter 조합하기</h2><p>User등의 커스텀 객체가 아닌 자바스크립트 기본 객체로 만들어진 users를 사용한 예제로 다시 돌아가 보자. 함수로 함수를 만들어 find 함수와 함께 사용하면 코드를 더욱 간결하게 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function bmatch1(key, val) &#123;</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return obj[key] === val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(find(users, bmatch1(&apos;id&apos;, 1)));</span><br><span class="line">console.log(find(users, bmatch1(&apos;name&apos;, &apos;BJ&apos;)));</span><br><span class="line">console.log(find(users, bmatch1(&apos;age&apos;, 28)));</span><br></pre></td></tr></table></figure><p>bmatch1의 실행 결과는 함수다. key와 val을 미리 받아서 나중에 들어올 obj와 비교하는 익명 함수 클로저로 만들어 리턴한다. bmatch1을 통해 id, name, age를 비교하는 predicate 3개를 만들어 find에 넘겼다.<br>bmatch1은 함수를 리턴하기 때문에 filter나 map과도 조합이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(filter(users, bmatch1(&apos;age&apos;, 32)));</span><br><span class="line">console.log(map(users, bmatch1(&apos;age&apos;, 32)));</span><br></pre></td></tr></table></figure><p>bmatch1은 하나의 key에 대한 value만 비교할 수 있다. 여러 개의 key에 해당하는 value들을 비교하는 함수를 만들어보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function object(key, val) &#123;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  obj[key] = val;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function match(obj, obj2) &#123;</span><br><span class="line">  for (var key in obj2) &#123;</span><br><span class="line">    if (obj[key] !== obj2[key]) return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bmatch(obj2, val) &#123;</span><br><span class="line">  if (arguments.length == 2) obj2 = object(obj2, val);</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return match(obj, obj2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  match(find(users, bmatch(&apos;id&apos;, 3)), find(users, bmatch(&apos;name&apos;, &apos;BJ&apos;)))</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.age === 32 &amp;&amp; u.name === &apos;JM&apos; &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, bmatch(&#123; name: &apos;JM&apos;, age: 32 &#125;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이제는 (key, val)와 ({key: val}) 두 가지 방식으로 사용할 수 있다. ({key: val}) 방식을 사용하면 두 가지 이상의 값이 모두 동일한지도 확인할 수 있다. bmatch1을 bmatch로 발전시키면서 유용한 함수인 match와 object도 만들어졌다. 이처럼 작은 기능을 하는 함수로 쪼개거나 재조합하는 식으로 코드를 발전시키는것도 좋은 방법이다.</p><p>find를 조금만 고치면 값 비교만 하는 <code>Array.prototype.indexOf</code>보다 활용도가 훨씬 높은 findIndex를 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findIndex</span><br><span class="line"> */</span><br><span class="line">function findIndex(list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) return i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findIndex(users, bmatch(&#123; name: &apos;JM&apos;, age: 32 &#125;))) // 5</span><br><span class="line">console.log(findIndex(users, bmatch(&#123; age: 36 &#125;))) // -1</span><br><span class="line">console.log(findIndex(users, bmatch(&apos;id&apos;, 2))); // 1</span><br></pre></td></tr></table></figure><h2 id="고차함수"><a href="#고차함수" class="headerlink" title="고차함수"></a>고차함수</h2><p>앞서 구현했던 filter, map, find, findIndex, bvalue, bmatch 같은 함수들은 모두 고차 함수다.<br>고차 함수란, 함수를 인자로 받거나 함수를 리턴하는 함수를 말한다. 당연히 둘 다 하는 경우도 고차 함수다. 보통 고차 함수는 함수를 인자로 받아 필요한 때에 실행하거나 클로저를 만들어 리턴한다.</p><p><code>Underscore.js</code>는 유명한 함수형 자바스크립트 라이브러리다. <code>Underscore.js</code> 의 _.map, _.filter, _.find, _.findIndex는 iteratee와 predicate가 사용할 인자를 몇 가지 더 제공한다. 재료가 많으면 더 다양한 로직을 만들 수 있다. 앞서 구현했던 고차 함수들을 <code>Underscore.js</code>에 가깝게 고쳐 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_.map = function (list, iteratee) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    new_list.push(iteratee(list[i], i, list))</span><br><span class="line">  &#125;</span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.filter = function (list, predicate) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) new_list.push(list[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.find = function (list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) return list[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.findIndex = function (list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) return i</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원래는 iteratee(list[i])처럼 한 개의 인자를 넘겼지만, 이제는 iteratee(list[i], i, list) 처럼 두 개의 인자를 추가했다. 이제 iteratee와 predicate 함수가 받는 인자가 많아져 좀 더 다양한 일을 할 수 있게 되었다. predicate도 iteratee와 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  _.filter([1, 2, 3, 4], function (val, idx) &#123;</span><br><span class="line">    return idx &gt; 1;</span><br><span class="line">  &#125;)</span><br><span class="line">) // [3, 4]</span><br><span class="line">console.log(</span><br><span class="line">  _.filter([1, 2, 3, 4], function (val, idx) &#123;</span><br><span class="line">    return idx % 2 === 0;</span><br><span class="line">  &#125;)</span><br><span class="line">) // [1,3]</span><br></pre></td></tr></table></figure><h2 id="function-identity"><a href="#function-identity" class="headerlink" title="function identity"></a>function identity</h2><p>정말 쓸모 없어 보이는 이상한 함수 하나를 소개한다. 이것은 <code>Underscore.js</code>에 있는 함수이기도 하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.identity = function (v) &#123; return v &#125;;</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(_.identity(10)) // 10</span><br></pre></td></tr></table></figure><p>받은 인자를 그냥 그대로 뱉는 함수다. _.identity 같은 아무런 기능이 없는 함수는 대체 언제 사용해야 하는 걸까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(_.filter([true, 0, 10, &apos;a&apos;, false, null], _.identity));</span><br><span class="line">// [true, 10, &apos;a&apos;]</span><br></pre></td></tr></table></figure><p>_.filter를 _.identity와 함께 사용했더니 <code>Truthy Values</code>만 남았다. 이렇게 놓고 보니 _.identity가 생각보다 실용적으로 보인다. _.identity를 다른 고차 함수와 조합하는 식으로 아래와 같은 유용한 함수들을 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return !!_.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return _.filter(list, _.identity).length === list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_.some([0, null, 2])); // true</span><br><span class="line">console.log(_.some([0, null, false])); // false</span><br><span class="line"></span><br><span class="line">console.log(_.every([0, null, true])); // false</span><br><span class="line">console.log(_.every([&#123;&#125;, true, 2])); // true</span><br></pre></td></tr></table></figure><p>_.some은 배열에 들어 있는 값 중 하나라도 긍정적인 값이 있으면 true, 하나도 없다면 false를 리턴한다.<br>_.every는 모두 긍정적인 값이어야 true를 리턴한다. _.some, _.every는 if나 predicate 등과 함께 사용할 때 매우 유용하다.<br>_.every는 filter를 사용했기 때문에 항상 루프를 끝까지 돌게 된다. 정말 쓸모 없어 보이지만 함수 두 개를 더 만들면 로직을 개선할 수 있다.</p><h2 id="연산자-대신-함수로"><a href="#연산자-대신-함수로" class="headerlink" title="연산자 대신 함수로"></a>연산자 대신 함수로</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function not(v) &#123; return !v; &#125;</span><br><span class="line">function beq(a) &#123;</span><br><span class="line">  return function (b) &#123;</span><br><span class="line">    return a === b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!를 써도 되는데 <code>not</code>이 왜 필요할까? ===로 비교하면 되는데 <code>beq</code>는 왜 필요할까? 굳이 not과 beq를 함수로 만들 필요가 있을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return !!_.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return beq(-1)(_.findIndex(list, not));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_.some([0, null, 2, 0])); // true</span><br><span class="line">console.log(_.some([0, null, false])); // false</span><br><span class="line"></span><br><span class="line">console.log(_.every([0, null, true])); // false</span><br><span class="line">console.log(_.every([&#123;&#125;, true, 2])); // true</span><br></pre></td></tr></table></figure><p>not은 연산자 !가 아닌 함수이기 때문에 _.findIndex와 함께 사용할 수 있다. list의 값 중 하나라도 부정적인 값을 만나면 predicate가 not이므로 true를 리턴하여 해당번째 i 값을 리턴하게 된다. 중간에 부정적인 값을 한 번이라고 만나면 루프가 중단된다. 만일 부정적인 값이 하나도 없다면 -1을 리턴한다.<br>_.every는 쓸모 없어 보이는 정말 작은 함수 not 덕분에 로직이 개선되었다. 좀 더 함수를 쪼개보다. 함수가 가능하면 한 가지 일만 하게끔 말이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function positive(list) &#123;</span><br><span class="line">  return _.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function negetiveIndex(list) &#123;</span><br><span class="line">  return _.findIndex(list, not);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return not(not(positive(list)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return beq(-1)(negetiveIndex(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="함수-합성"><a href="#함수-합성" class="headerlink" title="함수 합성"></a>함수 합성</h2><p>함수를 쪼갤수록 함수 합성은 쉬워진다. 다음은 다양한 함수 합성 기법 중 하나인 <code>Underscore.js</code>의 _.compose다. _.compose는 오른쪽의 함수의 결과를 바로 왼쪽의 함수에게 전달한다. 그리고 해당 함수의 결과를 다시 자신의 왼쪽의 함수에게 전달하는 고차 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_.compose = function () &#123;</span><br><span class="line">  var args = arguments;</span><br><span class="line">  var start = args.length - 1;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var i = start;</span><br><span class="line">    var result = args[start].apply(this, arguments);</span><br><span class="line">    while (i--) result = args[i].call(this, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var greet = function (name) &#123; return &apos;hi: &apos; + name; &#125;;</span><br><span class="line">var exclaim = function (statement) &#123; return statement.toUpperCase() + &apos;!&apos;; &#125;;</span><br><span class="line">var welcome = _.compose(greet, exclaim);</span><br><span class="line">console.log(welcome(&apos;moe&apos;));</span><br></pre></td></tr></table></figure><p>welcome을 실행하면 먼저 exclaim을 실행하면서 “moe”를 인자로 넘겨준다. exclaim 의 결과는 대문자로 변환된 “MOE!”이고 그 결과는 다시 greet의 인자로 넘어가 최종 결과로 “hi: MOE!”를 리턴한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.some = _.compose(not, not, positive);</span><br><span class="line">_.every = _.compose(beq(-1), negetiveIndex);</span><br></pre></td></tr></table></figure><p>_.compose로 _.some과 _.every를 더 간결하게 표현했다. 맨 오른쪽의 함수가 인자를 받아 결과를 만들고 결과는 다시 그 왼쪽의 함수에게 인자로 전달된다. 오른쪽에서 부터 왼쪽으로 연속적으로 실행되어 최종 결과를 만든다.</p><p>값 대신 함수로, for와 if 대신 고차 함수와 보조 함수로, 연산자 대신 함수로, 함수 합성 등 앞서 설명한 함수적 기법들을 사용하면 코드도 간결해지고 함수명을 통해 로직을 더 명확히 전달할 수 있어 읽기 좋은 코드가 된다.</p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>저번 포스트에서는 함수를 조합해서 사용한다는 것에 정확한 이해가 부족했는데, 이번 포스트를 통해 어느정도의 이해는 된것같다. 이번 포스트에서 제일 크게 느낀점은 “기능 단위로 최대한 작게 함수를 쪼개 놓고 이 함수들을 조합하여 하나의 고차 함수를 사용한다.” 이다.<br>if나 for 같은 로직도 함수 단위로 쪼개면서 재사용성을 고려해서 만들어 놓는 다면 코드의 품질 뿐만 아니라 가독성도 좋아지고 유지 보수도 좋아질 것이라는 생각이 들었다. 운영되고 있는 프로젝트에서 에러가 발생해서 고쳐야 하는 경우나 리팩토링을 해야하는 경우 복잡한 로직이라면 이해하기 쉽지 않은 경우가 있다.<br>내가 짜놓은 코드라도 그때 당시의 고려했던 점이나 여러 경우를 전부 기억하지 못해 수정에 어려움이 있을때가 많다. 이때 만약 함수 단위로 구현해 놓았으면 에러가 발생한 부분이나 고쳐야 할 부분을 함수만 파악하고 고치면 되기때문에 편할 것 같다는 생각이 들었다.</p><p>합성함수 (_.compose)의 arguments 부분이 아직 정확하게 이해 되지는 않지만 뒤에서 arguments에 대해 다시 다뤄준다고 했으니 합성함수의 동작방식만 이해하고 넘어가야겠다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이전 포스트에서 함수형 프로그래밍의 간략한 소개와 몇가지 예제 코드를 구현했었다. 오늘은 이전 포스트에 이어 다음 내용을 진행하려고 한다.&lt;/p&gt;
&lt;h2 id=&quot;회원-목록-중-한명-찾기&quot;&gt;&lt;a href=&quot;#회원-목록-중-한명-찾기&quot; class=&quot;headerlink&quot; title=&quot;회원 목록 중 한명 찾기&quot;&gt;&lt;/a&gt;회원 목록 중 한명 찾기&lt;/h2&gt;&lt;p&gt;회원 목록 중 id 값으로 해당 id 값을 가진 회원 한 명을 찾고자 한다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  filter(users, function (user) &amp;#123; return user.id === 3 &amp;#125;)[0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#123;id: 3, name: &amp;quot;BJ&amp;quot;, age: 32&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter를 통해 걸러낸 후 [0]으로 user를 얻어냈고 원하는 결과를 얻어냈기는 했다. 위 처럼 filter를 사용하여 찾을 수 있지만 filter 함수는 무조건 list.length 만큼 predicate가 실행되기 때문에 효율적이지 못하고, 동일 조건에 값이 두 개 이상이라면 두 개 이상의 값을 찾는다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="함수형 자바스크립트의 실용성 2" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%8B%A4%EC%9A%A9%EC%84%B1-2/"/>
    
      <category term="filter" scheme="https://kkangil.github.io/tags/filter/"/>
    
      <category term="map" scheme="https://kkangil.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 - 시작</title>
    <link href="https://kkangil.github.io/2019/09/28/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%91/"/>
    <id>https://kkangil.github.io/2019/09/28/함수형-프로그래밍-시작/</id>
    <published>2019-09-28T06:49:18.000Z</published>
    <updated>2019-09-28T09:07:34.419Z</updated>
    
    <content type="html"><![CDATA[<p>최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.<br>함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에<br>터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.</p><p>기본적으로 <code>함수형 자바스크립트 프로그래밍</code> 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.</p><p>도서 링크: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p><h1 id="함수형-자바스크립트-소개"><a href="#함수형-자바스크립트-소개" class="headerlink" title="함수형 자바스크립트 소개"></a>함수형 자바스크립트 소개</h1><ul><li>함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.</li><li>함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유<ol><li>오류를 줄이기 위함.</li><li>조합성 혹은 모듈화 수준을 높이기 위함.</li></ol></li></ul><h2 id="함수형-프로그래밍을-검색하면-나오는-예제"><a href="#함수형-프로그래밍을-검색하면-나오는-예제" class="headerlink" title="함수형 프로그래밍을 검색하면 나오는 예제"></a>함수형 프로그래밍을 검색하면 나오는 예제</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addMaker(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addMaker(10)(5);</span><br></pre></td></tr></table></figure><p>함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.<br>함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.</p><p><code>addMaker</code>는 함수를 값으로 다루는 함수다. <code>addMaker</code>에서는 단 하나의 값이 선언되며 그 값은 함수다.<br><code>addMaker(10)</code>의 결과는 function(b) { return 10 + b }; 와 같다.<br>이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add5 = addMaker(5);</span><br><span class="line">add5(3) // 8</span><br><span class="line">add5(4) // 9</span><br></pre></td></tr></table></figure><p>위와 같이 변수에 값을 할당해서 사용할 수 도 있다.</p><h2 id="값으로써의-함수와-클로저"><a href="#값으로써의-함수와-클로저" class="headerlink" title="값으로써의 함수와 클로저"></a>값으로써의 함수와 클로저</h2><p>위의 예제들을 보면 함수는 값을 리턴할 수 있고 함수는 값이 될 수 있다. <code>addMaker</code>는 내부에서 함수를 정의하고 리턴했다. <code>addMaker</code>가 리턴한 익명 함수는 클로저가 되었다.<br>리턴된 익명 함수 내부에서 a가 정의된 적은 없지만 a를 참조하고 있고 a는 부모 스코프에 있다.</p><p><code>addMaker</code>가 실행된 후, 어디서도 <code>addMaker</code>의 인자인 a 값을 변경시키지 않고 있기 때문에 항상 동일한 값을 갖는다. 때문에 위 상황에서 a는 불변하며 상수로 쓰이게 된다. 이 상황에서의 a는 불변하지만, 모든 경우의 클로저가 그렇지는 않다. 클로저가 기억하는 변수의 값은 변할 수 있다.</p><hr><h2 id="함수형-자바스크립트의-실용성"><a href="#함수형-자바스크립트의-실용성" class="headerlink" title="함수형 자바스크립트의 실용성"></a>함수형 자바스크립트의 실용성</h2><p>절차지향적으로 작성된 코드를 함수형으로 변경하면서 함수형 자바스크립트의 실용성을 알아보고자 한다.</p><h3 id="회원-목록-중-여러명-찾기"><a href="#회원-목록-중-여러명-찾기" class="headerlink" title="회원 목록 중 여러명 찾기"></a>회원 목록 중 여러명 찾기</h3><p>회원 목록 중 특정 나이의 회원들만 뽑거나 특정 조건의 회원 한 명을 찾는 코드들을 함수형 자바스크립트로 리팩토링 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var users = [</span><br><span class="line">  &#123; id: 1, name: &apos;ID&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 2, name: &apos;HA&apos;, age: 25 &#125;,</span><br><span class="line">  &#123; id: 3, name: &apos;BJ&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 4, name: &apos;PJ&apos;, age: 28 &#125;,</span><br><span class="line">  &#123; id: 5, name: &apos;JE&apos;, age: 27 &#125;,</span><br><span class="line">  &#123; id: 6, name: &apos;JM&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 7, name: &apos;HI&apos;, age: 24 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(temp_users[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &gt;= 30) temp_users.push(users[i])</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(temp_users[i].name);</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>1에서는 users 중에 age가 30 미만인 users[i]만 모아서 몇 명인지를 출력하고 2에서는 그들의 나이만 다시 모아 출력한다. 3에서는 나이가 30 이상인 temp_users가 몇 명인지를 출력하고 4에서는 그들의 이름만 다시 모아 출력한다.</p><p>위 코드를 함수형으로 리팩토링 하기 위해 먼저 중복되는 부분을 찾아본다. 1과 3의 for문에서 users를 돌며 특정 조건의 users[i]를 새로운 배열에 담고 있는데, if 문의 조건절 부분을 제외하고는 모두 동일한 코드이다. 30 부분은 변수로 바꿀 수 있겠지만 .age, &lt;, &gt;= 등은 쉽지 않아 보인다. 이때 함수를 활용하면 이런 부분까지도 쉽게 추상화 할 수 있다.</p><h3 id="for에서-filter로-if에서-predicate로"><a href="#for에서-filter로-if에서-predicate로" class="headerlink" title="for에서 filter로, if에서 predicate로"></a>for에서 filter로, if에서 predicate로</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 기존코드</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// refactoring</span><br><span class="line">function filter(list, predicate) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) new_list.push(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter 함수는 인자로 list와 predicate 함수를 받는다. 루프를 도며 list의 i번째의 값을 predicate에 넘겨준다. predicate 함수는 list.length 만큼 실행되며, predicate 함수의 결과가 참일 때만 new_list.push를 실행한다.<br>filter 함수는 predicate 함수 내부에서 어떤 일을 하는지 모른다. id를 조회할지 age를 조회할지 어떤 조건을 만들지를 filter는 전혀 모른다. 오직 predicate 결과에만 의존한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// filter 사용</span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30)</span><br><span class="line"></span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = users_under_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(users_under_30[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = users_over_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(users_over_30[i].name)</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>filter 함수를 실행하면서 predicate 자리에 익명 함수를 정의해서 넘겼다. predicate 익명 함수의 리턴값(<code>boolean</code>)에 따라서 push를 해줄지 안해줄지가 결정된다. 기존 코드와 비교해 코드가 짧아졌고 재사용성 높은 함수 filter를 얻게됐다.</p><h3 id="함수형-프로그래밍-관점으로-filter-보기"><a href="#함수형-프로그래밍-관점으로-filter-보기" class="headerlink" title="함수형 프로그래밍 관점으로 filter 보기"></a>함수형 프로그래밍 관점으로 filter 보기</h3><p>함수형 프로그래밍 관점에서 filter와 predicate 사이에는 많은 이야기가 담겨있다. filter 함수에는 for도 있고 if도 있지만, filter 함수는 항상 동일하게 동작하는 함수다. <strong>동일한 인자가 들어오면 항상 동일하게 동작한다.</strong> filter 함수의 로직은 외부나 내부의 어떤 상태 변화에도 의존하지 않는다. <code>new_list</code>의 값을 바꾸고 있지만 그 변화에 의존하는 다른 로직이 없다. <code>new_list</code>가 완성될 떄까지는 외부에서 어떠한 접근도 할 수 없기 때문에 filter의 결과도 달라질 수 없다. <code>new_list</code>가 완성되고 나면 <code>new_list</code>를 리턴해버리고 filter는 완전히 종료된다.</p><p>filter의 if는 predicate의 결과에만 의존한다. filter를 사용하는 부분을 다시 보면 filter와 users, filter가 사용할 predicate 함수만 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(users, function(user) &#123; return user.age &lt; 30 &#125;)</span><br></pre></td></tr></table></figure></p><p>절차지향 프로그래밍과 달리 함수형 프로그래밍 에서는 <strong>항상 동일하게 동작하는 함수</strong> 를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다. 내부에서 관리하고 있는 상태를 따로 두지않고 넘겨진 인자에만 의존한다. 동일한 인자가 들어오면 항상 동일한 값을 리턴 하도록 한다.</p><h3 id="map-함수"><a href="#map-함수" class="headerlink" title="map 함수"></a>map 함수</h3><p>리팩토링의 핵심은 중복을 제거하고 의도를 드러내는 것이다. 기존 코드를 보면 회원 목록을 통해 나이와 이름들을 추출하는데 두 코드에도 중복이 있다. 둘 다 for문에서 사용하는 회원 목록을 활용해 같은 크기의 새로운 배열을 만들고 원재료와 1:1로 매핑되는 다른 값을 만들어 담고 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// map 사용</span><br><span class="line">function map(list, iteratee) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    new_list.push(iteratee(list[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30.length)</span><br><span class="line"></span><br><span class="line">var ages = map(users_under_30, function (user) &#123; return user.age &#125;);</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30.length)</span><br><span class="line"></span><br><span class="line">var names = map(users_over_30, function (user) &#123; return user.name &#125;);</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>코드가 매우 단순해 진것을 확인할 수 있다. for도 없고 if도 없다. new_list에 무엇을 push 할지에 대해 iteratee 함수에게 위임했다.</p><h3 id="실행-결과로-바로-실행하기"><a href="#실행-결과로-바로-실행하기" class="headerlink" title="실행 결과로 바로 실행하기"></a>실행 결과로 바로 실행하기</h3><p>함수의 리턴값을 바로 다른 함수의 인자로 사용하면 변수 할당을 줄일 수 있다.<br>filter 함수의 결과가 배열이므로 map의 첫 번째 인자로 바로 사용 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 함수 중첩</span><br><span class="line">var ages = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.age &#125;</span><br><span class="line">)</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var names = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.name &#125;</span><br><span class="line">)</span><br><span class="line">console.log(names);</span><br><span class="line"></span><br><span class="line">// 함수 중첩 2</span><br><span class="line">function log_length(value) &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.age &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.name &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>filter 함수는 predicate를 통해 값을 필터링하여 map에게 전달하고 map은 받은 iteratee를 통해 새로운 값들을 만들어 log_length에게 전달한다. log_length는 length를 출력한 후 받은 인자를 그대로 console.log에게 전달하고 console.log는 받은 값을 출력한다.</p><h3 id="함수를-값으로-다룬-예제의-실용성"><a href="#함수를-값으로-다룬-예제의-실용성" class="headerlink" title="함수를 값으로 다룬 예제의 실용성"></a>함수를 값으로 다룬 예제의 실용성</h3><p>위에 만들었던 <code>addMaker</code> 와 비슷한 패턴의 함수가 실제로도 많이 사용된다.<br><code>addMaker</code>와 비슷한 패턴의 함수인 <code>bvalue</code> 함수를 만들어 보려고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function bvalue(key) &#123;</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bvalue(&apos;a&apos;)(&#123; a: &apos;hi&apos;, b: &apos;hello&apos; &#125;)); // hi</span><br></pre></td></tr></table></figure><p>bvalue를 실행할 때 넘겨준 인자 key를 나중에 obj를 받을 익명 함수가 기억한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * bvalue로 map의 iteratee 만들기</span><br><span class="line"> */</span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      bvalue(&apos;age&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      bvalue(&apos;name&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>map이 사용할 iteratee 함수를 bvalue가 리턴한 함수로 대체했다. 익명 함수 선언이 사라져 코드가 더욱 짧아졌다.</p><p>화살표 함수로 사용하기<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &lt; 30),</span><br><span class="line">      user =&gt; user.age</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &gt;= 30),</span><br><span class="line">      user =&gt; user.name</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var under_30 = user =&gt; user.age &lt; 30;</span><br><span class="line">var over_30 = user =&gt; user.age &gt;= 30;</span><br><span class="line">var ages = list =&gt; map(list, user =&gt; user.age);</span><br><span class="line">var names = list =&gt; map(list, user =&gt; user.name);</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, function (user) &#123; return user[key] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ages = bvalues(&apos;age&apos;);</span><br><span class="line">var names = bvalues(&apos;name&apos;);</span><br><span class="line">var under_30 = function (user) &#123; return user.age &lt; 30 &#125;;</span><br><span class="line">var over_30 = function (user) &#123; return user.age &gt;= 30 &#125;;</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  var value = bvalue(key);</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 화살표 함수 사용</span><br><span class="line">var bvalues = key =&gt; list =&gt; &#123;</span><br><span class="line">  var value = bvalue(key)</span><br><span class="line">  return map(list, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>Conclusion<br>어려운 점이 공부를 하면 할수록 많이 생기겠지만, 새로운 관점에서의 프로그래밍인 것 같아 흥미롭게 느껴진다.<br>본인은 아직 주니어라 절차지향적 사고 방식이 강한데 함수형 프로그래밍 공부하면서 새로운 사고 방식에 대해서도 생각해 봐야할 것 같다. 이번 챕터의 첫 코드(절차지향적 코드)는 쉽다고 느껴졌지만, 함수형으로 리팩토링 해 나가는 과정에서는 이게 정확히 어떤 방식으로 동작하는가, 인자값은 어떻게 넘겨 주는가에 대한 고민이 생기는것을 느끼면서 함수형 프로그래밍에 더 알고 싶어졌다.</p><p>처음에는 함수형 프로그래밍 방식이 “그래서 왜 좋은건데?”에 대한 의문이 있었는데 마지막 코드를 보고 재새용성이 뛰어나다는것을 느꼈다. 프로젝트를 시작할때 잘 구현해 놓은 함수는 계속 재사용하면서 코딩의 속도와 편리함을 제공해 줄 것 같다고 생각했다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.&lt;br&gt;함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에&lt;br&gt;터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.&lt;/p&gt;
&lt;p&gt;기본적으로 &lt;code&gt;함수형 자바스크립트 프로그래밍&lt;/code&gt; 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.&lt;/p&gt;
&lt;p&gt;도서 링크: &lt;a href=&quot;http://www.yes24.com/Product/Goods/56885507&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;함수형 자바스크립트 프로그래밍&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;함수형-자바스크립트-소개&quot;&gt;&lt;a href=&quot;#함수형-자바스크립트-소개&quot; class=&quot;headerlink&quot; title=&quot;함수형 자바스크립트 소개&quot;&gt;&lt;/a&gt;함수형 자바스크립트 소개&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.&lt;/li&gt;
&lt;li&gt;함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유&lt;ol&gt;
&lt;li&gt;오류를 줄이기 위함.&lt;/li&gt;
&lt;li&gt;조합성 혹은 모듈화 수준을 높이기 위함.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;함수형-프로그래밍을-검색하면-나오는-예제&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍을-검색하면-나오는-예제&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍을 검색하면 나오는 예제&quot;&gt;&lt;/a&gt;함수형 프로그래밍을 검색하면 나오는 예제&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function addMaker(a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return function(b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addMaker(10)(5);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.&lt;br&gt;함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addMaker&lt;/code&gt;는 함수를 값으로 다루는 함수다. &lt;code&gt;addMaker&lt;/code&gt;에서는 단 하나의 값이 선언되며 그 값은 함수다.&lt;br&gt;&lt;code&gt;addMaker(10)&lt;/code&gt;의 결과는 function(b) { return 10 + b }; 와 같다.&lt;br&gt;이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Sequelize model 정의</title>
    <link href="https://kkangil.github.io/2019/04/28/Sequelize-model-%EC%A0%95%EC%9D%98/"/>
    <id>https://kkangil.github.io/2019/04/28/Sequelize-model-정의/</id>
    <published>2019-04-28T05:45:40.000Z</published>
    <updated>2019-04-28T05:47:51.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sequelize-model-정의"><a href="#sequelize-model-정의" class="headerlink" title="sequelize model 정의"></a>sequelize model 정의</h2><ul><li>sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 <code>define</code> 메소드를 이용해 정의하고자 한다.</li><li>model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128)</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><code>define</code> 함수의 첫번째 파라미터는 테이블의 이름에 해당된다. 또한 express 프로젝트에서도 해당 이름으로 데이터베이스에 접근할 수 있다.</li><li>두번째 파라미터는 컬럼을 정의하는 것이다. 위의 예시는 가장 기본적인 컬럼을 생성한 것이고 나머지 옵션들은 밑에서 확인해 보도록 한다.</li></ul><h2 id="column-option"><a href="#column-option" class="headerlink" title="column option"></a>column option</h2><ul><li>sequelize model 생성시 sequelize 는 고유 키값을 정의해 주지 않아도, 다른 설정이 없다면 id 로 생성해주며 row 생성시 자동으로 1씩 증가한다.</li><li>id 이외에 createdAt(생성일), updatedAt(수정일) 도 같이 생성해준다.</li><li>defaultValue: row가 생성될때 기본값을 설정해줄 수 있다. (etc. Sequelize.NOW)</li><li>allowNull: false로 설정해주면 빈값으로 생성시 에러가 난다.(default true)</li><li>unique: 테이블내의 고유한 값(boolean)</li><li>primaryKey: 고유 키값 설정 여부</li><li>autoIncrement: 자동으로 값을 증가시켜준다. (Integer 에서만 사용 가능)</li><li>field: 객체 키값과 다르게 custom으로 컬럼명을 사용할 수 있게해준다.</li><li>comment: 해당 컬럼에 대한 설명을 달 수 있다. 컬럼 생성에 영향을 미치지는 않는다. 주석같은 개념</li></ul><h2 id="Getters-amp-setters"><a href="#Getters-amp-setters" class="headerlink" title="Getters &amp; setters"></a>Getters &amp; setters</h2><ul><li><p>컬럼 option에 getter와 setter를 추가해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false,</span><br><span class="line">      get() &#123;</span><br><span class="line">        const job = this.getDataValue(&apos;job&apos;)</span><br><span class="line">        return `$&#123;this.getDataValue(&apos;username&apos;)&#125; ($&#123;this.getDataValue(&apos;job&apos;)&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false,</span><br><span class="line">      set(job) &#123;</span><br><span class="line">        this.setDataValue(&apos;job&apos;, job.toUpperCase())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const userSample = async () =&gt; &#123;</span><br><span class="line">  const user = await User.create(&#123; username: &apos;kkangil&apos;, job: &apos;developer&apos; &#125;)</span><br><span class="line">  console.log(user.get(&apos;username&apos;)) // kkangil (DEVELOPER)</span><br><span class="line">  console.log(user.get(&apos;job&apos;)) // DEVELOPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getDataValue</code> 를 사용하여 자신의 컬럼 뿐만 아니라 테이블의 컬럼 데이터도 가져올 수 있다.</p></li><li><code>setDataValue</code> 를 사용하여 생성이나 수정 시 데이터 값을 수정, 변경할 수 있다. </li><li>컬럼 객체 내부에 설정해 주지 않고, <code>define</code> 함수의 세번째 파라미터로도 사용이 가능하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    getterMethods: &#123;</span><br><span class="line">      getUser() &#123;</span><br><span class="line">        return `$&#123;this.username&#125; ($&#123;this.job&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="validate-column"><a href="#validate-column" class="headerlink" title="validate column"></a>validate column</h2><ul><li><p>데이터 타입 이외에도 <code>validate</code> 를 사용해서 유효성 확인 후 에러를 반환해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;Foo&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      validate: &#123;</span><br><span class="line">        is: /^[a-z]+$/i, // 정규식 사용해서 유효성 확인</span><br><span class="line">        not: /^[a-z]+$/i,</span><br><span class="line">        isEmail: true, // 이메일 유효성 확인</span><br><span class="line">        isInt: true,</span><br><span class="line">        notNull: true,</span><br><span class="line">        isNull: true,</span><br><span class="line">        notEmpty: true, // string 빈값 확인</span><br><span class="line">        equals: &apos;specific value&apos;, // 특정 값으로만 생성 가능</span><br><span class="line">        contains: &apos;foo&apos;, // 해당 값을 포함하고 있는지 확인</span><br><span class="line">        notContains: &apos;bar&apos;,</span><br><span class="line">        notIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        isIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        len: [2,10], // 2자리 ~ 10자리</span><br><span class="line">        max: 23,</span><br><span class="line">        min: 10,</span><br><span class="line">        isCreditCard: true // 신용카드 유효성 확인</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>제공되는 <code>validate</code> 가 아닌 직접 만들어서 사용하는 기능도 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    isEven(value) &#123;</span><br><span class="line">      if (parseInt(value) % 2 !== 0) &#123;</span><br><span class="line">        throw new Error(&apos;Only even values are allowed!&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throw new Error의 메시지가 에러로 리턴된다.</p></li><li><p>직접 만들어서 사용하지 않아도 메시지를 설정해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    notNull: &#123;</span><br><span class="line">      msg: &quot;Must&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    isIn: &#123;</span><br><span class="line">      args: [[&apos;en&apos;, &apos;zh&apos;]],</span><br><span class="line">      msg: &quot;Must be English or Chinese&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>allowNull</code> 을 사용한다면 <code>notNull</code> 의 <code>msg</code>를 설정해주면 에러메시지로 사용가능하다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    validate: &#123;</span><br><span class="line">      checkUsernameAndJob() &#123;</span><br><span class="line">        if (!(this.username &amp;&amp; this.job)) &#123;</span><br><span class="line">          throw new Error(&apos;이름과 직업을 입력해주세요.&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>define</code> 함수의 세번째 파라미터 객체에 validate 를 설정해주면 하나의 컬럼이 아닌 테이블의 모든 컬럼의 유효성은 같이 확인 할 수 있다.</li></ul><h2 id="model-configuration"><a href="#model-configuration" class="headerlink" title="model configuration"></a>model configuration</h2><ul><li><code>define</code> 함수의 세번째 파라미터 객체의 설정값<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  ..., &#123;</span><br><span class="line">    modelName: &apos;bar&apos;, // 모델 이름 설정</span><br><span class="line">    timestamps: false, // createdAt, updatedAt 생성하지 않음</span><br><span class="line">    paranoid: true, // 데이터를 삭제하지 않고 현재 시간으로 deletedAt 데이터가 추가된다.</span><br><span class="line">    underscored: true, // 자동으로 컬럼명을 snake 네임으로 변경한다.</span><br><span class="line">    tableName: &apos;my_bar&apos;, // 테이블 이름 설정</span><br><span class="line">    createdAt: false, // createdAt 사용하지 않음</span><br><span class="line">    updatedAt: &apos;updateTimestamp&apos;, // updatedAt 컬럼명 정의</span><br><span class="line">    deletedAt: &apos;destroyTime&apos;, // deletedAt 컬럼명 정의 (paranoid가 true로 설정되어 있어야함.)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>참고 <a href="http://docs.sequelizejs.com/manual/models-definition.html" target="_blank" rel="noopener">sequelize docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sequelize-model-정의&quot;&gt;&lt;a href=&quot;#sequelize-model-정의&quot; class=&quot;headerlink&quot; title=&quot;sequelize model 정의&quot;&gt;&lt;/a&gt;sequelize model 정의&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 &lt;code&gt;define&lt;/code&gt; 메소드를 이용해 정의하고자 한다.&lt;/li&gt;
&lt;li&gt;model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;return sequelize.define(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;User&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    username: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING(128)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    job: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Sequelize" scheme="https://kkangil.github.io/categories/Sequelize/"/>
    
    
      <category term="Sequelize" scheme="https://kkangil.github.io/tags/Sequelize/"/>
    
      <category term="MySQL" scheme="https://kkangil.github.io/tags/MySQL/"/>
    
      <category term="model 정의" scheme="https://kkangil.github.io/tags/model-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 3. 사용방법2</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-3-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%952/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-3-사용방법2/</id>
    <published>2019-04-19T03:54:04.000Z</published>
    <updated>2019-04-19T03:56:23.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const reducer = (state, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;INCREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count + 1 &#125;;</span><br><span class="line">    case &quot;DECREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count - 1 &#125;;</span><br><span class="line">    case &quot;HANDLE_CHANGE&quot;:</span><br><span class="line">      return &#123; ...state, [action.target.name]: action.target.value &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const CountReducer = () =&gt; &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, &#123;</span><br><span class="line">    count: 0,</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    nickname: &quot;&quot;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const handleChange = e =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &quot;HANDLE_CHANGE&quot;, target: e.target &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;INCREMENT&quot; &#125;)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;DECREMENT&quot; &#125;)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.name&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.nickname&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default CountReducer;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>이전에 useState로 구현했었던 count와 input 컴포넌트를 위의 코드와 같이 reducer를 사용해서 구현할 수 있다.</li><li>useState 또는 useReducer 어떤것이 더 좋다 안좋다는 없지만, 상황에 따라 유연하게 사용할 줄 알아야 할것같다.</li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>두번째 파라미터 배열 값을 전달받아 해당 값이 변경 될때만 첫번째 파라미터 함수를 실행한다. 해당 기능을 사용하면 불필요한 함수 호출을 줄일 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Sum = () =&gt; &#123;</span><br><span class="line">  const [num, setNum] = useState(&quot;&quot;);</span><br><span class="line">  const [numList, setNumList] = useState([]);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = () =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const sumValue = useMemo(() =&gt; &#123;</span><br><span class="line">    if (!numList.length) return 0;</span><br><span class="line">    const sum = numList.reduce((a, b) =&gt; a + b);</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;, [numList]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Sum</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;num&#125; onChange=&#123;e =&gt; setNum(e.target.value)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClickAdd&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number list: &#123;numList.join(&quot;, &quot;)&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number total: &#123;sumValue&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Sum;</span><br></pre></td></tr></table></figure><ul><li>sumValue 함수에 <code>useMemo</code>를 사용하지 않으면, input 값이 변경될때도 해당 로직이 불필요하게 실행된다.</li><li>useMemo를 사용해 줌으로써 불필요하게 실행되지 않도록 하고, <code>numList</code>의 값이 변경될때마다 해당 로직이 실행된다.</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useMemo와 거의 비슷한 기능으로 렌더링 성능을 최적화 하기위해 주로 사용된다. 쓰지 않아도 문제되지는 않지만 렌더링 해야할 컴포넌트 개수나 로직이 많아진다면 고려해 봐야한다. 해당 기능은 이벤트 함수를 필요할때만 생성해 주는 기능이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = useCallback(e =&gt; &#123;</span><br><span class="line">    setNum(e.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br></pre></td></tr></table></figure><ul><li>위의 onChange 함수와 handleClickAdd 함수를 useCallback을 사용하는 함수로 변경했다.</li><li>두번째 파라미터 배열은 해당 값이 변경될때만 함수를 생성해 주는것이다. 빈 배열이라면 최초에만 생성해주고 이후 다시 생성되지 않는다.</li><li>handleChange 는 빈배열, handleClickAdd 은 두개의 값을 판단하고 있는데, 이는 handleChange는 단순히 <code>num</code> 의 값만 변경해 주고 있어 초기에만 생성해 줘도 되는것이다. handleClickAdd 함수는 이벤트가 실행 될때마다 값을 가져와서 사용해 주고 있기때문에 배열에 해당 값들을 명시해줘야한다.</li></ul><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>useRef는 함수형 컴포넌트에서도 ref 기능을 사용할 수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const inputElement = useRef(null);</span><br><span class="line">const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">      inputElement.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br><span class="line">&lt;input value=&#123;num&#125; onChange=&#123;handleChange&#125; ref=&#123;inputElement&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li>useRef는 다른 Hook과 다르게 최초 선언을 배열 형태로 선언해 주지 않는다.</li><li>ref 값이 변경되어도 리렌더링 되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h2&gt;&lt;p&gt;redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import React, &amp;#123; useReducer &amp;#125; from &amp;quot;react&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const reducer = (state, action) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  switch (action.type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;INCREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count + 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;DECREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count - 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;HANDLE_CHANGE&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, [action.target.name]: action.target.value &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const CountReducer = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const [state, dispatch] = useReducer(reducer, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count: 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &amp;quot;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nickname: &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const handleChange = e =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch(&amp;#123; type: &amp;quot;HANDLE_CHANGE&amp;quot;, target: e.target &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;p&amp;gt;current count: &amp;#123;state.count&amp;#125;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;INCREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;increase&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;DECREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;decrease&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.name&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.nickname&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export default CountReducer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useReducer" scheme="https://kkangil.github.io/tags/useReducer/"/>
    
      <category term="useMemo" scheme="https://kkangil.github.io/tags/useMemo/"/>
    
      <category term="useCallback" scheme="https://kkangil.github.io/tags/useCallback/"/>
    
      <category term="useRef" scheme="https://kkangil.github.io/tags/useRef/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 2. 사용방법1</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-2-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%951/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-2-사용방법1/</id>
    <published>2019-04-19T03:52:51.000Z</published>
    <updated>2019-04-19T03:53:43.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h3><p>useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.</p><p>사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><ul><li>useState를 사용하여 count state를 생성해 주었으며 초기값은 0으로 맞춰 주었다.</li><li>state 사용은 기존의 class에서 사용하던 this.state.count가 아닌 count로만 사용해야 한다.</li><li>setCount 파라미터로 값을 넘겨주면 해당 값으로 state가 변경된다.</li></ul><h3 id="여러개의-state-사용"><a href="#여러개의-state-사용" class="headerlink" title="여러개의 state 사용"></a>여러개의 state 사용</h3><p>여러개의 state를 사용해야 한다면, 기존 class 방식에서는 state 객체 안에 키와 값을 설정해 주면 됐지만, 함수형 컴포넌트에서는 useState를 여러번 써줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;name ? `$&#123;name&#125;&apos;s` : &quot;&quot;&#125; current count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="재사용-가능한-useState-함수-컴포넌트"><a href="#재사용-가능한-useState-함수-컴포넌트" class="headerlink" title="재사용 가능한 useState 함수 컴포넌트"></a>재사용 가능한 useState 함수 컴포넌트</h3><p>동일한 stateful 로직을 사용한다면 컴포넌트를 분리해서 사용하는것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const useInputOption = props =&gt; &#123;</span><br><span class="line">  const [value, setValue] = useState(props || &quot;&quot;);</span><br><span class="line">  const onChange = e =&gt; &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const nameInputOption = useInputOption(&quot;&quot;);</span><br><span class="line">  const nickInputOption = useInputOption(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input &#123;...nameInputOption&#125; /&gt;</span><br><span class="line">      &lt;input &#123;...nickInputOption&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;nameInputOption.value ? `$&#123;nameInputOption.value&#125;&apos;s` : &quot;&quot;&#125; current</span><br><span class="line">        count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>input의 value와 onChange 이벤트 함수를 return 해주는 <code>useInputOption</code> 컴포넌트를 만들었다.</li><li>코드가 간결해지고 재사용성이 높아진다.</li></ul><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect는 함수형 컴포넌트에서도 라이프사이클과 같은 기능을 사용할 수 있게 해준다.<br><code>componentDidMount</code> 와 <code>componentDidUpdate</code>, <code>componentWillUnmount</code> 를 합쳐놓은 것이다.<br>useEffect 함수는 state 변수를 하나만 관리하는것이 좋다. 즉 여러개의 useEffect 함수를 사용하는것을 추천해주고 있다.</p><h3 id="사용방법-1"><a href="#사용방법-1" class="headerlink" title="사용방법"></a>사용방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const User = () =&gt; &#123;</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default User;</span><br></pre></td></tr></table></figure><ul><li>해당 코드를 확인해보면 render 가 될때마다 console.log 가 찍히는것을 확인할 수 있다. 이것은 <code>componentDidMount</code> 와 <code>componentDidUpdate</code> 라이프사이클과 일치한다.</li></ul><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><ul><li>useEffect 함수에 두번째 파라미터로 빈배열을 넣으면 최초 렌더링이 될때만 실행되고 name이 변경되더라도 실행되지 않는다.</li></ul><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>배열에 원하는 값을 넣어주면 해당 값이 변할때만 실행된다.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      console.log(&quot;unmount&quot;, name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>return 함수는 렌더링이 될때마다 실행되는 함수이다. name을 확인해보면 변경되기 이전의 값이 찍히는것을 확인할 수 있다.</li><li>두번째 파라미터에 빈 배열을 담아서 실행하면 unmount 될때만 return 함수가 실행된다.</li></ul><h2 id="Promise-처리"><a href="#Promise-처리" class="headerlink" title="Promise 처리"></a>Promise 처리</h2><p>useEffect와 useState를 사용하여 promise 컴포넌트 또한 재사용이 가능하도록 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const usePromise = (&#123; promise, initialData, arr &#125;) =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState(initialData);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(false);</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    try &#123;</span><br><span class="line">      const result = await promise();</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      setError(true);</span><br><span class="line">    &#125;</span><br><span class="line">    setLoading(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, arr || []);</span><br><span class="line"></span><br><span class="line">  return &#123; data, loading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getNames = async () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt;</span><br><span class="line">    setTimeout(() =&gt; resolve([&#123; name: &quot;kkangil&quot; &#125;, &#123; name: &quot;kkangil2&quot; &#125;]), 1000)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Names = () =&gt; &#123;</span><br><span class="line">  const &#123; data: names, loading, error &#125; = usePromise(&#123;</span><br><span class="line">    promise: getNames,</span><br><span class="line">    initialData: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (loading) return &lt;div&gt;로딩중...&lt;/div&gt;;</span><br><span class="line">  if (error) return &lt;div&gt;에러&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;names.map((row, index) =&gt; (</span><br><span class="line">        &lt;div key=&#123;index&#125;&gt;&#123;row.name&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="usePromise"><a href="#usePromise" class="headerlink" title="usePromise"></a>usePromise</h3><ul><li>파라미터로 호출해야하는 <code>promise</code> 함수, 최초 초기화 데이터 <code>initialData</code>, useEffect 함수 2번째 파라미터 배열 <code>arr</code>을 객체로 받는다.</li><li><code>useEffect</code> 함수에서 async/await을 사용하면 warning이 발생한다. 그렇기 때문에 async/await 함수를 따로 만들어 해당 함수를 useEffect에서 실행 시켜준다.</li></ul><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><ul><li>initialData에 빈배열을 넣어주지 않으면 return의 <code>names.map</code> 에서 에러가 발생한다. 해당 에러를 막기 위해 빈 배열로 초기화해줬다. <code>names</code> 값이 존재할때만 map 을 사용하는 방법도 있지만, 추후 재사용을 위해 데이터 초기값을 설정해줄 수 있도록 했다.</li></ul><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>useContext는 함수형 컴포넌트에서 Context를 쉽게 사용할 수 있게 해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const backgroundColorContext = createContext(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">const Context = () =&gt; &#123;</span><br><span class="line">  const backgroundColor = useContext(backgroundColorContext);</span><br><span class="line">  const style = &#123;</span><br><span class="line">    width: &quot;50px&quot;,</span><br><span class="line">    height: &quot;50px&quot;,</span><br><span class="line">    borderRadius: &quot;50%&quot;,</span><br><span class="line">    background: backgroundColor</span><br><span class="line">  &#125;;</span><br><span class="line">  return &lt;div style=&#123;style&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Context;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useState&quot;&gt;&lt;a href=&quot;#useState&quot; class=&quot;headerlink&quot; title=&quot;useState&quot;&gt;&lt;/a&gt;useState&lt;/h2&gt;&lt;h3 id=&quot;사용방법&quot;&gt;&lt;a href=&quot;#사용방법&quot; class=&quot;headerlink&quot; title=&quot;사용방법&quot;&gt;&lt;/a&gt;사용방법&lt;/h3&gt;&lt;p&gt;useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useState" scheme="https://kkangil.github.io/tags/useState/"/>
    
      <category term="useEffect" scheme="https://kkangil.github.io/tags/useEffect/"/>
    
      <category term="useContext" scheme="https://kkangil.github.io/tags/useContext/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 1. hooks 란?</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-1-hooks-%EB%9E%80/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-1-hooks-란/</id>
    <published>2019-04-19T03:48:12.000Z</published>
    <updated>2019-04-19T03:52:29.003Z</updated>
    
    <content type="html"><![CDATA[<p>리액트 16.8 버전에서 <code>Hooks</code> 라는 새로운 기능이 추가 되었다.<br>해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.<br>이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.</p><a id="more"></a><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-intro.html</a></p><h2 id="Hooks-특징"><a href="#Hooks-특징" class="headerlink" title="Hooks 특징"></a>Hooks 특징</h2><ul><li>현재 진행중인 프로젝트가 있다면 코드를 다시 짜지 않아도, 바로 사용할 수 있다. </li><li>어떠한 변화 없이 기능이 추가 되었기 때문에 이전 버전과의 호환성이 100%이다.</li><li>16.8.0 이후 버전에서 사용가능하다.</li></ul><blockquote><p>Hooks로 class를 대신할 수 있게됐지만, 리액트는 class를 제거할 계획이 없다고 밝혔다. 리액트에 대한 여러가지 컨셉(props, state, context, refs, and lifecycle)을 대체할 수 없는 대신, 더욱 직관적으로 제공한다고 한다.</p></blockquote><h2 id="Hooks가-나오게된-배경"><a href="#Hooks가-나오게된-배경" class="headerlink" title="Hooks가 나오게된 배경"></a>Hooks가 나오게된 배경</h2><h3 id="Component-사이에서-stateful-한-로직의-재사용이-어렵다"><a href="#Component-사이에서-stateful-한-로직의-재사용이-어렵다" class="headerlink" title="Component 사이에서 stateful 한 로직의 재사용이 어렵다."></a>Component 사이에서 stateful 한 로직의 재사용이 어렵다.</h3><ul><li>리액트는 컴포넌트에 재활용하는 방법인 “attach” 방법을 제공하지 않는다.</li><li>이런 문제들을 해결하기 위해 다양한 패턴이 사용되었다. (render propr, HOC …) 이런 패턴을 사용했을 때, 재구조화를 해야하고 이는 번거롭고 어려워질 수 있다. 또한 이런 패턴을 <code>DevTools</code> 에서 확인해 보면 wrapper 지옥에 빠져있는 수많은 컴포넌트를 볼 수 있다.</li><li>Hooks 는 컴포넌트로 부터 stateful 한 로직을 추출해 낼 수 있으며 이것은 의존성과 재사용성을 테스트할 수 있다. </li></ul><h3 id="이해하기-어려운-복잡한-컴포넌트"><a href="#이해하기-어려운-복잡한-컴포넌트" class="headerlink" title="이해하기 어려운 복잡한 컴포넌트"></a>이해하기 어려운 복잡한 컴포넌트</h3><ul><li>처음은 가벼운 컴포넌트였지만, 개발을 진행하다보면 수많은 side effects와 stateful 로직이 걷잡을 수 없이 많아진다.</li><li>각각의 라이프 사이클은 자주 연관성이 없는 로직을 섞어 사용하곤 한다. 예를 들어 컴포넌트는 <code>componentDidMount</code>와 <code>componentDidUpdate</code> 라이프사이클에서 데이터를 fetch 할 수 있다. 하지만 몇몇 <code>componentDidMount</code> 메소드는 이벤트를 설정하는 데 연관 없는 로직 들을 포함할 수 있으며 <code>componentWillUnmount</code>는 cleanup을 수행할 수도 있다. 함께 변경되는 관련 코드는 분리되지만 연관 없는 코드들은 단일 메소드로 결합한다. 이것은 버그와 무결성을 쉽게 발생시킨다.</li><li>많은 경우 컴포넌트들을 작게 만드는 것은 불가능하다. stateful 로직은 모든곳에 있기 때문이다. 또한 이것은 테스트하는 것도 어렵다. 이것이 사람들이 state 를 관리하는 라이브러리를 함께 사용하는것을 선호하는 이유중 하나이다. 그러나 너무 추상적이라고 소개하고 다른 파일 사이를 건너뛰는것을 요구하며 컴포넌트 재사용을 더욱 어렵게 만든다.</li><li>이러한 이슈들을 해결하기 위해 Hooks는 라이프사이클 메소드를 기초로한 분리에 초점을 맞추는 것보다는 컴포넌트들을 연관성을 기초로 더 작은 함수로 분리할 수 있게 한다.</li></ul><h3 id="사람과-기계를-혼란시키는-Classes"><a href="#사람과-기계를-혼란시키는-Classes" class="headerlink" title="사람과 기계를 혼란시키는 Classes"></a>사람과 기계를 혼란시키는 Classes</h3><ul><li>코드를 재사용성과 구조적으로 만드는 것은 어려울뿐만 아니라 리액트를 배울때 classes는 큰 진입장벽이다. 다른 대부분의 언어들과는 다른 Javascript가 어떻게 동작하는지 이해하고 있어야한다. 이벤트 핸들러는 항상 바인딩이 되어야 하는것을 기억해야 한다. 안정적인 문법의 제안이 없다면, 코드는 매우 장황해진다.</li><li>사람들은 props, state, 단방향 데이터 흐름에 대해 이해하고 있지만 여전히 classes는 어려워한다.</li><li>이러한 문제를 해결하기 위해서 Hooks는 classes 없이 리액트의 특징들을 사용할 수 있게 해준다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;리액트 16.8 버전에서 &lt;code&gt;Hooks&lt;/code&gt; 라는 새로운 기능이 추가 되었다.&lt;br&gt;해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.&lt;br&gt;이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 정의" scheme="https://kkangil.github.io/tags/hooks-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>Next.js with pm2 ecosystem</title>
    <link href="https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/"/>
    <id>https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/</id>
    <published>2019-04-17T15:29:19.000Z</published>
    <updated>2019-04-17T15:47:37.770Z</updated>
    
    <content type="html"><![CDATA[<p><code>Next.js</code>는 Client-Side-Rendering 을 사용하는 react가 아닌 <code>SSR(Server-Side-Rendering)</code> 방식을 사용하는 react framework 이다.<br>해당 글은 <code>Next.js</code>에서 배포시 참고하면 좋을 내용으로 <code>Next.js</code>가 뿐만 아니라 react, Node 에서도 사용 가능하다.</p><a id="more"></a><h2 id="pm2-ecosystem"><a href="#pm2-ecosystem" class="headerlink" title="pm2 ecosystem"></a>pm2 ecosystem</h2><p>pm2 ecosystem이란, 실행할 인스턴스의 설정을 JSON 형식으로 관리할 수 있고, pm2 에서 제공해 주는 option 을 보다 쉽게 관리 할수 있도록 도와준다. pm2 명령어로 직접 실행시킬 수 있지만, ecosystem을 사용함으로써 어떤 서버나 환경에서도 같은 설정을 사용해서 서버를 실행할 수 있다는 점이 장점이다.</p><ol><li>ecosystem.config.js 를 최상위 폴더에 생성한다.</li><li>작성방법</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  apps: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;chungeoram&quot;,</span><br><span class="line">      script: &quot;./server.js&quot;,</span><br><span class="line">      watch: true,</span><br><span class="line">      interpreter: &apos;/home/ubuntu/.nvm/versions/node/v8.11.3/bin/node&apos;,</span><br><span class="line">      &quot;env_public-develop&quot;: &#123;</span><br><span class="line">        NODE_ENV: &quot;public-develop&quot;,</span><br><span class="line">        PORT: 1111,</span><br><span class="line">        API_END_POINT: &apos;http://endpoint/api&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      env_production: &#123;</span><br><span class="line">        NODE_ENV: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name: pm2 에서 관리하는 이름</li><li>script: 앱을 구동할 경로</li><li>watch: 파일이 변경되면 자동으로 재시작 유무</li><li>ignore_watch: 배열안에 있는 리스트는 watch 대상에서 무시한다.</li><li>exec_mode: 클러스터 모드로 구동instances: 클러스터로 구동될시 몇개까지 구동할것인지 선택(0 : cpu갯수)</li><li>merge_logs: 클러스터로 구동할시 로그를 한파일에 기록</li><li>interpreter: 해석기 절대 경로(default: node)</li><li>log_date_format: 로그에 출력될 날짜와 시간값의 형식</li><li>error_file: 에러 파일 위치</li><li>out_file: 기본 출력 로그 위치</li><li>env_{value}<ul><li>value는 <code>process.env.NODE_ENV</code> 값과 매칭된다. 예를 들어 현재 <code>process.env.NODE_ENV</code>가 <code>public-develop</code> 일때, <code>env_public-develop</code> 내부의 값이 사용된다. 내부의 값들은 <code>process.env</code> 객체 내로 값이 할당되며, <code>process.env.PORT</code> , <code>process.env.API_END_POINT</code> 로 값을 배포 환경의 따라 다르게 사용가능하다.</li></ul></li></ul><ol start="3"><li>pm2 구동방법<br>package.json script에 명령어를 추가해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;pm2 start ecosystem.config.js --env production&quot;,</span><br><span class="line">    &quot;start-public&quot;: &quot;pm2 start ecosystem.config.js --env public-develop&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon server.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>$ yarn build → $ yarn start</li><li>app 빌드 후 명령어를 사용해서, pm2를 구동시켜 준다. pm2 start {파일이름} –env {value} 와 같은 형식으로 명령어를 추가한다. 여기서 환경변수는 ecosystem.config.js 의 env_{value}와 매칭 된다.</li></ul><h2 id="Next-js-에서-process-env-변수-사용-주의사항"><a href="#Next-js-에서-process-env-변수-사용-주의사항" class="headerlink" title="Next.js 에서 process.env 변수 사용 주의사항"></a>Next.js 에서 process.env 변수 사용 주의사항</h2><p><code>Next.config.js</code> 에서 <code>sass</code>, <code>webpack</code> 등의 처리 후 export 하는 과정에서, process.env 객체가 비어있는 문제를 발견했다. 하지만, api.js config.js 등 환경 변수에 따라 값을 변경해줘야 하기 때문에 process.env 객체가 비어있으면 안된다. 해당 문제를 처리하기 위해 Next.js 에서 <code>publicRuntimeConfig</code> 라는 옵션을 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const withSass = require(&apos;@zeit/next-sass&apos;)</span><br><span class="line">const withCSS = require(&apos;@zeit/next-css&apos;)</span><br><span class="line"></span><br><span class="line">const publicRuntimeConfig = &#123;</span><br><span class="line">  API_END_POINT: process.env.API_END_POINT,</span><br><span class="line">  NODE_ENV: process.env.NODE_ENV,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = withCSS(withSass(&#123;</span><br><span class="line">  publicRuntimeConfig,</span><br><span class="line">  webpack: config =&gt; &#123;</span><br><span class="line">    // Fixes npm packages that depend on `fs` module</span><br><span class="line">    config.node = &#123;</span><br><span class="line">      fs: &apos;empty&apos;,</span><br><span class="line">      module: &apos;empty&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>필요한 process.env 의 값을 <code>publicRuntimeConfig</code> 객체에 담아주고 Next.js 의 옵션 값에 할당해준다.할당해 주게되면, Next.js 의 config 값으로 저장되게 된다.이후 Next.js의 config 값을 불러오는 함수를 추가해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import getConfig from &apos;next/config&apos;;</span><br><span class="line"></span><br><span class="line">export const getNodeEnv = () =&gt; &#123;</span><br><span class="line">  const &#123; publicRuntimeConfig &#125; = getConfig();</span><br><span class="line"></span><br><span class="line">  const realNodeEnv = publicRuntimeConfig.NODE_ENV || process.env.NODE_ENV;</span><br><span class="line">  const apiEndPoint = publicRuntimeConfig.API_END_POINT;</span><br><span class="line"></span><br><span class="line">  return &#123; realNodeEnv, apiEndPoint &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>해당 함수는 Next.js의 config에서 publicRuntimeConfig 를 가져와 return 해준다.이제 process.env 환경변수를 사용하고 싶다면, process.env.API_END_POINT 와 같이 직접적으로 사용하는것이 아닌, 해당 함수를 사용해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import config from &apos;./config&apos;</span><br><span class="line">import &#123; getNodeEnv &#125; from &apos;@/utils/env&apos;</span><br><span class="line"></span><br><span class="line">const env = getNodeEnv()</span><br><span class="line">const endPoint = env.apiEndPoint || config.apiEndPoint</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  AUTH_TOKEN: &#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    path: () =&gt; `$&#123;endPoint&#125;/auth/authenticate-token`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Next.js&lt;/code&gt;는 Client-Side-Rendering 을 사용하는 react가 아닌 &lt;code&gt;SSR(Server-Side-Rendering)&lt;/code&gt; 방식을 사용하는 react framework 이다.&lt;br&gt;해당 글은 &lt;code&gt;Next.js&lt;/code&gt;에서 배포시 참고하면 좋을 내용으로 &lt;code&gt;Next.js&lt;/code&gt;가 뿐만 아니라 react, Node 에서도 사용 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="Deploy" scheme="https://kkangil.github.io/categories/Deploy/"/>
    
    
      <category term="Next.js" scheme="https://kkangil.github.io/tags/Next-js/"/>
    
      <category term="deploy Next.js" scheme="https://kkangil.github.io/tags/deploy-Next-js/"/>
    
      <category term="pm2" scheme="https://kkangil.github.io/tags/pm2/"/>
    
      <category term="pm2-ecosystem" scheme="https://kkangil.github.io/tags/pm2-ecosystem/"/>
    
  </entry>
  
  <entry>
    <title>Deep clone</title>
    <link href="https://kkangil.github.io/2019/04/18/Deep-clone/"/>
    <id>https://kkangil.github.io/2019/04/18/Deep-clone/</id>
    <published>2019-04-17T15:01:31.000Z</published>
    <updated>2019-04-17T15:35:10.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a>이슈</h2><ol><li>react에서 setState를 하지 않았음에도 state가 변경되는 현상</li><li>api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상</li></ol><p>react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.<br>해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.<br>해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; a: 1, b: 2 &#125;</span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state = &#123;...this.state&#125;;</span><br><span class="line">  state[e.target.name] = e.target.value;</span><br><span class="line">  this.setState(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 본인이 input 의 onChange 이벤트 함수로 거의 복붙하면서 변형없이 사용하는 이벤트 함수이다.<br>최근 state 변수 선언 즉, state 객체를 복사하고 사용하는 과정에 있어 동일한 이슈가 많이 발생하고 있어, 해당 함수를 단순히 복사하는것이 아닌 이해가 필요하고 상황에 따라 변형해서 사용해야할 필요있다.</p><h2 id="Object-copy"><a href="#Object-copy" class="headerlink" title="Object copy"></a>Object copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;...this.state&#125;</span><br></pre></td></tr></table></figure><p>state 변수는 react state 객체를 복사한것이다. 해당 문법은 es9 문법으로 특정 값만 바꿀때 유용하다.<br>해당 문법의 es5 버전은 .assign() 메소드이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;&#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object3 = Object.assign(&#123; c: 3 &#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object4 = Object.assign(&#123;&#125;, object1);</span><br><span class="line">object4.a = 100</span><br><span class="line"></span><br><span class="line">const object5 = &#123;...object1&#125;</span><br><span class="line">object5.a = 100</span><br><span class="line"></span><br><span class="line">console.log(object2.a); //100</span><br><span class="line">console.log(object2.b); //2</span><br><span class="line">console.log(object3.a); //100</span><br><span class="line">console.log(object3.b); //2</span><br><span class="line">console.log(object3.c); //3</span><br><span class="line">console.log(object4.a); //100</span><br><span class="line">console.log(object5.a); //100</span><br></pre></td></tr></table></figure><ul><li>object2 : 빈 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object3: c: 3 값이 담겨있는 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object4: 현재 우리 회사에서 사용하는 handleChange를 es5로 바꾼 방법</li><li>object5: Spread syntax(…) es8 문법사용<br>하지만 state 내부에 객체를 변경하려고 할때 문제가 발생한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state &#123;...this.state&#125;</span><br><span class="line">  state.b.c = 3</span><br><span class="line">  this.setState(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2단계 이상 깊이의 object는 복사가 원활하지 않는것을 확인할 수 있다. 복사본의 값을 변경했는데 원본의 값도 변경되는 알수 없는 현상이 발생한다.<br>MDN: 깊은 클로닝에 대해서, Object.assign() 은 속성의 값을 복사하기때문에 다른 대안을 사용해야합니다. 출처 값이 객체에 대한 참조인 경우, 참조 값만을 복사합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(&#123;&#125;, org);</span><br><span class="line">obj.a.b = 100; </span><br><span class="line">console.log(obj.a.b);  //expected: 2 but actual: 100</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;...org&#125;;</span><br><span class="line">obj2.a.b = 100; </span><br><span class="line">console.log(org.a.b);  //expected: 2 but actual: 100</span><br></pre></td></tr></table></figure><p>해당 현상은 깊은 클로닝(deep cloning) 방식을 사용해야한다.<br>객체 복사 방식 변경 : 객체를 string 으로 변경하고 다시 파싱해주는 방법</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = JSON.parse(JSON.stringify(org)); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br><span class="line">lodash 메소드 사용</span><br><span class="line">import _ from &apos;lodash&apos;; const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = _.cloneDeep(org); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br></pre></td></tr></table></figure><h2 id="Array-copy"><a href="#Array-copy" class="headerlink" title="Array copy"></a>Array copy</h2><p>2단계 이상 깊이의 배열을 복사할때는 맵을 사용해서 객체 하나하나 복사해준 후 return 해주는 방식을 사용해서 에러발생을 막아야합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    a: [&#123;</span><br><span class="line">      b: 1</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">      b: 2</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj1 = &#123;...org&#125;</span><br><span class="line">const arr = org.obj.a // x</span><br><span class="line"></span><br><span class="line">const arr2 = org.obj.a.map(row =&gt; &#123;</span><br><span class="line">return &#123;...row&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>참고<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;이슈&quot;&gt;&lt;a href=&quot;#이슈&quot; class=&quot;headerlink&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;이슈&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;react에서 setState를 하지 않았음에도 state가 변경되는 현상&lt;/li&gt;
&lt;li&gt;api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.&lt;br&gt;해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.&lt;br&gt;해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://kkangil.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://kkangil.github.io/tags/Javascript/"/>
    
      <category term="syntax" scheme="https://kkangil.github.io/tags/syntax/"/>
    
      <category term="deep-clone" scheme="https://kkangil.github.io/tags/deep-clone/"/>
    
  </entry>
  
  <entry>
    <title>리액트 라이프사이클</title>
    <link href="https://kkangil.github.io/2019/04/17/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/"/>
    <id>https://kkangil.github.io/2019/04/17/리액트-라이프사이클/</id>
    <published>2019-04-17T14:48:33.000Z</published>
    <updated>2019-04-17T15:34:52.842Z</updated>
    
    <content type="html"><![CDATA[<p>React를 사용하기 전 <code>라이프사이클</code>에 대해 확실하게 알고 사용하는 것이 좋다.<br><code>라이프사이클</code> 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.<br>github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.<a href="https://github.com/kkangil/react-lifecycle" target="_blank" rel="noopener">code 보기</a></p><a id="more"></a><h2 id="주요-라이프사이클"><a href="#주요-라이프사이클" class="headerlink" title="주요 라이프사이클"></a>주요 라이프사이클</h2><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><ul><li>렌더가 된 이후 실행되는 라이프사이클로 최초 API 요청 사용에 적합한 라이프 사이클</li></ul><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><ul><li>component 의 상태값이 변경되었을때 render 직전에 호출되는 라이프 사이클</li><li>Boolean 값을 return 해야하며, false 를 return 하면 렌더를 하지 않음.</li><li>렌더를 하지 않으므로 이후 라이프사이클도 먹히지 않음.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><ul><li>component가 DOM 에서 삭제(해당 컴포넌트 미표시)할때 마지막으로 실행되는 메소드</li><li>interval 이나 비동기 API 제거에 주로 쓰임.</li></ul><h2 id="16-3-이후-변경된-라이프사이클"><a href="#16-3-이후-변경된-라이프사이클" class="headerlink" title="16.3 이후 변경된 라이프사이클"></a>16.3 이후 변경된 라이프사이클</h2><ul><li>렌더링 제어에 많은 방법이 있기때문에 라이프사이클 사용에 혼란이 생김.</li><li>실제 커뮤니티에서도 어떤 라이프사이클이 좋다 안좋다 성능 이슈가 많음. 대표적으로 componentWillMount 와 componentDidMount 둘중 어떤 라이프사이클에서 API를 호출해야하는지.</li><li>향후 componentWillMount, componentWillReceiveProps, componentWillUpdate 라이프사이클이 삭제되고 <code>UNSAFE_</code> 라이프사이클만 동작할것이라고 예고</li><li>이를 대체하기 위해 새로운 라이프사이클 추가</li></ul><h3 id="라이프사이클-동작-순서"><a href="#라이프사이클-동작-순서" class="headerlink" title="라이프사이클 동작 순서"></a>라이프사이클 동작 순서</h3><ul><li>최초 진입: <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code> 순으로 실행.</li><li>props 변경: <code>getDerivedStateFromProps</code> -&gt; <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li><li>state 변경: <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li></ul><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><ul><li>componentDidMount 보다 먼저 실행</li><li>window 객체 접근 가능(storage 사용 가능)</li><li>props 와 state가 변경되었을때는 최초 실행</li><li>파리미터로 변경될 props 와 state가 넘어옴. this.state 접근 불가능</li><li>return 되는 객체값으로 state 가 변경된다. (해당 라이프사이클에서는 state 변경만 해주는것이 바람직하다고 판단됨.) state를 변경해주고 싶지 않을때에는 null 을 return 해주면된다.</li><li>최초 페이지 진입시 <code>componentDidMount</code> 라이프사이클에서 fetch 실행</li><li>react 공식문서에서는 props 가 변경되었을때 fetch가 필요하다면 해당 라이프사이클에서 API(data fetching) 요청 하는것이 아닌 <code>componentDidUpdate</code> 라이프 사이클에서 fetch 하도록 유도하고 있음.</li></ul><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><ul><li><code>componentWillUpdate</code> 의 대체 라이프사이클</li><li>DOM이 업데이트 되기 직전이 실행</li><li><code>componentDidUpdate</code> 전에 실행되며 해당 라이프사이클의 return 값이 componentDidUpdate 3번째 파라미터로 전달됨.</li><li>기존 <code>componentWillUpdate</code> 와 같이 해당 라이프사이클 안에서 this.setState()를 사용하는 경우 무한루프에 빠지게 됨.</li><li>자주 사용되지는 않을것으로 판단됨.</li></ul><h2 id="Error-Boundary"><a href="#Error-Boundary" class="headerlink" title="Error Boundary"></a>Error Boundary</h2><ul><li>렌더 과정에서 에러가 생겼을경우 앱이 죽는것이 아니라 UI 변경과 같은 대안으로 앱이 죽지 않도록 하는 방식</li><li>해당 class를 최상단에 두고 라이프사이클을 이용해서 조작할 수 있다.</li></ul><h3 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError"></a>getDerivedStateFromError</h3><ul><li>16.6 버전에 추가된 라이프 사이클</li><li>해당 라이프 사이클은 렌더 중에 호출되며 fallback UI를 렌더링 하기 위한 메소드이다.</li><li>렌더 중에 호출되기 때문에 side effect(API call, 함수 호출) 을 사용하지 않는것이 좋다.</li><li>react 공식 문서에서는 componentDidCatch 라이프 사이클을 추천한다.</li><li>return 객체는 state 가 해당 객체로 변경된다.</li></ul><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><ul><li>해당 라이프사이클은 에러를 기록하거나 트래킹하기 위한 작업을 위해 주로 사용된다. (ex Sentry)</li><li>해당 라이프 사이클에서도 state 를 변경하여 UI 를 변경해줄수 있지만 추천되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React를 사용하기 전 &lt;code&gt;라이프사이클&lt;/code&gt;에 대해 확실하게 알고 사용하는 것이 좋다.&lt;br&gt;&lt;code&gt;라이프사이클&lt;/code&gt; 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.&lt;br&gt;github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.&lt;a href=&quot;https://github.com/kkangil/react-lifecycle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code 보기&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://kkangil.github.io/tags/React/"/>
    
      <category term="lifecycle" scheme="https://kkangil.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kkangil.github.io/2019/04/17/hello-world/"/>
    <id>https://kkangil.github.io/2019/04/17/hello-world/</id>
    <published>2019-04-17T11:51:34.545Z</published>
    <updated>2019-04-17T15:35:24.643Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><table><thead><tr><th>설정</th><th>설명</th><th>기본 값</th></tr></thead><tbody><tr><td>layout</td><td>레이아웃</td><td></td></tr><tr><td>title</td><td>타이틀</td><td></td></tr><tr><td>date</td><td>발행일</td><td>파일이 생성된 날짜</td></tr><tr><td>updated</td><td>갱신일</td><td>파일이 업로드된 날짜</td></tr><tr><td>tags</td><td>태그 (page에서는 사용 불가능)</td><td></td></tr><tr><td>categories</td><td>카테고리 (page에서는 사용 불가능)</td><td></td></tr><tr><td>permalink</td><td>포스트의 기본 permalink를 override합니다.</td><td></td></tr><tr><td>comments</td><td>포스트에서 comment 기능을 사용할지 여부</td><td>true</td></tr></tbody></table><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://kkangil.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://kkangil.github.io/tags/hexo/"/>
    
      <category term="hexo 시작" scheme="https://kkangil.github.io/tags/hexo-%EC%8B%9C%EC%9E%91/"/>
    
  </entry>
  
</feed>
