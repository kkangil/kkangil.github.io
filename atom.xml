<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkangil&#39;s Blog</title>
  
  <subtitle>kkangil&#39;s develop Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkangil.github.io/"/>
  <updated>2020-02-09T09:01:38.657Z</updated>
  <id>https://kkangil.github.io/</id>
  
  <author>
    <name>kkangil</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jest 메서드 - globals</title>
    <link href="https://kkangil.github.io/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/"/>
    <id>https://kkangil.github.io/2020/02/09/jest-메서드-globals/</id>
    <published>2020-02-09T08:01:54.000Z</published>
    <updated>2020-02-09T09:01:38.657Z</updated>
    
    <content type="html"><![CDATA[<p>Jest 제공 메서드들 중 Globals 메서드에 대해서 정리해보려 한다. Jest 공식 문서에 나와 있는 Globals 메서드 정의는 다음과 같다.</p><blockquote><p>Globals 메서드를 사용해서 전역 환경을 설정한다. 이것은 필수로 설정해 줄 필요는 없다.</p></blockquote><a id="more"></a><h3 id="afterAll-fn-timeout"><a href="#afterAll-fn-timeout" class="headerlink" title="afterAll(fn, timeout)"></a>afterAll(fn, timeout)</h3><p>이름에서 유추할 수 있듯이 테스트가 진행되는 동안 매번 실행되는 것이 아니라 모든 테스트가 완료 되었을 때 실행된다. 만약 인자의 함수가 Promise 이거나 generator 일 경우, Jest 는 완료를 기다린다.</p><p>다른 테스트와 공유되는 전역 환경 상태를 초기화 할때 주로 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">function cleanUpDatabase(db) &#123;</span><br><span class="line">  db.cleanUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterAll(() =&gt; &#123;</span><br><span class="line">  cleanUpDatabase(globalDatabase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트가 모두 완료될 때 실행된다.</p><h3 id="afterEach-fn-timeout"><a href="#afterEach-fn-timeout" class="headerlink" title="afterEach(fn, timeout)"></a>afterEach(fn, timeout)</h3><p>afterAll 메서드와 달리 afterEach는 하나의 테스트가 완료될 때마다 실행된다. 각 테스트에 의해 생성된 임시 상태 또는 변수를 초기화 하는 경우 주로 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">function cleanUpDatabase(db) &#123;</span><br><span class="line">  db.cleanUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterEach(() =&gt; &#123;</span><br><span class="line">  cleanUpDatabase(globalDatabase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 완료될 때 실행된다.</p><h3 id="beforeAll-fn-timeout"><a href="#beforeAll-fn-timeout" class="headerlink" title="beforeAll(fn, timeout)"></a>beforeAll(fn, timeout)</h3><p>afterAll과 정반대라고 생각하면 된다. 이 메서드는 테스트가 실행되기전 최초에 한번 실행된다. 각 테스트를 진행하기 위해 데이터를 설정해 줄때 주로 사용된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">beforeAll(() =&gt; &#123;</span><br><span class="line">  // Clears the database and adds some testing data.</span><br><span class="line">  // Jest will wait for this promise to resolve before running tests.</span><br><span class="line">  return globalDatabase.clear().then(() =&gt; &#123;</span><br><span class="line">    return globalDatabase.insert(&#123;testData: &apos;foo&apos;&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트를 하기전에 실행된다.</p><h3 id="beforeEach-fn-timeout"><a href="#beforeEach-fn-timeout" class="headerlink" title="beforeEach(fn, timeout)"></a>beforeEach(fn, timeout)</h3><p>하나의 테스트가 시작되기 전에 실행된다. descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 시작되기 전 실행된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">beforeEach(() =&gt; &#123;</span><br><span class="line">  // Clears the database and adds some testing data.</span><br><span class="line">  // Jest will wait for this promise to resolve before running tests.</span><br><span class="line">  return globalDatabase.clear().then(() =&gt; &#123;</span><br><span class="line">    return globalDatabase.insert(&#123;testData: &apos;foo&apos;&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>중복된 코드를 제거할때 유용하게 사용할 수 있다.</p><h3 id="describe-name-fn"><a href="#describe-name-fn" class="headerlink" title="describe(name, fn)"></a>describe(name, fn)</h3><p>describe 메서드는 몇몇의 관계가 있는 테스트들을 그룹으로 묶어 생성할 때 사용한다. test 메서드를 최상위에서 바로 실행시킬 수 있지만, describe 메서드로 관련있는 테스트 끼리 묶어서 작성하게 되면 가독성이 높아진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const myBeverage = &#123;</span><br><span class="line">  delicious: true,</span><br><span class="line">  sour: false,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(&apos;my beverage&apos;, () =&gt; &#123;</span><br><span class="line">  test(&apos;is delicious&apos;, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(&apos;is not sour&apos;, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>describe 메서드 함수 내부에서 다시 describe로 그룹화를 할 수 있다.</p><h3 id="describe-each-table-name-fn-timeout"><a href="#describe-each-table-name-fn-timeout" class="headerlink" title="describe.each(table)(name, fn, timeout)"></a>describe.each(table)(name, fn, timeout)</h3><p>여러가지 다른 데이터로 중복되는 테스트를 수행할때 describe.each를 활용할 수 있다. 하나의 테스트 케이스로  값이 다른 데이터들로 테스를 수행하는 것이다.</p><ul><li>table: 인자로 배열을 넘기면 fn 함수의 인자로 사용 가능하다.</li><li>name: 테스트의 이름 printf formatting 기법을 사용할 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe.each([</span><br><span class="line">  [1, 1, 2],</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  [2, 1, 3],</span><br><span class="line">])(&apos;.add(%i, %i)&apos;, (a, b, expected) =&gt; &#123;</span><br><span class="line">  test(`returns $&#123;expected&#125;`, () =&gt; &#123;</span><br><span class="line">    expect(a + b).toBe(expected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(`returned value not be greater than $&#123;expected&#125;`, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeGreaterThan(expected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(`returned value not be less than $&#123;expected&#125;`, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeLessThan(expected);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>describe.each<code>table</code> 형식으로도 사용 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe.each`</span><br><span class="line">  a    | b    | expected</span><br><span class="line">  $&#123;1&#125; | $&#123;1&#125; | $&#123;2&#125;</span><br><span class="line">  $&#123;1&#125; | $&#123;2&#125; | $&#123;3&#125;</span><br><span class="line">  $&#123;2&#125; | $&#123;1&#125; | $&#123;3&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><h3 id="describe-only-name-fn"><a href="#describe-only-name-fn" class="headerlink" title="describe.only(name, fn)"></a>describe.only(name, fn)</h3><p>오직 하나의 describe 그룹의 테스트만 수행하고 싶을 때 사용한다. 다른 describe 테스트들은 skip 된다.<br><code>describe.only.each</code> 메서드도 사용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe.only(&apos;my beverage&apos;, () =&gt; &#123;</span><br><span class="line">  test(&apos;is delicious&apos;, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(&apos;is not sour&apos;, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(&apos;my other beverage&apos;, () =&gt; &#123;</span><br><span class="line">  // ... will be skipped</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="describe-skip-name-fn"><a href="#describe-skip-name-fn" class="headerlink" title="describe.skip(name, fn)"></a>describe.skip(name, fn)</h3><p>특정한 describe 그룹을 테스트 하고 싶지 않을때 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;my beverage&apos;, () =&gt; &#123;</span><br><span class="line">  test(&apos;is delicious&apos;, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(&apos;is not sour&apos;, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe.skip(&apos;my other beverage&apos;, () =&gt; &#123;</span><br><span class="line">  // ... will be skipped</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>describe.skip.each(table)(name, fn)</code> 메서드도 사용가능하다.</p><h3 id="test-name-fn-timeout"><a href="#test-name-fn-timeout" class="headerlink" title="test(name, fn, timeout)"></a>test(name, fn, timeout)</h3><p>test 메서드를 사용하여 테스트를 수행할 수 있다. Promise나 비동기 방법을 지원한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;did not rain&apos;, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBe(0);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(&apos;has lemon in it&apos;, () =&gt; &#123;</span><br><span class="line">  return fetchBeverageList().then(list =&gt; &#123;</span><br><span class="line">    expect(list).toContain(&apos;lemon&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="test-each-table-name-fn-timeout"><a href="#test-each-table-name-fn-timeout" class="headerlink" title="test.each(table)(name, fn, timeout)"></a>test.each(table)(name, fn, timeout)</h3><p>describe.each(table)(name, fn, timeout)와 개념은 동일하다. 하지만 describe는 그룹화이기 때문에 여러가지 테스트를 동시에 수행할 수 있지만 test.each는 단일 테스트에 대한 each 이다.</p><h3 id="test-only-name-fn-timeout"><a href="#test-only-name-fn-timeout" class="headerlink" title="test.only(name, fn, timeout)"></a>test.only(name, fn, timeout)</h3><p>describe.only 와 개념은 동일하다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.only(&apos;it is raining&apos;, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBeGreaterThan(0);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(&apos;it is not snowing&apos;, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfSnow()).toBe(0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>오직 한가지의 test만 수행되며 describe 내부의 test들도 수행되지 않는다.</p><p><code>test.only.each(table)(name, fn)</code> 메서드도 사용할 수 있다.</p><h3 id="test-skip-name-fn"><a href="#test-skip-name-fn" class="headerlink" title="test.skip(name, fn)"></a>test.skip(name, fn)</h3><p>수행하고 싶지 않은 테스트를 건너뛰게 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(&apos;it is raining&apos;, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBeGreaterThan(0);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test.skip(&apos;it is not snowing&apos;, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfSnow()).toBe(0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>test.skip.each(table)(name, fn)</code> 도 사용가능하다.</p><h3 id="test-todo-name"><a href="#test-todo-name" class="headerlink" title="test.todo(name)"></a>test.todo(name)</h3><p>추가되어야할 테스트 TODO를 남겨놓을 수 있다. 해당 메서드를 사용하면 다른 테스트들과 달리 강조되어 표시된다. 인자로 callback을 넘기면 에러가 발생한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const add = (a, b) =&gt; a + b;</span><br><span class="line"></span><br><span class="line">test.todo(&apos;add should be associative&apos;);</span><br></pre></td></tr></table></figure><p>참조: <a href="https://jestjs.io/docs/en/api" target="_blank" rel="noopener">Jest 공식 문서</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jest 제공 메서드들 중 Globals 메서드에 대해서 정리해보려 한다. Jest 공식 문서에 나와 있는 Globals 메서드 정의는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Globals 메서드를 사용해서 전역 환경을 설정한다. 이것은 필수로 설정해 줄 필요는 없다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Jest" scheme="https://kkangil.github.io/categories/Jest/"/>
    
    
      <category term="jest globals 메서드" scheme="https://kkangil.github.io/tags/jest-globals-%EB%A9%94%EC%84%9C%EB%93%9C/"/>
    
      <category term="describe" scheme="https://kkangil.github.io/tags/describe/"/>
    
      <category term="test" scheme="https://kkangil.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>성능을 높이는 코드 스타일</title>
    <link href="https://kkangil.github.io/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/"/>
    <id>https://kkangil.github.io/2020/02/09/성능을-높이는-코드-스타일/</id>
    <published>2020-02-09T05:58:17.000Z</published>
    <updated>2020-02-09T07:24:53.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체의-생성-초기화-성능"><a href="#객체의-생성-초기화-성능" class="headerlink" title="객체의 생성, 초기화 성능"></a>객체의 생성, 초기화 성능</h2><p>많이 사용하지만 성능을 생각하지 않고 작성하는 코드에 객체 선언과 초기화 구문이 있다. 배열(Array) 형식의 객체와 오브젝트(Object) 형식의 객체를 생성하고 초기화하는 방법의 성능을 측정해 보고 두 코드 사이에 어떤 차이점이 있는지 비교해 보고자 한다.</p><h3 id="배열의-생성-초기화-성능-비교"><a href="#배열의-생성-초기화-성능-비교" class="headerlink" title="배열의 생성, 초기화 성능 비교"></a>배열의 생성, 초기화 성능 비교</h3><p>배열을 생성자 혹인 리터럴([]) 형식을 사용해 객체를 생성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Array() 생성자 사용</span><br><span class="line">var arr = new Array();</span><br><span class="line"></span><br><span class="line">// 리터럴 형식으로 배열 생성</span><br><span class="line">var arr = [];</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>성능 비교 방법은 <a href="http://jindo.dev.naver.com/jsMatch/index.html" target="_blank" rel="noopener">http://jindo.dev.naver.com/jsMatch/index.html</a> 사이트를 이용한다. (Chrome 79 버전 기준)</p></blockquote><p>두 방법의 성능을 비교한 결과는 생성자를 사용했을때는 0.111s, 리터럴 형식으로 사용했을 경우 0.100s 의 시간이 걸렸다.</p><p>배열을 사용하려면 배열의 각 요소에 데이터를 할당해 초기화해야한다.<br>배열의 각 요소에 데이터를 할당하는 방법에도 여러가지가 있다. 그 가운데 가장 많이 볼 수 있는 방법인 접근자 []를 사용하는 방법과 push() 메서드를 사용하는 방법의 성능을 비교한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 접근자 사용</span><br><span class="line">var arr = [];</span><br><span class="line">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// push() 메서드 사용</span><br><span class="line">var arr = [];</span><br><span class="line">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과: 접근자 사용 0.100s / push 사용 0.123s</p><p>push 메서드를 사용하는것 보다 접근자를 사용하는 것이 빠르다는 것을 확인할 수 있다. 배열의 생성과 초기화 방법을 비교한 결과, 배열을 사용할 때는 리터럴 형식으로 객체를 생성하고 Array.push() 메서드보다 접근자 []를 사용해 데이터를 추가하는 코드를 작성하는 것이 좀 더 최적화된 배열 사용법이라는 사실을 확인할 수 있다.</p><h3 id="오브젝트-Object-객체의-생성-초기화-성능-비교"><a href="#오브젝트-Object-객체의-생성-초기화-성능-비교" class="headerlink" title="오브젝트(Object) 객체의 생성, 초기화 성능 비교"></a>오브젝트(Object) 객체의 생성, 초기화 성능 비교</h3><p>오브젝트(Object) 객체도 배열처럼 객체를 생성하고 초기화하는 다양한 방법이 있다. 가장 많이 사용하는 방법인 리터럴({})을 사용하는 방법과 생성자를 사용하는 방법의 성능을 테스트해보고 어떤 방법으로 객체를 생성하고 초기화하는 것이 효과적인지 살펴보고자 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 리터럴 사용</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 생성자 사용</span><br><span class="line">var obj = new Object();</span><br></pre></td></tr></table></figure><p>결과: 리터럴 사용 0.104s / 생성자 사용 0.100s</p><p>배열과 다르게 생성자를 사용하는 것이 시간이 적게 걸리지만 차이가 적으므로 어떤 방법이 성능이 월등히 좋다고 판가름하기 어렵다. 리터럴 형식이 코드 크기를 좀 더 줄일 수 있는 방법이기 때문에 코드를 다운로드 하는 시간 관점에서 성능에 더 좋다고 볼 수는 있다.</p><p>객체 초기화 방법에는 연산자를 이용한 데이터 삽입과 []를 이용한 데이터 삽입이 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 연산자 이용</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.a = 1;</span><br><span class="line">obj.b = 2;</span><br><span class="line">obj.c = 3;</span><br><span class="line">obj.d = 4;</span><br><span class="line">obj.e = 5;</span><br><span class="line">obj.f = 6;</span><br><span class="line">obj.g = 7;</span><br><span class="line">obj.h = 8;</span><br><span class="line">obj.i = 9;</span><br><span class="line">obj.j = 10;</span><br><span class="line"></span><br><span class="line">// [] 이용</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj[&quot;a&quot;] = 1;</span><br><span class="line">obj[&quot;b&quot;] = 2;</span><br><span class="line">obj[&quot;c&quot;] = 3;</span><br><span class="line">obj[&quot;d&quot;] = 4;</span><br><span class="line">obj[&quot;e&quot;] = 5;</span><br><span class="line">obj[&quot;f&quot;] = 6;</span><br><span class="line">obj[&quot;g&quot;] = 7;</span><br><span class="line">obj[&quot;h&quot;] = 8;</span><br><span class="line">obj[&quot;i&quot;] = 9;</span><br><span class="line">obj[&quot;j&quot;] = 10;</span><br></pre></td></tr></table></figure><p>결과: 연산자 이용 0.102s / [] 이용 0.100s</p><p>Object 객체에 데이터를 삽입하는 초기화 방법에 대한 성능 테스트 결과도 Object 객체 생성에 대한 테스트 결과와 유사헀다. 객체의 초기화도 생성과 마찬가지로 한 가지 방식이 더 성능이 좋다고 판단할 수 없으며, 작성하는 코드의 크기와 주요 대상 브라우저 및 코드의 가독성과 유지 보수를 감안해 적절한 방식을 택하면 되겠다.</p><h2 id="스코프-체인-탐색과-성능"><a href="#스코프-체인-탐색과-성능" class="headerlink" title="스코프 체인 탐색과 성능"></a>스코프 체인 탐색과 성능</h2><p>자바스크립트 성능을 다루는 책에서 항상 빠지지 않는 부분이 스코프 체인이다. 개발자가 작성한 코드 자체의 성능이 런타임 성능에도 많은 영향을 준다. 런타임 환경에서 가장 많이 발생하는 브라우저의 작업 가운데 자바스크립트의 실행 성능을 저해하는 요인이 변수, 객체, 함수 등의 메모리상의 위치를 찾는 <code>탐색 작업</code>이다.</p><h3 id="스코프-체인이란"><a href="#스코프-체인이란" class="headerlink" title="스코프 체인이란?"></a>스코프 체인이란?</h3><p>자바스크립트의 함수를 실행하면서 어떤 속성(변수, 객체 등)에 접근해야 할 때 해당 속성을 효율적으로 탐색하도록 속성을 일정한 객체 단위로 분류하고 각 객체에 접근하기 위한 객체의 참조를 특정한 공간에 저장해 둔다. 이 공간이 바로 스코프 체인이다.</p><p>스코프 체인의 구성 요소에는 활성화 객체와 전역 객체가 있다. 함수에서 접근할 수 있는 모든 속성 가운데 함수 내부에서만 접근할 수 있는 함수의 지역변수나 this, arguments 객체 등의 속성은 스코프 체인의 활성화 객체에 포함돼 관리 된다. 함수 외부에서도 접근할 수 있는 window, document, 전역함수, 전역변수와 같은 속성은 스코프 체인의 전역 객체에 포함돼 관리 된다.<br>전역 객체는 자바스크립트 동작시 어디서나 항상 접근 가능한 데이터를 포함하고 있기 때문에 동작하는 모든 시간 동안 존재하지만, 활성화 객체는 실행 중인 함수 내부 데이터를 포함하기 때문에 함수가 실행되는 동안에만 존재한다.</p><p>실행 문맥(Execution Context)은 <code>함수가 동작하는 환경</code>을 나타내며, 브라우저 내부에서 사용되는 객체다. 실행 문맥은 함수가 실행될 때 새로 생성되고  함수가 종료될 때 소멸되며 함수의 스코프 체인에 대한 참조를 가지고 있게 된다. 실행 문맥은 자신과 연관된 함수의 스코프 체인을 참조하고 있으며, 함수에서 접근해야할 어떤 속성의 탐색 경로는 실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체 &gt; 스코프 체인 &gt; 전역 객체 와 같이 구성된다.</p><h3 id="지역변수를-활용한-스코프-체인-탐색-성능-개선"><a href="#지역변수를-활용한-스코프-체인-탐색-성능-개선" class="headerlink" title="지역변수를 활용한 스코프 체인 탐색 성능 개선"></a>지역변수를 활용한 스코프 체인 탐색 성능 개선</h3><p>스코프 체인의 탐색 방법을 살펴보면 여러 개의 활성화 객체와 전역 객체를 탐색하면서 접근하려는 속성이 있는지 확인하는 과정이 반복된다. 그렇다면 첫 번째로 탐색하는 활성화 객체에 찾고자 하는 속성이 있는 경우 추가로 발생할 수 있는 다른 활성화 객체, 전역 객체를 탐색하는 과정을 줄여 성능을 향상시킬 수 있을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 함수 내에서 전역 스코프 변수에 직접 접근하는 방법</span><br><span class="line">window.htmlstring = [];</span><br><span class="line">function makeList () &#123;</span><br><span class="line">  htmlstring.push(&quot;&lt;ul&gt;&quot;);</span><br><span class="line">  for (var i =0; i &lt; 100; i++) &#123;</span><br><span class="line">    htmlstring.push(`&lt;li&gt;value: $&#123;i&#125;&lt;/li&gt;`);</span><br><span class="line">  &#125;</span><br><span class="line">  htmlstring.push(&quot;&lt;/ul&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeList();</span><br><span class="line"></span><br><span class="line">// 지역변수로 참조해 전역 스코프 변수에 접근하는 방법</span><br><span class="line">window.htmlstring = [];</span><br><span class="line">function makeList () &#123;</span><br><span class="line">  var htmlstr = htmlstring;</span><br><span class="line">  htmlstr.push(&quot;&lt;ul&gt;&quot;);</span><br><span class="line">  for (var i =0; i &lt; 100; i++) &#123;</span><br><span class="line">    htmlstr.push(`&lt;li&gt;value: $&#123;i&#125;&lt;/li&gt;`);</span><br><span class="line">  &#125;</span><br><span class="line">  htmlstr.push(&quot;&lt;/ul&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeList();</span><br></pre></td></tr></table></figure><p>결과: 전역 스코프 변수 접근 0.119s / 지역변수 참조 0.100s</p><p>전역 객체에 존재하는 htmlstring 속성을 makeList() 함수의 지역변수에 저장해 활성화 객체에서 바로 찾을 수 있게 한것이다. 최초 한 번은 활성화 객체와 전역 객체를 모두 탐색해야한다. 하지만 그 이후에는 활성화 객체에 저장된 htmlstr 속성으로 전역변수인 htmlstring 객체에 접근할 수 있으니 활성화 객체를 거쳐 전역 객체까지 탐색할 필요가 없어진다.</p><h2 id="반복문과-성능"><a href="#반복문과-성능" class="headerlink" title="반복문과 성능"></a>반복문과 성능</h2><p>자바스크립트의 반복문인 for, for-in, while, do-while 구문에도 성능 차이가 있다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 성능 테스트 전에 배열 초기화</span><br><span class="line">arr = [];</span><br><span class="line">for (var i=0; i &lt; 400; i++) &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// for</span><br><span class="line">for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// for-in</span><br><span class="line">for (var i in arr) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// while</span><br><span class="line">var i = 0, len = arr.length;</span><br><span class="line">while (i &lt; len) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// do-while</span><br><span class="line">var i = 0, len = arr.length;</span><br><span class="line">do &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">  i++;</span><br><span class="line">&#125; while (i &lt; len);</span><br></pre></td></tr></table></figure><p>결과: for 0.113s / for-in 0.505s / while 0.108s / do-while 0.100s</p><p>for-in의 성능이 압도적으로 떨어지는 것을 확인할 수 있다. for-in 이외의 반복문은 주어진 배열 객체를 배열의 특성에 맞게 순차적으로 모든 요소를 탐색한다. 반면 for-in 구문은 인자로 주어진 배열을 배열이 아닌 일반 객체로 취급하며, 반복 시점마자 객체의 모든 속성을 무작위로 탐색한다. 이러한 탐색 방법의 차이로 다른 반복문에 비해 배열 탐색에서 현저하게 느리다.</p><h2 id="조건문과-성능"><a href="#조건문과-성능" class="headerlink" title="조건문과 성능"></a>조건문과 성능</h2><p>반복문만큼이나 조건문 또한 자바스크립트를 포함한 프로그래밍 전반에서 필수적으로 사용하는 요소다. 자바스크립트에는 if, if-else, switch, 삼항연산자 등의 조건문이 있다.</p><h3 id="조건문의-성능-비교"><a href="#조건문의-성능-비교" class="headerlink" title="조건문의 성능 비교"></a>조건문의 성능 비교</h3><p>먼저 true와 false만 판단하는 최소한의 조건 분기를 처리하는 코드로 if, switch, 삼항연산자의 성능을 측정했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// if-else</span><br><span class="line">function toEnglish(value) &#123;</span><br><span class="line">  var number = &quot;zero&quot;;</span><br><span class="line">  if (value === 1) &#123;</span><br><span class="line">    number = &quot;one&quot;;</span><br><span class="line">  &#125; else if (value === 2) &#123;</span><br><span class="line">    number = &quot;two&quot;;</span><br><span class="line">  &#125; else if (value === 3) &#123;</span><br><span class="line">    number = &quot;three&quot;;</span><br><span class="line">  &#125; else if (value === 4) &#123;</span><br><span class="line">    number = &quot;four&quot;;</span><br><span class="line">  &#125; else if (value === 5) &#123;</span><br><span class="line">    number = &quot;five&quot;;</span><br><span class="line">  &#125; else if (value === 6) &#123;</span><br><span class="line">    number = &quot;six&quot;;</span><br><span class="line">  &#125; else if (value === 7) &#123;</span><br><span class="line">    number = &quot;seven&quot;</span><br><span class="line">  &#125; else if (value === 8) &#123;</span><br><span class="line">    number = &quot;eight&quot;;</span><br><span class="line">  &#125; else if (value === 9) &#123;</span><br><span class="line">    number = &quot;nine&quot;;</span><br><span class="line">  &#125; else if (value === 10) &#123;</span><br><span class="line">    number = &quot;ten&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    number = &quot;null&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0; i &lt; 12; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// switch-case</span><br><span class="line">function toEnglish(value) &#123;</span><br><span class="line">  var number = &quot;zero&quot;;</span><br><span class="line">  switch(value) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      number = &quot;one&quot;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      number = &quot;two&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      number = &quot;three&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 4: </span><br><span class="line">      number = &quot;four&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 5:</span><br><span class="line">      number = &quot;five&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 6:</span><br><span class="line">      number = &quot;six&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 7:</span><br><span class="line">      number = &quot;seven&quot;</span><br><span class="line">      break;</span><br><span class="line">    case 8:</span><br><span class="line">      number = &quot;eight&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 9:</span><br><span class="line">      number = &quot;nine&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 10:</span><br><span class="line">      number = &quot;ten&quot;;</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      number = &quot;null&quot;;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0; i &lt; 12; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 삼항연산자</span><br><span class="line">function toEnglish(value) &#123;</span><br><span class="line">  var number = false;</span><br><span class="line">  number = (value === 1) ?</span><br><span class="line">    &quot;one&quot; : (value === 2) ?</span><br><span class="line">    &quot;two&quot; : (value === 3) ?</span><br><span class="line">    &quot;three&quot; : (value === 4) ?</span><br><span class="line">    &quot;four&quot; : (value === 5) ?</span><br><span class="line">    &quot;five&quot; : (value === 6) ?</span><br><span class="line">    &quot;six&quot; : (value === 7) ?</span><br><span class="line">    &quot;seven&quot; : (value === 8) ?</span><br><span class="line">    &quot;eight&quot; : (value === 9) ?</span><br><span class="line">    &quot;nine&quot; : (value === 10) ?</span><br><span class="line">    &quot;ten&quot; : &quot;null&quot;;</span><br><span class="line">  </span><br><span class="line">  return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0; i &lt; 12; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과: if-else 0.111s / switch 0.111s / 삼항연산자 0.100s</p><p>조건의 개수가 많지 않으므로 조건문 사이에 별다른 성능 차이가 없다. 단지, 일반적으로 조건 판단 요소가 많아질수록 switch-case 구문의 성능이 좀 더 좋다는 점은 알아두는 것이 좋다.</p><h2 id="문자열-연산과-성능"><a href="#문자열-연산과-성능" class="headerlink" title="문자열 연산과 성능"></a>문자열 연산과 성능</h2><h3 id="문자열-생성-비교"><a href="#문자열-생성-비교" class="headerlink" title="문자열 생성 비교"></a>문자열 생성 비교</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// String 객체 이용</span><br><span class="line">var str = new String(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">// 리터럴 이용</span><br><span class="line">var str = &quot;test&quot;;</span><br></pre></td></tr></table></figure><p>결과: String 객체 0.103s / 리터럴 이용 0.100s</p><p>측정한 시간이 지극히 짧지만 String 객체보다는 리터럴을 사용하는 것이 좋다.</p><h3 id="문자열-연산-성능-비교"><a href="#문자열-연산-성능-비교" class="headerlink" title="문자열 연산 성능 비교"></a>문자열 연산 성능 비교</h3><p>여러가지 데이터를 조합해 긴 문자열을 생성해야 할 때가 많다. 이때 가장 많이 사용하는 방법이 +, += 연산자를 이용하거나 Array.join() 메서드를 이용하는 방법이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// += 연신자</span><br><span class="line">str = &quot;&quot;;</span><br><span class="line">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">  str += &quot;test&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Array.join</span><br><span class="line">arr = [];</span><br><span class="line">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">  arr[i] = &quot;test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">arr.join(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>결과: += 연산자 0.398s / Array.join 0.100s</p><p>Array.join() 메서드를 이용하는것이 월등한 성능을 낸다는 것을 확인할 수 있다. += 연산자는 두 문자열을 합친 새로운 문자열을 만들고 새로운 메모리 위치에 저장함과 동시에 기존 문자열에 대한 참조를 변경하는 연산을 반복적으로 실행해야 한다. 하지만 Array.join() 메서드로 연산하면 비교적 메모리에 효율적으로 접근할 수 있는 배열을 사용한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>배열은 리터럴([])방식으로 생성하고 push() 메서드가 아닌 접근자([])로 데이터를 할당하는 코드의 성능이 더 좋다.</li><li>객체는 어떤 방식이든지 비슷한 성능을 낸다. 가독성과 유지보수의 편리성을 고려해 적절한 방식으로 사용하면 된다.</li><li>반복문 가운데 for-in의 성능이 월등히 낮다.</li><li>조건문의 종류에 따른 성능 차이는 거의 없지만 조건이 많아지면 switch-case 성능이 좀 더 좋다.</li><li>문자열을 연산할 때는 += 연산자 보다는 Array.join()을 이용하는 방법이 더 좋다.</li></ul><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2" target="_blank" rel="noopener">자바스크립트 성능 이야기</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;객체의-생성-초기화-성능&quot;&gt;&lt;a href=&quot;#객체의-생성-초기화-성능&quot; class=&quot;headerlink&quot; title=&quot;객체의 생성, 초기화 성능&quot;&gt;&lt;/a&gt;객체의 생성, 초기화 성능&lt;/h2&gt;&lt;p&gt;많이 사용하지만 성능을 생각하지 않고 작성하는 코드에 객체 선언과 초기화 구문이 있다. 배열(Array) 형식의 객체와 오브젝트(Object) 형식의 객체를 생성하고 초기화하는 방법의 성능을 측정해 보고 두 코드 사이에 어떤 차이점이 있는지 비교해 보고자 한다.&lt;/p&gt;
&lt;h3 id=&quot;배열의-생성-초기화-성능-비교&quot;&gt;&lt;a href=&quot;#배열의-생성-초기화-성능-비교&quot; class=&quot;headerlink&quot; title=&quot;배열의 생성, 초기화 성능 비교&quot;&gt;&lt;/a&gt;배열의 생성, 초기화 성능 비교&lt;/h3&gt;&lt;p&gt;배열을 생성자 혹인 리터럴([]) 형식을 사용해 객체를 생성할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Array() 생성자 사용&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var arr = new Array();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 리터럴 형식으로 배열 생성&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var arr = [];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="웹 성능 이야기" scheme="https://kkangil.github.io/categories/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%95%BC%EA%B8%B0/"/>
    
    
      <category term="웹 사이트 최적화" scheme="https://kkangil.github.io/tags/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    
      <category term="성능 테스트" scheme="https://kkangil.github.io/tags/%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>기본적인 웹 사이트 최적화 방법</title>
    <link href="https://kkangil.github.io/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/"/>
    <id>https://kkangil.github.io/2020/02/02/기본적인-웹-사이트-최적화-방법/</id>
    <published>2020-02-02T07:57:35.000Z</published>
    <updated>2020-02-02T08:56:37.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-요청-최소화"><a href="#HTTP-요청-최소화" class="headerlink" title="HTTP 요청 최소화"></a>HTTP 요청 최소화</h2><p>HTTP 요청 최소화는 최적화에서 가장 기본이면서도 중요한 부분이다. 웹 사이트는 주로 마크업, 이미지, 스타일시트, 자바스크립트 등으로 구성된다. 각 구성 요소는 모두 웹 서버에 있다. 이 구성 요소를 사용자의 컴퓨터로 가져오는 데는 네트워크 비용이 든다. 네트워크 비용은 곧 응답 시간으로 이어진다. 그러므로 다운로드 해야 하는 구성 요소의 개수를 줄이는 것은 가장 효과가 크고 중요한 최적화 방법이다.</p><a id="more"></a><h3 id="CSS-스프라이트"><a href="#CSS-스프라이트" class="headerlink" title="CSS 스프라이트"></a>CSS 스프라이트</h3><p>순수한 HTML 마크업만으로는 표현에 한계가 있기 때문에 어쩔 수 없이 이미지를 사용한다. 하지만 이미지를 많이 사용하면 HTTP 요청이 많아질 수 밖에 없다. 이미지를 많이 사용하면서도 HTTP 요청을 최소화하는 방법 가운데 하나가 CSS 스프라이트 기법이다.</p><p>CSS 스프라이트 기법은 이미지 여러 개를 하나로 만들고 스타일시트에서 <code>background-position</code> 속성을 설정해 필요한 부분의 이미지만 보여 주는 기술이다. 여러 이미지를 하나의 이미지로 합치기 때문에 HTTP 요청 횟수를 줄일 수 있고, 이미지의 컬러 테이블과 같은 메타데이터를 하나로 합칠 수 있어 파일 크기가 줄어든다.</p><p>CSS 스프라이트 기법은 이미지를 관리하기 어렵고 웹 접근성을 나쁘게 하는 요소가 있다는 단점이 있다. 하지만 많은 양의 이미지를 사용한다면 많은 시간을 줄일 수 있다.</p><h3 id="헤더에-만료-날짜-추가"><a href="#헤더에-만료-날짜-추가" class="headerlink" title="헤더에 만료 날짜 추가"></a>헤더에 만료 날짜 추가</h3><p>헤더에 만료 날짜를 추가하는 이유는 웹 페이지를 구성하는 여러 요소들을 사용자의 컴퓨터의 캐시에 저장해서 재사용하기 위해서다. 사용자가 처음 웹 페이지에 방문하면 만료 날짜가 설정된 요소를 사용자 컴퓨터에 저장한다. 이후 같은 웹 페이지에 다시 방문하면 유효한 요소는 서버에 요청하지 않고 사용자 컴퓨터에서 바로 읽어 온다.</p><h4 id="사용자-컴퓨터에-저장된-캐시-파일"><a href="#사용자-컴퓨터에-저장된-캐시-파일" class="headerlink" title="사용자 컴퓨터에 저장된 캐시 파일"></a>사용자 컴퓨터에 저장된 캐시 파일</h4><p>캐시에 저장된 파일에는 만료 날짜가 없는 파일도 있고 만료 날짜가 있는 파일도 있다. 모든 구성 요소에 무조건 만료 날짜를 설정하는 것이 아니라 특정 기간까지 변경되지 않아도 서비스에 문제가 없는 요소에만 적용해야 한다.<br>만약 만료 날짜 전에 수정 사항이 있어 파일을 변경해야 한다면 파일 이름을 변경하거나 파일 이름 뒤에 쿼리스트링을 추가해 새로 추가된 파일임을 알려야 바로 반영된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 파일 이름을 변경</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;test_0202.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 쿼리스트링 추가</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;test?0202.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>브라우저에서 캐싱된 파일을 이용할지 서버에 요청할지 판단하는 기준은 컬럼 이름을 기준으로 이름과 인터넷 주소다. 그렇기 때문에 파일 이름이나 파일의 주소를 바꾸지 않으면 계속 같은 파일로 인식하고 사용자 컴퓨터에 있는 파일을 로딩한다.</p><h4 id="자바스크립트-파일-통합"><a href="#자바스크립트-파일-통합" class="headerlink" title="자바스크립트 파일 통합"></a>자바스크립트 파일 통합</h4><p>기능이 향상됨에 따라 자바스크립트 파일은 개수도 많아지고 크기도 커지고 있다. 이럴 때 성능을 높이는 방법은 여러 개의 자바스크립트 파일을 하나의 파일로 합쳐 파일 개수를 최소화하는 것이다. 웹 사이트의 성능을 개선할 때는 파일의 용량보다 파일의 개수가 중요하다. 아주 용량이 작은 파일이라도 원격 서버에서 가져와야 한다면 네트워크 비용이 든다.</p><h3 id="파일-크기-최소화"><a href="#파일-크기-최소화" class="headerlink" title="파일 크기 최소화"></a>파일 크기 최소화</h3><h4 id="Gzip-압축을-이용한-파일-크기-최소화"><a href="#Gzip-압축을-이용한-파일-크기-최소화" class="headerlink" title="Gzip 압축을 이용한 파일 크기 최소화"></a>Gzip 압축을 이용한 파일 크기 최소화</h4><p>점점 커지는 자바스크립트 파일과 스타일시트 파일의 크기를 줄이는 가장 효과적이고 쉬운 방법은 파일을 압축하는 것이다. 아파치 웹 서버에서 파일을 압축하는 대표적인 인코딩 방식에는 Gzip과 deflate 두 가지가 있는데, deflate 방식은 지원하지 않는 브라우저가 많고 효과도 떨어지기 때문에 대부분 Gzip 방식을 사용한다.</p><h5 id="압축-전송-흐름-및-확인"><a href="#압축-전송-흐름-및-확인" class="headerlink" title="압축 전송 흐름 및 확인"></a>압축 전송 흐름 및 확인</h5><p>압축 전송은 다음과 같은 순서로 진행된다. 클라이언트에서 some.js 라는 파일을 만났을 때를 가정해보자.</p><ol><li>클라이언트에서 헤더 정보로 인코딩 여부를 물어본다.<blockquote><p>Accept-Encoding: gzip, deflate (Header)</p></blockquote></li><li>서버에서 헤더 정보로 인코딩 여부를 알려준다. 인코딩된 요소라면 다음과 같이 응답이 온다.<blockquote><p>Content-Encoding: gzip</p></blockquote></li><li>클라이언트에서 인코딩된 요소를 받음과 동시에 압축을 해제한다. 이때 추가적인 CPU 연산 비용이 들어간다. 여기서 발생하는 CPU 연산 비용도 무시할 수 없기 때문에 압축할 파일과 크기를 잘 설정해야한다. 보통 스타일시트 파일과 자바스크립트 파일을 압축한다. 그리고 파일 크기가 작으면 속도 개선 효과보다 CPU 연산 비용이 더 들기 때문에 파일 크기가 일정한 크기 이상인 경우에만 압축하는 것이 좋다. 파일 크기가 1~2KB 이상일때 압축할 것을 권장한다.</li></ol><h4 id="압축-전송의-효과"><a href="#압축-전송의-효과" class="headerlink" title="압축 전송의 효과"></a>압축 전송의 효과</h4><p>Gzip으로 압축해 전송하면 평균 70% 정도 파일 크기가 작아지는 효과를 볼 수 있다. 모바일 환경과 같이 네트워크 환경이 불안한 상황에서는 더욱 효과적인 기술일 것이다.<br>파일의 공백 및 주석을 제거하고 Gzip 으로 압축을 진행하면 파일 크기를 최소화 시킬 수 있다.</p><h3 id="쿠키-크기-최소화"><a href="#쿠키-크기-최소화" class="headerlink" title="쿠키 크기 최소화"></a>쿠키 크기 최소화</h3><p>필요한 정보를 저장하는 가장 손쉬운 방법이 최상위 도메인을 이용해 쿠키를 설정하는 방법이다. 이렇게 되면 자바스크립트 파일이나 스타일시트, 이미지등 쿠키 정보가 필요 없는 구성 요소를 요청할 때도 헤더 정보에 쿠키가 포함된다. 즉 헤더를 전송할 때 데이터 크기가 커진다.</p><p>쿠키의 크기를 줄이는 기본적인 방법</p><ul><li>지속적인 관리로 사용하지 않는 쿠키는 삭제한다.</li><li>쿠키를 설정할 때 최상위 도메인은 되도록 사용하지 않는다.</li><li>쿠키 정보가 필요없는 파일은 별도의 도메인으로 서비스한다.</li></ul><hr><h2 id="렌더링-성능-향상"><a href="#렌더링-성능-향상" class="headerlink" title="렌더링 성능 향상"></a>렌더링 성능 향상</h2><p>전체적인 로딩 속도는 동일한데 빈 페이지가 계속 보이다 갑자기 콘텐츠가 나타나는 페이지가 있고, 처음부터 콘텐츠가 조금씩 보이며 화면이 빠르게 나타나는 페이지가 있다. 렌더링 성능 향상의 목표는 페이지를 요청했을 때 사용자가 대기하는 시간을 최대한 줄여서 이 체감 속도를 높이는 것이다.</p><h3 id="브라우저-파싱-순서"><a href="#브라우저-파싱-순서" class="headerlink" title="브라우저 파싱 순서"></a>브라우저 파싱 순서</h3><ol><li><p>HTML 파싱과 DOM 트리 구성<br>사용자가 페이지를 요청하면 네트워크를 통해 마크업을 받아 온다. 그 후 마크업 문자열을 토큰 형태로 잘라서 트리를 구축하고 파싱 작업을 시작한다. 그런 다음 DOM 트리를 생성한다.</p></li><li><p>렌더트리 구성(DOM + 스타일규칙)<br>DOM 트리를 생성한 다음 바로 화면을 그리지는 않는다. 스타일시트의 정보를 적용해야 하기 떄문이다. DOM 트리 정보와 스타일시트의 스타일 규칙을 결합해 렌더 트리를 만든다. display:none 속성처럼 DOM 트리에는 있지만 화면에 보이면 안되는 요소를 걸러낸 결과가 렌더 트리다.</p></li><li><p>렌더 트리의 배치<br>스타일 규칙에 따라 각 요소를 화면의 어디에 배치할지 좌표를 설정한다.</p></li><li><p>렌더 트리 그리기<br>요소의 좌표가 설정되면 브라우저에 순차적으로 화면에 그린다. 이때 사용자는 화면을 조금씩 보게 된다.</p></li></ol><h3 id="스타일시트와-자바스크립트-배치를-이용한-성능-향상"><a href="#스타일시트와-자바스크립트-배치를-이용한-성능-향상" class="headerlink" title="스타일시트와 자바스크립트 배치를 이용한 성능 향상"></a>스타일시트와 자바스크립트 배치를 이용한 성능 향상</h3><p>스타일시트 파일은 페이지 제일 위쪽에, 자바스크립트 파일은 페이지 맨 아래쪽에 놓아야 한다.<br>브라우저 렌더링 단계에 따르면 사용자에게 화면을 보여 주기 전에 렌더 트리를 생성해야 하는데, 이때 스타일시트 파일이 반드시 필요하다. 스타일시트 파일을 최대한 빨리 다운로드 해야 하는 이유다.</p><p>자바스크립트 파일을 페이지 아래에 놓아야 하는 가장 큰 이유는 파일을 다운로드해서 실행하기 전까지 브라우저가 DOM 파싱도 중지하고 아무것도 렌더링하지 않기 때문이다. 자바스크립트에는 document.write() 메서드가 있어 마크업을 렌더링하는 도중에도 DOM을 추가할 수 있다. 이로 인해 이미 필요한 구성 요소를 모두 브라우저에 가져왔음에도 자바스크립트를 수행하느라 렌더링이 멈추게 된다. 이때 사용자에게는 마치 화면이 멈춘 것처럼 보여 체감 속도가 느려진다.</p><h3 id="초기-렌더링시-AJAX-요청-최소화"><a href="#초기-렌더링시-AJAX-요청-최소화" class="headerlink" title="초기 렌더링시 AJAX 요청 최소화"></a>초기 렌더링시 AJAX 요청 최소화</h3><p>동적인 웹 사이트에서 화면을 그리는 단계는 일반적으로 다음과 같다.</p><ol><li>사용자가 페이지를 요청</li><li>마크업을 다운로드해 렌더링 시작 (화면을 구성하는 레이아웃만 있고 실제로 보여줄 데이터는 나중에 AJAX 요청을 통해 받은 다음 그려야함)</li><li>자바스크립트 다운로드와 렌더링이 끝난 후 onload 이벤트가 발생</li><li>onload 이벤트가 발생한 다음에 AJAX 통신을 실행하고 데이터를 화면에 그린다.</li><li>화면 완성</li></ol><p>이 과정에는 두 가지 큰 문제점이 있다. AJAX 통신을 사용하지 않는 방법으로 페이지를 개발했다면 3번 단계에서 사용자는 화면을 보게 된다. 그런데 5번 단계가지 가서야 사용자는 최종 화면을 볼 수 있다. 또 다른 문제는 렌더링이 반복된다는 것이다. 1~3번 단계까지 전체 화면을 한 번 그리고 4~5번 단계에서 화면을 한 번 더 그린다.</p><p>초기 렌더링 시에 마크업 전체를 서버에서 보내는 방식으로 개발하여 체감 속도를 높일 수 있다. 1~3 단계에서 전체 화면과 데이터가 있는 화면을 모두 그리는 것이다. 그리고 사용자의 행동이 있을 때 AJAX 요청을 실행해서 데이터를 받은 다음 화면을 그리게 한다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2" target="_blank" rel="noopener">자바스크립트 성능 이야기</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-요청-최소화&quot;&gt;&lt;a href=&quot;#HTTP-요청-최소화&quot; class=&quot;headerlink&quot; title=&quot;HTTP 요청 최소화&quot;&gt;&lt;/a&gt;HTTP 요청 최소화&lt;/h2&gt;&lt;p&gt;HTTP 요청 최소화는 최적화에서 가장 기본이면서도 중요한 부분이다. 웹 사이트는 주로 마크업, 이미지, 스타일시트, 자바스크립트 등으로 구성된다. 각 구성 요소는 모두 웹 서버에 있다. 이 구성 요소를 사용자의 컴퓨터로 가져오는 데는 네트워크 비용이 든다. 네트워크 비용은 곧 응답 시간으로 이어진다. 그러므로 다운로드 해야 하는 구성 요소의 개수를 줄이는 것은 가장 효과가 크고 중요한 최적화 방법이다.&lt;/p&gt;
    
    </summary>
    
      <category term="웹 성능 이야기" scheme="https://kkangil.github.io/categories/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%95%BC%EA%B8%B0/"/>
    
    
      <category term="웹 사이트 최적화" scheme="https://kkangil.github.io/tags/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    
      <category term="HTTP 요청 최소화" scheme="https://kkangil.github.io/tags/HTTP-%EC%9A%94%EC%B2%AD-%EC%B5%9C%EC%86%8C%ED%99%94/"/>
    
      <category term="렌더링 성능 향상" scheme="https://kkangil.github.io/tags/%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81/"/>
    
  </entry>
  
  <entry>
    <title>도구 다루기-3</title>
    <link href="https://kkangil.github.io/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/"/>
    <id>https://kkangil.github.io/2020/02/02/도구-다루기-3/</id>
    <published>2020-02-02T05:36:43.000Z</published>
    <updated>2020-02-02T07:54:54.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="의존성-주입이란"><a href="#의존성-주입이란" class="headerlink" title="의존성 주입이란?"></a>의존성 주입이란?</h2><p>ConferenceWebSvc 객체에 서비스를 캡슐화하고 메시지를 화면에 표시할 자바스크립트 객체 Messenger를 작성한다.</p><p>참가자는 1인당 세션을 10개까지 등록할 수 있다. 참가자가 한 세션을 등록하면 그 결과를 성공/실패 메시지로 화면에 표시하는 함수를 개발해야 한다. 아래 코드는 해당 기능을 구현하기 위한 초기 버전이다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Attendee = function (attendeeId) &#123;</span><br><span class="line">  // &apos;new&apos;로 생성하도록 강제</span><br><span class="line">  if (!(this instanceof Attendee)) &#123;</span><br><span class="line">    return new Attendee(attendeeId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.attendeeId = attendeeId;</span><br><span class="line">  this.service = new ConferenceWebSvc();</span><br><span class="line">  this.messenger = new Messenger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 주어진 세션에 좌석 예약을 시도하고 성공/실패 여부를 메시지로 알려줌.</span><br><span class="line">Attendee.prototype.reserve = function (sessionId) &#123;</span><br><span class="line">  if (this.service.reserve(this.attendeeId, sessionId)) &#123;</span><br><span class="line">    this.messenger.success(</span><br><span class="line">      `좌석 예약이 완료되었습니다! 고객님은 $&#123;this.service.getRemainingReservations()&#125; 좌석을 추가로 예약하실 수 있습니다.`</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.messenger.failure(&apos;죄송합니다. 해당 좌석은 예약하실 수 없습니다.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 ConferenceWebSvc, Messenger, Attendee 객체가 각자 자신만의 임무를 갖고 모듈로 조화를 이룬것 처럼 보인다. Attendee.reserve는 너무 간단해서 굳이 단위 테스트를 하지 않아도 되는데, 어차피 그럴 수도 없다. ConferenceWebSvc 내부에는 HTTP 호출이 있다. Messenger는 메시지마다 OK 버튼이 있어야 하는데, 이 또한 이 모듈에서 단위 테스트할 대상은 아니다. 단위 테스트는 자바스크립트 코드를 바르게 작성하기 위한 핵심인데, 모든 단위가 미처 준비도 되기 전에 시스템 테스트의 늪으로 빠지는 게 싫다.</p><p>요는, Attendee 객체가 아니라 이 객체가 의존하는 코드다. 의존성을 주입하는 식으로 바꾸면 해결할 수 있다. 즉, ConferenceWebSvc와 Messenger와의 의존성을 하드 코딩하지 말고 이들을 Attendee에 주입하는 것이다. 실제 운영 환경에서는 진짜 의존성을 주입하겠지만, 단위 테스트용으로는 모의체(fake)나 재스민 스파이 같은 대체제를 주입하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 운영 환경:</span><br><span class="line">var attendee: new Attendee(new ConferenceWebSvc(), new Messenger(), id);</span><br><span class="line"></span><br><span class="line">// 개발 환경:</span><br><span class="line">var attendee = new Attendee(fakeService, fakeMessenger, id);</span><br></pre></td></tr></table></figure><p>이처럼 의존성을 주입하는 것을 두고 ‘빈자의 의존성 주입’이라 한다. 아래 코드는 빈자의 의존성 주입 방식으로 작성한 Attendee 객체다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Attendee = function (service, messenger, attendeeId) &#123;</span><br><span class="line">  // &apos;new&apos;로 생성하도록 강제</span><br><span class="line">  if (!(this instanceof Attendee)) &#123;</span><br><span class="line">    return new Attendee(attendeeId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.attendeeId = attendeeId;</span><br><span class="line">  this.service = service;</span><br><span class="line">  this.messenger = messenger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="의존성을-주입하여-믿음직한-코드-만들기"><a href="#의존성을-주입하여-믿음직한-코드-만들기" class="headerlink" title="의존성을 주입하여 믿음직한 코드 만들기"></a>의존성을 주입하여 믿음직한 코드 만들기</h2><p>의존성을 주입하여 다른 방법으로는 할 수 없는 단위 테스트를 어떻게 하는지 알았다. 아무래도 테스트를 통과한, 자동화한 테스트 꾸러미로 계속 테스트할 수 있는 코드가 더 믿음직하다. 이 뿐만 아니라, 의존성 주입은 실제 객체보다 주입한 스파이나 모의 객체에 더 많은 제어권을 안겨주므로 다양한 에러 조건과 기이한 상황을 만들어내기 쉽다.</p><p>의존성 주입은 코드 재사용을 적극적으로 유도한다. 의존성을 품은, 하드 코딩한 모듈은 보통 재사용하기 어렵다. 초기 Attendee 모듈도 Messenger를 하드 코딩하여 쓴 탓에 서버 측에서 재사용할 수 없었다. 의존성 주입으로 바꾼 다음에는 성공/실패 메서드만 있으면 어떤 messenger 라도 사용할 수 있다.</p><h2 id="의존성-주입의-모든-것"><a href="#의존성-주입의-모든-것" class="headerlink" title="의존성 주입의 모든 것"></a>의존성 주입의 모든 것</h2><p>의존성 주입은 어렵지 않다. 몇 가지 개념만 기억하면 잘 활용할 수 있다.<br>어떤 객체를 코딩하든 어떤 객체를 생성하든 스스로 다음 질문을 해봤을때 한 가지라도 답변이 ‘예’ 라면 직접 인스턴스화 하지 말고 주입하는 방향으로 생각을 전환해야 한다.</p><ul><li>객체 또는 의존성 중 어느 하나라도 DB, 설정 파일, HTTP, 기타 인프라 등의 외부 자원에 의존 하는가</li><li>객체 내부에서 발생할지 모를 에러를 테스트에서 고려해야 하나</li><li>특정한 방향으로 객체를 작동시켜야 할 테스트가 있는가</li><li>서드파티 제공 객체가 아니라 온전히 내가 소유한 객체인가</li></ul><h2 id="경량급-의존성-주입-프레임워크-개발"><a href="#경량급-의존성-주입-프레임워크-개발" class="headerlink" title="경량급 의존성 주입 프레임워크 개발"></a>경량급 의존성 주입 프레임워크 개발</h2><p>지금까지는 의존성 주입을 하드 코딩했다. 전문가다운 의존성 주입 프레임워크는 이렇게 작동한다.</p><ol><li>애플리케이션이 시작되자마자 각 인젝터블(주입 가능한 모든 의존성을 집합적으로 일컫는 말) 명을 확인하고 의존성을 지칭하며 순서대로 DI 컨테이너에 등록한다.</li><li>객체가 필요하면 컨테이너에 요청한다.</li><li>컨테이너는 일단 요청받은 객체와 그 의존성을 모두 재귀적으로 인스턴스화한다. 그리고 요건에 따라 필요한 객체에 각각 주입한다.</li></ol><p>컨테이너는 인젝터블과 의존성을 등록하고 요청시 객체를 내어주는 두 가지 일을 한다. register 함수의 인자는 세 가지를 받는다.</p><ul><li>인젝터블 명</li><li>의존성 명을 담은 배열</li><li>인젝터블 객체를 반환하는 함수. 인젝터블 인스턴스를 요청하면 컨테이너는 이 함수를 호출하여 반환 값을 다시 그대로 반환한다.</li></ul><p>TDD는 단계마다 가급적 조금씩 코딩하는게 좋다. 먼저 빈 DiContainer와 register 함수를 생성한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = function(name, dependencies, func) &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;DiContainer&apos;, function () &#123;</span><br><span class="line">  var container;</span><br><span class="line">  beforeEach(function () &#123;</span><br><span class="line">    container = new DiContainer();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  describe(&apos;register(name,dependencies,func)&apos;, function () &#123;</span><br><span class="line">    it(&apos;인자가 하나라도 빠졌거나 타입이 잘못되면 예외를 던진다.&apos;, function () &#123;</span><br><span class="line">      var badArgs = [</span><br><span class="line">        // 인자가 아예 없는 경우</span><br><span class="line">        [],</span><br><span class="line">        [&apos;Name&apos;],</span><br><span class="line">        [&apos;Name&apos;, [&apos;Dependency1&apos;, &apos;Dependency2&apos;]],</span><br><span class="line">        [&apos;Name&apos;, function () &#123; &#125;],</span><br><span class="line">        // 타입이 잘못된 경우</span><br><span class="line">        [1, [&apos;a&apos;, &apos;b&apos;], function () &#123; &#125;],</span><br><span class="line">        [&apos;Name&apos;, [1, 2], function () &#123; &#125;],</span><br><span class="line">        [&apos;Name&apos;, [&apos;a&apos;, &apos;b&apos;], &apos;should be a function&apos;]</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      badArgs.forEach(function (args) &#123;</span><br><span class="line">        expect(function () &#123;</span><br><span class="line">          container.register.apply(container, args);</span><br><span class="line">        &#125;).toThrowError(container.messages.registerRequiresArgs);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>container는 ‘테스트 대상’으로 beforeEach에서 생성된다. 테스트마다 인스턴스를 갓 구워내면 다른 테스트의 결과를 어지럽히지 않아도 된다.</li><li>TDD 순수주의자는 badArgs 원소마다 테스트를 따로 만들라고 하겠지만, 실제로 그렇게까지 개발자에게 부담을 주면 필요한 조건을 모두 테스트하기도 전에 질려버릴지도 모른다.</li></ul><p>위의 테스트는 당연히 실패한다. DiContainer에 수정이 필요하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = function () &#123;</span><br><span class="line">  if (!(this instanceof DiContainer)) &#123;</span><br><span class="line">    return new DiContainer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.messages = &#123;</span><br><span class="line">  registerRequiresArgs: &apos;이 생성자 함수는 인자가 3개 있어야 합니다. 문자열, 문자열 배열, 함수&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = function (name, dependencies, func) &#123;</span><br><span class="line">  var ix;</span><br><span class="line"></span><br><span class="line">  if (</span><br><span class="line">    typeof name !== &apos;string&apos; ||</span><br><span class="line">    !Array.isArray(dependencies) ||</span><br><span class="line">    typeof func !== &apos;function&apos;</span><br><span class="line">  ) &#123;</span><br><span class="line">    throw new Error(this.messages.registerRequiresArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (ix = 0; ix &lt; dependencies.length; ++ix) &#123;</span><br><span class="line">    if (typeof dependencies[ix] !== &apos;string&apos;) &#123;</span><br><span class="line">      throw new Error(this.messages.registerRequiresArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>register 함수는 여전히 아무 일도 하지 않지만, 이 함수만으로는 의존성을 다시 끌어낼 방법이 없으므로 컨테이너에 의존성이 잘 들어갔는지 테스트하기 어렵다. 따라서 자연스레 나머지 반쪽 그림에 해당하는 get 함수에 관심이 쏠린다. 이 함수의 유일한 인자는 조회할 의존성 명이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DiContainer.prototype.get = function (name) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(&apos;get(name)&apos;, function () &#123;</span><br><span class="line">    it(&apos;성명이 등록되어 있지 않으면 undefined를 반환한다.&apos;, function () &#123;</span><br><span class="line">      expect(container.get(&apos;notDefined&apos;)).toBeUndefined();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>이제 get 함수 작성과 DiContainer 를 수정한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = function () &#123;</span><br><span class="line">  ...</span><br><span class="line">  this.registrations = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = function (name, dependencies, func) &#123;</span><br><span class="line">  ...</span><br><span class="line">  this.registrations[name] = &#123; func: func &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.get = function (name) &#123;</span><br><span class="line">  var registration = this.registrations[name];</span><br><span class="line">  if (registration === undefined) &#123;</span><br><span class="line">    return undefined;</span><br><span class="line">  &#125;</span><br><span class="line">  return registration.func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it(&apos;등록된 함수를 실행한 결과를 반환한다.&apos;, function () &#123;</span><br><span class="line">  var name = &apos;MyName&apos;,</span><br><span class="line">    returnFromRegisteredFunction = &quot;something&quot;;</span><br><span class="line"></span><br><span class="line">  container.register(name, [], function () &#123;</span><br><span class="line">    return returnFromRegisteredFunction;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(container.get(name)).toBe(returnFromRegisteredFunction);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이제 get은 자신이 반환하는 객체에 의존성을 제공할 수 있다. 아래 코드는 1개의 메인 객체와 2개의 의존성을 등록하는 테스트로, 메인 객체는 두 의존성의 반환값을 합한 값을 반환한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DiContainer.prototype.register = function (name, dependencies, func) &#123;</span><br><span class="line">  ...</span><br><span class="line">  this.registrations[name] = &#123; dependencies: dependencies, func: func &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.get = function (name) &#123;</span><br><span class="line">  var self = this,</span><br><span class="line">    registration = this.registrations[name],</span><br><span class="line">    dependencies = [];</span><br><span class="line"></span><br><span class="line">  if (registration === undefined) &#123;</span><br><span class="line">    return undefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registration.dependencies.forEach(function (dependencyName) &#123;</span><br><span class="line">    var dependency = self.get(dependencyName);</span><br><span class="line">    dependencies.push(dependency === undefined ? undefined : dependency);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return registration.func.apply(undefined, dependencies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it(&apos;등록된 함수에 의존성을 제공한다.&apos;, function () &#123;</span><br><span class="line">  var main = &apos;main&apos;,</span><br><span class="line">    mainFunc,</span><br><span class="line">    dep1 = &apos;dep1&apos;,</span><br><span class="line">    dep2 = &apos;dep2&apos;;</span><br><span class="line"></span><br><span class="line">  container.register(main, [dep1, dep2], function (dep1Func, dep2Func) &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return dep1Func() + dep2Func();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.register(dep1, [], function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.register(dep2, [], function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  mainFunc = container.get(main);</span><br><span class="line">  expect(mainFunc()).toBe(3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/33211518?Acode=101" target="_blank" rel="noopener">자바스크립트 패턴과 테스트</a><br><a href="https://github.com/kkangil/javascript-pattern-test" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;의존성-주입이란&quot;&gt;&lt;a href=&quot;#의존성-주입이란&quot; class=&quot;headerlink&quot; title=&quot;의존성 주입이란?&quot;&gt;&lt;/a&gt;의존성 주입이란?&lt;/h2&gt;&lt;p&gt;ConferenceWebSvc 객체에 서비스를 캡슐화하고 메시지를 화면에 표시할 자바스크립트 객체 Messenger를 작성한다.&lt;/p&gt;
&lt;p&gt;참가자는 1인당 세션을 10개까지 등록할 수 있다. 참가자가 한 세션을 등록하면 그 결과를 성공/실패 메시지로 화면에 표시하는 함수를 개발해야 한다. 아래 코드는 해당 기능을 구현하기 위한 초기 버전이다.&lt;/p&gt;
    
    </summary>
    
      <category term="테스트 코드" scheme="https://kkangil.github.io/categories/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="테스트 코드" scheme="https://kkangil.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"/>
    
      <category term="jasmine" scheme="https://kkangil.github.io/tags/jasmine/"/>
    
      <category term="의존성 주입" scheme="https://kkangil.github.io/tags/%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/"/>
    
  </entry>
  
  <entry>
    <title>웹 사이트 최적화</title>
    <link href="https://kkangil.github.io/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    <id>https://kkangil.github.io/2020/01/27/웹-사이트-최적화/</id>
    <published>2020-01-27T07:06:16.000Z</published>
    <updated>2020-02-02T05:27:27.894Z</updated>
    
    <content type="html"><![CDATA[<p>제이콥 닐슨의 웹 사이트인 “useit.com”은 웹 사이트의 반응 시간을 다음과 같이 평가한다.</p><ul><li>0.1초: 사용자의 동작에 해당 기능이 바로 반응한다고 느끼는 시간</li><li>1초: 불필요하게 오래 기다리지 않았다고 느끼는 시간. 0.2~1초의 시간은 컴퓨터가 동작하는 시간으로 이해할 수 있는 시간이다. 시간이 1초 이상 걸리면 컴퓨터의 동작에 이상이 생겼다고 생각하게 된다.</li><li>10초: 사용자가 집중력을 잃지 않는 최대 시간</li></ul><p>이 평가에 따르면 웹 페이지의 반응 시간이 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다. 웹 사이트의 기능이 점점 복잡해지고 많아지면서 느린 반응 속도 때문에 이용 중인 서비스를 떠나 다른 유사한 서비스를 이용하게 만드는 사이트가 있는 반면, 빠른 반응 속도로 웹 사이트를 탐색하는데 큰 불편함이 없는 서비스를 제공하는 사이트도 있다.</p><a id="more"></a><p>많은 포털과 서비스 업체에서는 이러한 사용자의 기대에 부응하기 위해 여러 가지 방법을 시도했다. 그러던 중에 웹 페이지 성능 최적화라는 개념이 생겨났다. 웹 서비스의 반응 속도를 개선할 수 있는 가장 효과적인 방법은 네트워크 속도의 개선이지만 이는 단기간에 이루기 힘든 과제이며 인터넷 서비스를 제공하는 업체에서는 불가능한 부분이다. 대신 반대로 네트워크 사용량을 줄이고 브라우저에서 웹 페이지의 실행 속도를 높여 웹 페이지의 반응 속도를 개선하고 있다.</p><h2 id="브라우저-동작-방식을-기반으로-한-최적화"><a href="#브라우저-동작-방식을-기반으로-한-최적화" class="headerlink" title="브라우저 동작 방식을 기반으로 한 최적화"></a>브라우저 동작 방식을 기반으로 한 최적화</h2><p>웹 페이지 최적화는 브라우저가 네트워크와 통신하는 과정은 물론 브라우저에서 페이지를 표시하는 과정에서의 응답 속도를 개선하는 것이다. 브라우저가 어떻게 동작하는지 이해해야 올바른 개선 방향을 잡을 수 있다.<br>사용자는 원하는 웹 사이트로 이동하기 위해 다음의 작업을 수행하고 브라우저의 동작 방식이다.</p><ol><li>브라우저의 주소창에 주소를 입력하고 Enter 키를 누르거나 링크를 클릭한다.</li><li>브라우저는 서버에 요청을 보내 페이지를 구성하는 자원을 다운로드한다.</li><li>다운로드 받은 자원을 이용해 요청 결과를 화면에 보여준다.</li></ol><p>이때 브라우저가 어떤 단계로 동작하는지, 단계별로 얼마나 시간이 걸리는지 정의한 연구 활동이 W3C의 네비게이션 타이밍(Navigation Timing) 명세다. 네비게이션 타이밍 명세의 가장 큰 목적은 정확한 단계별 소요 시간을 측정하는 것이지만 브라우저의 처리 단계를 정확하게 정의했다는 데도 큰 의미가 있다.</p><p>네비게이션 타이밍 명세에서 브라우저가 사용자의 요청을 처리하는 순서를 정리한 프로세싱 모델에서 웹 페이지 최적화와 관련 있는 단계를 정리한 것이다.</p><blockquote><p>서비스 이동 단계 -&gt; 리다이렉트 단계 -&gt; 애플리케이션 캐시 확인 단계 -&gt; 네트워크 통신 단계 -&gt; 브라우저 처리 단계</p></blockquote><ul><li>서비스 이동 단계: 사용자가 웹 서비스를 이용하다 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계. 프로세싱 모델의 Prompt for unload</li><li>리다이렉트 단계: 사용자가 요청한 URL에서 다른 URL로 다시 보내는 단계. 프로세싱 모델의 redirect</li><li>애플리케이션 캐시 확인 단계: 브라우저의 캐시에 데이터가 있는지 확인하는 단계. 프로세싱 모델의 App Cache</li><li>네트워크 통신 단계: 브라우저가 네트워크와 통신해서 웹 페이지와 구성 요소를 다운로드 하는 단계. 프로세싱 모델의 DNS, TCP, Request, Response 등</li><li>브라우저 처리 단계: 다운로드한 웹 페이지와 구성 요소로 웹 페이지를 화면에 그리는 단계. 프로세싱 모델의 Processing, onLoad</li></ul><h3 id="서비스-이동-단계"><a href="#서비스-이동-단계" class="headerlink" title="서비스 이동 단계"></a>서비스 이동 단계</h3><p>서비스 이동 단계는 웹 서비스를 이용하다가 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계다. 이 단계의 작업은 다른 주소로 이동하기 전에 보고 있던 페이지에서 실행하는데, 모두 브라우저 내부에서 처리하기 때문에 브라우저 성능과 직결된다.</p><p>웹 서비스를 이용하면 페이지가 표시될 때 우리도 모르게 이번트가 할당되고, 이때 메모리를 조금씩 사용한다. 그런데 이 메모리를 더 이상 사용하지 않을 때, 즉 페이지를 떠날 때는 메모리를 해제해야 한다. 이 <code>메모리 해제</code> 작업이 서비스 이동 단계에서 실행하는 작업 가운데 하나다.</p><p>필요 없는 메모리 해제를 담당하는 <code>가비지 컬렉션 기능</code>이 제대로 동작하지 않으면 브라우저가 응답 없음 상태가 되거나 실행 속도가 급격히 느려진다. 웹 페이지에서 동시에 많은 변수가 생성되고 처리되는 동안 브라우저에서 허용한 임계치를 넘었을 때 가비지 컬렉션이 동작하는데 가비지 컬렉션이 동작하면 스크립트 실행이 중단된다. 가비지 컬렉션이 완료되기 전까지는 스크립트가 동작하지 못해 페이지 느려지는 것이다.</p><p>서비스 이용 단계의 작업은 브라우저 내부에서 자동으로 실행한다. 만약 별도로 처리하려면 beforeunload 이벤트를 활용할 수 있다.</p><h3 id="리다이렉트-단계"><a href="#리다이렉트-단계" class="headerlink" title="리다이렉트 단계"></a>리다이렉트 단계</h3><p>쉽게 볼 수 있는 리다이렉트는 SNS에서 사용하는 단축 URL이다. SNS의 특성상 입력하는 글자 수에 제한이 있다. 쿼리가 긴 URL을 그대로 SNS에 입력하면 글자 수 제한 때문에 원하는 내용을 다 입력하지 못한다. 이때 단축 URL을 사용하면 SNS의 글자 수 제한을 피할 수 있다. 단축 URL로 접속하면 원본 URL로 리다이렉트 된다.</p><p>리다이렉트가 발생하면 상태 코드로 301이나 302를 반환하는데, 이는 HTTP 요청을 완수하기 위해서 추가로 뭔가를 해야 한다는 의미다. 이런 이유로 리다이렉트가 발생하면 어떤 자원도 다운로드 하지 않으며 브라우저에 일시적으로 빈 페이지가 보인다. 그렇기 때문에 특정한 목적으로 리다이렉트를 사용하는 것은 어쩔 수 없지만 의도치 않게 또는 실수로 리다이렉트가 발생한다면 웹 페이지의 성능 향상을 위해 바로 잡아야 한다.</p><p>리다이렉트와 관련해서 개발자가 흔히 저지르는 실수 가운데 하나는 URL 뒤에 슬래시를 넣지 않는 것이다. 주소창에 ‘naver.com’을 입력하고 Enter키를 누르면, 주소창에 입력한 주소가 <code>https://www.naver.com/&#39;</code>으로 바뀌면서 리다이렉트 된다. 이 과정을 개발자 도구로 확인해보면 302 redirect 가 발생하는 것을 확인할 수 있다. a 태그의 href 속성에 주소 뒤에 슬래시를 붙여 301, 302 로 인한 리다이렉트가 발생하지 않도록 막을 수 있다. (307 도 발생하고는 하는데 302와 의미하는바가 같다.)</p><p>두번째로 실수하는 부분은 웹 페이지를 이용한 리다이렉트다. 흔히 메타태그를 이용하는데 다음 코드는 1초 후에 페이지가 이동하는 코드다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1; url=https://www.naver.com/&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>이 코드에는 두 가지 성능 문제가 있다. 첫 번째는 이 코드를 실행시킬 별도의 페이지를 거쳐야 리다이렉트 된다는 점이다. 두 번째는 최종 페이지에 도착했을 때 캐시가 설정된 리소스임에도 불구하고 조건부 GET 요청이 이뤄진다는 점이다.</p><p>조건부 GET 요청은 브라우저에 캐싱된 리소스를 사용하기 전에 해당 리소스를 사용해도 되는지 서버에 물어 보는 것이다. 이때 헤더의 <code>If-Modified-Since</code> 정보를 이용해 서버에 요청을 보낸다. 리소스가 수정되지 않았다면 <code>304 Not Modified</code> 코드를 받아 캐시에 있는 리소스를 사용한다. 자원이 수정됐다면 서버로부터 리소스를 다운로드 한다.</p><p><code>캐시의 만료 날짜를 설정</code>했다면 서버의 확인을 거치지 않고 바로 캐싱된 리소스를 사용할 수 있는데, 메타태그로 리다이렉트하면 조건부 GET 요청으로 불필요한 서버 통신이 발생해 응답 속도가 느려진다.</p><p>웹 페이지의 주소뿐 아니라 이미자와 스타일시트, 자바스크립트와 같이 페이지를 구성하는 요소도 리다이렉트 될 수 있다. 301 이나 302 상태 코드가 발생하는 요소를 찾고 의도치 않게 리다이렉트가 발생하고 있다면 성능 향상을 위해서 바로 잡아야 한다.</p><h3 id="애플리케이션-캐시-확인-단계"><a href="#애플리케이션-캐시-확인-단계" class="headerlink" title="애플리케이션 캐시 확인 단계"></a>애플리케이션 캐시 확인 단계</h3><p>리다이렉트 작업을 마치고 HTTP 요청을 처리하기 위한 준비를 마쳤다면 브라우저는 먼저 서버로 요청을 보낸다. 서버에서 응답이 오면 개별 요소(이미지, 스타일시트, 자바스크립트 등)가 사용자 PC에 있는지 캐시 데이터를 찾는다. 캐시 데이터의 종류에는 쿠키, 이미지, 스크립트, 스타일시트 등이 있다.</p><p>캐시 데이터가 있는 이유는 무엇보다도 사용자가 동일한 페이지를 다시 방문했을 때 브라우저와 서버 사이에 통신을 하지 않고 캐시에 있는 자원을 사용하겠다는 것이다. 성능 향상을 위해 가장 효과적인 방법은 브라우저와 서버 사이의 통신을 최대한으로 줄이는 것이다. 그러므로 다시 방문한 사용자에게 좀 더 빠른 응답 속도를 제공하려면 애플리케이션 캐시를 잘 활용해야한다.</p><p>캐시를 다룰 때는 개별 요소들이 정말 유효한지, 사용해도 되는 것인지 검증하는 것이 중요하기 때문에 몇 가지 용어와 규칙이 필요하다.</p><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Last-Modified</td><td>서버에서 저장하고 있는 마지막 수정 날짜 예: Last-Modified Sun, 27 Jan 2020 17:00:00 GMT</td></tr><tr><td>If-Modified-Since</td><td>브라우저에서 저장하고 있는 마지막 수정 날짜 예: If-Modified-Since Sun, 27 Jan 2020 17:00:00 GMT</td></tr><tr><td>Expires</td><td>만료 날짜. 언제까지 유효한지 미리 지정해 놓은 시간 정보로, 특정 날짜까지는 사용할 수 있다는 정보. 예: Expires 17:00:00 Sunday, December 27, 2020 GMT</td></tr><tr><td>Cache-Control</td><td>Expires 정보의 한계를 극복하려고 HTTP/1.1 에서 소개된 캐시 설정 추가 정보</td></tr><tr><td>max-age</td><td>캐싱할 시간. Cache-Control 정보 가운데 하나로 캐싱할 시간을 초 단위까지 정할 수 있다. max-age 정보는 클라이언트 시간과 관계 없이 현재부터 며칠, 몇 년 등으로 지정할 수 있다.</td></tr></tbody></table><p>자원 요소를 다운로드할때 브라우저가 처리하는 과정이다.</p><p>Expires 정보 확인 (정보 없음)-&gt; If-Modified-Since 정보 확인(정보 있음) -&gt; If-Modified-Since 정보와 Last-Modified 정보 비교</p><ul><li>Expires 정보가 있고 기한이 남아 있으면 캐시에 저장된 요소를 사용한다.</li><li>If-Modified-Since가 없으면 서버에 요소를 요청한다.</li><li>If-Modified-Since 정보가 있으면 Last-Modifed 정보를 비교하고 날짜가 같으면 캐시에 저장된 요소를 사용하라는 응답 304 Not Modifed 을 보내주고, 날짜가 다른 경우 서버의 요소를 전송한다.</li></ul><p>사용자 PC에 캐시 파일이 있고 Expires 정보가 유효하다면 해당 파일을 서버에 요청하지 않고 캐시에 저장된 파일을 이용한다. 이러면 동적인 이미지 등을 제외한 나머지 정적인 요소는 별도로 서버에 요청하지 않기 때문에 로딩 속도를 크게 향상시킬 수 있다.</p><h3 id="네트워크-통신-단계"><a href="#네트워크-통신-단계" class="headerlink" title="네트워크 통신 단계"></a>네트워크 통신 단계</h3><p>네트워크 비용을 줄이는 첫 번째 방법은 Expires 설정이나 Cache Control 속성을 이용해 사용자 웹 페이지에 다시 왔을 때 캐시를 사용하는 방법이다. 두 번째 방법은 스타일시트나 자바스크립트와 같이 파일을 합쳐서 서비스해도 문제가 없는 리소스를 합쳐 하나의 링크로 제공해 요청 횟수를 줄이는 방법이다.</p><h5 id="DNS-DNS-Lookup"><a href="#DNS-DNS-Lookup" class="headerlink" title="DNS (DNS Lookup)"></a>DNS (DNS Lookup)</h5><p>호스트 이름으로 IP 주소를 조회한 시간이다. 보통 20~120ms 정도 소요된다. 이 작업이 완료되지 않으면 어떤 자원도 다운로드 하지 않는다. 브라우저에서 IP 주소를 조회할 때 동일한 호스트로 요청하는 요소는 다시 IP 주소를 확인하지 않아 시간이 추가로 걸리지 않는다. 그럼 하나의 호스트로 모든 리소스를 호출하면 시간을 줄일 수 있을 것 같지만, 대신 호스트별 동시 연결 기능은 포기해야 한다.</p><p>보통 이미지의 크기가 크고 개수가 많은 이미지 검색 서비스를 개발할 때 이런 부분을 많이 고려한다. 한 번에 보이는 이미지의 개수가 많을 때 호스트를 여러 개 만들어 동시에 다운로드하면 성능을 높일 수 있다고 생각하지만 실제로는 고려할 사항도 많다. DNS Lookup 단계에서 걸리는 시간도 무시할 수 없다. 때문에 여러 가지 가정을 세워서 테스트한 다음 최적의 호스트 개수를 찾아야한다.</p><h5 id="Request-Send"><a href="#Request-Send" class="headerlink" title="Request(Send)"></a>Request(Send)</h5><p>웹 서버와 TCP 연결이 이뤄지면 원하는 정보를 서버에 보내는 시간이다. 주로 요청 헤더 정보를 보내는 시간이 여기에 해당한다. Send 시간은 파일 올리기와 같이 보내야 할 정보가 많을수록 오래 걸린다.<br>일반적인 상황에서 Send 시간을 최적화하는 방법은 쿠키 정보를 포함하지 않는 별도 호스트를 사용해 서비스하는 것이다. 쿠키 정보가 필요 없는 파일(이미지, 스타일시트, 자바스크립트)에는 별도 호스트를 적용해 헤더 정보에서 쿠키 정보를 없애는 것이다.</p><h5 id="Response-Receive"><a href="#Response-Receive" class="headerlink" title="Response(Receive)"></a>Response(Receive)</h5><p>서버에서 보내는 응답 메시지를 받는 시간이다. 이 단계에서 성능을 개선하는 방법으로는 데이터 크기를 줄이기 위해 Gzip과 같은 파일 압축 기술을 사용하는 방법이 있다. 주석이나 공백을 없애 코드의 양을 줄이고, 코드의 양을 줄인 파일을 Gzip 등으로 압축해서 파일의 크기를 줄인다. Gzip으로 압축하면 원본 파일의 약 30% 정도로 크기가 줄어든다.</p><h3 id="브라우저-처리-단계"><a href="#브라우저-처리-단계" class="headerlink" title="브라우저 처리 단계"></a>브라우저 처리 단계</h3><p>프로세싱 모델의 Processing과 onLoad 에 해당하는 브라우저 처리 단계는 서버에서 받은 HTML과 이미지, 스타일시트를 조합해 사용자가 실제로 보는 화면을 만드는 단계다. 복잡한 UI를 개발할 때는 인라인 형태의 이벤트 바인딩 방법보다 이벤트 핸들러로 바인딩하는 방법을 사용한다. 이벤트 핸들러로 이벤트를 바인딩하려면 최우선 조건이 해당 DOM이 존재해야 한다. 모든 DOM이 존재하는 바로 그 시점이 DOMContentLoaded 이벤트나 onload 이벤트가 발생하는 시점이다.</p><blockquote><p>브라우저의 DOM 처리 절차에 따른 이벤트 발생 순서<br>domLoading -&gt; domInteractive -&gt; domContentLoaded -&gt; domComplete -&gt; onload</p></blockquote><p>onload 이벤트는 DOM 에서 기본으로 제공하는 이벤트로 문서에 있는 모든 이미지, 스타일시트, 자바스크립트 등이 모두 다운로드 될 때마다 발생한다. 이와 달리 DOMContentLoaded 이벤트는 기본적으로 DOM 생성에만 관련돼있다. 이미자나 다른 요소를 다운로드 하는것과 관계없이 DOM이 로딩되고 난 직후에 발생한다.</p><p>많은 양의 이벤트를 바인딩해야 하고 이미지나 스타일시트의 개수가 많은 페이지를 개발한다면 onload 이벤트보다는 DOMContentLoaded 이벤트를 이용하는게 좋다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2" target="_blank" rel="noopener">자바스크립트 성능 이야기</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;제이콥 닐슨의 웹 사이트인 “useit.com”은 웹 사이트의 반응 시간을 다음과 같이 평가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0.1초: 사용자의 동작에 해당 기능이 바로 반응한다고 느끼는 시간&lt;/li&gt;
&lt;li&gt;1초: 불필요하게 오래 기다리지 않았다고 느끼는 시간. 0.2~1초의 시간은 컴퓨터가 동작하는 시간으로 이해할 수 있는 시간이다. 시간이 1초 이상 걸리면 컴퓨터의 동작에 이상이 생겼다고 생각하게 된다.&lt;/li&gt;
&lt;li&gt;10초: 사용자가 집중력을 잃지 않는 최대 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 평가에 따르면 웹 페이지의 반응 시간이 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다. 웹 사이트의 기능이 점점 복잡해지고 많아지면서 느린 반응 속도 때문에 이용 중인 서비스를 떠나 다른 유사한 서비스를 이용하게 만드는 사이트가 있는 반면, 빠른 반응 속도로 웹 사이트를 탐색하는데 큰 불편함이 없는 서비스를 제공하는 사이트도 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="웹 성능 이야기" scheme="https://kkangil.github.io/categories/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%95%BC%EA%B8%B0/"/>
    
    
      <category term="웹 사이트 최적화" scheme="https://kkangil.github.io/tags/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    
      <category term="네비게이션 타이밍" scheme="https://kkangil.github.io/tags/%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98-%ED%83%80%EC%9D%B4%EB%B0%8D/"/>
    
      <category term="프로세싱 모델" scheme="https://kkangil.github.io/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1-%EB%AA%A8%EB%8D%B8/"/>
    
  </entry>
  
  <entry>
    <title>도구 다루기-2</title>
    <link href="https://kkangil.github.io/2020/01/27/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-2/"/>
    <id>https://kkangil.github.io/2020/01/27/도구-다루기-2/</id>
    <published>2020-01-27T04:45:31.000Z</published>
    <updated>2020-01-27T06:50:24.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="재스민-들어가기"><a href="#재스민-들어가기" class="headerlink" title="재스민 들어가기"></a>재스민 들어가기</h2><p>재스민은 행위 주도 개발 (Behavior-Driven Development, BDD) 방식으로 자바스크립트 단위 테스트를 작성하기 위한 라이브러리다.</p><blockquote><p>BDD와 TDD는 상호 배타 관계가 아니다. BDD는 단위 테스트로 확인할 기능 또는 작동 로직을 일상 언어로 서술하는데, 이로써 개발자는 자신이 작성 중인 코드가 <code>어떻게</code>가 아니라 <code>무엇</code>을 해야하는지 테스트 코드에 표현할 수 있다. 그리고 행위 주도 스타일로 정의/구성한 테스트는 쉬운 문장으로 서술한 기능 명세서로 삼을 만하다는 이점도 있다.</p></blockquote><a id="more"></a><h3 id="테스트-꾸러미와-스펙"><a href="#테스트-꾸러미와-스펙" class="headerlink" title="테스트 꾸러미와 스펙"></a>테스트 꾸러미와 스펙</h3><p>재스민 테스트 꾸러미는 전역 함수 describe로 정의되며, 이 함수는 두 인자를 받는다.</p><ul><li>문자열: 무엇을 테스트할지 서술한다.</li><li>함수: 테스트 꾸러미의 구현부다.</li></ul><p>테스트 꾸러미는 스펙, 즉 개별 테스트로 구현되며, 각 스펙은 전역 함수 it으로 정의된다. it 함수도 describe 처럼 인자를 2개 받는다.</p><ul><li>문자열: 무엇을 테스트할지 서술한다.</li><li>적어도 한 개의 기대식을 가진 함수: 코드 상태의 true/false를 확인하는 단언</li></ul><p>테스트 꾸러미 구현부에 전역 함수 beforeEach/afterEach 를 쓰면 각 꾸러미 테스트가 실행되기 이전에 beforeEach 함수를, 그 이후에는 afterEach 함수를 호출한다. 전체 테스트가 공유할 설정과 정리 코드를 두 함수에 담아두면 코드 중복을 피할 수 있어 좋다.</p><p>설정 단계가 정확히 같은 테스트가 2개 있는데, beforeEach 함수로 간단히 해결할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;createReservation(passenger, flight)&apos;, function () &#123;</span><br><span class="line">  it(&apos;주어진 passenger를 passengerInfo 프로퍼티에 할당한다.&apos;, function () &#123;</span><br><span class="line">    var testPassenger = null,</span><br><span class="line">      testFlight = null,</span><br><span class="line">      testReservation = null;</span><br><span class="line"></span><br><span class="line">    beforeEach(function () &#123;</span><br><span class="line">      testPassenger = &#123;</span><br><span class="line">        firstName: &quot;윤지&quot;,</span><br><span class="line">        lastName: &quot;김&quot;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      testFlight = &#123;</span><br><span class="line">        number: &quot;3443&quot;,</span><br><span class="line">        carrier: &quot;대한항공&quot;,</span><br><span class="line">        destination: &quot;울산&quot;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      testReservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(&quot;passenger를 passenger Information 프로퍼티에 할당한다.&quot;, function () &#123;</span><br><span class="line">      expect(testReservation.passengerInformation).toBe(testPassenger);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(&quot;flight를 flightInformation 프로퍼티에 할당한다.&quot;, function () &#123;</span><br><span class="line">      expect(testReservation.flightInformation).toBe(testFlight);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="기대식과-매처"><a href="#기대식과-매처" class="headerlink" title="기대식과 매처"></a>기대식과 매처</h3><p>expect 문은 테스트마다 있다. 다음은 첫 번째 단위 테스트 createReservation의 expect 문이다.</p><blockquote><p>expect(testReservation.passengerInformation).toBe(testPassenger);</p></blockquote><p>expect 함수는 테스트 대상 코드가 낸 실제값을 인자로 받아 기댓값과 견주어본다. 이 테스트가 기대하는 값은 testPassenger다.</p><p>실제값과 기댓값을 비교하는 일은 매처(matcher) 함수의 몫이다. 매처는 비교 결과 성공하면 true, 실패하면 false를 반환한다. 하나 이상의 기대식이 포함된 스펙에서 매처가 하나라고 실패하면 모조리 실패한 것으로 간주한다.</p><p>toBe 매처는 이름에서 짐작할 수 있듯이 testResevation.passengerInformation이 testPassenger 와 같은 객체여야 한다는 의미다.</p><h3 id="스파이"><a href="#스파이" class="headerlink" title="스파이"></a>스파이</h3><p>재스민 스파이(spy)는 테스트 더블(test double) 역할을 하는 자바스크립트 함수다. 테스트 더블은 어떤 함수/객체의 본래 구현부를 테스트 도중 다른 코드로 대체한 것을 말하며, 웹 서비스 같은 외부 자원과의 의존 관계를 없애고 단위 테스트의 복잡도를 낮출 목적으로 사용된다.</p><blockquote><p>다음 다섯 가지를 통칭하여 테스트 더블이라고 한다.</p><ol><li>더미(dummy): 보통 인자 리스트를 채우기 위해 사용되며, 전달은 하지만 실제로 사용되지는 않는다.</li><li>틀(stub): 더미를 조금 더 구현하여 아직 개발되지 않은 클래스나 메서드가 실제 작동하는 것 처럼 보이게 만든 객체로 보통 리턴 값은 하드 코딩한다.</li><li>스파이(spy): 틀과 비슷하지만 내부적으로 기록을 남긴다는 점이 다르다. 특정 객체가 사용되었는지, 예상되는 메서드가 특정한 인자로 호출되었는지 등의 상황을 감시하고 이러한 정보를 제공하기도 한다.</li><li>모의체(fake): 틀에서 조금 더 발전하여 실제로 간단히 구현된 코드를 갖고는 있지만, 운영 환경에서 사용할 수는 없는 객체다.</li><li>모형(mock): 더미, 틀, 스파이를 혼합한 형태와 비슷하나 행위를 검증하는 용도로 주로 사용된다.</li></ol></blockquote><p>ReservationSaver 라는 자바스크립트 객체를 만들어 이 객체의 saveReservation 함수로 웹 서비스에 예약 데이터를 전송하는 기능을 캡슐화했다. createReservation 함수를 확장하여 이 함수가 ReservationSaver 인스턴스를 인자로 받아 이 인스턴스의 saveReservation 함수를 실행하는지 확인하고자 한다.<br>saveReservation 함수는 웹 서비스와 통신하므로 지금부터 작성할 테스트는 예약 데이터 저장 후 DB를 질의하고 예약 데이터가 분명히 추가됐는지 확인하는 과정이 모두 들어가야 할 듯 싶다. 하지만 그렇지 않다. 자칫 단위 테스트가 웹 서비스, DB 같은 외부 시스템 유무와 작동 여부에 의존하게 될지도 모른다.</p><p>재스민 스파이를 사용하면 복잡한 saveReservation 구현부를 외부 시스템 의존성을 배제한, 단순한 형태로 바꿀 수 있다. 먼저 작성한 ReservationSaver 객체다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createReservation(passenger, flight, saver) &#123;</span><br><span class="line">  var reservation = &#123;</span><br><span class="line">    passengerInformation: passenger,</span><br><span class="line">    flightInformation: flight</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  saver.saveReservation(reservation);</span><br><span class="line">  return reservation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ReservationSaver() &#123;</span><br><span class="line">  this.saveReservation = function (reservation) &#123;</span><br><span class="line">    // 예약 정보를 저장하는 웹 서비스와 연동하는 복잡한 코드가 있을 것이다.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createReservation 함수는 ReservationSaver 인스턴스를 전달받게끔 개선되었다. ReservationSaver를 인자로 받으므로 예약 데이터가 저장되었는지를 확인하는 테스트를 다음과 같이 작성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;createReservation&quot;, function() &#123;</span><br><span class="line">  var saver = new ReservationSaver();</span><br><span class="line">  var testPassenger = null,</span><br><span class="line">    testFlight = null;</span><br><span class="line"></span><br><span class="line">  beforeEach(function () &#123;</span><br><span class="line">    testPassenger = &#123;</span><br><span class="line">      firstName: &quot;윤지&quot;,</span><br><span class="line">      lastName: &quot;김&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testFlight = &#123;</span><br><span class="line">      number: &quot;3443&quot;,</span><br><span class="line">      carrier: &quot;대한항공&quot;,</span><br><span class="line">      destination: &quot;울산&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  createReservation(testPassenger, testFlight, saver);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>saver.saveReservation이 정말 호출 되었는지 어떻게 알 수 있을까?<br>이 테스트는 코드에 씌어있는 대로 복잡한 ReservationSaver의 기본 구현부를 createReservation 함수에 전달하고 있다. 이렇게 하면 결국 외부 시스템에 의존하게 되고 함수를 테스트하기가 어려워지므로 별로 내키지 않는다. 이럴때 재스민 스파이가 제격이다.</p><p>createReservation을 호출하기 전에 saveReservation 함수에 스파이를 심는다. 스파이로 함수 실행 여부를 알 수 있는데, 첫 번째 테스트에 아주 잘 들어맞는다.<br>재스민에서 전역 함수 spyOn을 쓰면 특정 함수를 몰래 들여다볼 수 있다. 이 함수의 첫 번째 인자는 객체 인스턴스, 두 번째 인자는 감시할 함수명이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;createReservation&quot;, function () &#123;</span><br><span class="line">  var saver = new ReservationSaver();</span><br><span class="line">  var testPassenger = null,</span><br><span class="line">    testFlight = null;</span><br><span class="line"></span><br><span class="line">  spyOn(saver, &apos;saveReservation&apos;);</span><br><span class="line"></span><br><span class="line">  beforeEach(function () &#123;</span><br><span class="line">    testPassenger = &#123;</span><br><span class="line">      firstName: &quot;윤지&quot;,</span><br><span class="line">      lastName: &quot;김&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testFlight = &#123;</span><br><span class="line">      number: &quot;3443&quot;,</span><br><span class="line">      carrier: &quot;대한항공&quot;,</span><br><span class="line">      destination: &quot;울산&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  createReservation(testPassenger, testFlight, saver);</span><br><span class="line"></span><br><span class="line">  expect(saver.saveReservation).toHaveBeenCalled();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>스파이를 써서 saver 객체의 saveReservation 구현부를 예약 데이터 저장 기능과 무관한 함수로 대체했다. 스파이는 함수를 호출한 시점과 호출 시 전달한 인자까지 정확히 포착하고, 무엇보다 재스민은 어떤 스파이가 한 번 이상 실했됐는지 확인하는 기대식을 지닌 스파이 전용 매처(toHaveBeenCalled())를 지원한다.</p><p>createReservation 함수의 인자가 늘었으니 기존 두 테스트 역시 수정할 수 밖에 없다. 하지만 saveReservation 함수 구현부를 직접 실행할 테스트는 없을 테니 ReservationSaver 생성 코드와 스파이 관련 코드를 전체 꾸러미의 beforeEach 함수로 옮겨 리팩토링 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;createReservation&quot;, function () &#123;</span><br><span class="line">  var testPassenger = null,</span><br><span class="line">    testFlight = null,</span><br><span class="line">    testReservation = null,</span><br><span class="line">    testSaver = null;</span><br><span class="line"></span><br><span class="line">  beforeEach(function () &#123;</span><br><span class="line">    testPassenger = &#123;</span><br><span class="line">      firstName: &quot;윤지&quot;,</span><br><span class="line">      lastName: &quot;김&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testFlight = &#123;</span><br><span class="line">      number: &quot;3443&quot;,</span><br><span class="line">      carrier: &quot;대한항공&quot;,</span><br><span class="line">      destination: &quot;울산&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testSaver = new ReservationSaver();</span><br><span class="line">    spyOn(testSaver, &apos;saveReservation&apos;);</span><br><span class="line"></span><br><span class="line">    testReservation = createReservation(testPassenger, testFlight, testSaver);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;passenger를 passenger Information 프로퍼티에 할당한다.&quot;, function () &#123;</span><br><span class="line">    expect(testReservation.passengerInformation).toBe(testPassenger);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;flight를 flightInformation 프로퍼티에 할당한다.&quot;, function () &#123;</span><br><span class="line">    expect(testReservation.flightInformation).toBe(testFlight);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;예약 정보를 저장한다.&quot;, function () &#123;</span><br><span class="line">    expect(testSaver.saveReservation).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/33211518?Acode=101" target="_blank" rel="noopener">자바스크립트 패턴과 테스트</a><br><a href="https://github.com/kkangil/javascript-pattern-test" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;재스민-들어가기&quot;&gt;&lt;a href=&quot;#재스민-들어가기&quot; class=&quot;headerlink&quot; title=&quot;재스민 들어가기&quot;&gt;&lt;/a&gt;재스민 들어가기&lt;/h2&gt;&lt;p&gt;재스민은 행위 주도 개발 (Behavior-Driven Development, BDD) 방식으로 자바스크립트 단위 테스트를 작성하기 위한 라이브러리다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BDD와 TDD는 상호 배타 관계가 아니다. BDD는 단위 테스트로 확인할 기능 또는 작동 로직을 일상 언어로 서술하는데, 이로써 개발자는 자신이 작성 중인 코드가 &lt;code&gt;어떻게&lt;/code&gt;가 아니라 &lt;code&gt;무엇&lt;/code&gt;을 해야하는지 테스트 코드에 표현할 수 있다. 그리고 행위 주도 스타일로 정의/구성한 테스트는 쉬운 문장으로 서술한 기능 명세서로 삼을 만하다는 이점도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="테스트 코드" scheme="https://kkangil.github.io/categories/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="테스트 코드" scheme="https://kkangil.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"/>
    
      <category term="jasmine" scheme="https://kkangil.github.io/tags/jasmine/"/>
    
      <category term="BDD" scheme="https://kkangil.github.io/tags/BDD/"/>
    
      <category term="spy" scheme="https://kkangil.github.io/tags/spy/"/>
    
  </entry>
  
  <entry>
    <title>도구 다루기</title>
    <link href="https://kkangil.github.io/2020/01/19/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0/"/>
    <id>https://kkangil.github.io/2020/01/19/도구-다루기/</id>
    <published>2020-01-19T08:05:23.000Z</published>
    <updated>2020-01-27T06:51:03.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="테스팅-프레임워크"><a href="#테스팅-프레임워크" class="headerlink" title="테스팅 프레임워크"></a>테스팅 프레임워크</h2><p>한 여행사의 차세대 예약 시스템 구축 프로젝트에 참여하여 항공 예약 데이터 생성 모듈을 맡게 되었는데, 그중에는 작동 명세가 다음과 같은 모듈 함수가 있었다.<br>‘승객(passenger) 객체, 항공편(flight) 객체를 입력받은 createReservation은 passengerInformation 프로퍼티가 승객 객체, flightInformation 프로퍼티가 항공편 객체인 새로운 객체를 반환한다.’</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createReservation(passenger, flight) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    passengerInfo: passenger,</span><br><span class="line">    flightInfo: flight</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>팀 규정상 단위 테스트 없이 제품 코드를 체크인할 수 없으므로 단위 테스트 작성은 반드시 필요하다.<br>참조할 함수는 이미 구현됐으니 어려운 일이 아니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;createReservation(passenger, flight&apos;, function () &#123;</span><br><span class="line">  it(&apos;주어진 passenger를 passengerInfo 프로퍼티에 할당한다.&apos;, function () &#123;</span><br><span class="line">    var testPassenger = &#123;</span><br><span class="line">      firstName: &apos;길동&apos;,</span><br><span class="line">      lastName: &apos;홍&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var testFlight = &#123;</span><br><span class="line">      number: &apos;3443&apos;,</span><br><span class="line">      carrier: &apos;대한항공&apos;,</span><br><span class="line">      destination: &apos;울신&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var reservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    expect(reservation.passengerInfo).toBe(testPassenger);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&apos;주어진 filght를 flightInfo 프로퍼티에 할당한다.&apos;, function () &#123;</span><br><span class="line">    var testPassenger = &#123;</span><br><span class="line">      firstName: &apos;길동&apos;,</span><br><span class="line">      lastName: &apos;홍&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var testFlight = &#123;</span><br><span class="line">      number: &apos;3443&apos;,</span><br><span class="line">      carrier: &apos;대한항공&apos;,</span><br><span class="line">      destination: &apos;울신&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var reservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    expect(reservation.flightInfo).toBe(testFlight);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위의 코드는 재스민 테스팅 프레임워크로 작성한 단위 테스트 코드다.<br>it 함수 각자는 개별 단위 테스트고(위 코드에서는 2개의 단위 테스트), 이들은 함수에서 반환된 객체의 속성이 적절한지 expect 함수로 검사한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;ko&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;link data-require=&quot;jasmine@*&quot; data-semver=&quot;2.0.0&quot;</span><br><span class="line">            rel=&quot;stylesheet&quot;</span><br><span class="line">            href=&quot;http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine.css&quot; /&gt;</span><br><span class="line">    &lt;script data-require=&quot;jasmine@*&quot; data-semver=&quot;2.0.0&quot;</span><br><span class="line">            src=&quot;http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine.js&quot;&gt;</span><br><span class="line">            &lt;/script&gt;</span><br><span class="line">    &lt;script data-require=&quot;jasmine@*&quot; data-semver=&quot;2.0.0&quot;</span><br><span class="line">            src=&quot;http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine-html.js&quot;&gt;</span><br><span class="line">            &lt;/script&gt;</span><br><span class="line">    &lt;script data-require=&quot;jasmine@*&quot; data-semver=&quot;2.0.0&quot;</span><br><span class="line">            src=&quot;http://cdn.jsdelivr.net/jasmine/2.0.0/boot.js&quot;&gt;</span><br><span class="line">            &lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;TestFrameworks_01.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;TestFrameworks_01_test.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>위와 같이 html 파일을 추가하고 단위 테스트를 실행한다.<br>자세히 들여다 보니 단위테스트에 오류가 보인다. 반환된 예약 객체의 속성명은 passengerInformation과 flightInformation이라고 명세에 나와 있는데, passengerInfo와 flightInfo로 잘못 코딩한 것이다. 명세가 아니라 함수 코드의 개발에 따라 테스트를 작성한 탓에 테스트는 기대하는 함수 작동이 아닌, 구현된 함수의 잘못된 실제 작동을 확인한 꼴이다. 명세 기준으로 테스트 코드를 작성했으면 속성명을 틀릴 일이 없었을 것이다.</p><h3 id="잘못된-코드-발견하기"><a href="#잘못된-코드-발견하기" class="headerlink" title="잘못된 코드 발견하기"></a>잘못된 코드 발견하기</h3><p>TDD는 코드 결함을 최대한 빨리, 곧 코드 생성 직후 감지하며, 작은 기능 하나라도 테스트를 먼저 작성한 뒤, 취소한의 코드만으로 기능을 구현한다.<br>createReservation 함수로 다시 돌아가 테스트를 먼저 작성하면 어떻게 달라지는지 알아보고자 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;createReservation(passenger, flight)&apos;, function () &#123;</span><br><span class="line">  it(&apos;주어진 passenger를 passengerInformation 프로퍼티에 할당한다.&apos;, function () &#123;</span><br><span class="line">    var testPassenger = &#123;</span><br><span class="line">      firstName: &apos;길동&apos;,</span><br><span class="line">      lastName: &apos;홍&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var testFlight = &#123;</span><br><span class="line">      number: &apos;3443&apos;,</span><br><span class="line">      carrier: &apos;대한항공&apos;,</span><br><span class="line">      destination: &apos;울신&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var reservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    expect(reservation.passengerInformation).toBe(testPassenger);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createReservation(passenger, flight) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    passengerInfo: passenger,</span><br><span class="line">    flightInfo: flight</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드로 단위 테스트하면 실패하게 된다.<br>반환 객체의 속성명을 잘못해서 passengerInformation 대신 passengerInfo로 적었다. 속성명을 정정하고 다시 테스트하면 성공한다.</p><p>반환 객체의 속성명을 잘못 쓴 실수가 createReservation 함수를 구현한 코드에 잠복해 있지만, 이번에는 테스트를 먼저 작성한 뒤 명세에 따라 테스트를 했으므로 다른 개발자가 통합 테스트를 진행하다가 에러를 즉시 확인하여 조치할 수 있다.</p><h3 id="테스트성을-감안하여-설계하기"><a href="#테스트성을-감안하여-설계하기" class="headerlink" title="테스트성을 감안하여 설계하기"></a>테스트성을 감안하여 설계하기</h3><p>테스트를 먼저 작성하란 건 코드의 테스트성을 차후에 두고 볼 문제가 아니라 우선적인 주요 관심사로 생각하는 것이다. 어떤 코드의 테스트 용이성과 그 코드의 테스트가 얼마나 잘 이루어졌는지는 직접적인 상관 관계가 있다.</p><h3 id="꼭-필요한-코드만-작성하기"><a href="#꼭-필요한-코드만-작성하기" class="headerlink" title="꼭 필요한 코드만 작성하기"></a>꼭 필요한 코드만 작성하기</h3><p>TDD 작업 절차를 정리해보자. 작은 기능 하나를 검증하려면 실패하는 테스트를 먼저 작성한 뒤, 테스트를 성공시킬 만큼만 최소한으로 코딩한다. 그 후 내부적으로 구현 세부를 변경하는 <code>리팩토링</code> 과정을 거쳐 개발 중인 코드에서 중복 코드를 들어낸다. 이런 과정을 거치면서 결국 마지막에는 꼭 필요한 코드만 남게 된다.</p><h3 id="안전한-유지-보수와-리팩토링"><a href="#안전한-유지-보수와-리팩토링" class="headerlink" title="안전한 유지 보수와 리팩토링"></a>안전한 유지 보수와 리팩토링</h3><p>TDD를 실천하면 프로젝트 제품 코드를 대상으로 확실한 단위 테스트 꾸러미를 구축할 수 있다. 예전에 잘 돌아가던 코드가 지금은 제대로 작동하지 않은 회귀 결함은 코드 품질과 믿음성을 떨어뜨리는 요인이다.<br>여타 보험 정책이 그렇듯, 혜택은 없고 짐만 되는 재발 비용이 발생한다. 단위 테스트의 경우 테스트 꾸러미를 개발/보수하느라 재발 비용이 들어가는데, 보험과 마찬가지로 이 재발 비용을 지불하는 부담에서 벗어나는 시점이 온다.<br>종합적인 단위 테스트 꾸러미가 마련된 제품 코드를 확장 또는 보수할 때도 비슷한 안도감을 느낄 수 있다. 실수로 다른 코드를 건드리지 않았다는 확신을 하고 코드 일부를 변경할 수 있기 때문이다.</p><h3 id="실행-가능한-명세"><a href="#실행-가능한-명세" class="headerlink" title="실행 가능한 명세"></a>실행 가능한 명세</h3><p>TDD 실천 결과, 탄탄하게 구축된 단위 테스트 꾸러미는 테스트 대상 코드의 실행 가능한 명세 역할도 한다. 단위 테스팅 프레임워크인 재스민은 행위 기반(behavior-based) 으로 테스트를 구성한다. 재스민에서 스펙이라 부르는 개별 테스트는, 테스트하여 검증할 작동 로직을 일상 문장으로 표현하면서 시작한다.<br>createReservation 함수를 예로 들면, 재스민으로 단위 테스트한 결과 메시지를 보고 이 함수가 무슨 일을 하는지 큰 그림을 그려볼 수 있다. createReservation이 하는 일을 굳이 코드를 읽고 분석하지 않아도 단위 테스트가 죄다 알려주는 셈이다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/33211518?Acode=101" target="_blank" rel="noopener">자바스크립트 패턴과 테스트</a><br><a href="https://github.com/kkangil/javascript-pattern-test" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;테스팅-프레임워크&quot;&gt;&lt;a href=&quot;#테스팅-프레임워크&quot; class=&quot;headerlink&quot; title=&quot;테스팅 프레임워크&quot;&gt;&lt;/a&gt;테스팅 프레임워크&lt;/h2&gt;&lt;p&gt;한 여행사의 차세대 예약 시스템 구축 프로젝트에 참여하여 항공 예약 데이터 생성 모듈을 맡게 되었는데, 그중에는 작동 명세가 다음과 같은 모듈 함수가 있었다.&lt;br&gt;‘승객(passenger) 객체, 항공편(flight) 객체를 입력받은 createReservation은 passengerInformation 프로퍼티가 승객 객체, flightInformation 프로퍼티가 항공편 객체인 새로운 객체를 반환한다.’&lt;/p&gt;
    
    </summary>
    
      <category term="테스트 코드" scheme="https://kkangil.github.io/categories/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="테스트 코드" scheme="https://kkangil.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"/>
    
      <category term="jasmine" scheme="https://kkangil.github.io/tags/jasmine/"/>
    
      <category term="TDD" scheme="https://kkangil.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>메모이제이션</title>
    <link href="https://kkangil.github.io/2020/01/12/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98/"/>
    <id>https://kkangil.github.io/2020/01/12/메모이제이션/</id>
    <published>2020-01-12T04:45:18.000Z</published>
    <updated>2020-01-12T08:13:07.797Z</updated>
    
    <content type="html"><![CDATA[<p>메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 메모이제이션은 함수형 프로그래밍 관련 이야기에서는 빠지지 않고 꼭 등장하는 사례이기도 하다.</p><a id="more"></a><p>함수형 자바스크립트에서 메모이제이션의 대표적인 사례로는, 한 번 들어온 인자에 대한 결과를 캐싱하여 함수 본체를 실행하지 않고 결과를 즉시 리턴하는 _.memoize 같은 고차 함수가 있다. 동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수의 콘셉트를 잘 활용한 사례이다. 함수 본체에서 하는 일이 복잡하거나 연산이 많거나 내부에서 생성하는 자원이 많거나 시간이 오래 걸리는 함수일수록 메모이제이션을 통해 얻을 수 있는 성능적 이득도 커진다.</p><h2 id="memoize-함수"><a href="#memoize-함수" class="headerlink" title="memoize 함수"></a>memoize 함수</h2><h3 id="메모이제이션-코드로-이해하기"><a href="#메모이제이션-코드로-이해하기" class="headerlink" title="메모이제이션 코드로 이해하기"></a>메모이제이션 코드로 이해하기</h3><p>메모이제이션에 대해 가장 빠르고 쉽게 이해하는 방법은 역시 코드를 통해 확인 하는 것이다. 간단 버전의 memoize 함수를 구현하여 메모이제이션의 콘셉트에 대해 파악해 보려 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function memoize(func) &#123;</span><br><span class="line">  var cache = &#123;&#125;;</span><br><span class="line">  return function (arg) &#123;</span><br><span class="line">    if (cache[arg]) &#123; // 이미 동일한 인자에 대한 결과가 있으면 리턴</span><br><span class="line">      console.log(&apos;캐시로 결과 바로 리턴&apos;, arg);</span><br><span class="line">      return cache[arg];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;본체 실행&apos;, arg);</span><br><span class="line">    // 받아둔 함수를 실행하면서 결과를 cache에 남겨둠</span><br><span class="line">    return cache[arg] = func.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단한 memoize 함수를 구현했다. memoize 함수를 이용해 mult5 라는 함수를 만든다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var mult5 = memoize(function (a) &#123;</span><br><span class="line">  return a * 5;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(mult5(1));</span><br><span class="line">// 본체 실행 1 -&gt; 5</span><br><span class="line">console.log(mult5(2));</span><br><span class="line">// 본체 실행 2 -&gt; 10</span><br><span class="line">console.log(mult5(1));</span><br><span class="line">// 캐시로 결과 바로 리턴 1 -&gt; 5</span><br><span class="line">console.log(mult5(2));</span><br><span class="line">// 캐시로 결과 바로 리턴 2 -&gt; 10</span><br></pre></td></tr></table></figure><p>매우 간단한 개념이다. memoize는 고차 함수다. 해당 로직을 memoize가 대신하도록 만든 사례이다. 메모이제이션은 인자가 하나일 때 활용성이 높다. 하지만 위의 memoize는 인자를 하나만 사용할 수 있다는 점과 문자열로 식별이 가능한 인자만 사용할 수 있다는 점이 아쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var add = memoize(function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(add(3, 5)); // 본체 실행 3 -&gt; 8</span><br><span class="line">console.log(add(3, 10)); // 캐시로 결과 바로 리턴 8 캐시가 동작했지만 3에만 의존하기 때문</span><br><span class="line"></span><br><span class="line">var keys = memoize(function (obj) &#123;</span><br><span class="line">  return _.keys(obj);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(keys(&#123; a: 1, b: 2 &#125;));</span><br><span class="line">// 본체 실행 Object &#123;a: 1, b: 2&#125; -&gt; [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">console.log(keys(&#123; a: 1, b: 2 &#125;));</span><br><span class="line">// 캐시로 결과 바로 리턴 Object &#123;a: 1, b: 2&#125; -&gt; [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">console.log(keys(&#123; a: 10, b: 20 &#125;));</span><br><span class="line">// 잘 동작하는 듯 했지만 cache가 &#123;[object Object]: ...&#125; 이런 식으로 되기 때문에 오류</span><br></pre></td></tr></table></figure><p>위의 코드를 보면 오류가 발생했다. JSON.stringfy(arguments); 를 활용해서 위와 같은 문제를 해결할 수 있다. 하지만 이 방법은 별도의 연산이 생겨 느리기도 하고 해결할 수 있는 범위가 적다. 이럴때는 역시 함수로 추상화를 하는 것이 좋다.</p><h3 id="Partial-js의-memoize2"><a href="#Partial-js의-memoize2" class="headerlink" title="Partial.js의 _.memoize2"></a>Partial.js의 _.memoize2</h3><p>Partial.js에도 _.memoize가 있다. partial.js의 _.memoize는 Underscore.js의 _.memoize다. partial.js 에는 또 다른 메모이제이션 함수인 _.memoize2가 있다. 이 함수는 인자를 하나만 사용하는 함수에서만 사용할 수 있으며 인자로 객체만 사용할 수 있다.</p><p>_.memoize가 캐시를 함수에 기록한다면 _.memoize2는 캐시를 인자에 기록한다. _.memoize2는 함수 생성 시 함수의 고유 아이디를 만든 후, 인자로 들어오는 객체에 해당 고유 아이디를 기준으로 arg._memoize 밑에 담아 둔다. _.memoize2는 불변 객체 콘셉트와 함께 사용하기 위해 만든 함수이고 실무에서 사용하기 위해 만든 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * _.memoize2</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var f1 = _.memoize2(function (obj) &#123;</span><br><span class="line">  console.log(&apos;함수 본체에 들어옴&apos;);</span><br><span class="line">  return obj.a + 10;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var obj1 = &#123; a: 1 &#125;;</span><br><span class="line">var obj2 = &#123; a: 2 &#125;;</span><br><span class="line"></span><br><span class="line">console.log(f1(obj1));</span><br><span class="line">// 함수 본체에 들어옴 11</span><br><span class="line">console.log(f1(obj1));</span><br><span class="line">// 캐시 사용</span><br><span class="line">console.log(f1(obj2));</span><br><span class="line">// 함수 본체에 들어옴 12</span><br><span class="line">console.log(f1(obj2));</span><br><span class="line">// 캐시 사용</span><br></pre></td></tr></table></figure><p>_.memoize2는 _.memoize와는 다른 특징과 장점을 가지고 있다. 우선 각 함수들에 대한 결과값을 인자로 사용된 객체에 담아두므로 한 번 사용하고 버리는 객체라면, 그 값은 별도의 관리 없이도 메모리에서 비워진다. 이것이 일단 가장 큰 장점이다. _.memoize는 결과 캐시가 함수에 쌓이기 때문에 함수를 없애거나 함수에 달린 캐시를 별도로 관리해야 하지만, _.memoize2는 사용한 인자에 결과 캐시가 쌓이므로 그 값을 계속 사용하느냐 아니냐에 따라 자동으로 메모리가 관리된다. 이것 외에도 값을 불변적으로 다룰 때 얻을 수 있는 실용적인 이점이 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var evens = _.memoize2(function (list) &#123;</span><br><span class="line">  console.log(&apos;함수 본체에 들어와서 loop 실행&apos;);</span><br><span class="line">  return _.filter(list, function (num) &#123;</span><br><span class="line">    return num % 2 === 0;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">console.log(evens(list)); // [2,4,6,8,10]</span><br><span class="line">console.log(evens(list)); // [2,4,6,8,10] (캐시를 사용하여 loop를 돌지 않음)</span><br><span class="line"></span><br><span class="line">list.push(11);</span><br><span class="line">list.push(12);</span><br><span class="line">console.log(list); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span><br><span class="line"></span><br><span class="line">console.log(evens(list)); // 캐시가 사용되어 12가 나오지 않음.</span><br></pre></td></tr></table></figure><p>마지막 evens 실행 시에는 원하는 결과를 얻지 못했다. 값을 가변적으로 다뤘기 때문이다. 불변적으로 값을 다루게 되면 캐시도 자동으로 갱신되고, 값이 변경되지 않은 상태에서는 계속해서 캐시를 사용하기 때문에 성능적으로 이득을 얻을 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">console.log(evens(list)); // [2,4,6,8,10]</span><br><span class="line">console.log(evens(list)); // [2,4,6,8,10] (캐시를 사용하여 loop를 돌지 않음)</span><br><span class="line"></span><br><span class="line">list2 = list2.concat(11, 12);</span><br><span class="line">console.log(list2); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span><br><span class="line"></span><br><span class="line">console.log(evens(list2)); // [2,4,6,8,10, 12]</span><br><span class="line">console.log(evens(list2)); // [2,4,6,8,10, 12] (캐시를 사용하여 loop를 돌지 않음)</span><br></pre></td></tr></table></figure><p>_.memoize2로 만든 함수는 인자를 한 개만 받을 수 있다. 두 개 이상의 인자를 필요로 하는 함수는 _.memoize2를 사용할 수 없다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 메모이제이션은 함수형 프로그래밍 관련 이야기에서는 빠지지 않고 꼭 등장하는 사례이기도 하다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="memoization" scheme="https://kkangil.github.io/tags/memoization/"/>
    
  </entry>
  
  <entry>
    <title>값에 대해</title>
    <link href="https://kkangil.github.io/2019/12/29/%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%B4/"/>
    <id>https://kkangil.github.io/2019/12/29/값에-대해/</id>
    <published>2019-12-29T07:35:45.000Z</published>
    <updated>2019-12-29T09:10:00.896Z</updated>
    
    <content type="html"><![CDATA[<p>함수로 협업하는 가장 좋은 방법은 인자와 리턴값으로만 소통하는 것이다. 순수하게 인자와 리턴값에만 의존하면 누가 만든 함수든 어떤 라이브러리로 만든 함수든 조립할 수 있게 된다. 이때 함수에서 다루는 값으로 자바스크립트의 기본 객체를 사용하거나 아주 보편적으로 약속된 객체만 사용하면 함수들 간의 조합성이 더욱 좋아진다.</p><a id="more"></a><p>여기서 말하는 기본 객체란 Array, Object, String, Number, Boolean, Null, Undefined 등의 자바스크립트 기본 객체를 말하며, 브라우저의 DOM 같은 것들도 범주 안에 들어올 수 있다. 어떤 프로퍼티와 어떤 메서드를 가지고 있는지 충분히 약속되고 보장된 값들을 말한다. 약속된 스펙을 가진 값들만 사용하는 함수들은 언제나 어떤 환경에서나 사용하기 편하다.</p><h2 id="순수-함수"><a href="#순수-함수" class="headerlink" title="순수 함수"></a>순수 함수</h2><h3 id="순수-함수와-부수-효과"><a href="#순수-함수와-부수-효과" class="headerlink" title="순수 함수와 부수 효과"></a>순수 함수와 부수 효과</h3><p>순수 함수는 동일한 인자가 들어오면 항상 동일한 값을 리턴하는 함수다. 메서드가 자신이 가진 내부의 상태에 따라 다른 결과를 만든다면, 순수 함수는 들어온 인자와 상수만 사용하여 항상 동일한 결과를 리턴한다.<br>또 하나 중요한 특징이 있는데, 바로 외부의 상태를 변경하지 않는다는 점이다. 함수에게 들어온 인자를 포함하여, 외부와 공유되고 있는 값 중 함수가 참조할 수 있는 어떤 값도 변경하지 않는 것을 말한다. 함수가 외부 상태를 변경하면, 외부 상태와 연관이 있는 다른 부분에도 영향이 있고 이것을 부수 효과(Side effect)라고 한다.</p><p>부수 효과 문제는 특히 동시성이 생길 때 더욱 취약하다. 브라우저나 Node.js는 다양한 작업을 동시에 처리한다. 이렇게 동시성이 생기는 상황에서는 여러 곳에서 공유되도 있는 값이 변경되는 것은 위험하다. 부수 효과는 단지 동시성에서만의 이슈가 아니다. 예를 들면 사용자가 오랫동안 인터랙션을 해서 상태를 지속적으로 관리해야 하는 웹 페이지나 앱의 코드들에서 부수 효과 문제가 생기는 경우가 많다.</p><p>순수 함수의 정의를 아는 것보다 중요한 점은 여기에 담긴 목적과 전략이다. 순수 함수에 담긴 전략은 그 이름처럼 간단 명료하다. 상태 변화를 최소화하고, 다음 단계로 넘어갈 때마다 새로운 값으로 출발하는 식으로 코딩하는 것이다. 이렇게 하면 문제가 쉬워진다. 문제가 단순해지면 해결책 역시 쉬워지고 오류를 만들 가능성도 줄어든다. 작은 순수 함수들을 모아 만든 소프트웨어는 유지 보수와 기획 변경에 유연하게 대응한다.</p><h3 id="순수-함수와-순수-함수가-아닌-함수"><a href="#순수-함수와-순수-함수가-아닌-함수" class="headerlink" title="순수 함수와 순수 함수가 아닌 함수"></a>순수 함수와 순수 함수가 아닌 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 순수 함수</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 순수 함수가 아닌 함수</span><br><span class="line">function add2(obj, value) &#123;</span><br><span class="line">  obj.value = obj.value + value;</span><br><span class="line">  return obj.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 작은 차이지만 순수 함수</span><br><span class="line">function add3(obj, value) &#123;</span><br><span class="line">  return obj.value + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 작은 차이지만 순수 함수 2</span><br><span class="line">function add4(obj, value) &#123;</span><br><span class="line">  return &#123; value: obj.value + value &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add는 인자를 받아 새로운 값을 리턴했고 add2는 obj의 상태를 변경한다. add는 인자가 같으면 항상 결과가 같고 부수 효과가 없다. add2는 obj.value의 상태에 따라 결과가 달라진다. 이런 점 자체가 문제를 만들지는 않지만 만일 obj.value를 사용하는 코드가 add2 외에 다른 곳에도 있다면 반드시 obj.value가 변경될 수 있다는 점과 변경될 시점 등을 정확히 인지하고 제어해야 할 것이다.</p><p>add3과 add4는 작은 차이가 있지만 순수 함수다. obj.value를 참조만 하고 있기 때문이다. 순수 함수를 만들기 위해 항상 모든 값을 새로 만들어야 하는 것은 아니다. 조회 자체는 부수 효과를 일으키지 않는다.</p><p>순수 함수로 프로그래밍을 한다면 add 같은 작은 기능의 함수만 만들어지는 게 아닌가 하는 생각이 들 수 있다. 클래스나 객체처럼 풍부한 기능을 가진 모듈을 만들 수 없을 것만 같을 수 있다. 하지만 인자로 함수를 사용하거나 고차 함수를 이용한 함수 조합을 통해 순수 함수의 조건을 따르면서 보다 풍부한 변화를 불러오는 함수들을 만들 수 있다.</p><h2 id="변경-최소화와-불변-객체"><a href="#변경-최소화와-불변-객체" class="headerlink" title="변경 최소화와 불변 객체"></a>변경 최소화와 불변 객체</h2><h3 id="직접-변경하는-대신-변경된-새로운-값을-만드는-전략"><a href="#직접-변경하는-대신-변경된-새로운-값을-만드는-전략" class="headerlink" title="직접 변경하는 대신, 변경된 새로운 값을 만드는 전략"></a>직접 변경하는 대신, 변경된 새로운 값을 만드는 전략</h3><p>대부분 이미 확인한 함수들이지만 이번에는 값과 값을 변경해 나가는 것에 초점을 두고 설명하고자 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var users1 = [</span><br><span class="line">  &#123; name: &quot;ID&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;HA&quot;, age: 25 &#125;,</span><br><span class="line">  &#123; name: &quot;BJ&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;PJ&quot;, age: 28 &#125;,</span><br><span class="line">  &#123; name: &quot;JE&quot;, age: 27 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var comparator = function (a, b) &#123;</span><br><span class="line">  if (a.age &lt; b.age) return -1;</span><br><span class="line">  if (a.age &gt; b.age) return 1;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var sortedUsers1 = users1.sort(comparator) // 1</span><br><span class="line"></span><br><span class="line">console.log(users1 === sortedUsers1) // 2 true</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(sortedUsers1, &apos;age&apos;)); // 3 [25, 27, 28, 32, 32]</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(users1, &apos;age&apos;)); // 4 [25, 27, 28, 32, 32]</span><br></pre></td></tr></table></figure><p>users1을 나이순으로 정렬하는 예제다. Array.prototype.sort는 자기 자신을 정렬하는 함수다. 2의 결과가 true라는 것은 둘이 완전히 같은 객체라는 뜻이다. 동일한 값을 가진 객체가 아닌 완전히 같은 객체라는 것이다. 1의 .sort() 메서드는 자기 자신을 바꾸고 자기 자신을 리턴한다. 3 _.pluck 를 통해 age 값만 꺼내보면 둘다 동일하게 정렬이 된 것을 확인할 수 있는데, users1과 sortedUsers1이 완전히 같은 값이어서 동일한 결과가 출력된 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var users2 = [</span><br><span class="line">  &#123; name: &quot;ID&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;HA&quot;, age: 25 &#125;,</span><br><span class="line">  &#123; name: &quot;BJ&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;PJ&quot;, age: 28 &#125;,</span><br><span class="line">  &#123; name: &quot;JE&quot;, age: 27 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var sortedUsers2 = _.sortBy(users2, &apos;age&apos;) // 1</span><br><span class="line"></span><br><span class="line">console.log(users2 === sortedUsers2) // 2 false</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(sortedUsers2, &apos;age&apos;)) // 3 [25, 27, 28, 32, 32]</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(users2, &apos;age&apos;)) // 4 [32, 25, 32, 28, 27]</span><br><span class="line"></span><br><span class="line">console.log(users2[1] === sortedUsers2[0]); // 5 true</span><br></pre></td></tr></table></figure><p>이번에는 _.sortBy 함수를 이용하여 정렬을 해 보았다. 2를 확인해 보면 false가 나온다. 1에서 리턴된 sortedUser2는 새로운 객체다. 3,4 를 확인해 보면 sortedUsers2는 나이순으로 정렬이 되었는데, users2 는 원본 그대로임을 알 수 있다. 다른 곳에 users2의 순서에 의존하여 동작하고 있는 코드가 있다면, sortedUsers2 처럼 새로운 객체를 만들어 정렬을 하는 방식이 부수 효과가 없고 유리하다.</p><p>sortedUser2는 새로운 값이다. 그렇다면 배열 안의 값들도 새로운 값일까? 서로 다르게 정렬이 되어 있지만, 두 배열 안에 있는 모든 값은 새로운 값이 아닌 기존의 값이다. 항상 배열 내의 모든 값을 새롭게 만든다면 메모리 사용량이 매우 높아질 것이다. _.sortBy는 내부의 값은 기존의 값을 그대로 활용하면서 배열만 새로 만들어 정렬한다.</p><p>Undescore.js의 콘셉트 중에는 이러한 중요한 전략이 있다. 이 전략을 잘 따르면 부수 효과를 줄이면서도 메모리 사용량 증가는 최소화하는 좋은 함수들을 만들 수 있다. 그것은 바로 그<code>함수가 변경할 영역에 대해서만 새 값을 만드는 전략</code>이다. 예를 들어 자신의 역할이 정렬이라면 정렬과 연관 있는 부분만 새 값으로 만들고 나머지 값들은 재활용하는 식이다. 이 전략을 대부분의 함수적 함수에 적용된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var rejectedUsers2 = _.reject(users2, function (user) &#123; return user.age &lt; 30; &#125;);</span><br><span class="line">console.log(rejectedUsers2);</span><br><span class="line">// [&#123;name: &quot;ID&quot;, age: 32&#125;, &#123;name: &quot;BJ&quot;, age: 32&#125;]</span><br><span class="line"></span><br><span class="line">console.log(rejectedUsers2 === users2) // false</span><br><span class="line">console.log(rejectedUsers2.length, users2.length); // 2 5 </span><br><span class="line">console.log(rejectedUsers2[0] === users2[0]) // true</span><br></pre></td></tr></table></figure><p>배열 내부의 값 중 특정 조건의 값들을 제외하는 _.reject 같은 함수도 배열 내부의 값들을 지우는 것이 아니라 값들이 지워진 새로운 배열을 만드는 것이다. _.reject도 결국 같은 전략을 따른 것이다. _.reject 함수의 역할은 값을 제외하는 것이고 달라지는 영역은 배열이기에 배열을 새로 만드는 것이다.</p><p>users2에서 30세 미만인 사람들을 제외했다. 더 정확히 말하면 30세 미만인 사람들이 제외된 새로운 배열을 만들어 리턴했다. rejectedUsers2는 users2가 아니며, users2.length도 그대로이고, 배열 내부의 값들도 기존의 값 그대로다. users2를 다루면서 새로 정렬하고 배열 내부의 값도 지웠지만, users2는 원래 상태 그대로이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//  1</span><br><span class="line">console.log(</span><br><span class="line">  _.pluck(_.reject(users2, function (user) &#123; return user.age &gt;= 30; &#125;), &apos;name&apos;)</span><br><span class="line">)</span><br><span class="line">// [&quot;HA&quot;, &quot;PJ&quot;, &quot;JE&quot;]</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">console.log(</span><br><span class="line">  _.pluck(users2, &apos;name&apos;)</span><br><span class="line">)</span><br><span class="line">// [&quot;ID&quot;, &quot;HA&quot;, &quot;BJ&quot;, &quot;PJ&quot;, &quot;JE&quot;]</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">console.log(users2)</span><br><span class="line">// 원본 그대로</span><br></pre></td></tr></table></figure><p>1 users에서는 _.reject로 30세 이상의 user를 제외한 새 배열을 만든 후, _.pluck을 통해 이름만 추출한 새 배열을 만들어 로그를 남겼다. _.reject를 이용해 users2의 상태를 변경하지 않으면서 필터링을 했고, _.pluck 를 통해 역시 원본 소스들을 건들지 않고 name이 추출된 새로운 배열을 만들었다. 따라서 원본 데이터에는 아무런 영향을 끼치지 않았다. 그 덕분에 2에서는 어려움 없이 원본에 있는 모든 이름을 출력할 수 있다. 2가 실행된 후에도 3 users는 역시 변경되지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var b1 = [1, 2, 3, 4, 5];</span><br><span class="line">var b2 = _.initial(b1, 2); // 뒤에서 2개 제거한 새로운 배열 리턴</span><br><span class="line">console.log(b1 === b2, b1, b2);</span><br><span class="line">// false (5) [1, 2, 3, 4, 5] (3) [1, 2, 3]</span><br><span class="line"></span><br><span class="line">var b3 = _.without(b1, 1, 5); // 1과 5를 제거한 새로운 배열 리턴</span><br><span class="line">var b4 = _.without(b3, 2); // 2를 제거한 새로운 배열 리턴</span><br><span class="line">console.log(b1 === b3, b3 === b4, b3, b4);</span><br><span class="line">// false false (3) [2, 3, 4] (2) [3, 4]</span><br></pre></td></tr></table></figure><p>맨 마지막에 b4를 만들 때, b3 에서 2를 제거했지만 b3에는 여전히 2가 남아있다.</p><h3 id="clone-으로-복사하기"><a href="#clone-으로-복사하기" class="headerlink" title="_.clone 으로 복사하기"></a>_.clone 으로 복사하기</h3><p>_.clone은 배열이나 객체를 받아 복사하는 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var product1 = &#123;</span><br><span class="line">  name: &quot;AB 반팔티&quot;,</span><br><span class="line">  price: 10000,</span><br><span class="line">  sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">  colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var product2 = _.clone(product1);</span><br><span class="line">console.log(product2);</span><br><span class="line">// &#123;</span><br><span class="line">//   name: &quot;AB 반팔티&quot;,</span><br><span class="line">//   price: 10000,</span><br><span class="line">//   sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">//   colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">console.log(product1 === product2); // false</span><br><span class="line"></span><br><span class="line">product2.name = &quot;ABCD 반팔티&quot;;</span><br><span class="line">console.log(product1.name, product2.name);</span><br><span class="line">// AB 반팔티 ABCD 반팔티</span><br></pre></td></tr></table></figure><p>product1을 _.clone 함수를 통해 복사했다. 동일한 내용이 들어 있는 새로운 객체가 리턴되어, 출력해 보면 내용은 같지만 비교하면 false가 나온다. product2.name 을 변경해도 product1에는 영향을 끼치지 않는다. product2를 마음 편히 다룰 수 있다.<br>그런데 _.clone을 정확히 다루려면 _.clone이 객체를 복하는 범위에 대해 제대로 알아야 한다. _.clone이 객체를 복사하는 것은 맞지만 객체 내부의 모든 값들까지 복사하는 것은 아니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">product2.sizes.push(&quot;2XL&quot;);</span><br><span class="line">console.log(product2.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;2XL&quot;]</span><br><span class="line">console.log(product1.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;2XL&quot;]</span><br><span class="line">console.log(product1.sizes === product2.sizes); // true</span><br></pre></td></tr></table></figure><p>_.clone은 동일한 key들을 가진 새로운 객체를 만들면서 각 key에 기존의 key에 해당하는 value를 할당한다. 때문에 내부의 값이 객체라면 같은 객체를 바라보게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_.clone = function (obj) &#123;</span><br><span class="line">  var cloned = _.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  var keys = _.keys(obj);</span><br><span class="line">  _.each(keys, function (key) &#123;</span><br><span class="line">    cloned[key] = obj[key]; // Array일때는 key가 숫자</span><br><span class="line">  &#125;);</span><br><span class="line">  return cloned;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;;</span><br><span class="line">var obj2 = _.clone(obj1);</span><br><span class="line">obj2.b = 22;</span><br><span class="line"></span><br><span class="line">console.log(obj2);</span><br><span class="line">// &#123; a: 1, b: 22, c: &#123; d: 3 &#125; &#125;;</span><br><span class="line">console.log(obj1);</span><br><span class="line">// &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj1 === obj2); // false</span><br><span class="line">console.log(obj1.c === obj2.c); // true</span><br><span class="line"></span><br><span class="line">obj2.c.d = 33;</span><br><span class="line">console.log(obj1.c.d) // 33 obj1도 같이 변경</span><br></pre></td></tr></table></figure><p>그렇다면 객체 안의 객체를 변경하고 싶은 경우에는 어떻게 해야 원본에 영향을 주지 않으면서 값을 변경할 수 있을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var product1 = &#123;</span><br><span class="line">  name: &quot;AB 반팔티&quot;,</span><br><span class="line">  price: 10000,</span><br><span class="line">  sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">  colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var product2 = _.clone(product1);</span><br><span class="line">product2.sizes = _.clone(product2.sizes); // 내부도 clone 후 push를 하거나</span><br><span class="line">product2.sizes.push(&quot;2XL&quot;)</span><br><span class="line">console.log(product2.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;2XL&quot;]</span><br><span class="line">console.log(product1.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;]</span><br><span class="line">console.log(product1.sizes === product2.sizes); // false</span><br><span class="line"></span><br><span class="line">product2.colors = product2.colors.concat(&quot;Yellow&quot;) // 아니면 concat으로 한번에</span><br><span class="line">console.log(product2.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;, &quot;Yellow&quot;]</span><br><span class="line">console.log(product1.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">console.log(product1.colors === product2.colors); // false</span><br></pre></td></tr></table></figure><p>위와 같이 하면 된다. 어차피 내부의 값도 복사하는 식으로 값을 다뤄야 한다면 왜 굳이 객체의 첫 번째 깊이만 복사하느냐고 생각할 수 있다. 값 복사 후 항상 내부의 모든 값을 변경할 것이 아니기에, 객체 내부의 객체는 공유하는 것이 메모리 사용에 유리하고, 복사 수행 처리 시간이라는 측면에서도 이점이 많다.</p><h3 id="extend-defaults로-복사하기"><a href="#extend-defaults로-복사하기" class="headerlink" title="_.extend, _.defaults로 복사하기"></a>_.extend, _.defaults로 복사하기</h3><p>_.extend나 _.defaults를 이용하면 값 복사와 변경을 좀 더 간결하게 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var product1 = &#123;</span><br><span class="line">  name: &quot;AB 반팔티&quot;,</span><br><span class="line">  price: 10000,</span><br><span class="line">  sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">  colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">var product2 = _.extend(&#123;&#125;, product1, &#123;</span><br><span class="line">  name: &quot;AB 긴팔티&quot;,</span><br><span class="line">  price: 15000</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">var product3 = _.defaults(&#123;</span><br><span class="line">  name: &quot;AB 후드티&quot;,</span><br><span class="line">  price: 15000</span><br><span class="line">&#125;, product1);</span><br><span class="line"></span><br><span class="line">console.log(product2);</span><br><span class="line">// &#123;</span><br><span class="line">//   name: &quot;AB 긴팔티&quot;,</span><br><span class="line">//   price: 15000,</span><br><span class="line">//   sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">//   colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">// &#125;;</span><br><span class="line">console.log(product3);</span><br><span class="line">// &#123;</span><br><span class="line">//   name: &quot;AB 후드티&quot;,</span><br><span class="line">//   price: 15000,</span><br><span class="line">//   sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">//   colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">// &#125;;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">var product4 = _.extend(&#123;&#125;, product3, &#123;</span><br><span class="line">  colors: product3.colors.concat(&quot;Purple&quot;)</span><br><span class="line">&#125;);</span><br><span class="line">var product5 = _.defaults(&#123;</span><br><span class="line">  colors: product4.colors.concat(&quot;Red&quot;)</span><br><span class="line">&#125;, product4);</span><br><span class="line"></span><br><span class="line">console.log(product3.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">console.log(product4.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;, &quot;Purple&quot;]</span><br><span class="line">console.log(product5.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;, &quot;Purple&quot;, &quot;Red&quot;]</span><br></pre></td></tr></table></figure><ol><li>product2는 값 복사를 위해 새로운 객체인 {} 를 _.extend의 첫 번째 인자로 넣었다.</li><li>어차피 {name: “AB 후드티”, price: 12000}도 새 객체이므로 product3처럼 _.defaults를 이용하는 것이 객체를 적게 생성해서 더 효율적이다. _.extend의 경우, 왼쪽 객체에 없는 key/value는 확장하고, 왼쪽 객체에 있던 key/value는 덮어 쓴다. _.defaults는 왼쪽에 없는 key/value만 확장한다.</li><li>1, 2를 보면 _.clone 없이 복사와 변경을 동시에 하여 간결해졌지만, colors 처럼 깊은 값을 변경해야 할 경우에는 직접 다뤄줘야 한다. _.extend와 _.defaults 역시 변경이 필요 없는 값은 이전의 값을 공유한다.</li></ol><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수로 협업하는 가장 좋은 방법은 인자와 리턴값으로만 소통하는 것이다. 순수하게 인자와 리턴값에만 의존하면 누가 만든 함수든 어떤 라이브러리로 만든 함수든 조립할 수 있게 된다. 이때 함수에서 다루는 값으로 자바스크립트의 기본 객체를 사용하거나 아주 보편적으로 약속된 객체만 사용하면 함수들 간의 조합성이 더욱 좋아진다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="순수 함수" scheme="https://kkangil.github.io/tags/%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98/"/>
    
      <category term="부수 효과" scheme="https://kkangil.github.io/tags/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC/"/>
    
      <category term="변경 최소화" scheme="https://kkangil.github.io/tags/%EB%B3%80%EA%B2%BD-%EC%B5%9C%EC%86%8C%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>Partial.js와 함수 조립</title>
    <link href="https://kkangil.github.io/2019/12/01/Partial-js%EC%99%80-%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/"/>
    <id>https://kkangil.github.io/2019/12/01/Partial-js와-함수-조립/</id>
    <published>2019-12-01T06:35:32.000Z</published>
    <updated>2019-12-01T09:41:04.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="파이프라인"><a href="#파이프라인" class="headerlink" title="파이프라인"></a>파이프라인</h2><h3 id="즉시-실행-파이프라인-go와-mr"><a href="#즉시-실행-파이프라인-go와-mr" class="headerlink" title="즉시 실행 파이프라인, _.go와 _.mr"></a>즉시 실행 파이프라인, _.go와 _.mr</h3><p>_.go는 파이프라인의 즉시 실행 버전이다. 첫 번째 인자로 받은 값을 두 번째 인자로 받은 함수에게 넘겨주고, 두 번째 인자로 받은 함수의 결과는 세 번째 함수에게 넘겨준다. 이것을 반복하다가 마지막 함수의 결과를 리턴해 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.go(10, // 첫번째 인자</span><br><span class="line">  function (a) &#123; return a * 10 &#125;, // 100</span><br><span class="line">  function (a) &#123; return a - 50 &#125;, // 50</span><br><span class="line">  function (a) &#123; return a + 10 &#125; // 60</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>_.go는 Multiple Results를 지원한다. _.mr 함수를 함께 사용하면 다음 함수에게 2개 이상의 인자들을 전달할 수 있다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.go(10,</span><br><span class="line">  function (a) &#123; return _.mr(a * 10, 50) &#125;,</span><br><span class="line">  function (a, b) &#123; return a - b &#125;,</span><br><span class="line">  function (a) &#123; return a + 10 &#125;</span><br><span class="line">)</span><br><span class="line">// 60</span><br></pre></td></tr></table></figure><p>_.go의 첫 번째 인자는 두 번째 인자인 함수가 사용할 인자이며 두 번째 부터는 파이프라인에서 사용할 함수들이다. _.go의 두 번째 인자인 함수, 즉 최초 실행될 함수에게 2개 이상의 인자를 넘끼고자 한다면 그때도 _.mr을 사용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.go(_.mr(2, 3),</span><br><span class="line">  function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;,</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return a * a</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 25</span><br></pre></td></tr></table></figure><p>위의 코드처럼 _.mr로 인자들을 감싸서 넘겨주면, 다음 함수는 인자를 여러개로 펼쳐서 받게 된다. _.mr(2, 3)은 하나의 값이지만 _.go 내부에서 인자를 펼쳐서 넘겨주어, 2와 3이 첫 번째 함수의 a와 b가 된다.<br>_.go는 이미 정의되어 있는 함수와 조합하거나 화살표 함수와 사용할 때 특히 표현력이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function square(a) &#123;</span><br><span class="line">  return a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.go(_.mr(2, 3), add, square);</span><br><span class="line">_.go(_.mr(2, 3), (a, b) =&gt; a + b, a =&gt; a * a)</span><br></pre></td></tr></table></figure><h3 id="함수를-만드는-파이프라인-pipe"><a href="#함수를-만드는-파이프라인-pipe" class="headerlink" title="함수를 만드는 파이프라인 _.pipe"></a>함수를 만드는 파이프라인 _.pipe</h3><p>_.go가 즉시 실행하는 파이프라인이라면 _.pipe는 실행할 준비가 된 함수를 리턴하는 파이프라인 함수다. 그 외 모든 기능은 _.go와 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f1 = _.pipe(add, square);</span><br><span class="line">f1(2, 3); // 25</span><br><span class="line"></span><br><span class="line">var f2 = _.pipe((a, b) =&gt; a + b, a =&gt; a * a);</span><br><span class="line">f2(2, 3) // 25</span><br></pre></td></tr></table></figure><h3 id="부분-커링-함수와의-조합"><a href="#부분-커링-함수와의-조합" class="headerlink" title="부분 커링 함수와의 조합"></a>부분 커링 함수와의 조합</h3><p>파이프라인 함수를, 함수를 리턴하는 함수와 함께 사용해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var products = [</span><br><span class="line">  &#123; id: 1, name: &quot;후드 집업&quot;, discounted_price: 6000, price: 10000 &#125;,</span><br><span class="line">  &#123; id: 2, name: &quot;코잼 후드티&quot;, discounted_price: 8000, price: 8000 &#125;,</span><br><span class="line">  &#123; id: 3, name: &quot;A1 반팔티&quot;, discounted_price: 6000, price: 6000 &#125;,</span><br><span class="line">  &#123; id: 4, name: &quot;코잼 반팔티&quot;, discounted_price: 5000, price: 6000 &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">_.go(products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price), // 1</span><br><span class="line">  _.sortBy(&apos;discounted_price&apos;), // 2</span><br><span class="line">  _.first, // 3</span><br><span class="line">  _.val(&apos;name&apos;) // 4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 코잼 반팔티</span><br></pre></td></tr></table></figure><ol><li><code>products</code> 중에 할인 중인 상품만 남긴다.</li><li><code>discounted_price</code> 가 낮은 순으로 정렬한다.</li><li>첫 번째를 꺼낸다.</li><li>product.name 을 확인한다.</li></ol><p>Partial.js의 _.filter, _.sortBy, _.val은 모두 부분 커링이 된다. 모두 인자를 하나만 넘겨 앞으로 실행될 함수를 리턴 받았다. 그렇게 만들어진 함수들은 _.go를 통해 순서대로 실행된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 할인 상품 중 가격이 가장 높은 상품의 이름</span><br><span class="line">_.go(products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.sortBy(&apos;discounted_price&apos;),</span><br><span class="line">  _.last,</span><br><span class="line">  _.val(&apos;name&apos;),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// 후드 집업</span><br><span class="line"></span><br><span class="line">// 할인 상품 중 할인액이 가장 높은 상품의 이름</span><br><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.sortBy(p =&gt; p.discounted_price - p.price),</span><br><span class="line">  _.first,</span><br><span class="line">  _.val(&apos;name&apos;),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// 후드 집업</span><br><span class="line"></span><br><span class="line">// 할인 상품 중 할인액이 가장 낮은 상품의 이름</span><br><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.max(p =&gt; p.discounted_price - p.price),</span><br><span class="line">  _.val(&apos;name&apos;),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// 코잼 반팔티</span><br></pre></td></tr></table></figure><p>중간중간 들어간 함수들의 조합을 약간씩 수정하여, 다른 로직으로 쉽게 변경할 수 있다. 할인이 진행 중인 상품들 중 제일 비싼 상품을 꺼낸다든지, 할인이 되지 않는 상품 중 제일 싼 상품을 꺼낸다든지 하는 로직으로 변경하는 것이 위에서 알 수 있듯 매우 쉽다.</p><h3 id="보조-함수로-사용하는-파이프라인"><a href="#보조-함수로-사용하는-파이프라인" class="headerlink" title="보조 함수로 사용하는 파이프라인"></a>보조 함수로 사용하는 파이프라인</h3><p>파이프라인을 보조 함수로 만들기 위해 사용하는 것도 좋다. 파이프라인을 _.each, _.map, _.reduce 등과 같은 고차 함수들의 보조 함수로 사용해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.map(_.pipe(_.identity, _.pick([&apos;id&apos;, &apos;name&apos;]), _.values)),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// [[1, &quot;후드 집업&quot;], [4, &quot;코잼 반팔티&quot;]]</span><br></pre></td></tr></table></figure><p>_.filter 에서는 할인 중인 상품만 남게 된다. _.map 에서는 iteratee를 파이프라인으로 만들었다. _.pipe는 _.identity를 통해 iteratee의 첫 번째 인자인 product만 리턴하게 되고, 부분 커링된 _.pick을 통애 id와 name만 남은 객체로 만들게 된다. 마지막으로 _.values를 통해 값만 남겼다.</p><h3 id="비동기와-go"><a href="#비동기와-go" class="headerlink" title="비동기와 _.go"></a>비동기와 _.go</h3><p>_.go는 비동기 제어를 지원한다. Promise가 체인 방식에 함수적인 아이디어를 가미하여 비동기 상황을 제어했다면, _.go는 함수적으로만 비동기를 제어한다. _.go는 내부적으로 함수들을 순차적으로 실행해 나가면서 비동기 함수의 결과를 재귀 함수로 꺼낸 후, 다음 함수에게 이어주는 식으로 비동기 상황을 제어한다.<br>_.go와 _.pipe는 일반 콜백 함수와 Promise를 모두 지원한다. _.go와 _.pipe는 기본적으로 동기로 동작하지만 파이프라인의 함수들을 실행하는 도중에 Promise 객체가 리턴되거나 jQuery의 then과 같은 Deferred Object가 리턴되거나 _.callback 함수를 이용했다면, 내부적으로 비동기를 제어하는 파이프라인으로 변한다.<br>Promise의 경우에는 함수가 실행되면 즉시 setTimeout을 일으키고, 일단 { then: … } 을 리턴하게 되므로 동기 함수들과 중첩 사용을 할 수 없다. 그러나 _.go의 경우에는 비동기 상황이 없을 경우 결과를 즉시 리턴하기 때문에, 이후 연속적으로 실행되는 함수들이 반드시 비동기성을 띌 필요가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  10,</span><br><span class="line">  _.callback(function (a, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a + 10)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">  &#125;),</span><br><span class="line">  function (a) &#123; // next를 통해 받은 결과 a</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 상황에서 _.go는 첫 번째 함수를 실행하면서 내부적으로 next를 만들어 함수에게 넘긴다. next에게 결과를 전달하면 그 결과는 다음 함수의 인자로 넘어가게 된다. 다시 바깥으로 나와 그 다음 함수들을 순차적으로 실행하므로 콜백 지옥에서 벗어날 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function asyncCallback() &#123;</span><br><span class="line">  function add(a, b, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a + b);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(a, b, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a - b);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function mul(a, b, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a * b);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function log(msg, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(msg);</span><br><span class="line">      next(msg);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _.go(</span><br><span class="line">    _.mr(5, 10),</span><br><span class="line">    _.callback(</span><br><span class="line">      function (a, b, next) &#123;</span><br><span class="line">        add(a, b, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function (result, next) &#123;</span><br><span class="line">        sub(result, 10, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function (result, next) &#123;</span><br><span class="line">        mul(result, 10, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function (result, next) &#123;</span><br><span class="line">        log(result, next);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncCallback(); // 50</span><br></pre></td></tr></table></figure><p>연속적으로 비동기 함수가 사용되어야 한다면 위와 같이 _.callback 함수에 여러개의 함수를 넘겨도 되고, 아래와 같이 미리 _.callback 패턴이라고 지정해 두면 더욱 간결하게 코딩할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var add = _.callback(function (a, b, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    next(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _.callback(function (a, b, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    next(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var mul = _.callback(function (a, b, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    next(a * b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var log = _.callback(function (msg, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">    next(msg);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">_.go(</span><br><span class="line">  _.mr(5, 10),</span><br><span class="line">  add,</span><br><span class="line">  function (result) &#123;</span><br><span class="line">    return sub(result, 10);</span><br><span class="line">  &#125;,</span><br><span class="line">  function (result) &#123;</span><br><span class="line">    return mul(result, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  function (result) &#123;</span><br><span class="line">    return log(result);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 코드 처럼 _.callback 함수로 미리 정의해 둔 ad, sub 등의 함수를 실행하면 그 함수는 Promise 객체를 리턴한다. 정확히는 Promise가 지원되는 환경에서는 Promise 객체를 리턴하고, Promise가 지원되지 않는 환경에서는 Partial.js 내부에 구현된 Promise 객체를 리턴한다. Promise 객체를 파이프라인이 다시 받아도 다시 비동기를 제어한다. 따라서 Promise가 지원되지 않는 환경에서도 파이프라인식의 비동기 제어가 가능하다.</p><h3 id="중간에-멈추고-나가기"><a href="#중간에-멈추고-나가기" class="headerlink" title="중간에 멈추고 나가기"></a>중간에 멈추고 나가기</h3><p>일반 함수에서는 함수 중간 어디서든 return문으로 함수를 빠져 나올 수 있다. Partial.js는 파이프라인에서도 이와 같은 일이 가능하도록 지원하는데, 바로 _.stop이라는 함수를 이용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  null,</span><br><span class="line">  function () &#123; console.log(1) &#125;,</span><br><span class="line">  function () &#123; console.log(2) &#125;,</span><br><span class="line">  function () &#123; return _.stop() &#125;,</span><br><span class="line">  function () &#123; console.log(3) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>1과 2만 찍힌 후 세번째 함수는 실행되지 않고 파이프라인 전체를 나오게 된다. _.go의 최종 결과도 함께 전달하고 싶다면 _.stop 함수에게 전달하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var result = _.go(</span><br><span class="line">  null,</span><br><span class="line">  function () &#123; console.log(1) &#125;,</span><br><span class="line">  function () &#123; console.log(2) &#125;,</span><br><span class="line">  function () &#123; return _.stop(&quot;Hi&quot;) &#125;,</span><br><span class="line">  function () &#123; console.log(3) &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(result); // Hi</span><br></pre></td></tr></table></figure><h2 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h2><h3 id="코드-변경없이-비동기-제어가-되는-고차-함수"><a href="#코드-변경없이-비동기-제어가-되는-고차-함수" class="headerlink" title="코드 변경없이 비동기 제어가 되는 고차 함수"></a>코드 변경없이 비동기 제어가 되는 고차 함수</h3><p>Partial.js의 _.each, _.map, _.reduce 등의 주요 함수들은 _.go와 _.pipe 처럼 하나의 함수로 동기와 비동기 상황이 모두 대응되도록 되어 있다. Partial.js의 함수를 이용하면 비동기 상황에서도 동기 상황과 동일한 코드를 작성할 수 있고, 비동기 함수와 동기 함수의 조합도 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">console.log(JSON.stringify(_.map([1, 2, 3], function (v) &#123;</span><br><span class="line">  return new Date();</span><br><span class="line">&#125;)))</span><br><span class="line"></span><br><span class="line">//  [&quot;2019-12-01T08:20:00.422Z&quot;,&quot;2019-12-01T08:20:00.422Z&quot;,&quot;2019-12-01T08:20:00.422Z&quot;]</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">_.map([1, 2, 3], function () &#123;</span><br><span class="line">  return new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      resolve(new Date())</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(function (result) &#123;</span><br><span class="line">  console.log(JSON.stringify(result))</span><br><span class="line">&#125;)</span><br><span class="line">// [&quot;2019-12-01T08:20:01.424Z&quot;,&quot;2019-12-01T08:20:02.424Z&quot;,&quot;2019-12-01T08:20:03.428Z&quot;]</span><br></pre></td></tr></table></figure><p>같은 _.map 함수지만 1은 즉시 완료되었고, 2는 3초 정도의 시간이 걸려 완료되었다. Partial.js의 _.each, _.map, _.reduce 등은 첫 번째 iteratee의 결과가 Promise 객체일 경우 내부적으로 for문 대신 재귀로 변경된다. 2의 경우 iteratee가 각각 모두 1초 정도의 시간이 걸렸기 때문에 배열에 1초 정도의 차이를 가진 값들이 담겼다.<br>위 코드는 둘 다 동일한 _.map 함수로 작성하기는 했지만 동기 상황의 코드와 비동기 상황의 전체적인 코드 구조가 다르다. _.go, _.pipe 등을 이용하면 두 가지 코드 모두 동일한 구조를 갖도록 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">_.go(</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  _.map(function () &#123; return new Date() &#125;),</span><br><span class="line">  JSON.stringify,</span><br><span class="line">  console.log</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">_.go(</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  _.map(function () &#123;</span><br><span class="line">    return new Promise(function (resolve) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        resolve(new Date())</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;),</span><br><span class="line">  JSON.stringify,</span><br><span class="line">  console.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>_.map의 iteratee에서 Promise 함수가 아닌 일반 비동기 함수를 사용해야 한다면 다음과 같이 사용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  _.map(_.callback(function (val, i, list, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(new Date());</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)),</span><br><span class="line">  JSON.stringify,</span><br><span class="line">  console.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>마지막 인자로 next가 들어오고 next를 통해 결과를 전달하면, 그 결과가 하나씩 _.map의 결과인 새로운 배열에 쌓여간다. new Promise를 사용하는 것 보다 간결하다.</p><p>Partial.js는 iteratee의 결과나 iteratee의 속성에 따라 동기 로직과 비동기 로직을 알아서 선택하도록 되어있다. 동기 로직으로 돌아가야 할 경우에는 for문을 사용하고 비동기 로직을 사용해야 할 경우에만 재귀로 변경되기 때문에 성능적으로도 문제가 없다.</p><h3 id="비동기-결과를-기다리는-if문-if"><a href="#비동기-결과를-기다리는-if문-if" class="headerlink" title="비동기 결과를 기다리는 if문, _.if"></a>비동기 결과를 기다리는 if문, _.if</h3><p>아래 is_1, is_2 함수는 결과를 즉시 리턴하는 함수다. 아래와 같은 함수는 if문과 같은 조건절에서 사용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var is_1 = function (a) &#123;</span><br><span class="line">  return a === 1;</span><br><span class="line">&#125;;</span><br><span class="line">var is_2 = function (a) &#123;</span><br><span class="line">  return a === 2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test1(a) &#123;</span><br><span class="line">  if (is_1(a)) return &apos;1입니다.&apos;</span><br><span class="line">  else if (is_2(a)) return &apos;2입니다.&apos;</span><br><span class="line">  else return &apos;1도 아니고 2도 아닙니다.&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(test1(2)); // 2입니다.</span><br></pre></td></tr></table></figure><p>그런데 만약 is_1과 같은 함수가 즉시 값을 리턴할 수 없고, 데이터베이스에 다녀와야 하거나 HTTP 통신이 있어야 하면 상황은 달라진다. 자바스크립트에서는 아래와 같은 상황을 if문으로 제어할 수 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var is_1_async = function (a) &#123;</span><br><span class="line">  return new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      resolve(a === 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var is_2_async = function (a) &#123;</span><br><span class="line">  return new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      resolve(a === 2);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test2(a) &#123;</span><br><span class="line">  if (is_1_async(a)) return &apos;1입니다.&apos;</span><br><span class="line">  else if (is_2_async(a)) return &apos;2입니다.&apos;</span><br><span class="line">  else return &apos;1도 아니고 2도 아닙니다.&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(test2(2)); // 1입니다. (정상적으로 동작하지 않음)</span><br></pre></td></tr></table></figure><p>is_1_async 함수의 진짜 결과는 false이겠지만  is_1_async가 즉시 Promise 객체를 리턴하기 때문에 if의 조건문 입장에서는 true가 된다. is_1_async가 콜백 패턴으로 이루어진 일반 함수 였다고 하더라고, undefined가 즉시 리턴될 것이므로 역시 정상적인 결과를 만들수 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var test4 =</span><br><span class="line">  _.if(is_1_async, function () &#123; return &apos;1입니다.&apos; &#125;)</span><br><span class="line">    .else_if(is_2_async, function () &#123; return &apos;2입니다.&apos; &#125;)</span><br><span class="line">    .else(function () &#123; return &apos;1도 아니고 2도 아닙니다. &apos; &#125;);</span><br><span class="line"></span><br><span class="line">test4(2).then(console.log); // 2입니다.</span><br></pre></td></tr></table></figure><p>위 함수는 동기 함수를 사용했던 test1과 유사한 구조를 가지고 있다. _.constant나 화살표 함수를 사용하면 더욱 간결해진다. _.go와 함께 사용한 버전도 확인해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var test5 =</span><br><span class="line">  _.if(is_1_async, _.constant(&apos;1입니다.&apos;))</span><br><span class="line">    .else_if(is_2_async, _.constant(&apos;2입니다.&apos;))</span><br><span class="line">    .else(_.constant(&apos;1도 아니고 2도 아닙니다. &apos;));</span><br><span class="line"></span><br><span class="line">test5(2).then(console.log);</span><br><span class="line"></span><br><span class="line">// 화살표함수</span><br><span class="line">var test6 =</span><br><span class="line">  _.if(is_1_async, () =&gt; &apos;1입니다.&apos;)</span><br><span class="line">    .else_if(is_2_async, () =&gt; &apos;2입니다.&apos;)</span><br><span class="line">    .else(() =&gt; &apos;1도 아니고 2도 아닙니다. &apos;);</span><br><span class="line">test6(1).then(console.log)</span><br><span class="line"></span><br><span class="line">// _.go</span><br><span class="line">_.go(</span><br><span class="line">  3,</span><br><span class="line">  _.if(is_1_async, _.constant(&apos;1입니다.&apos;))</span><br><span class="line">    .else_if(is_2_async, _.constant(&apos;2입니다.&apos;))</span><br><span class="line">    .else(_.constant(&apos;1도 아니고 2도 아닙니다. &apos;)),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>동기와 비동기 상황을 동시에 대응하는 함수를 쉽게 만드는 팁이 있다. 해당 함수의 로직을 _.go나 _.pipe로 구현해 두는 것이다. 그렇게 하면 자동으로 동기 상황과 비동기 상황에 맞춰 로직을 알아서 변경시키기 때문에 추가적인 다른 작업을 하지 않아도 된다.</p><h2 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h2><h3 id="all-spread"><a href="#all-spread" class="headerlink" title="_.all, _.spread"></a>_.all, _.spread</h3><p>이 두 함수는 파이프라인과 함께 사용할 때 유용한 함수다. _.all과 _.spread 모두 받은 인자를 받은 함수들에게 전달하는 함수들인데, _.all은 받은 모든 인자를 모든 함수들에게 동일하게 전달하고, _.spread는 받은 인자들을 하나씩 나눠 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.all(10, 5, [</span><br><span class="line">  function (a, b) &#123; return a + b &#125;,</span><br><span class="line">  function (a, b) &#123; return a - b &#125;,</span><br><span class="line">  function (a, b) &#123; return a * b &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">_.spread(10, 5, [</span><br><span class="line">  function (a) &#123; return a * a &#125;,</span><br><span class="line">  function (b) &#123; return b * b &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>_.all은 받아 둔 모든 인자를 마지막 인자로 들어온 배열 안에 있는 모든 함수들에게 동일하게 전달한다. _.spread는 받은 인자를 하나씩 나눠서, 받은 함수들에게 하나씩 전달하는 함수다.<br>_.all과 _.spread에게 인자 전달 없이 함수들만 전달하면 함수를 리턴하는 함수로 동작하여 파이프라인 등에서 사용하기 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  10,</span><br><span class="line">  _.all(</span><br><span class="line">    function (a) &#123; return a + 5 &#125;,</span><br><span class="line">    function (a) &#123; return a - 5 &#125;,</span><br><span class="line">    function (a) &#123; return a * 5 &#125;</span><br><span class="line">  ),</span><br><span class="line">  _.spread(</span><br><span class="line">    function (a) &#123; return a + 1 &#125;,</span><br><span class="line">    function (b) &#123; return b + 2 &#125;,</span><br><span class="line">    function (c) &#123; return c + 3 &#125;</span><br><span class="line">  ),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 16 7 53</span><br></pre></td></tr></table></figure><h2 id="파이프라인2"><a href="#파이프라인2" class="headerlink" title="파이프라인2"></a>파이프라인2</h2><h3 id="go에서-this-사용"><a href="#go에서-this-사용" class="headerlink" title="_.go에서 this 사용"></a>_.go에서 this 사용</h3><p>Partial.js의 _.pipe가 this를 지원하는 것을 확인했었다. _.go에서도 this 지원이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123; name: &quot;Cojamm&quot; &#125;;</span><br><span class="line">_.go.call(user, 32,</span><br><span class="line">  function (age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    this.job = &quot;Rapper&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(user); // &#123;name: &quot;Cojamm&quot;, age: 32, job: &quot;Rapper&quot;&#125;</span><br></pre></td></tr></table></figure><p>_.go.call의 call은 Fucntion.prototype.call 이다. _.go는 일반 함수이므로 call을 사용하는게 자연스럽다. _.go 는 call을 통해 전달받은 this를 파이프라인 내 함수들에게 전달한다. apply 역시 사용할 수 있다.</p><h3 id="또-다른-파이프라인-indent"><a href="#또-다른-파이프라인-indent" class="headerlink" title="또 다른 파이프라인, _.indent"></a>또 다른 파이프라인, _.indent</h3><p>자바스크립트에서는 부모 스코프와 자식 스코프라는 개념이 있다. 자식 스코프는 부모 스코프의 지역 변수를 참조할 수 있다. 이러한 중첩 구조의 접근 방식이 파이프라인 내에서도 필요했는데, 이를 위한 함수가 바로 _.indent다. _.indent는 이름처럼 _.indent가 중첩될 때마다 this와 arguments를 한 단계씩 안으로 들여쓰는 콘셉트를 가지고 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var f1 = _.indent(</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this, arguments); // 1</span><br><span class="line">    return &apos;hi&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this, arguments) // 2</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f1(1, 2);</span><br></pre></td></tr></table></figure><p>_.indent는 _.pipe처럼 함수를 리턴하는 파이프라인이다. 함수들의 연속 실행이 준비된 함수를 리턴하여 f1에 담았고 실행했다.<br>1과 2의 결과에는 차이가 있다. console.log 에게 두 번째 인자로 넘긴 arguments에 담긴 값이 다르다. 1은 파이프라인의 첫 번째 함수이기에 f1을 통해 넘겨진 인자 [1,2]가 arguments에 들어온다. 2는 두 번째 함수이고, 이전 함수에서 ‘hi’를 리턴했기에 [‘hi’]가 arguments에 담겨 있다.<br>파이프라인으로 코딩하다 보면 파이프라인의 최초 함수가 아닌 중간에 있는 함수에서 파이프라인이 최초로 받은 인자를 알고 싶을 때가 있다. 이것은 클로저를 사용하는 것으로도 자연스럽게 해결된다.<br>_.indent의 해결법은 파이프라인 내부의 함수들은 중간 어디서든 this.arguments로 파이프라인의 최초 인자들에 접근할 수 있다.</p><p>_.indent의 this는 한 번의 파이프라인 사용 후 휘발되는 this다. 파이프라인 전체에서 공유하고자 하는 값이 있을 때 값을 이어주는 식으로 사용할 수도 있다. 또한 인스턴스를 만들어 두고 계속 사용하는 this가 아닌, 함수를 실행할 때마다 새로 생겼다 사라지는 this이므로 부수효과가 최소화되고 메모리 사용에도 문제가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f2 = _.indent(</span><br><span class="line">  function (a) &#123; this.b = a + 10; &#125;,</span><br><span class="line">  function () &#123; &#125;,</span><br><span class="line">  function () &#123; &#125;,</span><br><span class="line">  function () &#123; console.log(this.b) &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f2(5); // 15</span><br><span class="line">f2(7); // 17</span><br></pre></td></tr></table></figure><p>_.indent에서 this는 이번에 실행할 때 열린 부모 스코프를 대신하는 역할이므로, 그 this의 key/value를 확장한다는 것은 새로운 변수를 할당하는 것 이라고 볼 수 있다. this에 값을 단 후 값을 변경하지 않는다면 부수 효과로부터 자유로워진다. 하나의 큰 함수 안에서 변수에 담고 그 변수에 담긴 값을 변경하지 않는 것과 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var f3 = _.indent(</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    this.b = a + 10;</span><br><span class="line">  &#125;,</span><br><span class="line">  _.indent(</span><br><span class="line">    function () &#123;</span><br><span class="line">      this.b = 20;</span><br><span class="line">      console.log(this.b); // 20</span><br><span class="line">      console.log(this.parent.b) // 15</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123;</span><br><span class="line">      console.log(this.parent.arguments); // [5]</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this.b);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f3(5);</span><br></pre></td></tr></table></figure><p>parent를 통해 부모를 찾아갈 수 있고, this.parent.arguments로 파이프라인의 최초 인자도 찾아갈 수 있다. 자바스크립트에서 값에 접근할 수 있다는 것은 값을 변경할 수도 있다는 의미이므로 위험하다. 이것은 모든 값 혹은 변수에 해당하는 이야기다. 그러나 값을 참조하는 식으로 접근한다면, 여기저기에서 값에 접근할 수 있다는 것 자체는 문제가 되지는 않는다.</p><h3 id="무조건-비동기로-동작하는-async"><a href="#무조건-비동기로-동작하는-async" class="headerlink" title="무조건 비동기로 동작하는 _.async"></a>무조건 비동기로 동작하는 _.async</h3><p>_.go, _.pipe, _.indent는 파이프라인 내부의 함수에서 비동기 결과가 나올 경우 비동기 제어를 시작하도록 구현되어 있다. 그러므로 비동기 상황이 생기지 않는다면 즉시 일반 값이 리턴되고, 비동기 상황이 생겼을 때만 Promise 객체가 리턴된다. 때로는 내부 함수의 결과와 상관없이 무조건 비동기를 일으키고 싶을 때가 있다. _.async는 이럴 때 사용하기 적합한, 무조건 비동기로 동작하는 파이프라인이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go.async(1, function (a) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;).then(console.log);</span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;파이프라인&quot;&gt;&lt;a href=&quot;#파이프라인&quot; class=&quot;headerlink&quot; title=&quot;파이프라인&quot;&gt;&lt;/a&gt;파이프라인&lt;/h2&gt;&lt;h3 id=&quot;즉시-실행-파이프라인-go와-mr&quot;&gt;&lt;a href=&quot;#즉시-실행-파이프라인-go와-mr&quot; class=&quot;headerlink&quot; title=&quot;즉시 실행 파이프라인, _.go와 _.mr&quot;&gt;&lt;/a&gt;즉시 실행 파이프라인, _.go와 _.mr&lt;/h3&gt;&lt;p&gt;_.go는 파이프라인의 즉시 실행 버전이다. 첫 번째 인자로 받은 값을 두 번째 인자로 받은 함수에게 넘겨주고, 두 번째 인자로 받은 함수의 결과는 세 번째 함수에게 넘겨준다. 이것을 반복하다가 마지막 함수의 결과를 리턴해 준다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_.go(10, // 첫번째 인자&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function (a) &amp;#123; return a * 10 &amp;#125;, // 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function (a) &amp;#123; return a - 50 &amp;#125;, // 50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function (a) &amp;#123; return a + 10 &amp;#125; // 60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;_.go는 Multiple Results를 지원한다. _.mr 함수를 함께 사용하면 다음 함수에게 2개 이상의 인자들을 전달할 수 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="파이프라인" scheme="https://kkangil.github.io/tags/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/"/>
    
      <category term="go 함수" scheme="https://kkangil.github.io/tags/go-%ED%95%A8%EC%88%98/"/>
    
      <category term="비동기와 _.go" scheme="https://kkangil.github.io/tags/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%99%80-go/"/>
    
      <category term="_.indent" scheme="https://kkangil.github.io/tags/indent/"/>
    
  </entry>
  
  <entry>
    <title>함수 조립하기</title>
    <link href="https://kkangil.github.io/2019/11/17/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD%ED%95%98%EA%B8%B0/"/>
    <id>https://kkangil.github.io/2019/11/17/함수-조립하기/</id>
    <published>2019-11-17T05:49:58.000Z</published>
    <updated>2019-12-01T09:41:21.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수-조립하기"><a href="#함수-조립하기" class="headerlink" title="함수 조립하기"></a>함수 조립하기</h1><p>함수형 자바스크립트 기법을 잘 활용하면 소프트웨어의 기능을 변경하거나 추가하기가 쉽다. 작은 단위로 쪼갠 함수들을 조합하여 큰 기능을 만들면 조합된 함수 사이사이에 새로운 함수를 추가하는 식으로 쉽게 확장해 나갈 수 있다.</p><p>함수형 자바스크립트 10가지 기법</p><ol><li>함수를 되도록 작게 만들기</li><li>다형성 높은 함수를 만들기</li><li>상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화하기</li><li>동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기</li><li>복잡한 객체 하나를 인자로 사용하기보다는 되도록 일반적인 값 여러개를 인자로 사용하기</li><li>큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기</li></ol><a id="more"></a><ol start="7"><li>어느 곳에서든 바로 실행하거나 혹은 미뤄서 실행할 수 있도록 일반 함수이자 순수 함수로 선언하기</li><li>모델이나 컬렉션 등의 커스텀 객체보다는 기본 객체를 이용하기</li><li>로직의 흐름을 최대한 단방향으로 흐르게 하기</li><li>작은 함수를 모아 큰 함수를 만들기</li></ol><p>이번 장에서는 작은 함수로 큰 함수를 만드는 방법들을 다룬다. 객체지향에 빗대어 표현하면 클래스와 인스턴스에 대해서 처음 다루는 장이라고 할 수도 있겠다.</p><h2 id="고차-함수와-보조-함수"><a href="#고차-함수와-보조-함수" class="headerlink" title="고차 함수와 보조 함수"></a>고차 함수와 보조 함수</h2><p>이번 장에서는 고차 함수의 다양한 사례를 통해 함수 조립에 대한 생각들을 확장하고자 한다. 함수를 주재료로 다루는 함수들을 다룰 것이다.</p><h3 id="한-번만-실행하는-함수"><a href="#한-번만-실행하는-함수" class="headerlink" title="한 번만 실행하는 함수"></a>한 번만 실행하는 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_.once = function (func) &#123;</span><br><span class="line">  var flag, result;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (flag) return result;</span><br><span class="line">    flag = true;</span><br><span class="line">    return result = func.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hi = _.once(function () &#123;</span><br><span class="line">  console.log(&apos;hi&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hi();</span><br><span class="line">// hi</span><br><span class="line">hi();</span><br><span class="line">// 아무일도 일어나지 않음</span><br></pre></td></tr></table></figure><p>_.once는 받아 둔 익명 함수가 한 번만 실행되도록 설정된 함수를 리턴한다. 이런 기능을 구현하기 위해서는 flag 값이 필요하며 flag 값에 따라 실행할 것인지 말 것인지 대해 판단하는 로직이 어딘가에 있어야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = _.once(function () &#123;</span><br><span class="line">  console.log(&apos;A&apos;);</span><br><span class="line">  return &apos;B&apos;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(a());</span><br><span class="line">// A</span><br><span class="line">// B</span><br><span class="line">console.log(a());</span><br><span class="line">// B</span><br></pre></td></tr></table></figure><h3 id="다시-물어-보지-않는-함수"><a href="#다시-물어-보지-않는-함수" class="headerlink" title="다시 물어 보지 않는 함수"></a>다시 물어 보지 않는 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function skip(body) &#123;</span><br><span class="line">  var yes;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return yes || (yes = body.apply(null, arguments));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최초 한번만 실행을 하고 그 이후로는 실행이 되지 않는다. skip은 고차 함수이고 body는 skip이 남겨 놓은 로직을 완성하는 함수다. 함수형 자바스크립트는 함수로 함수를 다루거나 함수로 함수를 만드는 것의 반복이고, 고차 함수 응용의 반복이다.<br>skip은 고차 함수이자 함수를 만드는 함수다. 함수로 함수를 만들 때는 재료로 함수가 사용되기도 하고 일반 값이 사용되기도 한다. 함수로 만들어진 함수는 대부분 클로저다.</p><h3 id="앞서-받은-인자-혹은-상황을-변경해-나가는-경우"><a href="#앞서-받은-인자-혹은-상황을-변경해-나가는-경우" class="headerlink" title="앞서 받은 인자 혹은 상황을 변경해 나가는 경우"></a>앞서 받은 인자 혹은 상황을 변경해 나가는 경우</h3><p>skip같은 함수는 앞서 만든 상황을 변경해 나가는 사례다. 처음에는 false로 시작했지만 true로 변경하여 이후 동작을 다르게 만들기 위해 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function idMaker(start) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return ++start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var messageCid = idMaker(0);</span><br><span class="line">messageCid();</span><br><span class="line">// 1</span><br><span class="line">messageCid();</span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">var postCid = idMaker(11);</span><br><span class="line">postCid()</span><br><span class="line">// 12</span><br><span class="line">postCid()</span><br><span class="line">// 13</span><br></pre></td></tr></table></figure><p>idMaker는 원하는 시작점부터 시작해 실행할 때마다 증가한 고유한 아이디 값을 만드는 함수를 만드는 함수다. idMaker는 메신저 등을 만들 때 사용할 수 있다. 사용자가 메시지를 입력하고 엔터 키를 쳤을 때, 임시로 클라이언트 측 고유 아이디를 만들어 메시지에 해당하는 HTML 요소를 즉시 그려 둔 다음, 서버에게 정보를 보내어 DB에 저장하고 응답으로 온 데이터를, 만들어 두었던 클라이언트 측 고유 아이디를 기준으로 매핑한다.</p><h3 id="앞서-받은-인자를-잘-유지해야-하는-경우"><a href="#앞서-받은-인자를-잘-유지해야-하는-경우" class="headerlink" title="앞서 받은 인자를 잘 유지해야 하는 경우"></a>앞서 받은 인자를 잘 유지해야 하는 경우</h3><p>클로저가 기억하고 있는 외부 변수도 일반 변수처럼 언제든지 값이 변경될 수 있다. 앞선 _.once, skip, idMaker 사례는 값이 변경되는 점을 이용한 기법이다. 이번에는 반대로 값을 잘 유지해야 하는 상황을 살펴 볼 텐데, 이런 상황에서 실수가 많이 생긴다.</p><p>특히 앞서 받은 인자와 나중에 받은 인자를 조합하여 결과를 만들려고 할 때는 실수하기가 쉽다. 이럴 때는 계속 사용할 객체는 원래 상태를 잘 유지하도록, 한 번만 쓰이고 사라져야 할 값은 사라지도록 잘 관리해 주어야 한다.</p><p>앞서 받은 인자의 상태가 변경되지 않도록 concat이나 slice를 이용해 항상 새로운 객체를 만든다거나, _.rest 같은 함수를 이용해 인자의 일부분을 잘 제외시켜야 하는데, 이 것을 어떤 타이밍에 하는지가 중요하다.</p><h2 id="부분-적용"><a href="#부분-적용" class="headerlink" title="부분 적용"></a>부분 적용</h2><h3 id="partial로-함수-만들기"><a href="#partial로-함수-만들기" class="headerlink" title="_.partial로 함수 만들기"></a>_.partial로 함수 만들기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var pc = _.partial(console.log, 1);</span><br><span class="line">pc(2);</span><br><span class="line">// 2가 오른쪽으로 들어감</span><br><span class="line">pc(2, 3);</span><br><span class="line">// 2, 3이 오른쪽으로 들어감</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, 2);</span><br><span class="line">pc(1);</span><br><span class="line">// 1, 2 1이 왼쪽의 _ 자리에 들어감</span><br><span class="line">pc(1, 3);</span><br><span class="line">// 1 2 3  1이 왼쪽의 _자리에 들어가고 3이 오른쪽으로 들어감</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, _, 3);</span><br><span class="line">pc(1);</span><br><span class="line">// 1 undefined 3 1이 왼쪽 _ 자리에 들어가고 두 번째 _는 들어오지 않아 undefined 가 됨</span><br><span class="line">pc(1, 2);</span><br><span class="line">// 1 2 3 1과 2가 순서대로 _, _ 를 채움</span><br><span class="line">pc(1, 2, 4);</span><br><span class="line">// 1 2 3 4 1과 2가 순서대로 _, _를 채우고 3의 오른쪽으로 4가 들어감</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, 2, _, _, 5);</span><br><span class="line">pc(1, 3, 4, 6)</span><br><span class="line">// 1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>_.partial 함수를 이용하면 원하는 위치에 인자를 부분적으로 적용할 수 있다. _.partial을 활용한 다양한 함수 조립 사례를 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var add_all = _.partial(_.reduce, _, function (a, b) &#123; return a + b &#125;);</span><br><span class="line">console.log(add_all([1, 2, 3, 4]));</span><br><span class="line">// 10</span><br><span class="line">console.log(add_all([5, 2]));</span><br><span class="line">// 7</span><br></pre></td></tr></table></figure><p>_.partial은 함수를 다루는 고차 함수다. _.reduce도 고차 함수다. 위 코드 처럼 _.partial을 이용해 _.reduce와 같은 고차 함수에 미리 보조 함수를 적용해 두는식으로 add_all 같은 함수를 구현할 수 있다.</p><p>_.partial은 정말 강력하다. _.partial을 이용하면, 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var method = function (obj, method) &#123;</span><br><span class="line">  return obj[method].apply(obj, _.rest(arguments, 2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var push = _.partial(method, _, &apos;push&apos;);</span><br><span class="line">var shift = _.partial(method, _, &apos;shift&apos;);</span><br><span class="line"></span><br><span class="line">var a = [1, 2];</span><br><span class="line">push(a, 3);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">shift(a);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">var b = method([1, 2, 3], &apos;concat&apos;, 4, 5);</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure><p>이번 method 함수로 함수를 만드는 함수가 아닌 혼자서도 실행할 수 있는 일반 함수가 되었다. 이러한 방식의 이점은 method 같은 함수가 혼자서도 활용 가능한 함수가 된다는 점이다.</p><h3 id="partial과-compose로-함수-만들기"><a href="#partial과-compose로-함수-만들기" class="headerlink" title="_.partial과 _.compose로 함수 만들기"></a>_.partial과 _.compose로 함수 만들기</h3><p>_.partial은 함수를 연속으로 실행해 주는 _.compose 등의 함수와 함께 더 재미있게 사용할 수 있다. _.compose는 오른쪽의 함수를 실행한 결과를 왼쪽의 함수에게 전달하는 것을 반복하는 고차 함수이다. _.compose는 인자로 함수만 받는 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_.compose(console.log, function (a) &#123; return a - 2 &#125;, function (a) &#123; return a + 5 &#125;)(0);</span><br><span class="line">// console.log &lt;- 5 - 2 &lt;- 0 + 5 &lt;- 0</span><br><span class="line"></span><br><span class="line">var falsy_values = _.compose(</span><br><span class="line">  _.partial(_.isEqual, -1), // 1</span><br><span class="line">  _.partial(_.findIndex, _, _.identity) // 2</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(falsy_values([1, true, &#123;&#125;]));</span><br><span class="line">// false</span><br><span class="line">console.log(falsy_values([0, 1, false]));</span><br><span class="line">// false</span><br><span class="line">console.log(falsy_values([0, &quot;&quot;, false]));</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">var some = _.negate(falsy_values); // 3</span><br><span class="line">console.log(some([1, true, &#123;&#125;]));</span><br><span class="line">// true</span><br><span class="line">console.log(some([0, 1, false]));</span><br><span class="line">// true</span><br><span class="line">console.log(some(0, &quot;&quot;, false));</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">var every = _.compose(</span><br><span class="line">  _.partial(_.isEqual, -1),</span><br><span class="line">  _.partial(_.findIndex, _, _.negate(_.identity)) // 4</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(every([1, true, &#123;&#125;]));</span><br><span class="line">// true</span><br><span class="line">console.log(every([0, 1, false]));</span><br><span class="line">// false</span><br><span class="line">console.log(every([0, &quot;&quot;, false]));</span><br><span class="line">// false</span><br></pre></td></tr></table></figure><ol><li>_.isEqual 함수에 -1을 부분 적용하여, 앞에서 나온 결과가 -1과 같은지를 검사하는 함수 만들기</li><li>-1 과 비교하는 함수가 실행되기 전에는 _.findIndex에 _.identity 를 부분 적용해 둔 함수가 실행된다. _.findIndex는 긍정적인 값을 처음 만났을 때의 index를 리턴한다. _.compose 를 통해 두 함수를 역순으로 나열했고, falsy_values 는 배열에 들어있는 모든 값이 부정적인 값인지를 판단하는 함수가 된다.</li><li>받은 함수를 실행한 후, 결과를 반대로 만드는 함수를 리턴하는 함수인 _.negate 와 앞서 조합한 falsy_values를 조합하여 하나라도 긍정적인 값이 있는지를 체크하는 some 함수를 만들었다.</li><li>falay_values를 조합던 코듸의 _.identity 부분만 _.negate로 감싸서 모두 긍정적인 값이 맞는지를 체크하는 every 함수</li></ol><h3 id="더-나은-partial-함수"><a href="#더-나은-partial-함수" class="headerlink" title="더 나은 _.partial 함수"></a>더 나은 _.partial 함수</h3><p>_.partial은 인자를 왼쪽에서부터 하나씩 적용하면서 _로 구분하여 인자가 적용될 위치를 지정해 둘 수 있도록 한다. 이런 _.partial에도 한 가지 아쉬움이 있다. 자바스크립트 함수는 인자 개수가 유동적일 수 있고 함수의 마지막 인자를 중요하게 사용할 수도 있는데, 이 같은 함수화 _.partial은 합이 잘 맞지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function m() &#123;</span><br><span class="line">  var iter = arguments[arguments.length - 1];</span><br><span class="line">  arguments.length--;</span><br><span class="line">  return _.reduce(arguments, iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m(100, 50, add);</span><br><span class="line">// 150</span><br><span class="line">m(100, 50, 10, add);</span><br><span class="line">// 160</span><br><span class="line">m(100, 50, sub);</span><br><span class="line">// 50</span><br><span class="line">m(100, 50, 10, sub);</span><br><span class="line">// 40</span><br><span class="line"></span><br><span class="line">var f1 = _.partial(m, _, _, _, add);</span><br><span class="line">// f1 은 3개의 인자만 더할 수 있다.</span><br><span class="line">f1(1, 1, 1);</span><br><span class="line">// 3</span><br><span class="line">f1(1, 1);</span><br><span class="line">// NaN</span><br><span class="line">f1(1, 1, 1, 1);</span><br><span class="line">// _.reduce에 1이 넘어가면서 에러</span><br></pre></td></tr></table></figure><p>f1의 상황처럼 인자를 유동적으로 다루는 함수는 _.partial로 다루기 좋지 않다. 맨 왼쪽 인자나 맨 왼쪽에서 두 번째 인자를 적용해 두는 것은 가능하지만 맨 오른쪽 인자나 맨 오른쪽에서 두 번째에만 인자를 적용해 두는것은 불가능 하기 때문이다. Lodash 는 이를 위해 _.partialRight를 구현했지만 양쪽 끝 모두를 부분 적용하고, 가운데 부분을 가변적으로 가져가고 싶을 때도 있기에 아직 아쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var ___ = &#123;&#125;;</span><br><span class="line">_.partial = function (fn) &#123;</span><br><span class="line">  var args1 = [], args3, len = arguments.length, ___idx = len;</span><br><span class="line">  for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">    var arg = arguments[i];</span><br><span class="line">    if (arg == ___ &amp;&amp; (___idx = i) &amp;&amp; (args3 = [])) continue;</span><br><span class="line">    if (i &lt; ___idx) args1.push(arg);</span><br><span class="line">    else args3.push(arg);</span><br><span class="line">  &#125;</span><br><span class="line">  return function () &#123; return fn.apply(this, mergeArgs(args1, arguments, args3)) &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function _toUndef(args1, args2, args3) &#123;</span><br><span class="line">  if (args2) args1 = args1.concat(args2);</span><br><span class="line">  if (args3) args1 = args1.concat(args3);</span><br><span class="line">  for (var i = 0, len = args1.length; i &lt; len; i++)</span><br><span class="line">    if (args1[i] == _) args1[i] = undefined;</span><br><span class="line">  return args1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mergeArgs(args1, args2, args3) &#123;</span><br><span class="line">  if (!args2.length) return args3 ? _toUndef(args1, args3) : _toUndef(args1.slice());</span><br><span class="line"></span><br><span class="line">  var n_args1 = args1.slice(), args2 = _.toArray(args2), i = -1, len = n_args1.length;</span><br><span class="line">  while (++i &lt; len) if (n_args1[i] == _) n_args1[i] = args2.shift();</span><br><span class="line">  if (!args3) return _toUndef(n_args1, args2.length ? args2 : undefined);</span><br><span class="line"></span><br><span class="line">  var n_arg3 = args3.slice(), i = n_arg3.length;</span><br><span class="line">  while (i--) if (n_arg3[i] == _) n_arg3[i] = args2.pop();</span><br><span class="line">  return args2.length ? _toUndef(n_args1, args2, n_arg3) : _toUndef(n_args1, n_arg3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>복잡해 보이지만 생각보다 단순하다. 우선 새로운 구분자인 <strong>_ 가 추가 되었다. _.partial을 실행하면 _</strong>를 기준으로 왼편의 인자들을 왼쪽부터 적용하고 오른편의 인자들을 오른쪽부터 적용할 준비를 해 둔 함수를 리턴한다. 부분 적용된 함수를 나중에 실행하면 그때 받은 인자들로 왼쪽과 오른쪽을 먼저 채운 후, 남은 인자들로 가운데 ___자리를 채운다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var pc = _.partial(console.log, ___, 2, 3);</span><br><span class="line">pc(1);</span><br><span class="line">// 1 2 3</span><br><span class="line">pc(1, 4, 5, 6);</span><br><span class="line">// 1 4 5 6 2 3</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, 2, ___, 5, _, 7);</span><br><span class="line">pc(1);</span><br><span class="line">// 1 2 5 undefined 7</span><br><span class="line">pc(1, 3, 4);</span><br><span class="line">// 1 2 3 5 4 7</span><br><span class="line">pc(1, 3, 4, 6, 8);</span><br><span class="line">// 1 2 3 4 6 5 8 7</span><br><span class="line"></span><br><span class="line">var add_all = _.partial(m, ___, add);</span><br><span class="line">add_all(1, 2, 3, 4);</span><br><span class="line"></span><br><span class="line">var sub10 = _.partial(m, ___, 10, sub);</span><br><span class="line">sub10(50, 20);</span><br></pre></td></tr></table></figure><p>_.partial을 이용하면 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있고, 코드에 함수 표현식이 나오는것도 많이 줄일 수 있다. 이렇게 하면 _.chain, _.compose, _.pipeline 등의 함수 합성 패턴과도 잘 어울리고 함수를 조립하는 것도 즐거워 진다. 함수에 인자를 미리 적용해 두는 기법은 비동기 상황에서도 효과적으로 쓰인다.</p><h2 id="연속적인-함수-실행"><a href="#연속적인-함수-실행" class="headerlink" title="연속적인 함수 실행"></a>연속적인 함수 실행</h2><h3 id="체인의-아쉬운점"><a href="#체인의-아쉬운점" class="headerlink" title="체인의 아쉬운점"></a>체인의 아쉬운점</h3><p>체인은 메서드를 연속적으로 실행하면서 객체의 상태를 변경해 나가는 기법이다. 체인은 표현력이 좋고 실행 순서를 눈으로 따라가기에도 좋다. 체인 방식은 많은 장점을 가지고 있지만 체인 방식으로만 모든 로직을 구현하기에는 다소 불편한 점이 있다.</p><p>체인 방식은 체인 객체가 가지고 있는 메서드만 이용할 수 있기 때문에 체인 객체와 연관 없는 로직이나 다른 재료를 중간에 섞어 사용하기 어렵다. 정해진 메서드나 규격에 맞춰서 사용해야 하기 때문에 인자를 자유롭게 사용하기 어렵고 다양한 로직을 만들기도 어렵다. 따라서 결과를 완성해 나가는 과정에서 체인을 끊어야 하는 경우가 많다.</p><p>체인 방식은 사용하기는 쉽지만 잘 만들어 두기는 어렵다. this만 리턴하면 되는데 뭐가 어렵냐고 할 수 있지만, 가만히 생각해 보면 잘 쓰이는 체인 API는 그렇게 많지 않다. 잘 쓰이는 체인 API가 되려면 우선 체인 패턴과 잘 어울리는 주제여야 한다.</p><p>체인 방식은 객체가 생성되어야만 메서드를 사용할 수 있기 때문에 반드시 생성 단계를 거쳐야 한다. 그리고 this 등의 상태와 흐름과 깊이에 의존하기 때문에 언제 어디서나 아무 때나 사용이 가능한 순수 함수보다는 접근성면에서 좀 불편하다.</p><h3 id="compose의-아쉬운-점"><a href="#compose의-아쉬운-점" class="headerlink" title="_.compose의 아쉬운 점"></a>_.compose의 아쉬운 점</h3><p>_.compose 함수는 디자인 패턴과 같은 특별한 개념이나 지식 없어도, 바로 코딩 및 설계가 가능하다는 장점이 있다. 인자와 결과만을 생각하면서 작은 함수들을 조합하면 된다. 몇 가지 아쉬운 점이 있는데 그중 가장 큰 아쉬움은, 함수 실행의 순서가 오른쪽에서부터 왼쪽이기 때문에 읽기가 어렵다는 점이다. 함수 실행을 중첩해서 하는 것과 코드의 표현력이 크게 다를 바가 없고, 기능적으로도 특별히 나을 점이 없다.</p><h3 id="파이프라인"><a href="#파이프라인" class="headerlink" title="파이프라인"></a>파이프라인</h3><p>파이프라인은 _.compose의 장점을 그대로 가지고 있다. _.compose와 기본적인 사용법은 동일하다. 다만, 함수 실행 방향은 왼쪽에서부터 오른쪽이다. 왼쪽에서부터 오른쪽, 위에서부터 아래로 표현되어 코드를 읽기 쉽다. 또한 체인과 달리 아무 함수나 사용할 수 있어 자유도가 높다. 여기서는 이런 파이프라인의 장점들을 살펴볼 것이다.</p><p>Michael Fogus의 _.pipeline </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_.pipeline = function () &#123;</span><br><span class="line">  var funs = arguments; // 1. 함수들</span><br><span class="line"></span><br><span class="line">  return function (seed) &#123; // 2. 첫 인자</span><br><span class="line">    return _.reduce(funs,</span><br><span class="line">      function (l, r) &#123; return r(l); &#125;, // 4. 모든 함수를 연속적으로 실행</span><br><span class="line">      seed) // 3. 첫 인자 전달</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var div_square = _.pipeline(</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return a / 2;</span><br><span class="line">  &#125;,</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return a * a;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(div_square(6));</span><br><span class="line">// 9</span><br></pre></td></tr></table></figure><p>_.pipeline은 _.reduce를 이용해서 만들어졌다. _.reduce는 정말 강력한 함수다. 위 상황에서 가지고 있는 데이터는 함수들이고 만들고자 하는 데이터는 최초 인자로부터 시작해 모든 함수를 통과한 마지막 결과이다.</p><ol><li>arguments를 지역 변수 funs에 담았다.</li><li>funs를 기억하는 함수를 리턴한다.</li><li>리턴된 함수가 나중에 실행되면 받은 인자인 seed를 _.reduce 의 마지막 인자로 넘겨주어 seed는 최초의 l이 된다.</li><li>예측해 보건대 l 은 left고 r은 right인 듯 하다. 오른쪽 함수를 r을 실행하며 왼쪽 함수의 결과 l을 넘겨주고 있다. funs의 개수만큼 반복되며 마지막 함수의 결과가 곧 _.pipeline으로 만든 함수의 결과가 된다.</li></ol><h3 id="클래스를-대신하는-파이프라인"><a href="#클래스를-대신하는-파이프라인" class="headerlink" title="클래스를 대신하는 파이프라인"></a>클래스를 대신하는 파이프라인</h3><p>_.pipeline은 작은 함수들을 모아 큰 함수를 만드는 함수다. 파이프라인은 클래스와 기능적인 면과 개념적인 면이 다르지만 비슷한 역할을 대신할 수 있다. 작은 함수들을 조합하여 큰 함수들을 만들고 함수 조합을 조금씩 변경하거나 추가하면서 새로운 로직을 만들어 갈 수 있다.</p><p>회원가입을 예로 들어 보자. 개인 회원과 기업 회원이 있다고 가정하면, 회원 가입과 관련된 작은 로직들을 작은 함수 단위로 쪼개어 나눈 후 약간 변경하여 조합하거나 더할 수 있고, 뺄 수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var users = [];</span><br><span class="line">var companies = [];</span><br><span class="line"></span><br><span class="line">function joined_at(attrs) &#123;</span><br><span class="line">  return _.extend(attrs, &#123; joined_at: new Date() &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function greeting(member) &#123;</span><br><span class="line">  return member.name + &quot; 회원님은 &quot; + member.id + &quot; 번째 회원이십니다. 환영합니다.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var join_user = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  function (member) &#123;</span><br><span class="line">    users.push(member);</span><br><span class="line">    member.id = users.length;</span><br><span class="line">    return member;</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var join_company = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  function (member) &#123;</span><br><span class="line">    companies.push(member);</span><br><span class="line">    member.id = companies.length;</span><br><span class="line">    return member;</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(join_user(&#123; name: &quot;ID&quot; &#125;));</span><br><span class="line">// ID 회원님은 1 번째 회원이십니다. 환영합니다.</span><br><span class="line">console.log(join_user(&#123; name: &quot;JI&quot; &#125;));</span><br><span class="line">// JI 회원님은 2 번째 회원이십니다. 환영합니다.</span><br><span class="line">console.log(join_company(&#123; name: &quot;MARPPLE&quot; &#125;));</span><br><span class="line">// MARPPLE 회원님은 1 번째 회원이십니다. 환영합니다.</span><br></pre></td></tr></table></figure><p>join_user와 join_company는 두 번째 함수만 다르고 첫 번째와 세 번째 함수는 동일하게 조합되었다. 위에서 부터 내려오면서 가입 날짜를 만들고 서로 다른 배열에 담은 후 인사말을 남기고 있다.<br>_.partial을 함께 이용하면 아래와 같은 표현이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function joined_at(attrs) &#123;</span><br><span class="line">  return _.extend(attrs, &#123; joined_at: new Date() &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function join(table, member) &#123;</span><br><span class="line">  table.push(member);</span><br><span class="line">  member.id = table.length;</span><br><span class="line">  return member;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function greeting(member) &#123;</span><br><span class="line">  return member.name + &quot; 회원님은 &quot; + member.id + &quot; 번째 회원이십니다. 환영합니다.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var join_user = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  _.partial(join, users),</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var join_company = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  _.partial(join, companies),</span><br><span class="line">  greeting</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이번에는 _.partial을 이용해 users에 담을지 companies에 담을지를 선택했다. 이런 방식은 로직을 단순하게 한다. 서로 다른 기능을 하지만 조건문이 없다. 각자 자신이 해야 할 일만 순서대로 수행할 뿐이다. 작은 함수는 작성이 쉽고 테스트도 쉬우면 오류도 적기 마련이다. 앞뒤로 받을 인자와 결과만을 생각하면서 문제를 작게 만들면 문제 해결도 쉬워진다.</p><h3 id="더-나은-파이프라인-그리고-Multiple-Results"><a href="#더-나은-파이프라인-그리고-Multiple-Results" class="headerlink" title="더 나은 파이프라인, 그리고 Multiple Results"></a>더 나은 파이프라인, 그리고 Multiple Results</h3><p>Underscore.js의 _.pipeline이나 Lodash의 _.flow에는 아쉬운 점이 있다. 인자를 하나만 받을 수 있다는 점이다. 파이프라인에 사용된 내부 함수들 역시 마찬가지다. 파이프라인 내부에서 function (a, b) { return a + b; } 와 같은 함수는 사용할 수 없다는 얘기다. 물론 객체나 배열에 담아 다음 함수에게 전달할 수도 있겠지만 function(args) { return args[0] + args[1]; } 과 같은 함수는 파이프라인만을 위한 함수라고 봐야 한다. 클로저나 _.partial을 이용해서 인자나 재료를 늘릴 수 있지만 자칫 외부 상황에 의존하는 함수가 될 수 있다.</p><p>함수형 자바스크립트는 순수 함수를 많이 사용할수록, 인자들을 적극 활용할수록 강력해진다. 인자는 특히 2~3개 사용할 때도 많고 개수가 가변적인 경우도 많다. 인자를 2개 이상 필요로 하는 함수들을 파이프라인 사이에 끼워 넣지 못한다는 것은, 곧 파이프라인 사이에 정의된 함수들의 재사용성도 낮아진다는 얘기다.</p><p>만일 언어가 Go였다면 함수의 결과로 Multiple Results를 리턴할 수 있고 파이프라인 중간중간에 여러 개의 인자를 받는 함수들을 얼마든지 끼워 넣을 수 있을 것이다.</p><p>Multiple Results는 함수의 결과값을 여러 개로 리턴하는 개념이다. 자바스크립트에는 이러한 기능이 없지만 이것을 대체하는 기능을 구현할 수 있다. 여러 개의 값을 모아 Multiple Results를 뜻하는 객체로 만든 후 파이프라인 안에서 Multiple Results에 담긴 인자를 다시 여러개로 펼쳐서 실행하도록 구현하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_.mr = function () &#123;</span><br><span class="line">  arguments._mr = true; // 인자들이 담긴 arguments 객체에 _mr로 구분자를 만듬</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.pipeline = function () &#123;</span><br><span class="line">  var funs = arguments;</span><br><span class="line">  return function (seed) &#123;</span><br><span class="line">    return _.reduce(funs,</span><br><span class="line">      function (l, r) &#123;</span><br><span class="line">        // Multiple Results라면 apply로 인자를 펼침.</span><br><span class="line">        return l &amp;&amp; l._mr ? r.apply(null, l) : r(l);</span><br><span class="line">      &#125;,</span><br><span class="line">      // 인자가 여러개면 첫 번째 함수에게도 Multiple Results로 만들어서 넘기기</span><br><span class="line">      arguments.length &lt; 2 ? seed : _.mr.apply(null, arguments)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>apply는 배열이나 arguments 객체를 받아 함수의 인자들로 펼쳐준다. 함수를 실행하기 전 l이 Multiple Results라면 r.apply()를 이용해 r 함수에게 인자를 여러개로 전달할 수 있도록 기능을 추가했다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function square(a) &#123;</span><br><span class="line">  return a * a;</span><br><span class="line">&#125;</span><br><span class="line">function sub(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f1 = _.pipeline(</span><br><span class="line">  add,</span><br><span class="line">  square,</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return _.mr(a, a / 5); // Multiple Results</span><br><span class="line">  &#125;,</span><br><span class="line">  sub</span><br><span class="line">);</span><br><span class="line">console.log(f1(3, 2));</span><br><span class="line">// 20</span><br></pre></td></tr></table></figure><p>이제 add와 sub 같이 인자를 2개 이상 사용하는 일반 함수들도 파이프라인 사이에 넣을 수 있게 되었다. _.pipeline으로 함수를 정의하면 Multiple Results 를 지원하는 함수가 되어, 함수를 중첩하기만 해도 마치 Go 언어 처럼 동작한다.</p><h2 id="더-나은-함수-조립"><a href="#더-나은-함수-조립" class="headerlink" title="더 나은 함수 조립"></a>더 나은 함수 조립</h2><p>함수를 조립하는 데에도 함수가 사용된다. 함수를 재료로 사용하고, 재료를 함수로 실행하면서 로직을 완성한다. 함수로 함수를 만드는 방법들을 더 정교하게 잘 다루면 훨씬 다양하고 재밌게 조합할 수 있다. _.partial이나 _.pipeline의 기능을 높인다거나 그동안 살펴보았던 함수형 스타일의 함수들에게 부분 커링을 내장하도록 한다거나 하면 함수 조립의 효과를 더욱 높일 수 있다.</p><h3 id="Partial-js의-pipe"><a href="#Partial-js의-pipe" class="headerlink" title="Partial.js의 _.pipe"></a>Partial.js의 _.pipe</h3><p>마이클 포거스의 _.pipeline은 Multiple Results를 지원하지 않는 아쉬움이 있었다. 한 가지 아쉬운 점이 더 있는데, 파이프라인의 내부 함수에서 this를 사용할 수 없다는 점이다. 자바스크립트에서의 함수는 메서드든 아니든 this를 사용할 수 있도록 되어있다. 새로운 기능을 만들 때, 기존의 기본 기능을 유지하는 것은 언제나 중요한 일이다.</p><p>Partial.js의 파이프라인 함수인 _.pipe는 Multiple Results와 this를 모두 지원한다. 그리고 Multiple Results를 사용할 수 있기 때문에 인자를 2개 이상 필요로 하는 함수도 함께 사용할 수 있고, this를 사용할 수 있기 때문에 메서드를 만들거나 this를 사용하는 라이브러리들과 협업이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_.pipe(</span><br><span class="line">  function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">  &#125;,</span><br><span class="line">  console.log, // 1</span><br><span class="line">  function () &#123;</span><br><span class="line">    this.b = 2;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line">  console.log, // &#123;a: 1, b: 2&#125;</span><br><span class="line">).call(&#123; a: 1 &#125;);</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  method1: _.pipe(</span><br><span class="line">    function () &#123;</span><br><span class="line">      return this.a;</span><br><span class="line">    &#125;,</span><br><span class="line">    console.log, // 10</span><br><span class="line">    function () &#123;</span><br><span class="line">      this.b = 2;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    console.log // &#123;a: 10, b: 2, method1: ƒ&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.method1();</span><br></pre></td></tr></table></figure><h3 id="즉시-실행-파이프라인-go"><a href="#즉시-실행-파이프라인-go" class="headerlink" title="즉시 실행 파이프라인 _.go"></a>즉시 실행 파이프라인 _.go</h3><p>_.go는 _.pipe의 즉시 실행 버전이다. 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 편하기 때문에 첫 번째 인자를 파이프라인에서 사용할 인자로 정했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.go(10,</span><br><span class="line">  function (a) &#123; return a / 2 &#125;,</span><br><span class="line">  function (a) &#123; return a + 2 &#125;,</span><br><span class="line">  console.log // 7</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;함수-조립하기&quot;&gt;&lt;a href=&quot;#함수-조립하기&quot; class=&quot;headerlink&quot; title=&quot;함수 조립하기&quot;&gt;&lt;/a&gt;함수 조립하기&lt;/h1&gt;&lt;p&gt;함수형 자바스크립트 기법을 잘 활용하면 소프트웨어의 기능을 변경하거나 추가하기가 쉽다. 작은 단위로 쪼갠 함수들을 조합하여 큰 기능을 만들면 조합된 함수 사이사이에 새로운 함수를 추가하는 식으로 쉽게 확장해 나갈 수 있다.&lt;/p&gt;
&lt;p&gt;함수형 자바스크립트 10가지 기법&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;함수를 되도록 작게 만들기&lt;/li&gt;
&lt;li&gt;다형성 높은 함수를 만들기&lt;/li&gt;
&lt;li&gt;상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화하기&lt;/li&gt;
&lt;li&gt;동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기&lt;/li&gt;
&lt;li&gt;복잡한 객체 하나를 인자로 사용하기보다는 되도록 일반적인 값 여러개를 인자로 사용하기&lt;/li&gt;
&lt;li&gt;큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="함수 조립" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/"/>
    
      <category term="once" scheme="https://kkangil.github.io/tags/once/"/>
    
      <category term="skip" scheme="https://kkangil.github.io/tags/skip/"/>
    
      <category term="partial" scheme="https://kkangil.github.io/tags/partial/"/>
    
      <category term="compose" scheme="https://kkangil.github.io/tags/compose/"/>
    
      <category term="pipeline" scheme="https://kkangil.github.io/tags/pipeline/"/>
    
      <category term="pipe" scheme="https://kkangil.github.io/tags/pipe/"/>
    
      <category term="go" scheme="https://kkangil.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>함수형 자바스크립트를 위한 문법 다시 보기-2</title>
    <link href="https://kkangil.github.io/2019/10/27/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0-2/"/>
    <id>https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/</id>
    <published>2019-10-27T05:33:33.000Z</published>
    <updated>2019-12-01T09:41:28.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if-else-amp-amp-삼항-연산자-다시-보기"><a href="#if-else-amp-amp-삼항-연산자-다시-보기" class="headerlink" title="if else || &amp;&amp; 삼항 연산자 다시 보기"></a>if else || &amp;&amp; 삼항 연산자 다시 보기</h2><h3 id="if의-괄호"><a href="#if의-괄호" class="headerlink" title="if의 괄호"></a>if의 괄호</h3><p>if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.</p><p>괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.<br><a id="more"></a><br>if (expression) { statements } 중 statements 부분에는 비동기 코드를 활용할 여지가 있고 몇 가지 아이디어를 통해 어느정도 제어가 가능하지만 if의 괄호 부분은 비동기 코드와 거리가 좀 있다. 하지만 괄호 안에서 할 수 있는 일들은 많다. 새로운 객체를 생성할 수도 있고 객체의 key에 값을 할당할 수도 있으며 함수를 실행할 수도 있다. 먼저 에러가 발생하는 코드를 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (var a = 0) console.log(a);</span><br></pre></td></tr></table></figure><p>위 코드는 문법 에러가 난다. 괄호에서는 표현식만 사용할 수 있기 때문이다. 아래 코드는 에러는 나지 않지만 쓸모없는 코드다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (function f1() &#123;&#125;) console.log(&apos;hi&apos;);</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>f1을 정의하는 곳에서는 에러가 나지 않았고 hi도 출력했지만 f1은 실행할 수 없다. f1이 값으로 다뤄져서 유명 함수로 선언되었기 때문이다. f1은 어디에서도 참조할 수 없어 위 코드는 사실상 에러가 나지 않지만 아무런 의미가 없는 코드다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">if (a = 5) console.log(a); // 1</span><br><span class="line"></span><br><span class="line">if (a = 0) console.log(1); // 2</span><br><span class="line">else console.log(a);</span><br><span class="line"></span><br><span class="line">if (!(a = false)) console.log(a); // 3</span><br><span class="line"></span><br><span class="line">if (a = 5 - 5); // 4</span><br><span class="line">else console.log(a)</span><br></pre></td></tr></table></figure><p>미리 선언된 변수에 값을 할당하는 것은 가능하다. 동시에 if의 괄호에는 a가 사용된다. 1에서는 if (5)인 셈이므로 5가 출력된다. 2에서는 if (0) 인 셈이므로 else로 넘어가게 된다. 3에서는 false를 담았고 !으로 반전하여 false가 결과로 나오도록 했다. 4에서는 a에 0이 담기고 else로 넘어간다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">if (obj.a = 5) console.log(obj.a); // 1</span><br><span class="line"></span><br><span class="line">if (obj.b = false) console.log(obj.b); // 2</span><br><span class="line">else console.log(&apos;hi&apos;);</span><br><span class="line"></span><br><span class="line">var c;</span><br><span class="line">if (c = obj.c = true) console.log(c); // 3</span><br></pre></td></tr></table></figure><p>이번에는 if의 괄호 안에서 객체의 key에 값을 할당했다. obj에 값을 할당했고, if의 괄호에서는 obj가 아닌 할당한 값이 쓰인다. 2와 3을 통해 알 수 있다. c에는 obj가 아닌 true가 담긴다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (add(1, 2)) console.log(&apos;hi1&apos;);</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line">if (a = add(1, 2)) console.log(a);</span><br><span class="line"></span><br><span class="line">if (function () &#123; return true; &#125;()) console.log(&apos;hi&apos;)</span><br></pre></td></tr></table></figure><p>함수를 실행할 수도 있고 실행한 결과를 변수에 담으면서 참과 거짓을 판단할 수도 있다. 익명 함수나 유명 함수를 정의하면서 즉시 실행할 수도 있다.</p><p>위에서 확인한 모든 코드들은 자바스크립트의 대부분의 괄호에서 동일하게 동작한다. 이를테면 while문의 괄호에서도 동일하게 동작한다. 괄호 안에서 어떤 코드들을 돌릴 수 있는지 잘 알고 있다면 코드를 더 깔끔하게 정리하거나 코드 구조를 크게 변경하지 않고도 기능을 발전시킬 수 있다.</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="|| &amp;&amp;"></a>|| &amp;&amp;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(0 &amp;&amp; 1) // 0</span><br><span class="line">console.log(1 &amp;&amp; 0) // 0</span><br><span class="line">console.log([] || &#123;&#125;); // []</span><br><span class="line">console.log([] &amp;&amp; &#123;&#125;); // &#123;&#125;</span><br><span class="line">console.log([] &amp;&amp; &#123;&#125; || 0); // &#123;&#125;</span><br><span class="line">console.log(0 || 0 || 0 || 1 || null); // 1</span><br><span class="line">console.log(add(10, -10) || add(10, -10)); // 0</span><br><span class="line">console.log(add(10, -10) || add(10, 10)); //20</span><br><span class="line">var v;</span><br><span class="line">console.log((v = add(10, -10)) || v++ &amp;&amp; 20); // 0</span><br><span class="line">console.log((v = add(10, 10)) || ++v &amp;&amp; 20); // 20</span><br></pre></td></tr></table></figure><p>||과 &amp;&amp;의 활용법은 생각보다 다양하다. 오른쪽으로 더 갈 것인가 말 것인가를 한 줄로 만들어 if else를 대체할 수도 있다. 상황에 따라 if else가 가독성이나 효율이 좋을 수 있고 ||, &amp;&amp; 가 좋을 수도 있다. 다양한 도구를 상황에 맞게 잘 사용하면 된다.</p><h3 id="삼항-연산자"><a href="#삼항-연산자" class="headerlink" title="삼항 연산자"></a>삼항 연산자</h3><p>삼항 연산자는 조건이 간단하고 실행 코드도 간단할 때 많이 사용된다. 보통 값을 담을 때 사용된다. 삼항 연산자를 이용해도 여러 줄을 코딩할 수 있다. 익명 함수, 유명 함수, 화살표 함수 등으로 즉시 실행 패턴을 사용하는 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = false;</span><br><span class="line"></span><br><span class="line">var c = a ? 10 : function f(arr, v) &#123;</span><br><span class="line">  return arr.length ? f(arr, v + arr.shift()) : v;</span><br><span class="line">&#125;([1, 2, 3], 0);</span><br><span class="line"></span><br><span class="line">console.log(c)</span><br></pre></td></tr></table></figure><p>위 코드에서는 a 가 false이므로 삼항 연산자에서 10을 건너뛰고 함수 부분이 실행된다. 함수 정의 끝부분을 보면 알 수 있듯이 즉시 실행했다. 그리고 [1,2,3]과 0을 인자로 받는다. 위와 같이 즉시 실행 함수를 이용하면 어디에서든 한 줄만 작성할 수 있던 곳을 확장할 수 있다. 또한 다른 함수를 실행할 수도 있고 재귀를 돌면서 얼마든지 복잡한 로직도 넣을 수 있다.</p><h2 id="함수-실행의-괄호"><a href="#함수-실행의-괄호" class="headerlink" title="함수 실행의 괄호"></a>함수 실행의 괄호</h2><h3 id="함수-실행을-통해-생기는-새로운-공간"><a href="#함수-실행을-통해-생기는-새로운-공간" class="headerlink" title="함수 실행을 통해 생기는 새로운 공간"></a>함수 실행을 통해 생기는 새로운 공간</h3><p>이전에 가장 특별한 괄호는 함수를 실행하는 괄호라고 했었다. 함수를 실행하는 괄호와 그렇지 않은 다른 괄호의 차이는 무엇일까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5);</span><br><span class="line">(function () &#123; return 10; &#125;);</span><br></pre></td></tr></table></figure><p>위 코드의 괄호 두 가지는 모두 일반적인 괄호다. 함수를 실행하는 괄호가 아닌 일반 괄호에서는 코드가 실행되면 해당 지점에 즉시 값을 만들고 끝난다. 해당 지점에서 만들어진 값을 참조할 수는 있지만 여기서 할 일은 바로 모두 끝난다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var add5 = function (a) &#123; // 새로운 공간</span><br><span class="line">  return a + 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var call = function (f) &#123; // 새로운 공간</span><br><span class="line">  return f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 함수를 실행하는 괄호</span><br><span class="line">add(5);</span><br><span class="line">call(function () &#123; return 10; &#125;);</span><br></pre></td></tr></table></figure><p>함수를 실행하는 괄호는 일반 괄호와 특성이 모두 같지만 한 가지 특성을 더 가지고 있다. 이 괄호를 통해 새로운 <code>실행 컨텍스트</code>가 열린다는 점이다. 이 점은 매우 중요하다. 함수를 실행하는 괄호에서는 코드가 실행되었을 때 해당 지점에 값을 만든 후 끝나지 않고, 이 값이 실행된 함수의 공간으로 넘어간다. 새롭게 열린 공간이 끝나기 전까지는 이전 공간의 상황들도 끝나지 않는다. 이 공간들을 실행 컨텍스트라고 한다.</p><p>새로운 공간이 생긴다는것, 콜 스택에 쌓인다는 것, 태스크 큐와 이벤트 루프에 의해 제어된다는 것, 이것들을 통해 개발자가 시작과 끝을 제어할 수 있다는 점들이 함수를 실행하는 괄호가 가진 가장 특별한 차이다.</p><p>함수가 정의되거나 실행되는 지점에서는 클로저도 만들어질 수 있고, 비동기 상황이 생길 수도 있으며 서로 다른 컨택스트가 연결되는 등의 특별한 일들이 생긴다. 이것들은 함수에 대한 매우 실제적이고 중요한 개념이다.<br>for문을 사용할 때 어떤 지점들을 확인하면서 코드 블록을 반복시키는지, 언제 어떻게 끝나는지 정확히 이해하지 않고는 코딩할 수 없듯이 함수도 마찬가지다.</p><h3 id="기본적인-비동기-상황"><a href="#기본적인-비동기-상황" class="headerlink" title="기본적인 비동기 상황"></a>기본적인 비동기 상황</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3 (1초 뒤)</span><br></pre></td></tr></table></figure><p>코드 라인 순서와 달리 1, 2, 3 으로 실행 되었다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var add = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(10, 5, function (r) &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>비동기 상황이 생기는 함수의 결과는 return 문으로 반환할 수 없다. 비동기 상황이 생기는 함수의 결과를 받는 방법 중 하나는 콜백 함수를 넘겨서 돌려받는 방법이다. add의 마지막 인자로 넘겨진 익명 함수 callback은 add 안에서 모든 상황이 끝날 때 실행된다. 이를 통해 add를 실행한 스코프 내부에서 다시 add의 결과를 받을 수 있게 된다.<br>일반 괄호였다면 10, 5, function등이 그 자리에 정의되고 끝났겠지만 함수를 실행하는 괄호에서는 그 값들이 다른 공간으로 넘어간다. 새롭게 열린 공간에서는 넘겨받은 재료들로 새로우 일을 할 수 있다.</p><h3 id="함수-실행-괄호의-마법과-비동기"><a href="#함수-실행-괄호의-마법과-비동기" class="headerlink" title="함수 실행 괄호의 마법과 비동기"></a>함수 실행 괄호의 마법과 비동기</h3><p>비동기 상황을 제어하는 방법은 함수 실행을 일렬로 나열하는 것이다.</p><p>add 함수 실행 -&gt; setTimeout 함수 실행 -&gt; setTimeout이 1초 뒤 익명 함수를 실행 -&gt; 받아 둔 callback 실행</p><p>위와 같이 함수들의 실행을 일렬로 나열하여 한 가지 일이 순서대로 일어나도록 하는 것이다.<br>이 함수 나열을 숨겨서 비동기 코드가 동기식으로 실행되는 것처럼 보이도록 해볼 것이다. Promise하고 비슷할 것이다. 이 작업을 통해 함수 실행의 괄호에서 다른 공간으로 이동되는 사이에 할 수 있는 일을 확인할 것이다. 이런 기법들을 통해 프로미스의 내부 코드를 예상해 볼 수도 있을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var add = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sub = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(10, 15, function (a) &#123;</span><br><span class="line">  sub(a, 5, function (a) &#123;</span><br><span class="line">    div(a, 10, function (r) &#123;</span><br><span class="line">      console.log(r); // 약 3초 후에 2가 찍힘</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>원래 비동기가 일어나는 함수들은 아래처럼 중첩 실행을 할 수 없다. 함수의 몇 가지 특성을 활용해 비동기 함수도 아래처럼 중첩 실행이 가능하도록 해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(div(sub(add(10, 15), 5), 10));</span><br><span class="line">// undefined가 찍히고 callback이 없다는 에러가 남.</span><br></pre></td></tr></table></figure><p>우선 함수가 실행되는 사이에 무언가를 할 수 있도록 함수로 한 번 감싸서 공간을 만들 것이다. wrap에게 함수를 전달하여 함수를 리턴 받으면 원래 기능을 유지하면서 코드 사이에 공간이 생긴다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function wrap(func) &#123; // 1. 함수 받기</span><br><span class="line">  return function () &#123; // 2. 함수 리턴하기, 이것이 실행됨.</span><br><span class="line">    // 여기에 새로운 공간이 생김, 나중에 함수를 실행했을 때 이 부분을 거쳐감</span><br><span class="line">    return func.apply(arguments); // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = wrap(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(5, 10, function (r) &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1에서 받은 함수를 기억하는 2 클로저를 만들어 리턴했고, add는 2가 된다. 나중에 2가 실행되면 1에서 받아 둔 3 함수를 실행하면서 2가 받은 모든 인자를 넘겨준다. 이전 add와 완전히 동일하게 동작하면서도 사이사이에 코드를 끼워 넣을 수 있는 공간들이 더 생겼다. wrap을 조금만 더 고치고 _async 라고 이름을 바꿔보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function _async(func) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    arguments[arguments.length++] = function (result) &#123; // 1</span><br><span class="line">      _callback(result) // 6</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    func.apply(null, arguments); // 2</span><br><span class="line"></span><br><span class="line">    var _callback; // 3</span><br><span class="line">    function _async_cb_receiver(callback) &#123; // 4</span><br><span class="line">      _callback = callback; // 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(20, 30)(function (r) &#123; // 7</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>우선 마지막 부분 7을 보면 add를 실행하는 방법이 바뀌었다. 한 번에 인자 3개를 넘기지 않고 마치 커링처럼 add에 필요한 재료를 넘긴 후 한 번 더 실행하면서 callback 함수를 넘기고 있다.</p><ol><li>add가 실행되면 인자로 20과 30이 넘어온다. 원래는 callback 함수를 받아야 하므로 arguments에 마지막 값으로 함수를 추가한다. 그리고 그 함수는 나중에 개발자가 넘겨준 callback 함수를 실행할 수 있게 준비해 두었다.</li><li>add를 정의할 때 받아 둔 func를 실행하면서 인자 3개를 넘긴다.</li><li>_callback 이라는 지역 변수를 만들어서 1과 4가 기억해 두도록 했다. 클로저를 활용하여 서로 다른 컨텍스트가 협업할 수 있도록 이어주었다.</li><li>_async_cb_receiver라는 이름을 가진 유명 함수이자 클로저를 만들어 리턴한다.</li><li>_async_cb_receiver가 실행될 때 받은 함수 callback을 _callback에 할당한다.</li><li>1초가 지나면 1이 실행될 것이고 add가 callback을 통해 넘긴 결과인 result를 받아 두었던 _callback을 실행하면서 다시 넘겨주고 있다.</li><li>이 익명 함수가 _callback 이므로 6에서 넘겨진 r을 받게 되고 로그를 남겼다.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var div = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(10, 15)(function (a) &#123;</span><br><span class="line">  sub(a, 5)(function (a) &#123;</span><br><span class="line">    div(a, 10)(function (r) &#123;</span><br><span class="line">      console.log(r);</span><br><span class="line">      // 약 3초 후 2가 찍힘</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="비동기와-재귀"><a href="#비동기와-재귀" class="headerlink" title="비동기와 재귀"></a>비동기와 재귀</h3><p>일반 콜백 패턴의 함수를 실행하는 것과 아직 큰 차이는 없지만 연산에 필요한 실행과 결과를 받기 위한 실행이 분리되었다. 함수를 실행하는 괄호에서는 값을 다른 공간으로 넘겨 새로운 일들을 더 할 수 있다. add, sub, div는 async를 통해 본체에 가기 전 새로운 공간을 가지고 있고, 그 공간에서는 시작과 끝을 제어하고 있다. 이 내부 공간을 손보면 좀 더 재밌는 일을 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _async(func) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    arguments[arguments.length++] = function (result) &#123;</span><br><span class="line">      _callback(result)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 변경된 부분</span><br><span class="line">    (function wait(args) &#123;</span><br><span class="line">      // 새로운 공간 추가</span><br><span class="line">      for (var i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;</span><br><span class="line">          return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      func.apply(null, args);</span><br><span class="line">    &#125;)(arguments);</span><br><span class="line"></span><br><span class="line">    var _callback;</span><br><span class="line">    function _async_cb_receiver(callback) &#123;</span><br><span class="line">      _callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;add&apos;, a, b);</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;sub&apos;, a, b);</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var div = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;div&apos;, a, b);</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var log = _async(function (val) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log(div(sub(add(10, 15), 5), 10));</span><br><span class="line">// 약 4초 뒤 2</span><br><span class="line">log(add(add(10, 10), sub(10, 5)));</span><br><span class="line">// 약 3초 뒤 25</span><br></pre></td></tr></table></figure><p>모두 비동기 함수들 인데도 마치 즉시 완료되는 동기 함수들을 중첩하여 실행한 것처럼 동작하고 있다. 추가된 부분만 다시 자세히 살펴보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 변경 전</span><br><span class="line">func.apply(null, args);</span><br><span class="line"></span><br><span class="line">// 변경 후</span><br><span class="line">(function wait(args) &#123;</span><br><span class="line">  for (var i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">    if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;</span><br><span class="line">      return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  func.apply(null, args);</span><br><span class="line">&#125;)(arguments);</span><br></pre></td></tr></table></figure><p>크게 보면 wait라는 유명 함수를 만들었고 내부에서 재귀를 돌다 func를 실행하도록 변경되었다. 재귀는 인자 중에 <code>_async_cb_receiver</code> 가 있다면 모두 결과값으로 치환될 때까지 돌게 된다.<br>add의 실행 결과는 숫자가 아닌 _async_cb_receiver라는 이름을 가진 함수다. 이 함수에 함수를 넣으면 결과를 받을 수 있다. 이를 이용하여 add의 실행 결과를 받은 sub는 자신의 본체(func) 로 가기 전에 wait로 _async_cb_receiver가 있는지 확인하고, 있다면 실행하여 결과값을 받고 재귀를 돌며 해당 번째 args[i]를 결과값으로 변경한다.</p><p>앞의 예제는 특정 지점에 함수를 정의하거나 함수로 감싸고, 함수를 즉시 실행하거나 재귀를 하는 식으로 기존 로직 사이에 선행 로직이나 후행 로직을 만들면서 프로그램의 순서를 제어할 수 있음을 보여준다. 위 예제에서는 이런 기법을 통해 비동기 상황을 제어하고, 다른 라이브러리들과의 연결 고리를 만드는 중요한 단위가 된다.</p><p>일반 괄호에서는 할 수 없는 일이지만 함수를 실행하는 괄호에서는 새로운 공간들을 레이어처럼 얼마든지 만들 수 있다. 앞의 예제 처럼 본체까지 가기 전 레이어들을 통과하면서 비동기 함수의 결과를 기다렸다가 결과값으로 변형해 넘겨줄 수도 있다. 함수를 실행하는 괄호에서 함수를 실행할 수 있고, 실행한 결과가 함수여서 그 함수를 다시 함수에게 인자로 넘길 수 있고, 그렇게 받은 함수를 실행할 수 있다.</p><p>자바스크립트에서 재귀는 충분히 실용적이라는 이야기를 했었다. 앞의 상황에서는 재귀를 통해 비동기 상황을 제어했다. 재귀는 로직들을 함수라는 단위로 일자로 나열하는 것이다. 비동기 제어의 핵심 역시 함수 실행의 나열이다. 비동기가 발생되면 스택이 초기화되므로 재귀에 대한 부담도 없다. 아무리 많은 재귀가 일어나도 ‘Maximum call stack size exceeded’ 에러는 절대로 발생하지 않는다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;if-else-amp-amp-삼항-연산자-다시-보기&quot;&gt;&lt;a href=&quot;#if-else-amp-amp-삼항-연산자-다시-보기&quot; class=&quot;headerlink&quot; title=&quot;if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기&quot;&gt;&lt;/a&gt;if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기&lt;/h2&gt;&lt;h3 id=&quot;if의-괄호&quot;&gt;&lt;a href=&quot;#if의-괄호&quot; class=&quot;headerlink&quot; title=&quot;if의 괄호&quot;&gt;&lt;/a&gt;if의 괄호&lt;/h3&gt;&lt;p&gt;if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.&lt;/p&gt;
&lt;p&gt;괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.&lt;br&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>함수형 자바스크립트를 위한 문법 다시 보기</title>
    <link href="https://kkangil.github.io/2019/10/20/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0/"/>
    <id>https://kkangil.github.io/2019/10/20/함수형-자바스크립트를-위한-문법-다시-보기/</id>
    <published>2019-10-20T05:29:11.000Z</published>
    <updated>2019-12-01T09:41:32.119Z</updated>
    
    <content type="html"><![CDATA[<p>함수형 자바스크립트를 잘 다루기 위해서는 숲을 보는 것보다 나무의 결을 들여다 보는 것이 중요하다. 자바스크립트 문법과 기본적인 동작에 집중해보자. 함수 하나가 정의되고 실행되고 참조되는 과정, 인자를 받거나 넘기는 과정, 클로저가 되거나 비동기가 일어나는 과정, 괄호, 대괄호, 점, 쉼표 등을 자세히 들여다 보자. 문법적 감각이 좋아지면 원하는 곳 어디에서나 함수를 열고 실행할 수 있게 된다.</p><a id="more"></a><h2 id="객체와-대괄호-다시-보기"><a href="#객체와-대괄호-다시-보기" class="headerlink" title="객체와 대괄호 다시 보기"></a>객체와 대괄호 다시 보기</h2><h3 id="객체와-key"><a href="#객체와-key" class="headerlink" title="객체와 key"></a>객체와 key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1, &quot;b&quot;: 2 &#125;; // 1</span><br><span class="line">obj.c = 3;</span><br><span class="line">obj[&apos;d&apos;] = 4; // 2</span><br><span class="line">var e = &apos;e&apos;;</span><br><span class="line">obj[e] = 5;</span><br><span class="line">function f() &#123; return &apos;f&apos; &#125;;</span><br><span class="line">obj[f()] = 6;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><p>일단 객체의 key 와 value에 대한 부분이다. 객체의 key와 value는 {}, . , [] 등을 통해 설정할 수 있다.<br>그중 어떤 문자열이든 key로 정의할 수 있는 곳이 있는데 1과 2 같은 곳이다. 이 두 가지 방식이 가진 공통점이 있다면 띄어쓰기, 특수 문자, 숫자 등을 가리지 않고 어떤 문자열이든 key로 만들 수 있다는 점이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj2 = &#123; &quot;a a a&quot;: 1 &#125;;</span><br><span class="line">obj2[&quot;b b b&quot;] = 2;</span><br><span class="line">console.log(obj2);</span><br><span class="line"></span><br><span class="line">var obj3 = &#123; &quot;margin-top&quot;: 5 &#125;;</span><br><span class="line">obj3[&quot;padding-bottom&quot;] = 20;</span><br><span class="line">console.log(obj3);</span><br><span class="line"></span><br><span class="line">var obj4 = &#123; 1: 10 &#125;;</span><br><span class="line">obj4[2] = 20;</span><br><span class="line">console.log(obj4);</span><br></pre></td></tr></table></figure><p>그렇다면 {} 안쪽에서 key를 선언하는 것과 [] 안에서 선언하는 것은 차이가 없을까? {}의 문자열 부분에서는 코드를 실행할 수 없고 []의 안쪽에서는 코드를 실행할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj5 = &#123; (true ? &quot;a&quot; : &quot;b&quot;): 1&#125;; // Uncaught SyntaxError</span><br><span class="line">var obj6 = &#123;&#125;;</span><br><span class="line">obj6[true ? &quot;a&quot; : &quot;b&quot;] = 1;</span><br><span class="line">console.log(obj6);</span><br></pre></td></tr></table></figure><p>{} 안쪽의 key 영역에서는 코드를 실행할 수 없다. [] 사이에는 문자열이 담긴 변수도 넣을 수 있고, 연산자도 사용할 수 있으며 함수도 실행할 수 있다. 즉, [] 에서는 코드를 실행할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj5 = &#123; [true ? &quot;a&quot; : &quot;b&quot;]: 1 &#125;</span><br><span class="line">console.log(obj5);</span><br></pre></td></tr></table></figure><p>하지만 ES6 의 경우에서는 {} 안에 [] 를 사용하여 코드를 실행할 수 있게됐다. </p><h3 id="함수나-배열에-달기"><a href="#함수나-배열에-달기" class="headerlink" title="함수나 배열에 달기"></a>함수나 배열에 달기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function obj8() &#123; &#125;</span><br><span class="line">obj8.a = 1;</span><br><span class="line">obj8.b = 2;</span><br><span class="line">console.log(obj8.a); // 1</span><br><span class="line">console.log(obj8.b); // 2</span><br></pre></td></tr></table></figure><p>자바스크립트에서는 함수도 객체다. 그러므로 함수도 key/value 쌍으로 구성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj10 = []</span><br><span class="line">obj10.a = 1;</span><br><span class="line">console.log(obj10.a); // 1</span><br><span class="line">console.log(obj10.length); // 0</span><br></pre></td></tr></table></figure><p>배열도 객체이며 배열에도 숫자가 아닌 key를 사용할 수 있다. 단, 숫자가 아닌 key로 값을 할당할 경우 length는 변하지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj11 = [];</span><br><span class="line">obj11[0] = 1;</span><br><span class="line">obj11[1] = 2;</span><br><span class="line">console.log(obj11);</span><br><span class="line">console.log(obj11.length) // 2</span><br></pre></td></tr></table></figure><p>배열에 숫자로 key를 직접 할당해도 push와 동일하게 동작한다. 자동으로 length도 올라간다.</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>자바스크립트에서는 기본 객체의 메서드나 프로퍼티도 지울 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line">delete obj.a;</span><br><span class="line">delete obj[&apos;b&apos;];</span><br><span class="line">delete obj[&apos;C&apos;.toLocaleLowerCase()];</span><br><span class="line">console.log(obj) // &#123;&#125;</span><br><span class="line"></span><br><span class="line">delete Array.prototype.push;</span><br><span class="line">var arr1 = [1, 2, 3];</span><br><span class="line">arr1.push(4); // Uncaught TypeError: arr1.push is not a function</span><br></pre></td></tr></table></figure><p>다른 언어를 다루었던 개발자라면 delete로 아무거나 지우기, 배열에 숫자가 아닌 key 사용하기 등을 봤을 때, 자바스크립트의 유연함을 난해하다거나 위험하다고 느낄 수 있다. 하지만 이 특징들을 문제가 아닌 자바스크립트의 특성으로 받아들인 후에 더욱 다양한 기법들이 나오기 시작했고 더 잘 동작하기까지했다.</p><h2 id="함수-정의-다시-보기"><a href="#함수-정의-다시-보기" class="headerlink" title="함수 정의 다시 보기"></a>함수 정의 다시 보기</h2><h3 id="기본-정의"><a href="#기본-정의" class="headerlink" title="기본 정의"></a>기본 정의</h3><p>자바스크립트에서 함수를 정의하는 방법은 다양하다. 대표적인 방법들은 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add1(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add2 = function(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var m = &#123;</span><br><span class="line">  add3: function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수를 정의하는 것은 이미 익숙하겠지만 확인해 볼 만한 부분이 있다. 바로 호이스팅인데, 호이스팅에 대해 어느 정도 알고 있더라도 읽어 보기를 권한다.</p><h3 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h3><p>호이스팅(hoisting)이란 변수나 함수가 어디서 선언되든지 해당 스코프 최상단에 위치하게 되어 동일 스코프 어디서든 참조할 수 있는 것을 말한다. 아래의 코드 add1과 add2에는 호이스팅이 적용된다. ‘add2는 실행이 안 될 텐데 호이스팅이 아니지 않나?’하고 생각할 수 있지만 이것은 오해다. 물론 에러가 난 걸로 알 수 있듯이 add2는 선언하기 전 라인에서 실행할 수 없다. 하지만 분명히 add2도 호이스팅이 적용된 것이다. 결론부터 말하면 선언은 되었지만 아직 초기화되지 않은 상태에서 실행했기 때문에 에러가 난 것 이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add1(10, 5); // 15</span><br><span class="line">add2(10, 5); // Uncaught TypeError: add2 is not a function</span><br><span class="line"></span><br><span class="line">function add1(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add2 = function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제에서 add2는 실행되지 않았고, ‘add2 is not a function’ 이라는 에러 메시지가 출력되었다. 이번에는 선언한 적 없는 함수를 실행해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hi();</span><br><span class="line">// Uncaught ReferenceError: hi is not defined</span><br></pre></td></tr></table></figure><p>에러 메시지가 다르다. 자바스크립트에서는 아예 선언된 적이 없는 것을 참조하려고 할 때 이러한 에러가 난다. 실행하지 않고 참조만 하려고 해도 동일한 에러가 난다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(add1); // function add1(a, b) &#123; return a + b &#125;;</span><br><span class="line">console.log(add2); // undefined;</span><br><span class="line"></span><br><span class="line">function add1(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add2 = function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번엔 에러가 나지 않았고 undefined가 출력되었다. 그렇다면 add1과 add2는 어떤 차이에 의해 실행이 되고 안 되는 것 일까?<br>이는 변수 선언과 함수 선언에서의 차이 떄문이다. 변수는 선언 단계와 초기화 단계가 구분되어 있다. 변수는 선언과 초기화가 동시에 이루어지지 않기 때문에 호이스팅에 의해 참조만 가능하고, 아직 값이 담기지 않아 실행은 불가능하다. 반면에 함수 선언은 선언과 동시에 초기화가 이루어지기 때문에 참조뿐 아니라 실행도 가능하다.<br>add2는 변수를 선언하여 익명 함수를 담았고 add1은 함수로 선언했다. 호이스팅에 의해 add1은 미리 실행할 수 있고 add2는 호이스팅에 의해 미리 참조할 수 있지만 값이 없어 실행할 수는 없다.</p><h3 id="호이스팅-활용하기"><a href="#호이스팅-활용하기" class="headerlink" title="호이스팅 활용하기"></a>호이스팅 활용하기</h3><p>함수 선언과 호이스팅을 이용하면 다음과 같이 코드를 작성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return valid() ? a + b : new Error();</span><br><span class="line"></span><br><span class="line">  function valid() &#123;</span><br><span class="line">    return Number.isInteger(a) &amp;&amp; Number.isInteger(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(10, 5)); // 15</span><br><span class="line">console.log(add(10, &apos;&apos;)); // Error(...)</span><br></pre></td></tr></table></figure><p>위와 같이 return 문 아래에 정의한 함수도 실행이 가능하다. 비교적 복잡한 코드를 하단부에 정의하고 실행부 코드는 깔끔하게 유지하는 등으로 활용할 수도 있다.</p><h3 id="괄호없이-즉시-실행하기"><a href="#괄호없이-즉시-실행하기" class="headerlink" title="괄호없이 즉시 실행하기"></a>괄호없이 즉시 실행하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)(100);</span><br></pre></td></tr></table></figure><p>자바스크립트에서는 위와 같이 괄호를 통해 익명 함수를 즉시 실행할 수 있다. 괄호 없이 실행하면 에러가 발생한다. 많은 경우, 참조가 잘못되어 에러가 났다고 생각할 수 있지만 그렇지 않다. 에러가 난 이유는 익명 함수를 잘못 실행한 것이 아니라 익명 함수 선언 자체가 실패했기 떄문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;&#125;</span><br><span class="line">// Uncaught SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure><p>실행 없이 선언만 시도해도 에러가 난다. 그런데 우리는 이와 비슷한데 에러가 나지 않는 코드를 봤었다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>이 예제는 1장에서 봤었던 함수를 값으로 다루는 패턴 중 하나다. 위 코드는 함수를 괄호로 감싸지 않았는데 문법 에러가 나지 않고 정상적으로 동작한다. 이 상황에서 에러가 나지 않는다면 괄호 없이 즉시 실행도 되지 않을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  return function (a) &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>이 코드는 정상적으로 동작한다. f1이라느느 함수 안에 있는 익명 함수는 괄호 없이도 즉시 실행이 되었다. 만일 f1이라는 함수의 return 바로 뒤에서 함수를 즉시 실행하고 싶다면, 그 상황에서는 괄호 없이도 익명 함수를 즉시 실행할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">!function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">true &amp;&amp; function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">1 ? function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1) : 5;</span><br><span class="line"></span><br><span class="line">0, function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">var b = function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">function f2() &#123; &#125;</span><br><span class="line">f2(function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1));</span><br><span class="line"></span><br><span class="line">var f3 = function c(a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">new function () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 상황들에서는 괄호 없이도 익명 함수를 즉시 실행할 수 있다. 이 중 !를 이용한 방법은 꽤 알려진 편이다. 이 상황에서의 공통점은 무엇일까? 일단 모두 연산자와 함께 있고, 함수가 값으로 다뤄졌다. 그리고 모두 익명 함수 선언에 대한 오류가 나지 않는다. 앞에서 즉시 실행이 실패했던 것은 익명 함수를 잘못 실행한 것이 아니라 익명 함수 선언 자체를 하지 못해서였다.</p><h3 id="유명-named-함수"><a href="#유명-named-함수" class="headerlink" title="유명(named) 함수"></a>유명(named) 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function f() &#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수를 값으로 다루면서 익명이 아닌 f() 처럼 이름을 지은 함수를 유명 함수라고 한다. 함수를 즉시 실행한다거나 함수를 클로저로 만들어 리턴할 때, 함수를 메서도로 만들 때는 주로 익명 함수를 사용하게 된다. 이와 같은 상황에서 익명 함수 대신 유명 함수로 사용하는 것이 유용할 때가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function () &#123;</span><br><span class="line">  console.log(f1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">// 위험 상황</span><br><span class="line">var f2 = f1;</span><br><span class="line">f1 = &apos;hi~&apos;;</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><p>이렇게 하면 참조가 가능하지만 ‘위험 상황’ 부분처럼 함수 생성 이후 변경이 일어나면 더 이상 자기 자신을 참조하지 못하게 될 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function () &#123;</span><br><span class="line">  console.log(arguments.callee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line">// ƒ () &#123;</span><br><span class="line">//   console.log(arguments.callee)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">var f2 = f1;</span><br><span class="line">f1 = null;</span><br><span class="line">f2();</span><br><span class="line">// ƒ () &#123;</span><br><span class="line">//   console.log(arguments.callee)</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>위 방법은 이 전 코드의 문제를 해결하지만 arguments.callee는 ES5 Strict mode에서 사용할 수 없다. 유명 함수식을 사용하면 arguments.callee를 대체할 수 있다. 유명 함수는 함수가 값으로 사용되는 상황에서 자신을 참조하기 매우 편하다. 함수의 이름이 바뀌든 메서드 안에서 생성한 함수를 다시 참조하고 싶은 상황이든 어떤 상황에서든 상관없이 자기 자신을 정확히 참조할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function f() &#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">var f2 = f1;</span><br><span class="line">f1 = null;</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><h3 id="유명-함수를-이용한-재귀"><a href="#유명-함수를-이용한-재귀" class="headerlink" title="유명 함수를 이용한 재귀"></a>유명 함수를 이용한 재귀</h3><p>유명 함수는 재귀를 만들 때에도 편리하다. 다음은 깊이를 가진 배열을 펴 주는 flatten 함수다. 아래와 같은 함수를 만들 때 재귀와 유명 함수는 특히 유용하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return function f(arr, new_arr) &#123; // 1</span><br><span class="line">    arr.forEach(function (v) &#123;</span><br><span class="line">      Array.isArray(v) ? f(v, new_arr) : new_arr.push(v); // 2</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return new_arr;</span><br><span class="line">  &#125;(arr, []); // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten([1, [2], [3, 4]]));</span><br><span class="line">// [1,2,3,4]</span><br><span class="line">console.log(flatten([1, [2], [[3], 4]]));</span><br><span class="line">// [1,2,3,4]</span><br></pre></td></tr></table></figure><ol><li>flatten 함수가 실행되면 먼저 즉시 실행할 f 라는 이름의 유명 함수로 만든다.</li><li>함수 f를 즉시 실행하면서 새로운 배열 객체를 생성하여 넘겨준다.</li><li>루프를 돌면서 배열이 아닐 때만 값을 push하고 배열인 경우에는 f를 다시 실행하여 배열을 펴고 있다.</li></ol><p>이 코드가 재밌는 점은 즉시 실행과 유명 함수를 이용한 재귀라는 것이다. 만일 재귀로만 이 로직을 구현한다면 함수를 사용하는 개발자가 빈 배열을 항상 직접 넘겨주거나 if문을 체크하는 식으로 재귀를 제어해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function flatten2(arr, new_arr) &#123;</span><br><span class="line">  arr.forEach(function (v) &#123;</span><br><span class="line">    Array.isArray(v) ? flatten2(v, new_arr) : new_arr.push(v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return new_arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flatten2([1, [2], [3, 4]], []) // 항상 빈 Array를 추가로 넘겨 줘야함.</span><br><span class="line"></span><br><span class="line">function flatten3(arr, new_arr) &#123;</span><br><span class="line">  if (!new_arr) return flatten3(arr, []); // if 문이 생김</span><br><span class="line">  arr.forEach(function (v) &#123;</span><br><span class="line">    Array.isArray(v) ? flatten3(v, new_arr) : new_arr.push(v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return new_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>세 가지 방식의 코드 모두 장단점이 있다. flatten2는 if가 없고 가장 빠르지만 함수를 사용할 때 개발자가 직접 배열을 넘겨주어야 한다. flatten3은 사용하기 간단하지만 if가 있다. flatten은 if가 없으면서 사용하기 간단하지만 함수를 한 번 생성한다. </p><h3 id="자바스크립트에서-재귀의-아쉬움"><a href="#자바스크립트에서-재귀의-아쉬움" class="headerlink" title="자바스크립트에서 재귀의 아쉬움"></a>자바스크립트에서 재귀의 아쉬움</h3><p>재귀를 이용하면 복잡한 로직이나 중복되는 로직을 제거할 수 있고 읽기 쉬운 로직을 만들 수 있어 편하다. 그러나 아직까지는 자바스크립트에서 재귀를 사용하는 것에 약간 부담스러운면이 있다. 환경에 따라 다르지만 대략 15,000번 이상 재귀가 일어나면 ‘Maximum call stack exceeded’라는 에러가 발생하고 소프트웨어가 죽는다. 따라서 자바스크립트에서 얼마나 깊은 재귀가 일어날 것인가 유의하며 함수를 작성해야 한다.</p><p>아직 자바스크립트의 실제 동작 환경에서는 꼬리 재귀 최적화가 되지 않았다. 그렇다고 자바스크립트에서 성능 때문에 재귀를 사용할 일이 없다는 것은 잘못된 얘기다. 자바스크립트의 실제 동작 환경에서는 비동기 프로그래밍이 많이 쓰이고 비동기가 일어나면 스택이 초기화 된다. 애초에 비동기 상황이었다면 어차피 스택이 초기화 될 것이므로 재귀 사용을 피할 이유가 없다. </p><h2 id="함수-실행과-인자-그리고-점-다시-보기"><a href="#함수-실행과-인자-그리고-점-다시-보기" class="headerlink" title="함수 실행과 인자 그리고 점 다시 보기"></a>함수 실행과 인자 그리고 점 다시 보기</h2><h3 id="다시-보기"><a href="#다시-보기" class="headerlink" title="() 다시 보기"></a>() 다시 보기</h3><p>함수를 실행하는 방법에는 (), call, apply가 있고, 함수 안에서는 arguments 객체와 this 키워드를 사용할 수 있다. 각각의 사용법과 용도, 특이사항들을 하나씩 확인해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a, b, c) &#123;</span><br><span class="line">  console.log(&apos;a b c:&apos;, a, b, c);</span><br><span class="line">  console.log(this);</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 실행 방법에 따른 차이를 정확히 확인하기 위해 test 함수를 만들었다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">test(10); // 1</span><br><span class="line">// a b c: 10 undefined undefined</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [10]</span><br><span class="line"></span><br><span class="line">test(10, undefined); // 2</span><br><span class="line">// a b c: 10 undefined undefined</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [10, undefined]</span><br><span class="line"></span><br><span class="line">test(10, 20, 30); // 3</span><br><span class="line">// a b c: 10 20 30</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [10, 20, 30]</span><br></pre></td></tr></table></figure><p>arguments는 함수가 실행될 때 넘겨받은 모든 인자를 배열과 비슷한 형태로 담은 객체다. length로 넘겨받은 인자의 수를 확인할 수 있고 index로 순서별 인자를 확인할 수 있다. 2의 경우 1과 거의 유사하지만 arguments 객체가 다르게 생성이 된다. 인자로 undefined를 직접 넘긴 경우와 넘기지 않아 자연히 undefined 상태가 되는 것 사이에는 분명한 차이가 있다.</p><h3 id="인자-다시-보기"><a href="#인자-다시-보기" class="headerlink" title="인자 다시 보기"></a>인자 다시 보기</h3><p>인자는 일반 변수 혹은 객체와 약간 다르게 동작하는 부분이 있다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test2(a, b) &#123;</span><br><span class="line">  b = 10;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2(1); // 1</span><br><span class="line">// [1]</span><br><span class="line">test2(1, 2) // 2</span><br><span class="line">// [1, 10]</span><br></pre></td></tr></table></figure><p>인자는 변수와 달리 객체의 값이 바뀐다. 2는 arguments[1]에 해당하는 값이 넘어왔고, 인자인 b와 arguments[1]은 서로 마치 링크가 걸린 것 처럼 연결되어 있다. b를 고치니 arguments[1]도 바뀌었다. 1에서도 b를 고쳤는데 arguments[1]에 영향을 주지 않는다. 이 부분에 대해서 정확히 알고 있지 않은 상태에서 인자를 변경하는 코드를 작성할 경우, 의도와 다른 상황이 일어날 수 있을 것이다.</p><h3 id="this-다시-보기"><a href="#this-다시-보기" class="headerlink" title="this 다시 보기"></a>this 다시 보기</h3><p>위의 test 함수 내부의 console.log로 확인 하는 예제에서는 모든 this가 window 객체이다. 어떻게 해야 this에 다른 값이 들어갈 수 있을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; name: &quot;obj1&quot; &#125;;</span><br><span class="line">o1.test = test;</span><br><span class="line">o1.test(3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line"></span><br><span class="line">var a1 = [1, 2, 3];</span><br><span class="line">a1.test = test;</span><br><span class="line">a1.test(3, 3, 3);</span><br><span class="line">// a b c: 3 3 3</span><br><span class="line">// this: Array [1, 2, 3, test: f]</span><br><span class="line">// arguments: [3,3,3]</span><br></pre></td></tr></table></figure><p>기존에 있던 test 함수를 o1에 연결한 후 o1.test를 실행하니 this가 o1이 되었다. a1 역시 연결 후 실행하니 this가 a1이 되었다. 자바스크립트에서는 객체에 함수를 붙인 다음 그 함수를 . 으로 접근하여 실행하면 함수 내부의 this가 . 왼쪽의 객체가 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1_test = o1.test;</span><br><span class="line">o1_test(5, 6, 7);</span><br><span class="line">// a b c: 5 6 7</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [5, 6, 7]</span><br></pre></td></tr></table></figure><p>o1.test를 o1_test에 담은 다음 . 없이 o1_test를 실행했더니 this가 다시 window가 되었다. 이런 차이를 알아야 함수를 값으로 잘 다룰 수 있다. 실제로 메서드로 정의된 함수를 일반 함수처럼 사용하는 경우가 있다. o1.test에 붙였기 때문에 o1이 this가 되는 것이 아니라 . 으로 접근하여 실행했기 때문에 o1이 this가 되는 것이다. 어디에 붙어 있는 함수인지보다 어떻게 실행했는지가 중요하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(a1.test)(8, 9, 10);</span><br><span class="line">// a b c: 8 9 10</span><br><span class="line">// this: Array [1, 2, 3, test: f]</span><br><span class="line">// arguments: [8, 9, 10]</span><br><span class="line"></span><br><span class="line">a1[&apos;test&apos;](8, 9, 10);</span><br><span class="line">// a b c: 8 9 10</span><br><span class="line">// this: Array [1, 2, 3, test: f]</span><br><span class="line">// arguments: [8, 9, 10]</span><br></pre></td></tr></table></figure><p>괄호로 전체를 감쌌지만 여전히 this는 a1이 찍히고 있다. 참조를 어떻게 했느냐가 중요하다. [] 를 이용해 test 메서드를 참조 후 실행해도 . 으로 접근하여 실행한 것과 동일한 결과를 낸다.</p><p>자바스크립트에서의 함수는 ‘어떻게 선언했느냐’와 ‘어떻게 실행했느냐’가 모두 중요하다. ‘어떻게 정의했느냐’는 클로저와 스코프와 관련된 부분들을 결정하고 ‘어떻게 실행했느냐’는 this와 arguments를 결정한다.</p><h3 id="call-apply-다시-보기"><a href="#call-apply-다시-보기" class="headerlink" title="call, apply 다시 보기"></a>call, apply 다시 보기</h3><p>자바스크립트에서 함수를 실행하는 대표적인 방법이 2개 더 남아 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.call(undefined, 1, 2, 3);</span><br><span class="line">test.call(null, 1, 2, 3);</span><br><span class="line">test.call(void 0, 1, 2, 3);</span><br></pre></td></tr></table></figure><p>위 3가지 실행 모두 동일한 결과가 나온다. null 이나 undefined를 call의 첫 번째 인자에 넣으면 this는 windnow가 된다. void 0 의 결과도 undefined 이기 때문에 같은 결과가 나온다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.call(o1, 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">test.call(1000, 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Number &#123;1000&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>함수의 메서드인 call은 Function.prototype.call 이다. test는 함수이자 객체이고  test 객체의 call은 함수 자신(test)을 실행하면서 첫 번째 인자로 받은 값을 this로 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">o1.test.call(undefined, 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">o1.test.call([50], 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Array [50]</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>call을 사용할 경우, 그 앞에서 함수를 .으로 참조했을지라도 call을 통해 넘겨받은 첫 번째 인자에 의해 this가 결정된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test.apply(o1, [3, 2, 1]);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">test.apply(1000, [3, 2, 1]);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Number &#123;1000&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">o1.test.apply(undefined, [3, 2, 1]);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">o1.test.apply([50], [3, 2, 1])</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Array [50]</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>apply는 call과 동일하게 동작하지만 인자 전달 방식이 다르다. 인자들을 배열이나 배열과 비슷한 객체를 통해 전달한다. 여기서 배열과 비슷하다는 것은 다음과 같은 값들을 사용할 수 있다는 말이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test.apply(o1, &#123; 0: 3, 1: 2, 2: 1, length: 3 &#125;);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  test.apply(1000, arguments)</span><br><span class="line">&#125;)(3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Number &#123;1000&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>{ 0: 3, 1: 2, 2: 1, length: 3 }은 Array도 아니고 Arguments도 아닌 그냥 일반 객체다. 숫자를 키로 사용하고 그에 맞는 length를 가지고 있다. 이와 같이 되어 있는 객체라면 apply를 통해 인자로 전달할 수 있다. 다른 함수를 통해 생성된 arguments도 apply로 전달할 수 있다.</p><h3 id="call의-실용적-사례"><a href="#call의-실용적-사례" class="headerlink" title="call의 실용적 사례"></a>call의 실용적 사례</h3><p>계속해서 확인하고 있는, 일반적이지 않은 이런 기법들은 유명한 자바스크립트 개발자들의 코드에서 자주 등장한다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var slice = Array.prototype.slice;</span><br><span class="line">function toArray(data) &#123;</span><br><span class="line">  return slice.call(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rest(data, n) &#123;</span><br><span class="line">  return slice.call(data, n || 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr1 = toArray(&#123; 0: 1, 1: 2, length: 2 &#125;);</span><br><span class="line">arr1.push(3);</span><br><span class="line">console.log(arr1);</span><br><span class="line">// [1,2,3]</span><br><span class="line"></span><br><span class="line">rest([1, 2, 3]);</span><br><span class="line">// [2, 3]</span><br><span class="line">rest([1, 2, 3], 2);</span><br><span class="line">// [3]</span><br></pre></td></tr></table></figure><p>Array.prototye.slice의 경우, 키를 숫자로 갖고 length를 갖는 객체이기만 하면 Array가 아닌 값이어도 call을 통해 Array.prototype.slice를 동작시킬 수 있다. toArray와 rest 함수는 구현을 <code>Native Helper</code>에게 위임하여 짧은 코드로 성능이 좋은 유틸 함수를 만들었다.</p><p>자바스크립트에서는 this 키워드 못지않게 call, apply, arguments 등도 중요하다. call, apply, arguments, bind 등을 알고 자바스크립트를 다루는 것과 그렇지 않은 것은 정말 큰 차이를 만든다. 그리고 이 모든 기능들은 자바스크립트의 함수와 관련되어 있다. 자바스크립트 진영의 객체지향 관련 라이브러리에도 상속이나 메서드 오버라이드 같은 것을 구현하기 위해서는 apply와 arguments 등을 사용해야 한다. 함수형 자바스크립트에서는 특히나 중요하다. apply, arguments는 좋은 도구들이며 실제로 매우 실용적이다.</p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>오늘은 함수형 프로그래밍을 시작하기 앞서 기본적인 것들을 다시 확인해보는 시간이었다. 이미 알고 있던 내용도 있었지만, 복습하고 확실히 익히고자 하는 마음으로 정리했다. 해당 챕터의 내용이 많아 나머지 내용은 다음 시간에 정리해야겠다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수형 자바스크립트를 잘 다루기 위해서는 숲을 보는 것보다 나무의 결을 들여다 보는 것이 중요하다. 자바스크립트 문법과 기본적인 동작에 집중해보자. 함수 하나가 정의되고 실행되고 참조되는 과정, 인자를 받거나 넘기는 과정, 클로저가 되거나 비동기가 일어나는 과정, 괄호, 대괄호, 점, 쉼표 등을 자세히 들여다 보자. 문법적 감각이 좋아지면 원하는 곳 어디에서나 함수를 열고 실행할 수 있게 된다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="객체" scheme="https://kkangil.github.io/tags/%EA%B0%9D%EC%B2%B4/"/>
    
      <category term="함수의 호이스팅" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%EC%9D%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/"/>
    
      <category term="named function" scheme="https://kkangil.github.io/tags/named-function/"/>
    
      <category term="call, apply, arguments, this" scheme="https://kkangil.github.io/tags/call-apply-arguments-this/"/>
    
  </entry>
  
  <entry>
    <title>함수형 자바스크립트를 위한 기초</title>
    <link href="https://kkangil.github.io/2019/10/13/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88/"/>
    <id>https://kkangil.github.io/2019/10/13/함수형-자바스크립트를-위한-기초/</id>
    <published>2019-10-13T06:52:02.000Z</published>
    <updated>2019-12-01T09:41:24.903Z</updated>
    
    <content type="html"><![CDATA[<p>함수형 자바스크립트를 잘 익히기 위해서는 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데 이를테면 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드 등이 있다.</p><a id="more"></a><h2 id="일급-함수"><a href="#일급-함수" class="headerlink" title="일급 함수"></a>일급 함수</h2><p>자바스크립트에서 함수는 일급 객체이자 일급 함수다. 자바스크립트에서 객체는 일급 객체다. 여기서 <code>일급</code>은 값으로 다룰 수 있다는 의미로, 아래와 같은 조건을 만족해야 한다.</p><ul><li>변수에 담을 수 있다.</li><li>함수나 메서드의 인자로 넘길 수 있다.</li><li>함수나 메서드에서 리턴할 수 있다.</li></ul><p>자바스크립트에서 모든 값은 일급이다. 자바스크립트에서 모든 객체는 일급 객체이며 함수도 객체이자 일급 객체다.<br>일급 함수는 아래와 같은 추가적인 조건을 더 만족한다.</p><ul><li>아무 때나(런타임에서도) 선언이 가능하다.</li><li>익명으로 선언할 수 있다.</li><li>익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123; &#125;</span><br><span class="line">var a = typeof f1 === &apos;function&apos; ? f1 : function () &#123; &#125;;</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line">  return function () &#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function (a, b) &#123; return a + b; &#125;)(10, 5);</span><br><span class="line"></span><br><span class="line">function callAndAdd(a, b) &#123;</span><br><span class="line">  return a() + b();</span><br><span class="line">&#125;</span><br><span class="line">callAndAdd(function () &#123; return 10; &#125;, function () &#123; return 5; &#125;)</span><br></pre></td></tr></table></figure><ul><li>f1은 함수를 값으로 다룰 수 있음을 보여준다.</li><li>f2는 함수를 리턴한다.</li><li>a와 b를 더하는 익명 함수를 선언하였으며, a와 b에 각각 10, 5를 전달하여 즉시 실행했다.</li><li>callAndAdd를 실행하면서 익명 함수들을 선언했고 바로 인자로 사용되었다. callAndAdd는 넘겨받은 함수 둘을 실행하여 결과들을 더한다.</li></ul><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p>스코프에 대한 개념을 잘 알고 있다면 이 글을 읽는 데 더욱 도움이 될 것 이다. 스코프란 변수를 어디에서 어떻게 찾을지를 정한 규칙으로, 여기에서 다루는 스코프는 함수 단위의 변수 참조에 대한 것이다.<br>함수는 변수 참조 범위를 결정하는 중요한 기준이다. 함수가 중첩되어 있다면 스코프들 역시 중첩되어 생겨난다.</p><p><i>클로저는 자신이 생성될 때의 환경을 기억하는 함수다.</i></p><p>이 말을 보다 실용적으로 표현해 보면 <strong>클로저는 자신의 상위 스코프의 변수를 참조할 수 있다</strong>고 할 수 있다.</p><p><i>클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다.</i></p><p>자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다. 자바스크립트의 모든 함수는 상위 스코프를 가지며 모든 함수는 자신이 정의되는 순간(정의되는 곳)의 실행 컨텍스트 안에 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">  var a = 5;</span><br><span class="line">  function myfn() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parent2() &#123;</span><br><span class="line">  var a = 5;</span><br><span class="line">  function parent1() &#123;</span><br><span class="line">    function myfn() &#123;</span><br><span class="line">      console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parent와 parent2의 myfn에서는 a라는 변수를 선언하지 않았지만 사용하고 있다. parent의 변수 a는 myfn을 생성하는 스코프에서 정의되었고 parent2의 변수 a는 myfn을 생성하는 스코프의 상위 스코프에 정의되었다.</p><p>위와 같은 조건을 충족시키지 않는다면 그 함수가 아무리 함수 안에서 선언되었다고 하더라도 일반 함수와 전혀 다를 바가 없다. 클로저가 기억할 환경이라는 것은 외부의 변수들밖에 없기 때문이다. 또한 자신의 상위 스코프에서 알 수 있는 변수를 자신이 사용하고 있지 않다면 그 환경을 기억해야 할 필요가 없다.<br>글로벌 스코프를 제외한 외부 스코프에 있었던 변수 중 클로저 혹은 다른 누군가가 참조하고 있지 않는 모든 변수는 실행 컨텍스트가 끝난 후 가비지 컬렉션 대상이 된다. 어떤 함수가 외부 스코프의 변수를 사용하지 않았고, 그래서 외부 스코프의 환경이 가비지 컬렉션 대상이 된다면 그렇게 내비려 두는 함수를 클로저라고 보기 어렵다.</p><p><i>클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.</i></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = 20;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f1은 클로저처럼 외부 변수를 참조하여 결과를 만든다. 게다가 상위 스코프의 변수를 사용하고 있으므로 앞서 강조했던 조건을 모두 충족시키고 있다. 그런데 왜 클로저가 아닐까?<br>글로벌 스코프에서 선언된 모든 변수는 그 변수를 사용하는 함수가 있는지 없는지와 관계없이 유지된다. a와 b 변수가 f1에 의해 사라지지 못하는 상황이 아니므로 f1은 클로저가 아니다.<br>그렇다면 클로저는 ‘함수 안에서 함수가 생성될 때’만 생성된다고 할 수 있을까? 그렇지 않다. 웹 브라우저에서는 함수 내부가 아니라면 모두 글로벌 스코프지만, 요즘 자바스크립트에서는 함수 내부가 아니면서 글로벌 스코프도 아닌 경우가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f2() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = 20;</span><br><span class="line">  function f3(c, d) &#123;</span><br><span class="line">    return c + d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f4 = f2();</span><br><span class="line">console.log(f4(5, 7));</span><br></pre></td></tr></table></figure><p>위 코드에서는 클로저가 있을까? 특히 f3처럼 함수 안에서 함수를 리턴하면 클로저처럼 보인다. 하지만 이 코드의 f4에 담긴 f3도 클로저가 아니다. f3은 f2 안에서 생성되었고 f3 바로 위에는 a, b라는 지역 변수도 있다. 하지만 f3 안에서 사용하고 있는 변수는 c,d이고 두 변수는 모두 f3에서 정의되었다. 자신이 생성될 때의 스코프가 알고 있는 변수 a, b는 사용하지 않았다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 자신이 스스로 정의한 c, d는 f3이 실행되고 나면 없어진다. 다시 실행되면 c, d를 다시 생성하고 리턴 후에 변수는 사라진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f4() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = 20;</span><br><span class="line">  function f5() &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f4());</span><br></pre></td></tr></table></figure><p>그렇다면 위 코드에서는 클로저가 있을까? 정확한 표현은 <code>있었다</code>이다. 결과적으로는 클로저는 없다고 볼 수 있다. f4가 실행되고 a, b가 할당된 후 f5가 정의된다. 그리고 f5에서는 a, b가 사용되고 있으므로 f5는 자신이 생성된 환경을 기억하는 클로저가 된다. 그런데 f4의 마지막 라인을 보면 f5를 실행하여 리턴한다. 결국 f5를 참조하고 있는 곳이 어디에도 없기 때문에 f5는 사라지고, f5가 사라지면 a, b도 결국 사라질 수 있기에 클로저는 f4가 실행되는 사이에만 생겼다가 사라진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f6() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  function f7(b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f8 = f6();</span><br><span class="line">console.log(f8(20));</span><br><span class="line">console.log(f8(10));</span><br></pre></td></tr></table></figure><p>드디어 클로저 코드를 사용했다. f7은 진짜 클로저다. 이제 a는 사라지지 않는다. f7이 a를 사용하기에 a를 기억해야 하고 f7이 f8에 담겼기 때문에 클로저가 되었다. 원래대로라면 f6의 지역 변수는 모두 사라져야 하지만 f6 실행이 끝났어도 f7이 a를 기억하는 클로저가 되었기 때문에 a는 사라지지 않으며, f8을 실행할 때마다 새로운 변수인 b와 함께 사용되어 결과를 만든다.</p><p>혹시 위 상황에 메모리 누수가 있다고 볼 수 있을까? 그렇지 않다. 메모리가 해제되지 않는 것과 메모리 누수는 다르다. 메모리 누수는 메모리가 해제되지 않을 때 일어나는 것은 맞지만, 위 상황을 메모리 누수라고 할 수는 없다. a는 한 번 생겨날 뿐, 계속해서 생겨나거나 하지 않는다. 메모리 누수란 개발자가 의도하지 않았는데 메모리가 해제되지 않고 계속 남는 것을 말하며, 메모리 누수가 지속적으로 반복될 때는 치명적인 문제를 만든다. f8이 아무리 많이 실행되더라도 이미 할당된 a가 그대로 유지되기 때문에 메모리 누수는 일어나지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f9() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var f10 = function (c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line">  var b = 20;</span><br><span class="line">  return f10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f11 = f9();</span><br><span class="line">console.log(f11(30));</span><br></pre></td></tr></table></figure><p>위 코드는 에러없이 정상 동작한다. 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수라고 했었는데, 여기서 ‘때’는 생각하는 것보다 조금 길다고 했었다.<br>f10에는 익명 함수를 담았다. f10이 생성되기 딱 이전 시점에는 b가 20으로 초기화되지 않았다. 클로저는 자신이 생성되는 스코프의 모든 라인, 어느곳에서 선언된 변수든지 참조하고 기억할 수 있다. 그리고 그것은 변수이기에 클로저가 생성된 이후 언제라도 그 값은 변경될 수 있다.</p><p>클로저는 자바스크립트에서 절차지향 프로그래밍, 객체지향 프로그래밍, 함수형 프로그매일 모두를 지탱하는 매우 중요한 기능이자 개념이다. 분명 클로저는 메모리 누수 같은 위험성을 가지고 있다. 그러나 메모리 누수나 성능 저하의 문제는 클로저의 단점이나 문제가 아니다.</p><h2 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h2><p>고차 함수란, 함수를 다루는 함수를 말한다.</p><ol><li>함수를 인자를 받아 대신 실행하는 함수</li><li>함수를 리턴하는 함수</li><li>함수를 인자를 받아서 또 다른 함수를 리턴하는 함수</li></ol><p>고차 함수을 시작하기전 정의를 보고 클로저와의 차이점이 궁금해져 검색해봤다. </p><blockquote><p><i>“Closures are also functions. But when a function captures state upon its creation, we call it a closure.”</i><br>즉, 클로저 역시 함수지만, 함수가 생성될 때 state를 점유하고 있다면 우리는 그것을 클로저라고 합니다.</p></blockquote><p>출처: <a href="https://azsha.tistory.com/100" target="_blank" rel="noopener">https://azsha.tistory.com/100</a> [Azsha’s Forge]</p><p>사실상 함수형 프로그래밍의 절반은 고차 함수를 적극적으로 활용하는 프로그래밍이라고도 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function callWith10(val, func) &#123;</span><br><span class="line">  return func(10, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(callWith10(20, add));</span><br><span class="line">console.log(callWith10(5, sub));</span><br></pre></td></tr></table></figure><p>여기서 add와 sub는 일반 함수다. 함수를 인자로 받거나 함수를 리턴하지 않기 때문이다. callWith10은 고차 함수다. 함수를 받아 내부에서 대신 실행하기 때문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function constant(val) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var always10 = constant(10);</span><br><span class="line">console.log(always10()); // 10</span><br><span class="line">console.log(always10()); // 10</span><br><span class="line">console.log(always10()); // 10</span><br></pre></td></tr></table></figure><p>constant 함수는 실행 당시 받았던 10이라는 값을 받아 내부에서 익명 함수를 클로저로 만들어 val를 기억하게 만든 수 리턴한다. 리턴된 함수에는 always10 이라는 이름을 지어주었다. always10을 실행하면 항상 10을 리턴한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function callWith(val1) &#123;</span><br><span class="line">  return function (val2, func) &#123;</span><br><span class="line">    return func(val1, val2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var callWith10 = callWith(10);</span><br><span class="line">console.log(callWith10(20, add)); // 30</span><br><span class="line"></span><br><span class="line">var callWith5 = callWith(5);</span><br><span class="line">console.log(callWith5(5, sub)); // 0</span><br></pre></td></tr></table></figure><p>callWith는 함수를 리턴하는 함수다. val1을 받아서 val1을 기억하는 함수를 리턴했다. 리턴된 함수는 이후에 val2와 func를 받아 대신 func를 실행해 준다. 함수를 리턴하는 함수를 사옹할 경우 다음처럼 변수에 담지 않고 바로 실행해도 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(callWith(30)(20, add));</span><br><span class="line">console.log(callWith(5)(5, sub));</span><br></pre></td></tr></table></figure><p>인자는 숫가자 아닌 값도 활용이 가능하다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_.get = function (list, index) &#123;</span><br><span class="line">  return list[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users = [</span><br><span class="line">  &#123; id: 2, name: &quot;HA&quot;, age: 25 &#125;,</span><br><span class="line">  &#123; id: 4, name: &quot;PJ&quot;, age: 28 &#125;,</span><br><span class="line">  &#123; id: 5, name: &quot;JE&quot;, age: 27 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var callWithUsers = callWith(users);</span><br><span class="line">console.log(callWithUsers(2, _.get));</span><br></pre></td></tr></table></figure></p><h2 id="콜백-함수라-잘못-불리는-보조-함수"><a href="#콜백-함수라-잘못-불리는-보조-함수" class="headerlink" title="콜백 함수라 잘못 불리는 보조 함수"></a>콜백 함수라 잘못 불리는 보조 함수</h2><p>콜백 함수를 받아 자신이 해야 할 일을 모두 끝낸 후 결과를 되돌려 주는 함수도 고차 함수다. 보통은 비동기가 일어나는 상황에서 사용되며 콜백 함수를 통해 다시 원래 위치로 돌아오기 위해 사용되는 패턴이다. 콜백 패턴은 클로저 등과 함께 사용할 수 있는 매우 강력한 표현이자 비동기 프로그래밍에 있어 없어서는 안 될 매우 중요한 패턴이다. 콜백 패턴은 끝이 나면 컨텍스트를 다시 돌려주는 단순한 협업 로직을 가진다.</p><p>button.click(function() {})과 같은 코드의 익명 함수도 콜백 함수라고 표현되는 것을 많이 보았지만, 이 익명 함수는 ‘이벤트 리스너’라고 칭하는 것이 적합하다. 함수가 고차 함수에서 쓰이는 역할의 이름으로 불러주면 된다. _.each([1,2,3], function() {})에서의 익명 함수는 callback이 아니라 <code>iteratee</code>이며 _.filter(users, function() {})에서의 익명 함수는 <code>predicate</code>다. callback은 종료가 되었을 때 단 한 번 실행되지만 <code>iteratee</code>나 <code>predicate</code>, <code>listener</code>등은 종료될 때 실행되지 않으며 상황에 따라 여러 번 실행되기도 하고 각각 다른 역할을 한다.</p><h2 id="함수를-리턴하는-함수와-부분-적용"><a href="#함수를-리턴하는-함수와-부분-적용" class="headerlink" title="함수를 리턴하는 함수와 부분 적용"></a>함수를 리턴하는 함수와 부분 적용</h2><p>앞서 곳곳에서 미리 필요한 인자를 넘겨 두고 그 인자를 기억하는 클로저를 리턴하는 함수들을 확인했다. 클로저로 만들어진 함수가 추가적으로 인자를 받아 로직을 완성해 나가는 패턴을 갖는다. 이와 유사한 기법들로 bind, curry, partial 등이 있다. 이런 기법들을 통틀어 칭하는 특별한 용어는 없지만 다음과 같은 공통점을 갖는다.</p><p><i>기억하는 인자 혹은 변수가 있는 클로저를 리턴한다.</i></p><p>bind는 this와 인자들이 부분적으로 적용된 함수를 리턴한다. bind의 경우 인자보다는 주로 함수 안에서 사용될 this를 적용해 두는데 많이 사용한다. 그 이유는 아마 this 적용을 스킵할 수 없다는 점과 인자의 부분 적용을 왼쪽에서 부터 순서대로 할 수 있는 점 때문일 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add10 = add.bind(null, 10);</span><br><span class="line">console.log(add10(20)); // 30</span><br></pre></td></tr></table></figure><p>bind는 첫 번째 인자로 bind가 리턴할 함수에서 사용될 this를 받는다. 두 번째 인자부터 함수에 미리 적용될 인자들이다. 인자를 미리 적용해 두기 위해 this로 사용될 첫 번째 인자에 null을 넣은 후 10을 넣었다. add10과 같이 this를 사용하지 않는 함수이면서 왼쪽에서 부터 순서대로만 인자를 적용하면 되는 상황에서는 원하는 결과를 얻을 수 있다. bind의 아쉬운 점은 두 가지다. 인자를 왼쪽에서 부터 순서대로만 적용할 수 있다는 점과 bind를 한 번 실행한 함수의 this는 무엇을 적용해 두었든 앞으로 바꿀 수 없다는 점이다.<br>bind는 왼쪽에서 부터 원하는 만큼의 인자를 지정해 둘 수 있지만 원하는 지점을 비워 두고 적용할 수는 없다. 예를 들어 어떤 함수가 필요로 하는 인자가 3개가 있는데 그 중 두 번째 인자만을 적용해 두고 싶다면 bind로는 이것을 할 수 없다. 이러한 점을 개선한 방식이 있는데 바로 partial 이다.</p><h3 id="존-레식의-partial"><a href="#존-레식의-partial" class="headerlink" title="존 레식의 partial"></a>존 레식의 partial</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.partial = function () &#123;</span><br><span class="line">  var fn = this, args = Array.prototype.slice.call(arguments); // 1</span><br><span class="line">  return function () &#123; // 2</span><br><span class="line">    var arg = 0;</span><br><span class="line">    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) // 5</span><br><span class="line">      if (args[i] === undefined) args[i] = arguments[arg++]; // 6</span><br><span class="line"></span><br><span class="line">    return fn.apply(this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function abc(a, b, c) &#123;</span><br><span class="line">  console.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ac = abc.partial(undefined, &apos;b&apos;, undefined); // 3 </span><br><span class="line">ac(&apos;a&apos;, &apos;c&apos;); // 4</span><br><span class="line">// a, b, c</span><br></pre></td></tr></table></figure><ol><li>우선 <code>partial</code>이 실행되면 fn에 자기 자신인 this를 담는다. 여기서 자기 자신은 abc 같은 함수다. args에는 partial이 실행될 때 넘어온 인자들을 배열로 변경하여 args에 담아 둔다.</li><li>fn과 args는 리턴된 익명 함수가 기억하게 되므로 지워지지 않는다.</li><li>abc.partial을 실행할 때 첫 번째 인자와 세 번쩨 인자로 넘긴 undefined 자리는 나중에 ac가 실행될 때 채워질 것이다. </li><li>ac를 실행하면서 넘긴 ‘a’와 ‘c’는 </li><li>리턴된 익명 함수의 arguments에 담겨 있다.</li><li>for를 돌면서 미리 받아 두었던 args에 undefined가 들어 있던 자리를 arguments의 앞에서 부터 꺼내면서 모두 채운다. 다 채우고 나면 미리 받아 두었던 fn을 apply로 실행하면서 인자들을 배열로 넘긴다.</li></ol><p>사실 partial은 구현이 잘 된 것은 아니다. 함수의 인자로 undefined를 사용하고 싶을 수도 있는데 undefined가 인자를 비워 두기 우한 구분자로 사용되고 있기 때문에, undefined를 미리 적용하고 싶다면 방법이 없다. 또한 초기에 partial을 실행할 때 나중에 실제로 실행될 함수에서 사용할 인자의 개수만큼 꼭 미리 채워 놓아야만 한다. 이 처럼 partial이 가진 제약은 ‘인자 개수 동적으로 사용하기’나 ‘arguments 객체 활용’과 같은 자바스크립트의 유연함을 반영하지 못한다는 점에서 특히 아쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">  var result = 0;</span><br><span class="line">  for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    result += arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 2, 3, 4, 5));</span><br><span class="line"></span><br><span class="line">var add2 = add.partial(undefined, 2);</span><br><span class="line">console.log(add2(1, 3, 4, 5)); // 3</span><br><span class="line"></span><br><span class="line">var add3 = add.partial(undefined, undefined, 3, undefined, undefined);</span><br><span class="line">console.log(add3(1, 2, 4, 5)); // 15</span><br><span class="line"></span><br><span class="line">console.log(add3(50, 50, 50, 50)); // 15 (bug)</span><br><span class="line">console.log(add3(100, 100, 100, 100)); // 15 (bug)</span><br></pre></td></tr></table></figure><p>위 상황에서 add2는 3, 4, 5 인자를 무시하게 된다. add3처럼 하면 1, 2, 4, 5를 모두 사용할 수 있게 되지만 undefined로라도 인자 개수를 채워놔야 해서 코드가 깔끔하지 못하고 partial 이후에는 역시 4개 이상의 인자를 사용할 수 없다는 단점이 생긴다.<br>위 코드에는 치명적인 문제가 있다. 의도한 것인지는 모르겠지만 그가 만든 partial 함수로 만든 함수는 재사용이 사실상 불가능하다. 한번 partial을 통해 만들어진 함수를 실행하고 나면 클로저로 생성된 args의 상태를 직접 변경하기 때문에, 다음번에 다시 실행해도 같은 args를 바라보고 이전에 적용된 인자가 남는다. 결과적으로 partial로 만들어진 함수는 단 한 번만 정상적으로 동작한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.partial = function () &#123;</span><br><span class="line">  var fn = this, _args = arguments;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(_args);</span><br><span class="line">    var arg = 0;</span><br><span class="line">    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++)</span><br><span class="line">      if (args[i] === undefined) args[i] = arguments[arg++];</span><br><span class="line"></span><br><span class="line">    return fn.apply(this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같이 두 줄만 변경하면 두 번 이상 실행해도 정상적으로 동작한다. 클로저가 기억할 변수에는 원본을 남기고 리턴된 함수가 실행될 때마다 복사하여 원본을 지키는 방식을 사용한다. </p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>오늘은 본격적인 함수형 프로그래밍 시작에 앞서 기본이 될 기능들을 확인해 봤다. 일급 함수 같은 처음 듣는 용어도 있었고, 고차 함수 같은 경우는 내가 실무에서도 사용하고 있지만 정확한 용어도 모르고 사용하고 있었다. 또한 클로저, callback의 존재?는 알고 있었지만 정확한 개념이 부족했다는 것을 느꼈다. 오늘 내용의 모든 기능들의 대한 설명이 이 포스트로는 부족하지만 실력 향상에 많은 도움이 될 것같다. 기록해 두고 자주 보면서 내 것으로 만들어야 할 것 같다. </p><p>partial 같은 함수를 보고 들었던 생각은 함수형 프로그래밍의 끝은 어디 일까가 궁금해졌다. 정말 나는 생각도 못했던 기능이고 저게 그래서 실무에서 필요할까? 라는 생각을 했다. 하지만 partial과 같은 helper 함수들을 구현해 놓고 사용하면 생산성이 눈에 띄게 좋아질 것 같다고 생각한다.</p><p>이제 1장의 내용이 끝났는데 다음 장의 내용은 함수형 자바스크립트를 위한 문법 다시보기 이다. 이미 알고 있던 내용일 지더라도 기초를 더 다지기 위해 소홀히 보지 않아야겠다. </p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수형 자바스크립트를 잘 익히기 위해서는 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데 이를테면 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드 등이 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="일급 함수" scheme="https://kkangil.github.io/tags/%EC%9D%BC%EA%B8%89-%ED%95%A8%EC%88%98/"/>
    
      <category term="클로저" scheme="https://kkangil.github.io/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"/>
    
      <category term="고차 함수" scheme="https://kkangil.github.io/tags/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/"/>
    
      <category term="partial function" scheme="https://kkangil.github.io/tags/partial-function/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 - 시작2</title>
    <link href="https://kkangil.github.io/2019/09/29/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%912/"/>
    <id>https://kkangil.github.io/2019/09/29/함수형-프로그래밍-시작2/</id>
    <published>2019-09-29T06:27:54.000Z</published>
    <updated>2019-12-01T09:40:56.647Z</updated>
    
    <content type="html"><![CDATA[<p>이전 포스트에서 함수형 프로그래밍의 간략한 소개와 몇가지 예제 코드를 구현했었다. 오늘은 이전 포스트에 이어 다음 내용을 진행하려고 한다.</p><h2 id="회원-목록-중-한명-찾기"><a href="#회원-목록-중-한명-찾기" class="headerlink" title="회원 목록 중 한명 찾기"></a>회원 목록 중 한명 찾기</h2><p>회원 목록 중 id 값으로 해당 id 값을 가진 회원 한 명을 찾고자 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  filter(users, function (user) &#123; return user.id === 3 &#125;)[0]</span><br><span class="line">)</span><br><span class="line">// &#123;id: 3, name: &quot;BJ&quot;, age: 32&#125;</span><br></pre></td></tr></table></figure><p>filter를 통해 걸러낸 후 [0]으로 user를 얻어냈고 원하는 결과를 얻어냈기는 했다. 위 처럼 filter를 사용하여 찾을 수 있지만 filter 함수는 무조건 list.length 만큼 predicate가 실행되기 때문에 효율적이지 못하고, 동일 조건에 값이 두 개 이상이라면 두 개 이상의 값을 찾는다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user;</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].id === 3) &#123;</span><br><span class="line">    user = users[i];</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(user);</span><br></pre></td></tr></table></figure><p>원하는 user를 찾은 후 break로 for문을 빠져나왔다. 앞선 filter를 통해 찾은 것보다 훨씬 효율적이다.<br>하지만 위 코드는 재사용이 불가능 하므로 위 코드를 함수로 만들어서 재사용 가능하도록 만들어 보려고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function findById(list, id) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].id === id) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findById(users, 3));</span><br><span class="line">console.log(findById(users, 5));</span><br></pre></td></tr></table></figure><p>findById는 list와 id를 받아 루프를 돌다가 id가 동일한 객체를 만나면 그 값을 리턴한다.<br>만약 동일한 객체를 찾지 못한다면 기본 리턴 값인 undefined 가 리턴된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findByName</span><br><span class="line"> */</span><br><span class="line">function findByName(list, name) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].name === name) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findByName(users, &apos;BJ&apos;));</span><br><span class="line">console.log(findByName(users, &apos;JE&apos;));</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * findByAge</span><br><span class="line"> */</span><br><span class="line">function findByAge(list, age) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].age === age) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findByAge(users, 28));</span><br><span class="line">console.log(findByAge(users, 25));</span><br></pre></td></tr></table></figure><p>findById 와 동일하게 이름과 나이로도 찾을 수 있는 함수를 만들었다. 하지만 위의 세 함수 사이에 중복이 있다는 점이 아쉽다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findBy</span><br><span class="line"> */</span><br><span class="line">function findBy(key, list, val) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i][key] === val) return list[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(findBy(&apos;name&apos;, users, &apos;BJ&apos;));</span><br><span class="line">console.log(findBy(&apos;id&apos;, users, 2));</span><br><span class="line">console.log(findBy(&apos;age&apos;, users, 28));</span><br></pre></td></tr></table></figure><p>위와 같이 함수에 key 라는 인자를 하나 추가함으로써 세 함수를 공통으로 사용할 수 있게됐다. 위 함수는 key로 value를 얻을 수 있는 객체들을 가진 배열이라면 무엇이든 받을 수 있다. 객체의 key 값이 무엇이든지 간에 찾아줄 수 있으므로 훨씬 많은 경우를 대응할 수 있는 함수가 되었다.<br>하지만 위 함수에서도 아직 아쉬운 점이 존재한다.</p><ul><li>key가 아닌 메서드를 통해 값을 얻어야 할 때</li><li>두 가지 이상의 조건이 필요할 때</li><li>===이 아닌 다른 조건으로 찾고자 할 때</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function User(id, name, age) &#123;</span><br><span class="line">  this.getId = function () &#123;</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">  this.getName = function () &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line">  this.getAge = function () &#123;</span><br><span class="line">    return age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users2 = [</span><br><span class="line">  new User(1, &quot;ID&quot;, 32),</span><br><span class="line">  new User(2, &quot;HA&quot;, 25),</span><br><span class="line">  new User(3, &quot;BJ&quot;, 32),</span><br><span class="line">  new User(4, &quot;PJ&quot;, 28),</span><br><span class="line">  new User(5, &quot;JE&quot;, 27),</span><br><span class="line">  new User(6, &quot;JM&quot;, 32),</span><br><span class="line">  new User(7, &quot;HI&quot;, 24),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">console.log(findBy(&apos;age&apos;, users2, 25));</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure><p>user의 나이를 .getAge() 로 얻어내야 하기 때문에 findBy 함수로는 위 상황을 대응할 수 없을을 알 수 있다. 이름에 ‘P’ 가 포함된 user를 찾고 싶다거나 아니가 32이면서 이름이 ‘JM’인 user를 찾고 싶다거나 하는 것도 불가능하다.</p><h2 id="값에서-함수로"><a href="#값에서-함수로" class="headerlink" title="값에서 함수로"></a>값에서 함수로</h2><p>앞서 만들었던 filter나 map처럼, 인자로 키와 값 대신 함수를 사용해 보려고 한다. 그렇게 하면 모든 상황에 대응 가능한 find 함수를 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function find(list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) return list[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  find(users2, function (u) &#123; return u.getAge() === 25 &#125;).getName()</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.name.indexOf(&apos;P&apos;) !== -1 &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.age === 32 &amp;&amp; u.name === &apos;JM&apos; &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users2, function (u) &#123; return u.getAge() &lt; 30 &#125;).getName()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>find의 인자로 key와 val 대신 predicate 함수 하나를 받았다. 값 대신 함수를 받았다. 덕분에 if 안쪽에서 할 수 있는 일이 정말 많아졌다. 메서드를 사용하거나 두가지 이상의 조건을 사용하는 것도 잘 동작한다.<br>find는 이제 배열에 어떤 값이 들어 있든 사용할 수 있게 되었다. <strong>함수형 자바스크립트는 이처럼 다형성이 높은 기법을 많이 사용하며 이러한 기법은 정말 실용적이다</strong></p><p>filter, map, find 함수들은 들어온 데이터가 무엇이든지 루프들 돌리거나 분기를 만들거나 push를 하거나 predicate를 실행하거나 등의 자기 할 일을 한다. find는 전달 받을 데이터와 데이터의 특성에 맞는 보조 함수(predicate)도 함께 전달받는다. 들어온 데이터의 특성은 보조 함수가 대응해 주기 때문에 find 함수는 데이터의 특성에서 완전히 분리될 수 있다. 이러한 방식은 다형성을 높이며 동시에 안정성도 높인다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 다형성</span><br><span class="line"> */</span><br><span class="line">console.log(</span><br><span class="line">  map(</span><br><span class="line">    filter(users, function (u) &#123; return u.age &gt;= 30 &#125;),</span><br><span class="line">    function (u) &#123; return u.name &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  map(</span><br><span class="line">    filter(users2, function (u) &#123; return u.getAge() &gt; 30 &#125;), // 메서드 실행으로 변경</span><br><span class="line">    function (u) &#123; return u.getName() &#125; // 메서드 실행으로 변경</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="함수를-만드는-함수와-find-filter-조합하기"><a href="#함수를-만드는-함수와-find-filter-조합하기" class="headerlink" title="함수를 만드는 함수와 find, filter 조합하기"></a>함수를 만드는 함수와 find, filter 조합하기</h2><p>User등의 커스텀 객체가 아닌 자바스크립트 기본 객체로 만들어진 users를 사용한 예제로 다시 돌아가 보자. 함수로 함수를 만들어 find 함수와 함께 사용하면 코드를 더욱 간결하게 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function bmatch1(key, val) &#123;</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return obj[key] === val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(find(users, bmatch1(&apos;id&apos;, 1)));</span><br><span class="line">console.log(find(users, bmatch1(&apos;name&apos;, &apos;BJ&apos;)));</span><br><span class="line">console.log(find(users, bmatch1(&apos;age&apos;, 28)));</span><br></pre></td></tr></table></figure><p>bmatch1의 실행 결과는 함수다. key와 val을 미리 받아서 나중에 들어올 obj와 비교하는 익명 함수 클로저로 만들어 리턴한다. bmatch1을 통해 id, name, age를 비교하는 predicate 3개를 만들어 find에 넘겼다.<br>bmatch1은 함수를 리턴하기 때문에 filter나 map과도 조합이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(filter(users, bmatch1(&apos;age&apos;, 32)));</span><br><span class="line">console.log(map(users, bmatch1(&apos;age&apos;, 32)));</span><br></pre></td></tr></table></figure><p>bmatch1은 하나의 key에 대한 value만 비교할 수 있다. 여러 개의 key에 해당하는 value들을 비교하는 함수를 만들어보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function object(key, val) &#123;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  obj[key] = val;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function match(obj, obj2) &#123;</span><br><span class="line">  for (var key in obj2) &#123;</span><br><span class="line">    if (obj[key] !== obj2[key]) return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bmatch(obj2, val) &#123;</span><br><span class="line">  if (arguments.length == 2) obj2 = object(obj2, val);</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return match(obj, obj2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  match(find(users, bmatch(&apos;id&apos;, 3)), find(users, bmatch(&apos;name&apos;, &apos;BJ&apos;)))</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.age === 32 &amp;&amp; u.name === &apos;JM&apos; &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, bmatch(&#123; name: &apos;JM&apos;, age: 32 &#125;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이제는 (key, val)와 ({key: val}) 두 가지 방식으로 사용할 수 있다. ({key: val}) 방식을 사용하면 두 가지 이상의 값이 모두 동일한지도 확인할 수 있다. bmatch1을 bmatch로 발전시키면서 유용한 함수인 match와 object도 만들어졌다. 이처럼 작은 기능을 하는 함수로 쪼개거나 재조합하는 식으로 코드를 발전시키는것도 좋은 방법이다.</p><p>find를 조금만 고치면 값 비교만 하는 <code>Array.prototype.indexOf</code>보다 활용도가 훨씬 높은 findIndex를 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findIndex</span><br><span class="line"> */</span><br><span class="line">function findIndex(list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) return i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findIndex(users, bmatch(&#123; name: &apos;JM&apos;, age: 32 &#125;))) // 5</span><br><span class="line">console.log(findIndex(users, bmatch(&#123; age: 36 &#125;))) // -1</span><br><span class="line">console.log(findIndex(users, bmatch(&apos;id&apos;, 2))); // 1</span><br></pre></td></tr></table></figure><h2 id="고차함수"><a href="#고차함수" class="headerlink" title="고차함수"></a>고차함수</h2><p>앞서 구현했던 filter, map, find, findIndex, bvalue, bmatch 같은 함수들은 모두 고차 함수다.<br>고차 함수란, 함수를 인자로 받거나 함수를 리턴하는 함수를 말한다. 당연히 둘 다 하는 경우도 고차 함수다. 보통 고차 함수는 함수를 인자로 받아 필요한 때에 실행하거나 클로저를 만들어 리턴한다.</p><p><code>Underscore.js</code>는 유명한 함수형 자바스크립트 라이브러리다. <code>Underscore.js</code> 의 _.map, _.filter, _.find, _.findIndex는 iteratee와 predicate가 사용할 인자를 몇 가지 더 제공한다. 재료가 많으면 더 다양한 로직을 만들 수 있다. 앞서 구현했던 고차 함수들을 <code>Underscore.js</code>에 가깝게 고쳐 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_.map = function (list, iteratee) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    new_list.push(iteratee(list[i], i, list))</span><br><span class="line">  &#125;</span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.filter = function (list, predicate) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) new_list.push(list[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.find = function (list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) return list[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.findIndex = function (list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) return i</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원래는 iteratee(list[i])처럼 한 개의 인자를 넘겼지만, 이제는 iteratee(list[i], i, list) 처럼 두 개의 인자를 추가했다. 이제 iteratee와 predicate 함수가 받는 인자가 많아져 좀 더 다양한 일을 할 수 있게 되었다. predicate도 iteratee와 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  _.filter([1, 2, 3, 4], function (val, idx) &#123;</span><br><span class="line">    return idx &gt; 1;</span><br><span class="line">  &#125;)</span><br><span class="line">) // [3, 4]</span><br><span class="line">console.log(</span><br><span class="line">  _.filter([1, 2, 3, 4], function (val, idx) &#123;</span><br><span class="line">    return idx % 2 === 0;</span><br><span class="line">  &#125;)</span><br><span class="line">) // [1,3]</span><br></pre></td></tr></table></figure><h2 id="function-identity"><a href="#function-identity" class="headerlink" title="function identity"></a>function identity</h2><p>정말 쓸모 없어 보이는 이상한 함수 하나를 소개한다. 이것은 <code>Underscore.js</code>에 있는 함수이기도 하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.identity = function (v) &#123; return v &#125;;</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(_.identity(10)) // 10</span><br></pre></td></tr></table></figure><p>받은 인자를 그냥 그대로 뱉는 함수다. _.identity 같은 아무런 기능이 없는 함수는 대체 언제 사용해야 하는 걸까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(_.filter([true, 0, 10, &apos;a&apos;, false, null], _.identity));</span><br><span class="line">// [true, 10, &apos;a&apos;]</span><br></pre></td></tr></table></figure><p>_.filter를 _.identity와 함께 사용했더니 <code>Truthy Values</code>만 남았다. 이렇게 놓고 보니 _.identity가 생각보다 실용적으로 보인다. _.identity를 다른 고차 함수와 조합하는 식으로 아래와 같은 유용한 함수들을 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return !!_.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return _.filter(list, _.identity).length === list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_.some([0, null, 2])); // true</span><br><span class="line">console.log(_.some([0, null, false])); // false</span><br><span class="line"></span><br><span class="line">console.log(_.every([0, null, true])); // false</span><br><span class="line">console.log(_.every([&#123;&#125;, true, 2])); // true</span><br></pre></td></tr></table></figure><p>_.some은 배열에 들어 있는 값 중 하나라도 긍정적인 값이 있으면 true, 하나도 없다면 false를 리턴한다.<br>_.every는 모두 긍정적인 값이어야 true를 리턴한다. _.some, _.every는 if나 predicate 등과 함께 사용할 때 매우 유용하다.<br>_.every는 filter를 사용했기 때문에 항상 루프를 끝까지 돌게 된다. 정말 쓸모 없어 보이지만 함수 두 개를 더 만들면 로직을 개선할 수 있다.</p><h2 id="연산자-대신-함수로"><a href="#연산자-대신-함수로" class="headerlink" title="연산자 대신 함수로"></a>연산자 대신 함수로</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function not(v) &#123; return !v; &#125;</span><br><span class="line">function beq(a) &#123;</span><br><span class="line">  return function (b) &#123;</span><br><span class="line">    return a === b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!를 써도 되는데 <code>not</code>이 왜 필요할까? ===로 비교하면 되는데 <code>beq</code>는 왜 필요할까? 굳이 not과 beq를 함수로 만들 필요가 있을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return !!_.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return beq(-1)(_.findIndex(list, not));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_.some([0, null, 2, 0])); // true</span><br><span class="line">console.log(_.some([0, null, false])); // false</span><br><span class="line"></span><br><span class="line">console.log(_.every([0, null, true])); // false</span><br><span class="line">console.log(_.every([&#123;&#125;, true, 2])); // true</span><br></pre></td></tr></table></figure><p>not은 연산자 !가 아닌 함수이기 때문에 _.findIndex와 함께 사용할 수 있다. list의 값 중 하나라도 부정적인 값을 만나면 predicate가 not이므로 true를 리턴하여 해당번째 i 값을 리턴하게 된다. 중간에 부정적인 값을 한 번이라고 만나면 루프가 중단된다. 만일 부정적인 값이 하나도 없다면 -1을 리턴한다.<br>_.every는 쓸모 없어 보이는 정말 작은 함수 not 덕분에 로직이 개선되었다. 좀 더 함수를 쪼개보다. 함수가 가능하면 한 가지 일만 하게끔 말이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function positive(list) &#123;</span><br><span class="line">  return _.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function negetiveIndex(list) &#123;</span><br><span class="line">  return _.findIndex(list, not);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return not(not(positive(list)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return beq(-1)(negetiveIndex(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="함수-합성"><a href="#함수-합성" class="headerlink" title="함수 합성"></a>함수 합성</h2><p>함수를 쪼갤수록 함수 합성은 쉬워진다. 다음은 다양한 함수 합성 기법 중 하나인 <code>Underscore.js</code>의 _.compose다. _.compose는 오른쪽의 함수의 결과를 바로 왼쪽의 함수에게 전달한다. 그리고 해당 함수의 결과를 다시 자신의 왼쪽의 함수에게 전달하는 고차 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_.compose = function () &#123;</span><br><span class="line">  var args = arguments;</span><br><span class="line">  var start = args.length - 1;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var i = start;</span><br><span class="line">    var result = args[start].apply(this, arguments);</span><br><span class="line">    while (i--) result = args[i].call(this, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var greet = function (name) &#123; return &apos;hi: &apos; + name; &#125;;</span><br><span class="line">var exclaim = function (statement) &#123; return statement.toUpperCase() + &apos;!&apos;; &#125;;</span><br><span class="line">var welcome = _.compose(greet, exclaim);</span><br><span class="line">console.log(welcome(&apos;moe&apos;));</span><br></pre></td></tr></table></figure><p>welcome을 실행하면 먼저 exclaim을 실행하면서 “moe”를 인자로 넘겨준다. exclaim 의 결과는 대문자로 변환된 “MOE!”이고 그 결과는 다시 greet의 인자로 넘어가 최종 결과로 “hi: MOE!”를 리턴한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.some = _.compose(not, not, positive);</span><br><span class="line">_.every = _.compose(beq(-1), negetiveIndex);</span><br></pre></td></tr></table></figure><p>_.compose로 _.some과 _.every를 더 간결하게 표현했다. 맨 오른쪽의 함수가 인자를 받아 결과를 만들고 결과는 다시 그 왼쪽의 함수에게 인자로 전달된다. 오른쪽에서 부터 왼쪽으로 연속적으로 실행되어 최종 결과를 만든다.</p><p>값 대신 함수로, for와 if 대신 고차 함수와 보조 함수로, 연산자 대신 함수로, 함수 합성 등 앞서 설명한 함수적 기법들을 사용하면 코드도 간결해지고 함수명을 통해 로직을 더 명확히 전달할 수 있어 읽기 좋은 코드가 된다.</p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>저번 포스트에서는 함수를 조합해서 사용한다는 것에 정확한 이해가 부족했는데, 이번 포스트를 통해 어느정도의 이해는 된것같다. 이번 포스트에서 제일 크게 느낀점은 “기능 단위로 최대한 작게 함수를 쪼개 놓고 이 함수들을 조합하여 하나의 고차 함수를 사용한다.” 이다.<br>if나 for 같은 로직도 함수 단위로 쪼개면서 재사용성을 고려해서 만들어 놓는 다면 코드의 품질 뿐만 아니라 가독성도 좋아지고 유지 보수도 좋아질 것이라는 생각이 들었다. 운영되고 있는 프로젝트에서 에러가 발생해서 고쳐야 하는 경우나 리팩토링을 해야하는 경우 복잡한 로직이라면 이해하기 쉽지 않은 경우가 있다.<br>내가 짜놓은 코드라도 그때 당시의 고려했던 점이나 여러 경우를 전부 기억하지 못해 수정에 어려움이 있을때가 많다. 이때 만약 함수 단위로 구현해 놓았으면 에러가 발생한 부분이나 고쳐야 할 부분을 함수만 파악하고 고치면 되기때문에 편할 것 같다는 생각이 들었다.</p><p>합성함수 (_.compose)의 arguments 부분이 아직 정확하게 이해 되지는 않지만 뒤에서 arguments에 대해 다시 다뤄준다고 했으니 합성함수의 동작방식만 이해하고 넘어가야겠다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이전 포스트에서 함수형 프로그래밍의 간략한 소개와 몇가지 예제 코드를 구현했었다. 오늘은 이전 포스트에 이어 다음 내용을 진행하려고 한다.&lt;/p&gt;
&lt;h2 id=&quot;회원-목록-중-한명-찾기&quot;&gt;&lt;a href=&quot;#회원-목록-중-한명-찾기&quot; class=&quot;headerlink&quot; title=&quot;회원 목록 중 한명 찾기&quot;&gt;&lt;/a&gt;회원 목록 중 한명 찾기&lt;/h2&gt;&lt;p&gt;회원 목록 중 id 값으로 해당 id 값을 가진 회원 한 명을 찾고자 한다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  filter(users, function (user) &amp;#123; return user.id === 3 &amp;#125;)[0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#123;id: 3, name: &amp;quot;BJ&amp;quot;, age: 32&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter를 통해 걸러낸 후 [0]으로 user를 얻어냈고 원하는 결과를 얻어냈기는 했다. 위 처럼 filter를 사용하여 찾을 수 있지만 filter 함수는 무조건 list.length 만큼 predicate가 실행되기 때문에 효율적이지 못하고, 동일 조건에 값이 두 개 이상이라면 두 개 이상의 값을 찾는다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="함수형 자바스크립트의 실용성 2" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%8B%A4%EC%9A%A9%EC%84%B1-2/"/>
    
      <category term="filter" scheme="https://kkangil.github.io/tags/filter/"/>
    
      <category term="map" scheme="https://kkangil.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 - 시작</title>
    <link href="https://kkangil.github.io/2019/09/28/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%91/"/>
    <id>https://kkangil.github.io/2019/09/28/함수형-프로그래밍-시작/</id>
    <published>2019-09-28T06:49:18.000Z</published>
    <updated>2019-09-28T09:07:34.419Z</updated>
    
    <content type="html"><![CDATA[<p>최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.<br>함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에<br>터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.</p><p>기본적으로 <code>함수형 자바스크립트 프로그래밍</code> 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.</p><p>도서 링크: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p><h1 id="함수형-자바스크립트-소개"><a href="#함수형-자바스크립트-소개" class="headerlink" title="함수형 자바스크립트 소개"></a>함수형 자바스크립트 소개</h1><ul><li>함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.</li><li>함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유<ol><li>오류를 줄이기 위함.</li><li>조합성 혹은 모듈화 수준을 높이기 위함.</li></ol></li></ul><h2 id="함수형-프로그래밍을-검색하면-나오는-예제"><a href="#함수형-프로그래밍을-검색하면-나오는-예제" class="headerlink" title="함수형 프로그래밍을 검색하면 나오는 예제"></a>함수형 프로그래밍을 검색하면 나오는 예제</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addMaker(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addMaker(10)(5);</span><br></pre></td></tr></table></figure><p>함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.<br>함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.</p><p><code>addMaker</code>는 함수를 값으로 다루는 함수다. <code>addMaker</code>에서는 단 하나의 값이 선언되며 그 값은 함수다.<br><code>addMaker(10)</code>의 결과는 function(b) { return 10 + b }; 와 같다.<br>이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add5 = addMaker(5);</span><br><span class="line">add5(3) // 8</span><br><span class="line">add5(4) // 9</span><br></pre></td></tr></table></figure><p>위와 같이 변수에 값을 할당해서 사용할 수 도 있다.</p><h2 id="값으로써의-함수와-클로저"><a href="#값으로써의-함수와-클로저" class="headerlink" title="값으로써의 함수와 클로저"></a>값으로써의 함수와 클로저</h2><p>위의 예제들을 보면 함수는 값을 리턴할 수 있고 함수는 값이 될 수 있다. <code>addMaker</code>는 내부에서 함수를 정의하고 리턴했다. <code>addMaker</code>가 리턴한 익명 함수는 클로저가 되었다.<br>리턴된 익명 함수 내부에서 a가 정의된 적은 없지만 a를 참조하고 있고 a는 부모 스코프에 있다.</p><p><code>addMaker</code>가 실행된 후, 어디서도 <code>addMaker</code>의 인자인 a 값을 변경시키지 않고 있기 때문에 항상 동일한 값을 갖는다. 때문에 위 상황에서 a는 불변하며 상수로 쓰이게 된다. 이 상황에서의 a는 불변하지만, 모든 경우의 클로저가 그렇지는 않다. 클로저가 기억하는 변수의 값은 변할 수 있다.</p><hr><h2 id="함수형-자바스크립트의-실용성"><a href="#함수형-자바스크립트의-실용성" class="headerlink" title="함수형 자바스크립트의 실용성"></a>함수형 자바스크립트의 실용성</h2><p>절차지향적으로 작성된 코드를 함수형으로 변경하면서 함수형 자바스크립트의 실용성을 알아보고자 한다.</p><h3 id="회원-목록-중-여러명-찾기"><a href="#회원-목록-중-여러명-찾기" class="headerlink" title="회원 목록 중 여러명 찾기"></a>회원 목록 중 여러명 찾기</h3><p>회원 목록 중 특정 나이의 회원들만 뽑거나 특정 조건의 회원 한 명을 찾는 코드들을 함수형 자바스크립트로 리팩토링 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var users = [</span><br><span class="line">  &#123; id: 1, name: &apos;ID&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 2, name: &apos;HA&apos;, age: 25 &#125;,</span><br><span class="line">  &#123; id: 3, name: &apos;BJ&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 4, name: &apos;PJ&apos;, age: 28 &#125;,</span><br><span class="line">  &#123; id: 5, name: &apos;JE&apos;, age: 27 &#125;,</span><br><span class="line">  &#123; id: 6, name: &apos;JM&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 7, name: &apos;HI&apos;, age: 24 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(temp_users[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &gt;= 30) temp_users.push(users[i])</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(temp_users[i].name);</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>1에서는 users 중에 age가 30 미만인 users[i]만 모아서 몇 명인지를 출력하고 2에서는 그들의 나이만 다시 모아 출력한다. 3에서는 나이가 30 이상인 temp_users가 몇 명인지를 출력하고 4에서는 그들의 이름만 다시 모아 출력한다.</p><p>위 코드를 함수형으로 리팩토링 하기 위해 먼저 중복되는 부분을 찾아본다. 1과 3의 for문에서 users를 돌며 특정 조건의 users[i]를 새로운 배열에 담고 있는데, if 문의 조건절 부분을 제외하고는 모두 동일한 코드이다. 30 부분은 변수로 바꿀 수 있겠지만 .age, &lt;, &gt;= 등은 쉽지 않아 보인다. 이때 함수를 활용하면 이런 부분까지도 쉽게 추상화 할 수 있다.</p><h3 id="for에서-filter로-if에서-predicate로"><a href="#for에서-filter로-if에서-predicate로" class="headerlink" title="for에서 filter로, if에서 predicate로"></a>for에서 filter로, if에서 predicate로</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 기존코드</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// refactoring</span><br><span class="line">function filter(list, predicate) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) new_list.push(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter 함수는 인자로 list와 predicate 함수를 받는다. 루프를 도며 list의 i번째의 값을 predicate에 넘겨준다. predicate 함수는 list.length 만큼 실행되며, predicate 함수의 결과가 참일 때만 new_list.push를 실행한다.<br>filter 함수는 predicate 함수 내부에서 어떤 일을 하는지 모른다. id를 조회할지 age를 조회할지 어떤 조건을 만들지를 filter는 전혀 모른다. 오직 predicate 결과에만 의존한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// filter 사용</span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30)</span><br><span class="line"></span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = users_under_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(users_under_30[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = users_over_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(users_over_30[i].name)</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>filter 함수를 실행하면서 predicate 자리에 익명 함수를 정의해서 넘겼다. predicate 익명 함수의 리턴값(<code>boolean</code>)에 따라서 push를 해줄지 안해줄지가 결정된다. 기존 코드와 비교해 코드가 짧아졌고 재사용성 높은 함수 filter를 얻게됐다.</p><h3 id="함수형-프로그래밍-관점으로-filter-보기"><a href="#함수형-프로그래밍-관점으로-filter-보기" class="headerlink" title="함수형 프로그래밍 관점으로 filter 보기"></a>함수형 프로그래밍 관점으로 filter 보기</h3><p>함수형 프로그래밍 관점에서 filter와 predicate 사이에는 많은 이야기가 담겨있다. filter 함수에는 for도 있고 if도 있지만, filter 함수는 항상 동일하게 동작하는 함수다. <strong>동일한 인자가 들어오면 항상 동일하게 동작한다.</strong> filter 함수의 로직은 외부나 내부의 어떤 상태 변화에도 의존하지 않는다. <code>new_list</code>의 값을 바꾸고 있지만 그 변화에 의존하는 다른 로직이 없다. <code>new_list</code>가 완성될 떄까지는 외부에서 어떠한 접근도 할 수 없기 때문에 filter의 결과도 달라질 수 없다. <code>new_list</code>가 완성되고 나면 <code>new_list</code>를 리턴해버리고 filter는 완전히 종료된다.</p><p>filter의 if는 predicate의 결과에만 의존한다. filter를 사용하는 부분을 다시 보면 filter와 users, filter가 사용할 predicate 함수만 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(users, function(user) &#123; return user.age &lt; 30 &#125;)</span><br></pre></td></tr></table></figure></p><p>절차지향 프로그래밍과 달리 함수형 프로그래밍 에서는 <strong>항상 동일하게 동작하는 함수</strong> 를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다. 내부에서 관리하고 있는 상태를 따로 두지않고 넘겨진 인자에만 의존한다. 동일한 인자가 들어오면 항상 동일한 값을 리턴 하도록 한다.</p><h3 id="map-함수"><a href="#map-함수" class="headerlink" title="map 함수"></a>map 함수</h3><p>리팩토링의 핵심은 중복을 제거하고 의도를 드러내는 것이다. 기존 코드를 보면 회원 목록을 통해 나이와 이름들을 추출하는데 두 코드에도 중복이 있다. 둘 다 for문에서 사용하는 회원 목록을 활용해 같은 크기의 새로운 배열을 만들고 원재료와 1:1로 매핑되는 다른 값을 만들어 담고 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// map 사용</span><br><span class="line">function map(list, iteratee) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    new_list.push(iteratee(list[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30.length)</span><br><span class="line"></span><br><span class="line">var ages = map(users_under_30, function (user) &#123; return user.age &#125;);</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30.length)</span><br><span class="line"></span><br><span class="line">var names = map(users_over_30, function (user) &#123; return user.name &#125;);</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>코드가 매우 단순해 진것을 확인할 수 있다. for도 없고 if도 없다. new_list에 무엇을 push 할지에 대해 iteratee 함수에게 위임했다.</p><h3 id="실행-결과로-바로-실행하기"><a href="#실행-결과로-바로-실행하기" class="headerlink" title="실행 결과로 바로 실행하기"></a>실행 결과로 바로 실행하기</h3><p>함수의 리턴값을 바로 다른 함수의 인자로 사용하면 변수 할당을 줄일 수 있다.<br>filter 함수의 결과가 배열이므로 map의 첫 번째 인자로 바로 사용 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 함수 중첩</span><br><span class="line">var ages = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.age &#125;</span><br><span class="line">)</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var names = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.name &#125;</span><br><span class="line">)</span><br><span class="line">console.log(names);</span><br><span class="line"></span><br><span class="line">// 함수 중첩 2</span><br><span class="line">function log_length(value) &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.age &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.name &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>filter 함수는 predicate를 통해 값을 필터링하여 map에게 전달하고 map은 받은 iteratee를 통해 새로운 값들을 만들어 log_length에게 전달한다. log_length는 length를 출력한 후 받은 인자를 그대로 console.log에게 전달하고 console.log는 받은 값을 출력한다.</p><h3 id="함수를-값으로-다룬-예제의-실용성"><a href="#함수를-값으로-다룬-예제의-실용성" class="headerlink" title="함수를 값으로 다룬 예제의 실용성"></a>함수를 값으로 다룬 예제의 실용성</h3><p>위에 만들었던 <code>addMaker</code> 와 비슷한 패턴의 함수가 실제로도 많이 사용된다.<br><code>addMaker</code>와 비슷한 패턴의 함수인 <code>bvalue</code> 함수를 만들어 보려고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function bvalue(key) &#123;</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bvalue(&apos;a&apos;)(&#123; a: &apos;hi&apos;, b: &apos;hello&apos; &#125;)); // hi</span><br></pre></td></tr></table></figure><p>bvalue를 실행할 때 넘겨준 인자 key를 나중에 obj를 받을 익명 함수가 기억한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * bvalue로 map의 iteratee 만들기</span><br><span class="line"> */</span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      bvalue(&apos;age&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      bvalue(&apos;name&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>map이 사용할 iteratee 함수를 bvalue가 리턴한 함수로 대체했다. 익명 함수 선언이 사라져 코드가 더욱 짧아졌다.</p><p>화살표 함수로 사용하기<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &lt; 30),</span><br><span class="line">      user =&gt; user.age</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &gt;= 30),</span><br><span class="line">      user =&gt; user.name</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var under_30 = user =&gt; user.age &lt; 30;</span><br><span class="line">var over_30 = user =&gt; user.age &gt;= 30;</span><br><span class="line">var ages = list =&gt; map(list, user =&gt; user.age);</span><br><span class="line">var names = list =&gt; map(list, user =&gt; user.name);</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, function (user) &#123; return user[key] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ages = bvalues(&apos;age&apos;);</span><br><span class="line">var names = bvalues(&apos;name&apos;);</span><br><span class="line">var under_30 = function (user) &#123; return user.age &lt; 30 &#125;;</span><br><span class="line">var over_30 = function (user) &#123; return user.age &gt;= 30 &#125;;</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  var value = bvalue(key);</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 화살표 함수 사용</span><br><span class="line">var bvalues = key =&gt; list =&gt; &#123;</span><br><span class="line">  var value = bvalue(key)</span><br><span class="line">  return map(list, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>Conclusion<br>어려운 점이 공부를 하면 할수록 많이 생기겠지만, 새로운 관점에서의 프로그래밍인 것 같아 흥미롭게 느껴진다.<br>본인은 아직 주니어라 절차지향적 사고 방식이 강한데 함수형 프로그래밍 공부하면서 새로운 사고 방식에 대해서도 생각해 봐야할 것 같다. 이번 챕터의 첫 코드(절차지향적 코드)는 쉽다고 느껴졌지만, 함수형으로 리팩토링 해 나가는 과정에서는 이게 정확히 어떤 방식으로 동작하는가, 인자값은 어떻게 넘겨 주는가에 대한 고민이 생기는것을 느끼면서 함수형 프로그래밍에 더 알고 싶어졌다.</p><p>처음에는 함수형 프로그래밍 방식이 “그래서 왜 좋은건데?”에 대한 의문이 있었는데 마지막 코드를 보고 재새용성이 뛰어나다는것을 느꼈다. 프로젝트를 시작할때 잘 구현해 놓은 함수는 계속 재사용하면서 코딩의 속도와 편리함을 제공해 줄 것 같다고 생각했다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.&lt;br&gt;함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에&lt;br&gt;터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.&lt;/p&gt;
&lt;p&gt;기본적으로 &lt;code&gt;함수형 자바스크립트 프로그래밍&lt;/code&gt; 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.&lt;/p&gt;
&lt;p&gt;도서 링크: &lt;a href=&quot;http://www.yes24.com/Product/Goods/56885507&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;함수형 자바스크립트 프로그래밍&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;함수형-자바스크립트-소개&quot;&gt;&lt;a href=&quot;#함수형-자바스크립트-소개&quot; class=&quot;headerlink&quot; title=&quot;함수형 자바스크립트 소개&quot;&gt;&lt;/a&gt;함수형 자바스크립트 소개&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.&lt;/li&gt;
&lt;li&gt;함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유&lt;ol&gt;
&lt;li&gt;오류를 줄이기 위함.&lt;/li&gt;
&lt;li&gt;조합성 혹은 모듈화 수준을 높이기 위함.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;함수형-프로그래밍을-검색하면-나오는-예제&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍을-검색하면-나오는-예제&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍을 검색하면 나오는 예제&quot;&gt;&lt;/a&gt;함수형 프로그래밍을 검색하면 나오는 예제&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function addMaker(a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return function(b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addMaker(10)(5);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.&lt;br&gt;함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addMaker&lt;/code&gt;는 함수를 값으로 다루는 함수다. &lt;code&gt;addMaker&lt;/code&gt;에서는 단 하나의 값이 선언되며 그 값은 함수다.&lt;br&gt;&lt;code&gt;addMaker(10)&lt;/code&gt;의 결과는 function(b) { return 10 + b }; 와 같다.&lt;br&gt;이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Sequelize model 정의</title>
    <link href="https://kkangil.github.io/2019/04/28/Sequelize-model-%EC%A0%95%EC%9D%98/"/>
    <id>https://kkangil.github.io/2019/04/28/Sequelize-model-정의/</id>
    <published>2019-04-28T05:45:40.000Z</published>
    <updated>2019-04-28T05:47:51.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sequelize-model-정의"><a href="#sequelize-model-정의" class="headerlink" title="sequelize model 정의"></a>sequelize model 정의</h2><ul><li>sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 <code>define</code> 메소드를 이용해 정의하고자 한다.</li><li>model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128)</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><code>define</code> 함수의 첫번째 파라미터는 테이블의 이름에 해당된다. 또한 express 프로젝트에서도 해당 이름으로 데이터베이스에 접근할 수 있다.</li><li>두번째 파라미터는 컬럼을 정의하는 것이다. 위의 예시는 가장 기본적인 컬럼을 생성한 것이고 나머지 옵션들은 밑에서 확인해 보도록 한다.</li></ul><h2 id="column-option"><a href="#column-option" class="headerlink" title="column option"></a>column option</h2><ul><li>sequelize model 생성시 sequelize 는 고유 키값을 정의해 주지 않아도, 다른 설정이 없다면 id 로 생성해주며 row 생성시 자동으로 1씩 증가한다.</li><li>id 이외에 createdAt(생성일), updatedAt(수정일) 도 같이 생성해준다.</li><li>defaultValue: row가 생성될때 기본값을 설정해줄 수 있다. (etc. Sequelize.NOW)</li><li>allowNull: false로 설정해주면 빈값으로 생성시 에러가 난다.(default true)</li><li>unique: 테이블내의 고유한 값(boolean)</li><li>primaryKey: 고유 키값 설정 여부</li><li>autoIncrement: 자동으로 값을 증가시켜준다. (Integer 에서만 사용 가능)</li><li>field: 객체 키값과 다르게 custom으로 컬럼명을 사용할 수 있게해준다.</li><li>comment: 해당 컬럼에 대한 설명을 달 수 있다. 컬럼 생성에 영향을 미치지는 않는다. 주석같은 개념</li></ul><h2 id="Getters-amp-setters"><a href="#Getters-amp-setters" class="headerlink" title="Getters &amp; setters"></a>Getters &amp; setters</h2><ul><li><p>컬럼 option에 getter와 setter를 추가해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false,</span><br><span class="line">      get() &#123;</span><br><span class="line">        const job = this.getDataValue(&apos;job&apos;)</span><br><span class="line">        return `$&#123;this.getDataValue(&apos;username&apos;)&#125; ($&#123;this.getDataValue(&apos;job&apos;)&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false,</span><br><span class="line">      set(job) &#123;</span><br><span class="line">        this.setDataValue(&apos;job&apos;, job.toUpperCase())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const userSample = async () =&gt; &#123;</span><br><span class="line">  const user = await User.create(&#123; username: &apos;kkangil&apos;, job: &apos;developer&apos; &#125;)</span><br><span class="line">  console.log(user.get(&apos;username&apos;)) // kkangil (DEVELOPER)</span><br><span class="line">  console.log(user.get(&apos;job&apos;)) // DEVELOPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getDataValue</code> 를 사용하여 자신의 컬럼 뿐만 아니라 테이블의 컬럼 데이터도 가져올 수 있다.</p></li><li><code>setDataValue</code> 를 사용하여 생성이나 수정 시 데이터 값을 수정, 변경할 수 있다. </li><li>컬럼 객체 내부에 설정해 주지 않고, <code>define</code> 함수의 세번째 파라미터로도 사용이 가능하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    getterMethods: &#123;</span><br><span class="line">      getUser() &#123;</span><br><span class="line">        return `$&#123;this.username&#125; ($&#123;this.job&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="validate-column"><a href="#validate-column" class="headerlink" title="validate column"></a>validate column</h2><ul><li><p>데이터 타입 이외에도 <code>validate</code> 를 사용해서 유효성 확인 후 에러를 반환해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;Foo&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      validate: &#123;</span><br><span class="line">        is: /^[a-z]+$/i, // 정규식 사용해서 유효성 확인</span><br><span class="line">        not: /^[a-z]+$/i,</span><br><span class="line">        isEmail: true, // 이메일 유효성 확인</span><br><span class="line">        isInt: true,</span><br><span class="line">        notNull: true,</span><br><span class="line">        isNull: true,</span><br><span class="line">        notEmpty: true, // string 빈값 확인</span><br><span class="line">        equals: &apos;specific value&apos;, // 특정 값으로만 생성 가능</span><br><span class="line">        contains: &apos;foo&apos;, // 해당 값을 포함하고 있는지 확인</span><br><span class="line">        notContains: &apos;bar&apos;,</span><br><span class="line">        notIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        isIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        len: [2,10], // 2자리 ~ 10자리</span><br><span class="line">        max: 23,</span><br><span class="line">        min: 10,</span><br><span class="line">        isCreditCard: true // 신용카드 유효성 확인</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>제공되는 <code>validate</code> 가 아닌 직접 만들어서 사용하는 기능도 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    isEven(value) &#123;</span><br><span class="line">      if (parseInt(value) % 2 !== 0) &#123;</span><br><span class="line">        throw new Error(&apos;Only even values are allowed!&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throw new Error의 메시지가 에러로 리턴된다.</p></li><li><p>직접 만들어서 사용하지 않아도 메시지를 설정해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    notNull: &#123;</span><br><span class="line">      msg: &quot;Must&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    isIn: &#123;</span><br><span class="line">      args: [[&apos;en&apos;, &apos;zh&apos;]],</span><br><span class="line">      msg: &quot;Must be English or Chinese&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>allowNull</code> 을 사용한다면 <code>notNull</code> 의 <code>msg</code>를 설정해주면 에러메시지로 사용가능하다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    validate: &#123;</span><br><span class="line">      checkUsernameAndJob() &#123;</span><br><span class="line">        if (!(this.username &amp;&amp; this.job)) &#123;</span><br><span class="line">          throw new Error(&apos;이름과 직업을 입력해주세요.&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>define</code> 함수의 세번째 파라미터 객체에 validate 를 설정해주면 하나의 컬럼이 아닌 테이블의 모든 컬럼의 유효성은 같이 확인 할 수 있다.</li></ul><h2 id="model-configuration"><a href="#model-configuration" class="headerlink" title="model configuration"></a>model configuration</h2><ul><li><code>define</code> 함수의 세번째 파라미터 객체의 설정값<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  ..., &#123;</span><br><span class="line">    modelName: &apos;bar&apos;, // 모델 이름 설정</span><br><span class="line">    timestamps: false, // createdAt, updatedAt 생성하지 않음</span><br><span class="line">    paranoid: true, // 데이터를 삭제하지 않고 현재 시간으로 deletedAt 데이터가 추가된다.</span><br><span class="line">    underscored: true, // 자동으로 컬럼명을 snake 네임으로 변경한다.</span><br><span class="line">    tableName: &apos;my_bar&apos;, // 테이블 이름 설정</span><br><span class="line">    createdAt: false, // createdAt 사용하지 않음</span><br><span class="line">    updatedAt: &apos;updateTimestamp&apos;, // updatedAt 컬럼명 정의</span><br><span class="line">    deletedAt: &apos;destroyTime&apos;, // deletedAt 컬럼명 정의 (paranoid가 true로 설정되어 있어야함.)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>참고 <a href="http://docs.sequelizejs.com/manual/models-definition.html" target="_blank" rel="noopener">sequelize docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sequelize-model-정의&quot;&gt;&lt;a href=&quot;#sequelize-model-정의&quot; class=&quot;headerlink&quot; title=&quot;sequelize model 정의&quot;&gt;&lt;/a&gt;sequelize model 정의&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 &lt;code&gt;define&lt;/code&gt; 메소드를 이용해 정의하고자 한다.&lt;/li&gt;
&lt;li&gt;model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;return sequelize.define(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;User&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    username: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING(128)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    job: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Sequelize" scheme="https://kkangil.github.io/categories/Sequelize/"/>
    
    
      <category term="Sequelize" scheme="https://kkangil.github.io/tags/Sequelize/"/>
    
      <category term="MySQL" scheme="https://kkangil.github.io/tags/MySQL/"/>
    
      <category term="model 정의" scheme="https://kkangil.github.io/tags/model-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 3. 사용방법2</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-3-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%952/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-3-사용방법2/</id>
    <published>2019-04-19T03:54:04.000Z</published>
    <updated>2019-04-19T03:56:23.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const reducer = (state, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;INCREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count + 1 &#125;;</span><br><span class="line">    case &quot;DECREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count - 1 &#125;;</span><br><span class="line">    case &quot;HANDLE_CHANGE&quot;:</span><br><span class="line">      return &#123; ...state, [action.target.name]: action.target.value &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const CountReducer = () =&gt; &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, &#123;</span><br><span class="line">    count: 0,</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    nickname: &quot;&quot;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const handleChange = e =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &quot;HANDLE_CHANGE&quot;, target: e.target &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;INCREMENT&quot; &#125;)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;DECREMENT&quot; &#125;)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.name&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.nickname&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default CountReducer;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>이전에 useState로 구현했었던 count와 input 컴포넌트를 위의 코드와 같이 reducer를 사용해서 구현할 수 있다.</li><li>useState 또는 useReducer 어떤것이 더 좋다 안좋다는 없지만, 상황에 따라 유연하게 사용할 줄 알아야 할것같다.</li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>두번째 파라미터 배열 값을 전달받아 해당 값이 변경 될때만 첫번째 파라미터 함수를 실행한다. 해당 기능을 사용하면 불필요한 함수 호출을 줄일 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Sum = () =&gt; &#123;</span><br><span class="line">  const [num, setNum] = useState(&quot;&quot;);</span><br><span class="line">  const [numList, setNumList] = useState([]);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = () =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const sumValue = useMemo(() =&gt; &#123;</span><br><span class="line">    if (!numList.length) return 0;</span><br><span class="line">    const sum = numList.reduce((a, b) =&gt; a + b);</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;, [numList]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Sum</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;num&#125; onChange=&#123;e =&gt; setNum(e.target.value)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClickAdd&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number list: &#123;numList.join(&quot;, &quot;)&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number total: &#123;sumValue&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Sum;</span><br></pre></td></tr></table></figure><ul><li>sumValue 함수에 <code>useMemo</code>를 사용하지 않으면, input 값이 변경될때도 해당 로직이 불필요하게 실행된다.</li><li>useMemo를 사용해 줌으로써 불필요하게 실행되지 않도록 하고, <code>numList</code>의 값이 변경될때마다 해당 로직이 실행된다.</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useMemo와 거의 비슷한 기능으로 렌더링 성능을 최적화 하기위해 주로 사용된다. 쓰지 않아도 문제되지는 않지만 렌더링 해야할 컴포넌트 개수나 로직이 많아진다면 고려해 봐야한다. 해당 기능은 이벤트 함수를 필요할때만 생성해 주는 기능이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = useCallback(e =&gt; &#123;</span><br><span class="line">    setNum(e.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br></pre></td></tr></table></figure><ul><li>위의 onChange 함수와 handleClickAdd 함수를 useCallback을 사용하는 함수로 변경했다.</li><li>두번째 파라미터 배열은 해당 값이 변경될때만 함수를 생성해 주는것이다. 빈 배열이라면 최초에만 생성해주고 이후 다시 생성되지 않는다.</li><li>handleChange 는 빈배열, handleClickAdd 은 두개의 값을 판단하고 있는데, 이는 handleChange는 단순히 <code>num</code> 의 값만 변경해 주고 있어 초기에만 생성해 줘도 되는것이다. handleClickAdd 함수는 이벤트가 실행 될때마다 값을 가져와서 사용해 주고 있기때문에 배열에 해당 값들을 명시해줘야한다.</li></ul><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>useRef는 함수형 컴포넌트에서도 ref 기능을 사용할 수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const inputElement = useRef(null);</span><br><span class="line">const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">      inputElement.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br><span class="line">&lt;input value=&#123;num&#125; onChange=&#123;handleChange&#125; ref=&#123;inputElement&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li>useRef는 다른 Hook과 다르게 최초 선언을 배열 형태로 선언해 주지 않는다.</li><li>ref 값이 변경되어도 리렌더링 되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h2&gt;&lt;p&gt;redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import React, &amp;#123; useReducer &amp;#125; from &amp;quot;react&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const reducer = (state, action) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  switch (action.type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;INCREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count + 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;DECREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count - 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;HANDLE_CHANGE&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, [action.target.name]: action.target.value &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const CountReducer = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const [state, dispatch] = useReducer(reducer, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count: 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &amp;quot;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nickname: &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const handleChange = e =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch(&amp;#123; type: &amp;quot;HANDLE_CHANGE&amp;quot;, target: e.target &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;p&amp;gt;current count: &amp;#123;state.count&amp;#125;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;INCREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;increase&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;DECREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;decrease&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.name&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.nickname&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export default CountReducer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useReducer" scheme="https://kkangil.github.io/tags/useReducer/"/>
    
      <category term="useMemo" scheme="https://kkangil.github.io/tags/useMemo/"/>
    
      <category term="useCallback" scheme="https://kkangil.github.io/tags/useCallback/"/>
    
      <category term="useRef" scheme="https://kkangil.github.io/tags/useRef/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 2. 사용방법1</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-2-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%951/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-2-사용방법1/</id>
    <published>2019-04-19T03:52:51.000Z</published>
    <updated>2019-04-19T03:53:43.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h3><p>useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.</p><p>사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><ul><li>useState를 사용하여 count state를 생성해 주었으며 초기값은 0으로 맞춰 주었다.</li><li>state 사용은 기존의 class에서 사용하던 this.state.count가 아닌 count로만 사용해야 한다.</li><li>setCount 파라미터로 값을 넘겨주면 해당 값으로 state가 변경된다.</li></ul><h3 id="여러개의-state-사용"><a href="#여러개의-state-사용" class="headerlink" title="여러개의 state 사용"></a>여러개의 state 사용</h3><p>여러개의 state를 사용해야 한다면, 기존 class 방식에서는 state 객체 안에 키와 값을 설정해 주면 됐지만, 함수형 컴포넌트에서는 useState를 여러번 써줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;name ? `$&#123;name&#125;&apos;s` : &quot;&quot;&#125; current count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="재사용-가능한-useState-함수-컴포넌트"><a href="#재사용-가능한-useState-함수-컴포넌트" class="headerlink" title="재사용 가능한 useState 함수 컴포넌트"></a>재사용 가능한 useState 함수 컴포넌트</h3><p>동일한 stateful 로직을 사용한다면 컴포넌트를 분리해서 사용하는것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const useInputOption = props =&gt; &#123;</span><br><span class="line">  const [value, setValue] = useState(props || &quot;&quot;);</span><br><span class="line">  const onChange = e =&gt; &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const nameInputOption = useInputOption(&quot;&quot;);</span><br><span class="line">  const nickInputOption = useInputOption(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input &#123;...nameInputOption&#125; /&gt;</span><br><span class="line">      &lt;input &#123;...nickInputOption&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;nameInputOption.value ? `$&#123;nameInputOption.value&#125;&apos;s` : &quot;&quot;&#125; current</span><br><span class="line">        count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>input의 value와 onChange 이벤트 함수를 return 해주는 <code>useInputOption</code> 컴포넌트를 만들었다.</li><li>코드가 간결해지고 재사용성이 높아진다.</li></ul><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect는 함수형 컴포넌트에서도 라이프사이클과 같은 기능을 사용할 수 있게 해준다.<br><code>componentDidMount</code> 와 <code>componentDidUpdate</code>, <code>componentWillUnmount</code> 를 합쳐놓은 것이다.<br>useEffect 함수는 state 변수를 하나만 관리하는것이 좋다. 즉 여러개의 useEffect 함수를 사용하는것을 추천해주고 있다.</p><h3 id="사용방법-1"><a href="#사용방법-1" class="headerlink" title="사용방법"></a>사용방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const User = () =&gt; &#123;</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default User;</span><br></pre></td></tr></table></figure><ul><li>해당 코드를 확인해보면 render 가 될때마다 console.log 가 찍히는것을 확인할 수 있다. 이것은 <code>componentDidMount</code> 와 <code>componentDidUpdate</code> 라이프사이클과 일치한다.</li></ul><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><ul><li>useEffect 함수에 두번째 파라미터로 빈배열을 넣으면 최초 렌더링이 될때만 실행되고 name이 변경되더라도 실행되지 않는다.</li></ul><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>배열에 원하는 값을 넣어주면 해당 값이 변할때만 실행된다.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      console.log(&quot;unmount&quot;, name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>return 함수는 렌더링이 될때마다 실행되는 함수이다. name을 확인해보면 변경되기 이전의 값이 찍히는것을 확인할 수 있다.</li><li>두번째 파라미터에 빈 배열을 담아서 실행하면 unmount 될때만 return 함수가 실행된다.</li></ul><h2 id="Promise-처리"><a href="#Promise-처리" class="headerlink" title="Promise 처리"></a>Promise 처리</h2><p>useEffect와 useState를 사용하여 promise 컴포넌트 또한 재사용이 가능하도록 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const usePromise = (&#123; promise, initialData, arr &#125;) =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState(initialData);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(false);</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    try &#123;</span><br><span class="line">      const result = await promise();</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      setError(true);</span><br><span class="line">    &#125;</span><br><span class="line">    setLoading(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, arr || []);</span><br><span class="line"></span><br><span class="line">  return &#123; data, loading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getNames = async () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt;</span><br><span class="line">    setTimeout(() =&gt; resolve([&#123; name: &quot;kkangil&quot; &#125;, &#123; name: &quot;kkangil2&quot; &#125;]), 1000)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Names = () =&gt; &#123;</span><br><span class="line">  const &#123; data: names, loading, error &#125; = usePromise(&#123;</span><br><span class="line">    promise: getNames,</span><br><span class="line">    initialData: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (loading) return &lt;div&gt;로딩중...&lt;/div&gt;;</span><br><span class="line">  if (error) return &lt;div&gt;에러&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;names.map((row, index) =&gt; (</span><br><span class="line">        &lt;div key=&#123;index&#125;&gt;&#123;row.name&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="usePromise"><a href="#usePromise" class="headerlink" title="usePromise"></a>usePromise</h3><ul><li>파라미터로 호출해야하는 <code>promise</code> 함수, 최초 초기화 데이터 <code>initialData</code>, useEffect 함수 2번째 파라미터 배열 <code>arr</code>을 객체로 받는다.</li><li><code>useEffect</code> 함수에서 async/await을 사용하면 warning이 발생한다. 그렇기 때문에 async/await 함수를 따로 만들어 해당 함수를 useEffect에서 실행 시켜준다.</li></ul><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><ul><li>initialData에 빈배열을 넣어주지 않으면 return의 <code>names.map</code> 에서 에러가 발생한다. 해당 에러를 막기 위해 빈 배열로 초기화해줬다. <code>names</code> 값이 존재할때만 map 을 사용하는 방법도 있지만, 추후 재사용을 위해 데이터 초기값을 설정해줄 수 있도록 했다.</li></ul><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>useContext는 함수형 컴포넌트에서 Context를 쉽게 사용할 수 있게 해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const backgroundColorContext = createContext(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">const Context = () =&gt; &#123;</span><br><span class="line">  const backgroundColor = useContext(backgroundColorContext);</span><br><span class="line">  const style = &#123;</span><br><span class="line">    width: &quot;50px&quot;,</span><br><span class="line">    height: &quot;50px&quot;,</span><br><span class="line">    borderRadius: &quot;50%&quot;,</span><br><span class="line">    background: backgroundColor</span><br><span class="line">  &#125;;</span><br><span class="line">  return &lt;div style=&#123;style&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Context;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useState&quot;&gt;&lt;a href=&quot;#useState&quot; class=&quot;headerlink&quot; title=&quot;useState&quot;&gt;&lt;/a&gt;useState&lt;/h2&gt;&lt;h3 id=&quot;사용방법&quot;&gt;&lt;a href=&quot;#사용방법&quot; class=&quot;headerlink&quot; title=&quot;사용방법&quot;&gt;&lt;/a&gt;사용방법&lt;/h3&gt;&lt;p&gt;useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useState" scheme="https://kkangil.github.io/tags/useState/"/>
    
      <category term="useEffect" scheme="https://kkangil.github.io/tags/useEffect/"/>
    
      <category term="useContext" scheme="https://kkangil.github.io/tags/useContext/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 1. hooks 란?</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-1-hooks-%EB%9E%80/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-1-hooks-란/</id>
    <published>2019-04-19T03:48:12.000Z</published>
    <updated>2019-04-19T03:52:29.003Z</updated>
    
    <content type="html"><![CDATA[<p>리액트 16.8 버전에서 <code>Hooks</code> 라는 새로운 기능이 추가 되었다.<br>해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.<br>이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.</p><a id="more"></a><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-intro.html</a></p><h2 id="Hooks-특징"><a href="#Hooks-특징" class="headerlink" title="Hooks 특징"></a>Hooks 특징</h2><ul><li>현재 진행중인 프로젝트가 있다면 코드를 다시 짜지 않아도, 바로 사용할 수 있다. </li><li>어떠한 변화 없이 기능이 추가 되었기 때문에 이전 버전과의 호환성이 100%이다.</li><li>16.8.0 이후 버전에서 사용가능하다.</li></ul><blockquote><p>Hooks로 class를 대신할 수 있게됐지만, 리액트는 class를 제거할 계획이 없다고 밝혔다. 리액트에 대한 여러가지 컨셉(props, state, context, refs, and lifecycle)을 대체할 수 없는 대신, 더욱 직관적으로 제공한다고 한다.</p></blockquote><h2 id="Hooks가-나오게된-배경"><a href="#Hooks가-나오게된-배경" class="headerlink" title="Hooks가 나오게된 배경"></a>Hooks가 나오게된 배경</h2><h3 id="Component-사이에서-stateful-한-로직의-재사용이-어렵다"><a href="#Component-사이에서-stateful-한-로직의-재사용이-어렵다" class="headerlink" title="Component 사이에서 stateful 한 로직의 재사용이 어렵다."></a>Component 사이에서 stateful 한 로직의 재사용이 어렵다.</h3><ul><li>리액트는 컴포넌트에 재활용하는 방법인 “attach” 방법을 제공하지 않는다.</li><li>이런 문제들을 해결하기 위해 다양한 패턴이 사용되었다. (render propr, HOC …) 이런 패턴을 사용했을 때, 재구조화를 해야하고 이는 번거롭고 어려워질 수 있다. 또한 이런 패턴을 <code>DevTools</code> 에서 확인해 보면 wrapper 지옥에 빠져있는 수많은 컴포넌트를 볼 수 있다.</li><li>Hooks 는 컴포넌트로 부터 stateful 한 로직을 추출해 낼 수 있으며 이것은 의존성과 재사용성을 테스트할 수 있다. </li></ul><h3 id="이해하기-어려운-복잡한-컴포넌트"><a href="#이해하기-어려운-복잡한-컴포넌트" class="headerlink" title="이해하기 어려운 복잡한 컴포넌트"></a>이해하기 어려운 복잡한 컴포넌트</h3><ul><li>처음은 가벼운 컴포넌트였지만, 개발을 진행하다보면 수많은 side effects와 stateful 로직이 걷잡을 수 없이 많아진다.</li><li>각각의 라이프 사이클은 자주 연관성이 없는 로직을 섞어 사용하곤 한다. 예를 들어 컴포넌트는 <code>componentDidMount</code>와 <code>componentDidUpdate</code> 라이프사이클에서 데이터를 fetch 할 수 있다. 하지만 몇몇 <code>componentDidMount</code> 메소드는 이벤트를 설정하는 데 연관 없는 로직 들을 포함할 수 있으며 <code>componentWillUnmount</code>는 cleanup을 수행할 수도 있다. 함께 변경되는 관련 코드는 분리되지만 연관 없는 코드들은 단일 메소드로 결합한다. 이것은 버그와 무결성을 쉽게 발생시킨다.</li><li>많은 경우 컴포넌트들을 작게 만드는 것은 불가능하다. stateful 로직은 모든곳에 있기 때문이다. 또한 이것은 테스트하는 것도 어렵다. 이것이 사람들이 state 를 관리하는 라이브러리를 함께 사용하는것을 선호하는 이유중 하나이다. 그러나 너무 추상적이라고 소개하고 다른 파일 사이를 건너뛰는것을 요구하며 컴포넌트 재사용을 더욱 어렵게 만든다.</li><li>이러한 이슈들을 해결하기 위해 Hooks는 라이프사이클 메소드를 기초로한 분리에 초점을 맞추는 것보다는 컴포넌트들을 연관성을 기초로 더 작은 함수로 분리할 수 있게 한다.</li></ul><h3 id="사람과-기계를-혼란시키는-Classes"><a href="#사람과-기계를-혼란시키는-Classes" class="headerlink" title="사람과 기계를 혼란시키는 Classes"></a>사람과 기계를 혼란시키는 Classes</h3><ul><li>코드를 재사용성과 구조적으로 만드는 것은 어려울뿐만 아니라 리액트를 배울때 classes는 큰 진입장벽이다. 다른 대부분의 언어들과는 다른 Javascript가 어떻게 동작하는지 이해하고 있어야한다. 이벤트 핸들러는 항상 바인딩이 되어야 하는것을 기억해야 한다. 안정적인 문법의 제안이 없다면, 코드는 매우 장황해진다.</li><li>사람들은 props, state, 단방향 데이터 흐름에 대해 이해하고 있지만 여전히 classes는 어려워한다.</li><li>이러한 문제를 해결하기 위해서 Hooks는 classes 없이 리액트의 특징들을 사용할 수 있게 해준다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;리액트 16.8 버전에서 &lt;code&gt;Hooks&lt;/code&gt; 라는 새로운 기능이 추가 되었다.&lt;br&gt;해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.&lt;br&gt;이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 정의" scheme="https://kkangil.github.io/tags/hooks-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
</feed>
