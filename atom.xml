<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkangil&#39;s Blog</title>
  
  <subtitle>kkangil&#39;s develop Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkangil.github.io/"/>
  <updated>2019-12-29T09:10:00.896Z</updated>
  <id>https://kkangil.github.io/</id>
  
  <author>
    <name>kkangil</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>값에 대해</title>
    <link href="https://kkangil.github.io/2019/12/29/%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%B4/"/>
    <id>https://kkangil.github.io/2019/12/29/값에-대해/</id>
    <published>2019-12-29T07:35:45.000Z</published>
    <updated>2019-12-29T09:10:00.896Z</updated>
    
    <content type="html"><![CDATA[<p>함수로 협업하는 가장 좋은 방법은 인자와 리턴값으로만 소통하는 것이다. 순수하게 인자와 리턴값에만 의존하면 누가 만든 함수든 어떤 라이브러리로 만든 함수든 조립할 수 있게 된다. 이때 함수에서 다루는 값으로 자바스크립트의 기본 객체를 사용하거나 아주 보편적으로 약속된 객체만 사용하면 함수들 간의 조합성이 더욱 좋아진다.</p><a id="more"></a><p>여기서 말하는 기본 객체란 Array, Object, String, Number, Boolean, Null, Undefined 등의 자바스크립트 기본 객체를 말하며, 브라우저의 DOM 같은 것들도 범주 안에 들어올 수 있다. 어떤 프로퍼티와 어떤 메서드를 가지고 있는지 충분히 약속되고 보장된 값들을 말한다. 약속된 스펙을 가진 값들만 사용하는 함수들은 언제나 어떤 환경에서나 사용하기 편하다.</p><h2 id="순수-함수"><a href="#순수-함수" class="headerlink" title="순수 함수"></a>순수 함수</h2><h3 id="순수-함수와-부수-효과"><a href="#순수-함수와-부수-효과" class="headerlink" title="순수 함수와 부수 효과"></a>순수 함수와 부수 효과</h3><p>순수 함수는 동일한 인자가 들어오면 항상 동일한 값을 리턴하는 함수다. 메서드가 자신이 가진 내부의 상태에 따라 다른 결과를 만든다면, 순수 함수는 들어온 인자와 상수만 사용하여 항상 동일한 결과를 리턴한다.<br>또 하나 중요한 특징이 있는데, 바로 외부의 상태를 변경하지 않는다는 점이다. 함수에게 들어온 인자를 포함하여, 외부와 공유되고 있는 값 중 함수가 참조할 수 있는 어떤 값도 변경하지 않는 것을 말한다. 함수가 외부 상태를 변경하면, 외부 상태와 연관이 있는 다른 부분에도 영향이 있고 이것을 부수 효과(Side effect)라고 한다.</p><p>부수 효과 문제는 특히 동시성이 생길 때 더욱 취약하다. 브라우저나 Node.js는 다양한 작업을 동시에 처리한다. 이렇게 동시성이 생기는 상황에서는 여러 곳에서 공유되도 있는 값이 변경되는 것은 위험하다. 부수 효과는 단지 동시성에서만의 이슈가 아니다. 예를 들면 사용자가 오랫동안 인터랙션을 해서 상태를 지속적으로 관리해야 하는 웹 페이지나 앱의 코드들에서 부수 효과 문제가 생기는 경우가 많다.</p><p>순수 함수의 정의를 아는 것보다 중요한 점은 여기에 담긴 목적과 전략이다. 순수 함수에 담긴 전략은 그 이름처럼 간단 명료하다. 상태 변화를 최소화하고, 다음 단계로 넘어갈 때마다 새로운 값으로 출발하는 식으로 코딩하는 것이다. 이렇게 하면 문제가 쉬워진다. 문제가 단순해지면 해결책 역시 쉬워지고 오류를 만들 가능성도 줄어든다. 작은 순수 함수들을 모아 만든 소프트웨어는 유지 보수와 기획 변경에 유연하게 대응한다.</p><h3 id="순수-함수와-순수-함수가-아닌-함수"><a href="#순수-함수와-순수-함수가-아닌-함수" class="headerlink" title="순수 함수와 순수 함수가 아닌 함수"></a>순수 함수와 순수 함수가 아닌 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 순수 함수</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 순수 함수가 아닌 함수</span><br><span class="line">function add2(obj, value) &#123;</span><br><span class="line">  obj.value = obj.value + value;</span><br><span class="line">  return obj.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 작은 차이지만 순수 함수</span><br><span class="line">function add3(obj, value) &#123;</span><br><span class="line">  return obj.value + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 작은 차이지만 순수 함수 2</span><br><span class="line">function add4(obj, value) &#123;</span><br><span class="line">  return &#123; value: obj.value + value &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add는 인자를 받아 새로운 값을 리턴했고 add2는 obj의 상태를 변경한다. add는 인자가 같으면 항상 결과가 같고 부수 효과가 없다. add2는 obj.value의 상태에 따라 결과가 달라진다. 이런 점 자체가 문제를 만들지는 않지만 만일 obj.value를 사용하는 코드가 add2 외에 다른 곳에도 있다면 반드시 obj.value가 변경될 수 있다는 점과 변경될 시점 등을 정확히 인지하고 제어해야 할 것이다.</p><p>add3과 add4는 작은 차이가 있지만 순수 함수다. obj.value를 참조만 하고 있기 때문이다. 순수 함수를 만들기 위해 항상 모든 값을 새로 만들어야 하는 것은 아니다. 조회 자체는 부수 효과를 일으키지 않는다.</p><p>순수 함수로 프로그래밍을 한다면 add 같은 작은 기능의 함수만 만들어지는 게 아닌가 하는 생각이 들 수 있다. 클래스나 객체처럼 풍부한 기능을 가진 모듈을 만들 수 없을 것만 같을 수 있다. 하지만 인자로 함수를 사용하거나 고차 함수를 이용한 함수 조합을 통해 순수 함수의 조건을 따르면서 보다 풍부한 변화를 불러오는 함수들을 만들 수 있다.</p><h2 id="변경-최소화와-불변-객체"><a href="#변경-최소화와-불변-객체" class="headerlink" title="변경 최소화와 불변 객체"></a>변경 최소화와 불변 객체</h2><h3 id="직접-변경하는-대신-변경된-새로운-값을-만드는-전략"><a href="#직접-변경하는-대신-변경된-새로운-값을-만드는-전략" class="headerlink" title="직접 변경하는 대신, 변경된 새로운 값을 만드는 전략"></a>직접 변경하는 대신, 변경된 새로운 값을 만드는 전략</h3><p>대부분 이미 확인한 함수들이지만 이번에는 값과 값을 변경해 나가는 것에 초점을 두고 설명하고자 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var users1 = [</span><br><span class="line">  &#123; name: &quot;ID&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;HA&quot;, age: 25 &#125;,</span><br><span class="line">  &#123; name: &quot;BJ&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;PJ&quot;, age: 28 &#125;,</span><br><span class="line">  &#123; name: &quot;JE&quot;, age: 27 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var comparator = function (a, b) &#123;</span><br><span class="line">  if (a.age &lt; b.age) return -1;</span><br><span class="line">  if (a.age &gt; b.age) return 1;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var sortedUsers1 = users1.sort(comparator) // 1</span><br><span class="line"></span><br><span class="line">console.log(users1 === sortedUsers1) // 2 true</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(sortedUsers1, &apos;age&apos;)); // 3 [25, 27, 28, 32, 32]</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(users1, &apos;age&apos;)); // 4 [25, 27, 28, 32, 32]</span><br></pre></td></tr></table></figure><p>users1을 나이순으로 정렬하는 예제다. Array.prototype.sort는 자기 자신을 정렬하는 함수다. 2의 결과가 true라는 것은 둘이 완전히 같은 객체라는 뜻이다. 동일한 값을 가진 객체가 아닌 완전히 같은 객체라는 것이다. 1의 .sort() 메서드는 자기 자신을 바꾸고 자기 자신을 리턴한다. 3 _.pluck 를 통해 age 값만 꺼내보면 둘다 동일하게 정렬이 된 것을 확인할 수 있는데, users1과 sortedUsers1이 완전히 같은 값이어서 동일한 결과가 출력된 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var users2 = [</span><br><span class="line">  &#123; name: &quot;ID&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;HA&quot;, age: 25 &#125;,</span><br><span class="line">  &#123; name: &quot;BJ&quot;, age: 32 &#125;,</span><br><span class="line">  &#123; name: &quot;PJ&quot;, age: 28 &#125;,</span><br><span class="line">  &#123; name: &quot;JE&quot;, age: 27 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var sortedUsers2 = _.sortBy(users2, &apos;age&apos;) // 1</span><br><span class="line"></span><br><span class="line">console.log(users2 === sortedUsers2) // 2 false</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(sortedUsers2, &apos;age&apos;)) // 3 [25, 27, 28, 32, 32]</span><br><span class="line"></span><br><span class="line">console.log(_.pluck(users2, &apos;age&apos;)) // 4 [32, 25, 32, 28, 27]</span><br><span class="line"></span><br><span class="line">console.log(users2[1] === sortedUsers2[0]); // 5 true</span><br></pre></td></tr></table></figure><p>이번에는 _.sortBy 함수를 이용하여 정렬을 해 보았다. 2를 확인해 보면 false가 나온다. 1에서 리턴된 sortedUser2는 새로운 객체다. 3,4 를 확인해 보면 sortedUsers2는 나이순으로 정렬이 되었는데, users2 는 원본 그대로임을 알 수 있다. 다른 곳에 users2의 순서에 의존하여 동작하고 있는 코드가 있다면, sortedUsers2 처럼 새로운 객체를 만들어 정렬을 하는 방식이 부수 효과가 없고 유리하다.</p><p>sortedUser2는 새로운 값이다. 그렇다면 배열 안의 값들도 새로운 값일까? 서로 다르게 정렬이 되어 있지만, 두 배열 안에 있는 모든 값은 새로운 값이 아닌 기존의 값이다. 항상 배열 내의 모든 값을 새롭게 만든다면 메모리 사용량이 매우 높아질 것이다. _.sortBy는 내부의 값은 기존의 값을 그대로 활용하면서 배열만 새로 만들어 정렬한다.</p><p>Undescore.js의 콘셉트 중에는 이러한 중요한 전략이 있다. 이 전략을 잘 따르면 부수 효과를 줄이면서도 메모리 사용량 증가는 최소화하는 좋은 함수들을 만들 수 있다. 그것은 바로 그<code>함수가 변경할 영역에 대해서만 새 값을 만드는 전략</code>이다. 예를 들어 자신의 역할이 정렬이라면 정렬과 연관 있는 부분만 새 값으로 만들고 나머지 값들은 재활용하는 식이다. 이 전략을 대부분의 함수적 함수에 적용된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var rejectedUsers2 = _.reject(users2, function (user) &#123; return user.age &lt; 30; &#125;);</span><br><span class="line">console.log(rejectedUsers2);</span><br><span class="line">// [&#123;name: &quot;ID&quot;, age: 32&#125;, &#123;name: &quot;BJ&quot;, age: 32&#125;]</span><br><span class="line"></span><br><span class="line">console.log(rejectedUsers2 === users2) // false</span><br><span class="line">console.log(rejectedUsers2.length, users2.length); // 2 5 </span><br><span class="line">console.log(rejectedUsers2[0] === users2[0]) // true</span><br></pre></td></tr></table></figure><p>배열 내부의 값 중 특정 조건의 값들을 제외하는 _.reject 같은 함수도 배열 내부의 값들을 지우는 것이 아니라 값들이 지워진 새로운 배열을 만드는 것이다. _.reject도 결국 같은 전략을 따른 것이다. _.reject 함수의 역할은 값을 제외하는 것이고 달라지는 영역은 배열이기에 배열을 새로 만드는 것이다.</p><p>users2에서 30세 미만인 사람들을 제외했다. 더 정확히 말하면 30세 미만인 사람들이 제외된 새로운 배열을 만들어 리턴했다. rejectedUsers2는 users2가 아니며, users2.length도 그대로이고, 배열 내부의 값들도 기존의 값 그대로다. users2를 다루면서 새로 정렬하고 배열 내부의 값도 지웠지만, users2는 원래 상태 그대로이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//  1</span><br><span class="line">console.log(</span><br><span class="line">  _.pluck(_.reject(users2, function (user) &#123; return user.age &gt;= 30; &#125;), &apos;name&apos;)</span><br><span class="line">)</span><br><span class="line">// [&quot;HA&quot;, &quot;PJ&quot;, &quot;JE&quot;]</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">console.log(</span><br><span class="line">  _.pluck(users2, &apos;name&apos;)</span><br><span class="line">)</span><br><span class="line">// [&quot;ID&quot;, &quot;HA&quot;, &quot;BJ&quot;, &quot;PJ&quot;, &quot;JE&quot;]</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">console.log(users2)</span><br><span class="line">// 원본 그대로</span><br></pre></td></tr></table></figure><p>1 users에서는 _.reject로 30세 이상의 user를 제외한 새 배열을 만든 후, _.pluck을 통해 이름만 추출한 새 배열을 만들어 로그를 남겼다. _.reject를 이용해 users2의 상태를 변경하지 않으면서 필터링을 했고, _.pluck 를 통해 역시 원본 소스들을 건들지 않고 name이 추출된 새로운 배열을 만들었다. 따라서 원본 데이터에는 아무런 영향을 끼치지 않았다. 그 덕분에 2에서는 어려움 없이 원본에 있는 모든 이름을 출력할 수 있다. 2가 실행된 후에도 3 users는 역시 변경되지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var b1 = [1, 2, 3, 4, 5];</span><br><span class="line">var b2 = _.initial(b1, 2); // 뒤에서 2개 제거한 새로운 배열 리턴</span><br><span class="line">console.log(b1 === b2, b1, b2);</span><br><span class="line">// false (5) [1, 2, 3, 4, 5] (3) [1, 2, 3]</span><br><span class="line"></span><br><span class="line">var b3 = _.without(b1, 1, 5); // 1과 5를 제거한 새로운 배열 리턴</span><br><span class="line">var b4 = _.without(b3, 2); // 2를 제거한 새로운 배열 리턴</span><br><span class="line">console.log(b1 === b3, b3 === b4, b3, b4);</span><br><span class="line">// false false (3) [2, 3, 4] (2) [3, 4]</span><br></pre></td></tr></table></figure><p>맨 마지막에 b4를 만들 때, b3 에서 2를 제거했지만 b3에는 여전히 2가 남아있다.</p><h3 id="clone-으로-복사하기"><a href="#clone-으로-복사하기" class="headerlink" title="_.clone 으로 복사하기"></a>_.clone 으로 복사하기</h3><p>_.clone은 배열이나 객체를 받아 복사하는 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var product1 = &#123;</span><br><span class="line">  name: &quot;AB 반팔티&quot;,</span><br><span class="line">  price: 10000,</span><br><span class="line">  sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">  colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var product2 = _.clone(product1);</span><br><span class="line">console.log(product2);</span><br><span class="line">// &#123;</span><br><span class="line">//   name: &quot;AB 반팔티&quot;,</span><br><span class="line">//   price: 10000,</span><br><span class="line">//   sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">//   colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">console.log(product1 === product2); // false</span><br><span class="line"></span><br><span class="line">product2.name = &quot;ABCD 반팔티&quot;;</span><br><span class="line">console.log(product1.name, product2.name);</span><br><span class="line">// AB 반팔티 ABCD 반팔티</span><br></pre></td></tr></table></figure><p>product1을 _.clone 함수를 통해 복사했다. 동일한 내용이 들어 있는 새로운 객체가 리턴되어, 출력해 보면 내용은 같지만 비교하면 false가 나온다. product2.name 을 변경해도 product1에는 영향을 끼치지 않는다. product2를 마음 편히 다룰 수 있다.<br>그런데 _.clone을 정확히 다루려면 _.clone이 객체를 복하는 범위에 대해 제대로 알아야 한다. _.clone이 객체를 복사하는 것은 맞지만 객체 내부의 모든 값들까지 복사하는 것은 아니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">product2.sizes.push(&quot;2XL&quot;);</span><br><span class="line">console.log(product2.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;2XL&quot;]</span><br><span class="line">console.log(product1.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;2XL&quot;]</span><br><span class="line">console.log(product1.sizes === product2.sizes); // true</span><br></pre></td></tr></table></figure><p>_.clone은 동일한 key들을 가진 새로운 객체를 만들면서 각 key에 기존의 key에 해당하는 value를 할당한다. 때문에 내부의 값이 객체라면 같은 객체를 바라보게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_.clone = function (obj) &#123;</span><br><span class="line">  var cloned = _.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  var keys = _.keys(obj);</span><br><span class="line">  _.each(keys, function (key) &#123;</span><br><span class="line">    cloned[key] = obj[key]; // Array일때는 key가 숫자</span><br><span class="line">  &#125;);</span><br><span class="line">  return cloned;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;;</span><br><span class="line">var obj2 = _.clone(obj1);</span><br><span class="line">obj2.b = 22;</span><br><span class="line"></span><br><span class="line">console.log(obj2);</span><br><span class="line">// &#123; a: 1, b: 22, c: &#123; d: 3 &#125; &#125;;</span><br><span class="line">console.log(obj1);</span><br><span class="line">// &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj1 === obj2); // false</span><br><span class="line">console.log(obj1.c === obj2.c); // true</span><br><span class="line"></span><br><span class="line">obj2.c.d = 33;</span><br><span class="line">console.log(obj1.c.d) // 33 obj1도 같이 변경</span><br></pre></td></tr></table></figure><p>그렇다면 객체 안의 객체를 변경하고 싶은 경우에는 어떻게 해야 원본에 영향을 주지 않으면서 값을 변경할 수 있을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var product1 = &#123;</span><br><span class="line">  name: &quot;AB 반팔티&quot;,</span><br><span class="line">  price: 10000,</span><br><span class="line">  sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">  colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var product2 = _.clone(product1);</span><br><span class="line">product2.sizes = _.clone(product2.sizes); // 내부도 clone 후 push를 하거나</span><br><span class="line">product2.sizes.push(&quot;2XL&quot;)</span><br><span class="line">console.log(product2.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;2XL&quot;]</span><br><span class="line">console.log(product1.sizes);</span><br><span class="line">// [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;]</span><br><span class="line">console.log(product1.sizes === product2.sizes); // false</span><br><span class="line"></span><br><span class="line">product2.colors = product2.colors.concat(&quot;Yellow&quot;) // 아니면 concat으로 한번에</span><br><span class="line">console.log(product2.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;, &quot;Yellow&quot;]</span><br><span class="line">console.log(product1.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">console.log(product1.colors === product2.colors); // false</span><br></pre></td></tr></table></figure><p>위와 같이 하면 된다. 어차피 내부의 값도 복사하는 식으로 값을 다뤄야 한다면 왜 굳이 객체의 첫 번째 깊이만 복사하느냐고 생각할 수 있다. 값 복사 후 항상 내부의 모든 값을 변경할 것이 아니기에, 객체 내부의 객체는 공유하는 것이 메모리 사용에 유리하고, 복사 수행 처리 시간이라는 측면에서도 이점이 많다.</p><h3 id="extend-defaults로-복사하기"><a href="#extend-defaults로-복사하기" class="headerlink" title="_.extend, _.defaults로 복사하기"></a>_.extend, _.defaults로 복사하기</h3><p>_.extend나 _.defaults를 이용하면 값 복사와 변경을 좀 더 간결하게 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var product1 = &#123;</span><br><span class="line">  name: &quot;AB 반팔티&quot;,</span><br><span class="line">  price: 10000,</span><br><span class="line">  sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">  colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">var product2 = _.extend(&#123;&#125;, product1, &#123;</span><br><span class="line">  name: &quot;AB 긴팔티&quot;,</span><br><span class="line">  price: 15000</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">var product3 = _.defaults(&#123;</span><br><span class="line">  name: &quot;AB 후드티&quot;,</span><br><span class="line">  price: 15000</span><br><span class="line">&#125;, product1);</span><br><span class="line"></span><br><span class="line">console.log(product2);</span><br><span class="line">// &#123;</span><br><span class="line">//   name: &quot;AB 긴팔티&quot;,</span><br><span class="line">//   price: 15000,</span><br><span class="line">//   sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">//   colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">// &#125;;</span><br><span class="line">console.log(product3);</span><br><span class="line">// &#123;</span><br><span class="line">//   name: &quot;AB 후드티&quot;,</span><br><span class="line">//   price: 15000,</span><br><span class="line">//   sizes: [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;],</span><br><span class="line">//   colors: [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">// &#125;;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">var product4 = _.extend(&#123;&#125;, product3, &#123;</span><br><span class="line">  colors: product3.colors.concat(&quot;Purple&quot;)</span><br><span class="line">&#125;);</span><br><span class="line">var product5 = _.defaults(&#123;</span><br><span class="line">  colors: product4.colors.concat(&quot;Red&quot;)</span><br><span class="line">&#125;, product4);</span><br><span class="line"></span><br><span class="line">console.log(product3.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;]</span><br><span class="line">console.log(product4.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;, &quot;Purple&quot;]</span><br><span class="line">console.log(product5.colors);</span><br><span class="line">// [&quot;Black&quot;, &quot;White&quot;, &quot;Blue&quot;, &quot;Purple&quot;, &quot;Red&quot;]</span><br></pre></td></tr></table></figure><ol><li>product2는 값 복사를 위해 새로운 객체인 {} 를 _.extend의 첫 번째 인자로 넣었다.</li><li>어차피 {name: “AB 후드티”, price: 12000}도 새 객체이므로 product3처럼 _.defaults를 이용하는 것이 객체를 적게 생성해서 더 효율적이다. _.extend의 경우, 왼쪽 객체에 없는 key/value는 확장하고, 왼쪽 객체에 있던 key/value는 덮어 쓴다. _.defaults는 왼쪽에 없는 key/value만 확장한다.</li><li>1, 2를 보면 _.clone 없이 복사와 변경을 동시에 하여 간결해졌지만, colors 처럼 깊은 값을 변경해야 할 경우에는 직접 다뤄줘야 한다. _.extend와 _.defaults 역시 변경이 필요 없는 값은 이전의 값을 공유한다.</li></ol><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수로 협업하는 가장 좋은 방법은 인자와 리턴값으로만 소통하는 것이다. 순수하게 인자와 리턴값에만 의존하면 누가 만든 함수든 어떤 라이브러리로 만든 함수든 조립할 수 있게 된다. 이때 함수에서 다루는 값으로 자바스크립트의 기본 객체를 사용하거나 아주 보편적으로 약속된 객체만 사용하면 함수들 간의 조합성이 더욱 좋아진다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="순수 함수" scheme="https://kkangil.github.io/tags/%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98/"/>
    
      <category term="부수 효과" scheme="https://kkangil.github.io/tags/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC/"/>
    
      <category term="변경 최소화" scheme="https://kkangil.github.io/tags/%EB%B3%80%EA%B2%BD-%EC%B5%9C%EC%86%8C%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>Partial.js와 함수 조립</title>
    <link href="https://kkangil.github.io/2019/12/01/Partial-js%EC%99%80-%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/"/>
    <id>https://kkangil.github.io/2019/12/01/Partial-js와-함수-조립/</id>
    <published>2019-12-01T06:35:32.000Z</published>
    <updated>2019-12-01T09:41:04.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="파이프라인"><a href="#파이프라인" class="headerlink" title="파이프라인"></a>파이프라인</h2><h3 id="즉시-실행-파이프라인-go와-mr"><a href="#즉시-실행-파이프라인-go와-mr" class="headerlink" title="즉시 실행 파이프라인, _.go와 _.mr"></a>즉시 실행 파이프라인, _.go와 _.mr</h3><p>_.go는 파이프라인의 즉시 실행 버전이다. 첫 번째 인자로 받은 값을 두 번째 인자로 받은 함수에게 넘겨주고, 두 번째 인자로 받은 함수의 결과는 세 번째 함수에게 넘겨준다. 이것을 반복하다가 마지막 함수의 결과를 리턴해 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.go(10, // 첫번째 인자</span><br><span class="line">  function (a) &#123; return a * 10 &#125;, // 100</span><br><span class="line">  function (a) &#123; return a - 50 &#125;, // 50</span><br><span class="line">  function (a) &#123; return a + 10 &#125; // 60</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>_.go는 Multiple Results를 지원한다. _.mr 함수를 함께 사용하면 다음 함수에게 2개 이상의 인자들을 전달할 수 있다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.go(10,</span><br><span class="line">  function (a) &#123; return _.mr(a * 10, 50) &#125;,</span><br><span class="line">  function (a, b) &#123; return a - b &#125;,</span><br><span class="line">  function (a) &#123; return a + 10 &#125;</span><br><span class="line">)</span><br><span class="line">// 60</span><br></pre></td></tr></table></figure><p>_.go의 첫 번째 인자는 두 번째 인자인 함수가 사용할 인자이며 두 번째 부터는 파이프라인에서 사용할 함수들이다. _.go의 두 번째 인자인 함수, 즉 최초 실행될 함수에게 2개 이상의 인자를 넘끼고자 한다면 그때도 _.mr을 사용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.go(_.mr(2, 3),</span><br><span class="line">  function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;,</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return a * a</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 25</span><br></pre></td></tr></table></figure><p>위의 코드처럼 _.mr로 인자들을 감싸서 넘겨주면, 다음 함수는 인자를 여러개로 펼쳐서 받게 된다. _.mr(2, 3)은 하나의 값이지만 _.go 내부에서 인자를 펼쳐서 넘겨주어, 2와 3이 첫 번째 함수의 a와 b가 된다.<br>_.go는 이미 정의되어 있는 함수와 조합하거나 화살표 함수와 사용할 때 특히 표현력이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function square(a) &#123;</span><br><span class="line">  return a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.go(_.mr(2, 3), add, square);</span><br><span class="line">_.go(_.mr(2, 3), (a, b) =&gt; a + b, a =&gt; a * a)</span><br></pre></td></tr></table></figure><h3 id="함수를-만드는-파이프라인-pipe"><a href="#함수를-만드는-파이프라인-pipe" class="headerlink" title="함수를 만드는 파이프라인 _.pipe"></a>함수를 만드는 파이프라인 _.pipe</h3><p>_.go가 즉시 실행하는 파이프라인이라면 _.pipe는 실행할 준비가 된 함수를 리턴하는 파이프라인 함수다. 그 외 모든 기능은 _.go와 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f1 = _.pipe(add, square);</span><br><span class="line">f1(2, 3); // 25</span><br><span class="line"></span><br><span class="line">var f2 = _.pipe((a, b) =&gt; a + b, a =&gt; a * a);</span><br><span class="line">f2(2, 3) // 25</span><br></pre></td></tr></table></figure><h3 id="부분-커링-함수와의-조합"><a href="#부분-커링-함수와의-조합" class="headerlink" title="부분 커링 함수와의 조합"></a>부분 커링 함수와의 조합</h3><p>파이프라인 함수를, 함수를 리턴하는 함수와 함께 사용해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var products = [</span><br><span class="line">  &#123; id: 1, name: &quot;후드 집업&quot;, discounted_price: 6000, price: 10000 &#125;,</span><br><span class="line">  &#123; id: 2, name: &quot;코잼 후드티&quot;, discounted_price: 8000, price: 8000 &#125;,</span><br><span class="line">  &#123; id: 3, name: &quot;A1 반팔티&quot;, discounted_price: 6000, price: 6000 &#125;,</span><br><span class="line">  &#123; id: 4, name: &quot;코잼 반팔티&quot;, discounted_price: 5000, price: 6000 &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">_.go(products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price), // 1</span><br><span class="line">  _.sortBy(&apos;discounted_price&apos;), // 2</span><br><span class="line">  _.first, // 3</span><br><span class="line">  _.val(&apos;name&apos;) // 4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 코잼 반팔티</span><br></pre></td></tr></table></figure><ol><li><code>products</code> 중에 할인 중인 상품만 남긴다.</li><li><code>discounted_price</code> 가 낮은 순으로 정렬한다.</li><li>첫 번째를 꺼낸다.</li><li>product.name 을 확인한다.</li></ol><p>Partial.js의 _.filter, _.sortBy, _.val은 모두 부분 커링이 된다. 모두 인자를 하나만 넘겨 앞으로 실행될 함수를 리턴 받았다. 그렇게 만들어진 함수들은 _.go를 통해 순서대로 실행된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 할인 상품 중 가격이 가장 높은 상품의 이름</span><br><span class="line">_.go(products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.sortBy(&apos;discounted_price&apos;),</span><br><span class="line">  _.last,</span><br><span class="line">  _.val(&apos;name&apos;),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// 후드 집업</span><br><span class="line"></span><br><span class="line">// 할인 상품 중 할인액이 가장 높은 상품의 이름</span><br><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.sortBy(p =&gt; p.discounted_price - p.price),</span><br><span class="line">  _.first,</span><br><span class="line">  _.val(&apos;name&apos;),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// 후드 집업</span><br><span class="line"></span><br><span class="line">// 할인 상품 중 할인액이 가장 낮은 상품의 이름</span><br><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.max(p =&gt; p.discounted_price - p.price),</span><br><span class="line">  _.val(&apos;name&apos;),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// 코잼 반팔티</span><br></pre></td></tr></table></figure><p>중간중간 들어간 함수들의 조합을 약간씩 수정하여, 다른 로직으로 쉽게 변경할 수 있다. 할인이 진행 중인 상품들 중 제일 비싼 상품을 꺼낸다든지, 할인이 되지 않는 상품 중 제일 싼 상품을 꺼낸다든지 하는 로직으로 변경하는 것이 위에서 알 수 있듯 매우 쉽다.</p><h3 id="보조-함수로-사용하는-파이프라인"><a href="#보조-함수로-사용하는-파이프라인" class="headerlink" title="보조 함수로 사용하는 파이프라인"></a>보조 함수로 사용하는 파이프라인</h3><p>파이프라인을 보조 함수로 만들기 위해 사용하는 것도 좋다. 파이프라인을 _.each, _.map, _.reduce 등과 같은 고차 함수들의 보조 함수로 사용해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(p =&gt; p.discounted_price &lt; p.price),</span><br><span class="line">  _.map(_.pipe(_.identity, _.pick([&apos;id&apos;, &apos;name&apos;]), _.values)),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line">// [[1, &quot;후드 집업&quot;], [4, &quot;코잼 반팔티&quot;]]</span><br></pre></td></tr></table></figure><p>_.filter 에서는 할인 중인 상품만 남게 된다. _.map 에서는 iteratee를 파이프라인으로 만들었다. _.pipe는 _.identity를 통해 iteratee의 첫 번째 인자인 product만 리턴하게 되고, 부분 커링된 _.pick을 통애 id와 name만 남은 객체로 만들게 된다. 마지막으로 _.values를 통해 값만 남겼다.</p><h3 id="비동기와-go"><a href="#비동기와-go" class="headerlink" title="비동기와 _.go"></a>비동기와 _.go</h3><p>_.go는 비동기 제어를 지원한다. Promise가 체인 방식에 함수적인 아이디어를 가미하여 비동기 상황을 제어했다면, _.go는 함수적으로만 비동기를 제어한다. _.go는 내부적으로 함수들을 순차적으로 실행해 나가면서 비동기 함수의 결과를 재귀 함수로 꺼낸 후, 다음 함수에게 이어주는 식으로 비동기 상황을 제어한다.<br>_.go와 _.pipe는 일반 콜백 함수와 Promise를 모두 지원한다. _.go와 _.pipe는 기본적으로 동기로 동작하지만 파이프라인의 함수들을 실행하는 도중에 Promise 객체가 리턴되거나 jQuery의 then과 같은 Deferred Object가 리턴되거나 _.callback 함수를 이용했다면, 내부적으로 비동기를 제어하는 파이프라인으로 변한다.<br>Promise의 경우에는 함수가 실행되면 즉시 setTimeout을 일으키고, 일단 { then: … } 을 리턴하게 되므로 동기 함수들과 중첩 사용을 할 수 없다. 그러나 _.go의 경우에는 비동기 상황이 없을 경우 결과를 즉시 리턴하기 때문에, 이후 연속적으로 실행되는 함수들이 반드시 비동기성을 띌 필요가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  10,</span><br><span class="line">  _.callback(function (a, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a + 10)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">  &#125;),</span><br><span class="line">  function (a) &#123; // next를 통해 받은 결과 a</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 상황에서 _.go는 첫 번째 함수를 실행하면서 내부적으로 next를 만들어 함수에게 넘긴다. next에게 결과를 전달하면 그 결과는 다음 함수의 인자로 넘어가게 된다. 다시 바깥으로 나와 그 다음 함수들을 순차적으로 실행하므로 콜백 지옥에서 벗어날 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function asyncCallback() &#123;</span><br><span class="line">  function add(a, b, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a + b);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(a, b, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a - b);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function mul(a, b, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(a * b);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function log(msg, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(msg);</span><br><span class="line">      next(msg);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _.go(</span><br><span class="line">    _.mr(5, 10),</span><br><span class="line">    _.callback(</span><br><span class="line">      function (a, b, next) &#123;</span><br><span class="line">        add(a, b, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function (result, next) &#123;</span><br><span class="line">        sub(result, 10, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function (result, next) &#123;</span><br><span class="line">        mul(result, 10, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function (result, next) &#123;</span><br><span class="line">        log(result, next);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncCallback(); // 50</span><br></pre></td></tr></table></figure><p>연속적으로 비동기 함수가 사용되어야 한다면 위와 같이 _.callback 함수에 여러개의 함수를 넘겨도 되고, 아래와 같이 미리 _.callback 패턴이라고 지정해 두면 더욱 간결하게 코딩할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var add = _.callback(function (a, b, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    next(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _.callback(function (a, b, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    next(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var mul = _.callback(function (a, b, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    next(a * b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var log = _.callback(function (msg, next) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">    next(msg);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">_.go(</span><br><span class="line">  _.mr(5, 10),</span><br><span class="line">  add,</span><br><span class="line">  function (result) &#123;</span><br><span class="line">    return sub(result, 10);</span><br><span class="line">  &#125;,</span><br><span class="line">  function (result) &#123;</span><br><span class="line">    return mul(result, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  function (result) &#123;</span><br><span class="line">    return log(result);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 코드 처럼 _.callback 함수로 미리 정의해 둔 ad, sub 등의 함수를 실행하면 그 함수는 Promise 객체를 리턴한다. 정확히는 Promise가 지원되는 환경에서는 Promise 객체를 리턴하고, Promise가 지원되지 않는 환경에서는 Partial.js 내부에 구현된 Promise 객체를 리턴한다. Promise 객체를 파이프라인이 다시 받아도 다시 비동기를 제어한다. 따라서 Promise가 지원되지 않는 환경에서도 파이프라인식의 비동기 제어가 가능하다.</p><h3 id="중간에-멈추고-나가기"><a href="#중간에-멈추고-나가기" class="headerlink" title="중간에 멈추고 나가기"></a>중간에 멈추고 나가기</h3><p>일반 함수에서는 함수 중간 어디서든 return문으로 함수를 빠져 나올 수 있다. Partial.js는 파이프라인에서도 이와 같은 일이 가능하도록 지원하는데, 바로 _.stop이라는 함수를 이용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  null,</span><br><span class="line">  function () &#123; console.log(1) &#125;,</span><br><span class="line">  function () &#123; console.log(2) &#125;,</span><br><span class="line">  function () &#123; return _.stop() &#125;,</span><br><span class="line">  function () &#123; console.log(3) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>1과 2만 찍힌 후 세번째 함수는 실행되지 않고 파이프라인 전체를 나오게 된다. _.go의 최종 결과도 함께 전달하고 싶다면 _.stop 함수에게 전달하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var result = _.go(</span><br><span class="line">  null,</span><br><span class="line">  function () &#123; console.log(1) &#125;,</span><br><span class="line">  function () &#123; console.log(2) &#125;,</span><br><span class="line">  function () &#123; return _.stop(&quot;Hi&quot;) &#125;,</span><br><span class="line">  function () &#123; console.log(3) &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(result); // Hi</span><br></pre></td></tr></table></figure><h2 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h2><h3 id="코드-변경없이-비동기-제어가-되는-고차-함수"><a href="#코드-변경없이-비동기-제어가-되는-고차-함수" class="headerlink" title="코드 변경없이 비동기 제어가 되는 고차 함수"></a>코드 변경없이 비동기 제어가 되는 고차 함수</h3><p>Partial.js의 _.each, _.map, _.reduce 등의 주요 함수들은 _.go와 _.pipe 처럼 하나의 함수로 동기와 비동기 상황이 모두 대응되도록 되어 있다. Partial.js의 함수를 이용하면 비동기 상황에서도 동기 상황과 동일한 코드를 작성할 수 있고, 비동기 함수와 동기 함수의 조합도 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">console.log(JSON.stringify(_.map([1, 2, 3], function (v) &#123;</span><br><span class="line">  return new Date();</span><br><span class="line">&#125;)))</span><br><span class="line"></span><br><span class="line">//  [&quot;2019-12-01T08:20:00.422Z&quot;,&quot;2019-12-01T08:20:00.422Z&quot;,&quot;2019-12-01T08:20:00.422Z&quot;]</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">_.map([1, 2, 3], function () &#123;</span><br><span class="line">  return new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      resolve(new Date())</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(function (result) &#123;</span><br><span class="line">  console.log(JSON.stringify(result))</span><br><span class="line">&#125;)</span><br><span class="line">// [&quot;2019-12-01T08:20:01.424Z&quot;,&quot;2019-12-01T08:20:02.424Z&quot;,&quot;2019-12-01T08:20:03.428Z&quot;]</span><br></pre></td></tr></table></figure><p>같은 _.map 함수지만 1은 즉시 완료되었고, 2는 3초 정도의 시간이 걸려 완료되었다. Partial.js의 _.each, _.map, _.reduce 등은 첫 번째 iteratee의 결과가 Promise 객체일 경우 내부적으로 for문 대신 재귀로 변경된다. 2의 경우 iteratee가 각각 모두 1초 정도의 시간이 걸렸기 때문에 배열에 1초 정도의 차이를 가진 값들이 담겼다.<br>위 코드는 둘 다 동일한 _.map 함수로 작성하기는 했지만 동기 상황의 코드와 비동기 상황의 전체적인 코드 구조가 다르다. _.go, _.pipe 등을 이용하면 두 가지 코드 모두 동일한 구조를 갖도록 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">_.go(</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  _.map(function () &#123; return new Date() &#125;),</span><br><span class="line">  JSON.stringify,</span><br><span class="line">  console.log</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">_.go(</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  _.map(function () &#123;</span><br><span class="line">    return new Promise(function (resolve) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        resolve(new Date())</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;),</span><br><span class="line">  JSON.stringify,</span><br><span class="line">  console.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>_.map의 iteratee에서 Promise 함수가 아닌 일반 비동기 함수를 사용해야 한다면 다음과 같이 사용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  _.map(_.callback(function (val, i, list, next) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      next(new Date());</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)),</span><br><span class="line">  JSON.stringify,</span><br><span class="line">  console.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>마지막 인자로 next가 들어오고 next를 통해 결과를 전달하면, 그 결과가 하나씩 _.map의 결과인 새로운 배열에 쌓여간다. new Promise를 사용하는 것 보다 간결하다.</p><p>Partial.js는 iteratee의 결과나 iteratee의 속성에 따라 동기 로직과 비동기 로직을 알아서 선택하도록 되어있다. 동기 로직으로 돌아가야 할 경우에는 for문을 사용하고 비동기 로직을 사용해야 할 경우에만 재귀로 변경되기 때문에 성능적으로도 문제가 없다.</p><h3 id="비동기-결과를-기다리는-if문-if"><a href="#비동기-결과를-기다리는-if문-if" class="headerlink" title="비동기 결과를 기다리는 if문, _.if"></a>비동기 결과를 기다리는 if문, _.if</h3><p>아래 is_1, is_2 함수는 결과를 즉시 리턴하는 함수다. 아래와 같은 함수는 if문과 같은 조건절에서 사용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var is_1 = function (a) &#123;</span><br><span class="line">  return a === 1;</span><br><span class="line">&#125;;</span><br><span class="line">var is_2 = function (a) &#123;</span><br><span class="line">  return a === 2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test1(a) &#123;</span><br><span class="line">  if (is_1(a)) return &apos;1입니다.&apos;</span><br><span class="line">  else if (is_2(a)) return &apos;2입니다.&apos;</span><br><span class="line">  else return &apos;1도 아니고 2도 아닙니다.&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(test1(2)); // 2입니다.</span><br></pre></td></tr></table></figure><p>그런데 만약 is_1과 같은 함수가 즉시 값을 리턴할 수 없고, 데이터베이스에 다녀와야 하거나 HTTP 통신이 있어야 하면 상황은 달라진다. 자바스크립트에서는 아래와 같은 상황을 if문으로 제어할 수 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var is_1_async = function (a) &#123;</span><br><span class="line">  return new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      resolve(a === 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var is_2_async = function (a) &#123;</span><br><span class="line">  return new Promise(function (resolve) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      resolve(a === 2);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test2(a) &#123;</span><br><span class="line">  if (is_1_async(a)) return &apos;1입니다.&apos;</span><br><span class="line">  else if (is_2_async(a)) return &apos;2입니다.&apos;</span><br><span class="line">  else return &apos;1도 아니고 2도 아닙니다.&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(test2(2)); // 1입니다. (정상적으로 동작하지 않음)</span><br></pre></td></tr></table></figure><p>is_1_async 함수의 진짜 결과는 false이겠지만  is_1_async가 즉시 Promise 객체를 리턴하기 때문에 if의 조건문 입장에서는 true가 된다. is_1_async가 콜백 패턴으로 이루어진 일반 함수 였다고 하더라고, undefined가 즉시 리턴될 것이므로 역시 정상적인 결과를 만들수 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var test4 =</span><br><span class="line">  _.if(is_1_async, function () &#123; return &apos;1입니다.&apos; &#125;)</span><br><span class="line">    .else_if(is_2_async, function () &#123; return &apos;2입니다.&apos; &#125;)</span><br><span class="line">    .else(function () &#123; return &apos;1도 아니고 2도 아닙니다. &apos; &#125;);</span><br><span class="line"></span><br><span class="line">test4(2).then(console.log); // 2입니다.</span><br></pre></td></tr></table></figure><p>위 함수는 동기 함수를 사용했던 test1과 유사한 구조를 가지고 있다. _.constant나 화살표 함수를 사용하면 더욱 간결해진다. _.go와 함께 사용한 버전도 확인해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var test5 =</span><br><span class="line">  _.if(is_1_async, _.constant(&apos;1입니다.&apos;))</span><br><span class="line">    .else_if(is_2_async, _.constant(&apos;2입니다.&apos;))</span><br><span class="line">    .else(_.constant(&apos;1도 아니고 2도 아닙니다. &apos;));</span><br><span class="line"></span><br><span class="line">test5(2).then(console.log);</span><br><span class="line"></span><br><span class="line">// 화살표함수</span><br><span class="line">var test6 =</span><br><span class="line">  _.if(is_1_async, () =&gt; &apos;1입니다.&apos;)</span><br><span class="line">    .else_if(is_2_async, () =&gt; &apos;2입니다.&apos;)</span><br><span class="line">    .else(() =&gt; &apos;1도 아니고 2도 아닙니다. &apos;);</span><br><span class="line">test6(1).then(console.log)</span><br><span class="line"></span><br><span class="line">// _.go</span><br><span class="line">_.go(</span><br><span class="line">  3,</span><br><span class="line">  _.if(is_1_async, _.constant(&apos;1입니다.&apos;))</span><br><span class="line">    .else_if(is_2_async, _.constant(&apos;2입니다.&apos;))</span><br><span class="line">    .else(_.constant(&apos;1도 아니고 2도 아닙니다. &apos;)),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>동기와 비동기 상황을 동시에 대응하는 함수를 쉽게 만드는 팁이 있다. 해당 함수의 로직을 _.go나 _.pipe로 구현해 두는 것이다. 그렇게 하면 자동으로 동기 상황과 비동기 상황에 맞춰 로직을 알아서 변경시키기 때문에 추가적인 다른 작업을 하지 않아도 된다.</p><h2 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h2><h3 id="all-spread"><a href="#all-spread" class="headerlink" title="_.all, _.spread"></a>_.all, _.spread</h3><p>이 두 함수는 파이프라인과 함께 사용할 때 유용한 함수다. _.all과 _.spread 모두 받은 인자를 받은 함수들에게 전달하는 함수들인데, _.all은 받은 모든 인자를 모든 함수들에게 동일하게 전달하고, _.spread는 받은 인자들을 하나씩 나눠 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.all(10, 5, [</span><br><span class="line">  function (a, b) &#123; return a + b &#125;,</span><br><span class="line">  function (a, b) &#123; return a - b &#125;,</span><br><span class="line">  function (a, b) &#123; return a * b &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">_.spread(10, 5, [</span><br><span class="line">  function (a) &#123; return a * a &#125;,</span><br><span class="line">  function (b) &#123; return b * b &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>_.all은 받아 둔 모든 인자를 마지막 인자로 들어온 배열 안에 있는 모든 함수들에게 동일하게 전달한다. _.spread는 받은 인자를 하나씩 나눠서, 받은 함수들에게 하나씩 전달하는 함수다.<br>_.all과 _.spread에게 인자 전달 없이 함수들만 전달하면 함수를 리턴하는 함수로 동작하여 파이프라인 등에서 사용하기 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  10,</span><br><span class="line">  _.all(</span><br><span class="line">    function (a) &#123; return a + 5 &#125;,</span><br><span class="line">    function (a) &#123; return a - 5 &#125;,</span><br><span class="line">    function (a) &#123; return a * 5 &#125;</span><br><span class="line">  ),</span><br><span class="line">  _.spread(</span><br><span class="line">    function (a) &#123; return a + 1 &#125;,</span><br><span class="line">    function (b) &#123; return b + 2 &#125;,</span><br><span class="line">    function (c) &#123; return c + 3 &#125;</span><br><span class="line">  ),</span><br><span class="line">  console.log</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 16 7 53</span><br></pre></td></tr></table></figure><h2 id="파이프라인2"><a href="#파이프라인2" class="headerlink" title="파이프라인2"></a>파이프라인2</h2><h3 id="go에서-this-사용"><a href="#go에서-this-사용" class="headerlink" title="_.go에서 this 사용"></a>_.go에서 this 사용</h3><p>Partial.js의 _.pipe가 this를 지원하는 것을 확인했었다. _.go에서도 this 지원이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123; name: &quot;Cojamm&quot; &#125;;</span><br><span class="line">_.go.call(user, 32,</span><br><span class="line">  function (age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    this.job = &quot;Rapper&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(user); // &#123;name: &quot;Cojamm&quot;, age: 32, job: &quot;Rapper&quot;&#125;</span><br></pre></td></tr></table></figure><p>_.go.call의 call은 Fucntion.prototype.call 이다. _.go는 일반 함수이므로 call을 사용하는게 자연스럽다. _.go 는 call을 통해 전달받은 this를 파이프라인 내 함수들에게 전달한다. apply 역시 사용할 수 있다.</p><h3 id="또-다른-파이프라인-indent"><a href="#또-다른-파이프라인-indent" class="headerlink" title="또 다른 파이프라인, _.indent"></a>또 다른 파이프라인, _.indent</h3><p>자바스크립트에서는 부모 스코프와 자식 스코프라는 개념이 있다. 자식 스코프는 부모 스코프의 지역 변수를 참조할 수 있다. 이러한 중첩 구조의 접근 방식이 파이프라인 내에서도 필요했는데, 이를 위한 함수가 바로 _.indent다. _.indent는 이름처럼 _.indent가 중첩될 때마다 this와 arguments를 한 단계씩 안으로 들여쓰는 콘셉트를 가지고 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var f1 = _.indent(</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this, arguments); // 1</span><br><span class="line">    return &apos;hi&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this, arguments) // 2</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f1(1, 2);</span><br></pre></td></tr></table></figure><p>_.indent는 _.pipe처럼 함수를 리턴하는 파이프라인이다. 함수들의 연속 실행이 준비된 함수를 리턴하여 f1에 담았고 실행했다.<br>1과 2의 결과에는 차이가 있다. console.log 에게 두 번째 인자로 넘긴 arguments에 담긴 값이 다르다. 1은 파이프라인의 첫 번째 함수이기에 f1을 통해 넘겨진 인자 [1,2]가 arguments에 들어온다. 2는 두 번째 함수이고, 이전 함수에서 ‘hi’를 리턴했기에 [‘hi’]가 arguments에 담겨 있다.<br>파이프라인으로 코딩하다 보면 파이프라인의 최초 함수가 아닌 중간에 있는 함수에서 파이프라인이 최초로 받은 인자를 알고 싶을 때가 있다. 이것은 클로저를 사용하는 것으로도 자연스럽게 해결된다.<br>_.indent의 해결법은 파이프라인 내부의 함수들은 중간 어디서든 this.arguments로 파이프라인의 최초 인자들에 접근할 수 있다.</p><p>_.indent의 this는 한 번의 파이프라인 사용 후 휘발되는 this다. 파이프라인 전체에서 공유하고자 하는 값이 있을 때 값을 이어주는 식으로 사용할 수도 있다. 또한 인스턴스를 만들어 두고 계속 사용하는 this가 아닌, 함수를 실행할 때마다 새로 생겼다 사라지는 this이므로 부수효과가 최소화되고 메모리 사용에도 문제가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f2 = _.indent(</span><br><span class="line">  function (a) &#123; this.b = a + 10; &#125;,</span><br><span class="line">  function () &#123; &#125;,</span><br><span class="line">  function () &#123; &#125;,</span><br><span class="line">  function () &#123; console.log(this.b) &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f2(5); // 15</span><br><span class="line">f2(7); // 17</span><br></pre></td></tr></table></figure><p>_.indent에서 this는 이번에 실행할 때 열린 부모 스코프를 대신하는 역할이므로, 그 this의 key/value를 확장한다는 것은 새로운 변수를 할당하는 것 이라고 볼 수 있다. this에 값을 단 후 값을 변경하지 않는다면 부수 효과로부터 자유로워진다. 하나의 큰 함수 안에서 변수에 담고 그 변수에 담긴 값을 변경하지 않는 것과 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var f3 = _.indent(</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    this.b = a + 10;</span><br><span class="line">  &#125;,</span><br><span class="line">  _.indent(</span><br><span class="line">    function () &#123;</span><br><span class="line">      this.b = 20;</span><br><span class="line">      console.log(this.b); // 20</span><br><span class="line">      console.log(this.parent.b) // 15</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123;</span><br><span class="line">      console.log(this.parent.arguments); // [5]</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  function () &#123;</span><br><span class="line">    console.log(this.b);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f3(5);</span><br></pre></td></tr></table></figure><p>parent를 통해 부모를 찾아갈 수 있고, this.parent.arguments로 파이프라인의 최초 인자도 찾아갈 수 있다. 자바스크립트에서 값에 접근할 수 있다는 것은 값을 변경할 수도 있다는 의미이므로 위험하다. 이것은 모든 값 혹은 변수에 해당하는 이야기다. 그러나 값을 참조하는 식으로 접근한다면, 여기저기에서 값에 접근할 수 있다는 것 자체는 문제가 되지는 않는다.</p><h3 id="무조건-비동기로-동작하는-async"><a href="#무조건-비동기로-동작하는-async" class="headerlink" title="무조건 비동기로 동작하는 _.async"></a>무조건 비동기로 동작하는 _.async</h3><p>_.go, _.pipe, _.indent는 파이프라인 내부의 함수에서 비동기 결과가 나올 경우 비동기 제어를 시작하도록 구현되어 있다. 그러므로 비동기 상황이 생기지 않는다면 즉시 일반 값이 리턴되고, 비동기 상황이 생겼을 때만 Promise 객체가 리턴된다. 때로는 내부 함수의 결과와 상관없이 무조건 비동기를 일으키고 싶을 때가 있다. _.async는 이럴 때 사용하기 적합한, 무조건 비동기로 동작하는 파이프라인이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go.async(1, function (a) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;).then(console.log);</span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;파이프라인&quot;&gt;&lt;a href=&quot;#파이프라인&quot; class=&quot;headerlink&quot; title=&quot;파이프라인&quot;&gt;&lt;/a&gt;파이프라인&lt;/h2&gt;&lt;h3 id=&quot;즉시-실행-파이프라인-go와-mr&quot;&gt;&lt;a href=&quot;#즉시-실행-파이프라인-go와-mr&quot; class=&quot;headerlink&quot; title=&quot;즉시 실행 파이프라인, _.go와 _.mr&quot;&gt;&lt;/a&gt;즉시 실행 파이프라인, _.go와 _.mr&lt;/h3&gt;&lt;p&gt;_.go는 파이프라인의 즉시 실행 버전이다. 첫 번째 인자로 받은 값을 두 번째 인자로 받은 함수에게 넘겨주고, 두 번째 인자로 받은 함수의 결과는 세 번째 함수에게 넘겨준다. 이것을 반복하다가 마지막 함수의 결과를 리턴해 준다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_.go(10, // 첫번째 인자&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function (a) &amp;#123; return a * 10 &amp;#125;, // 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function (a) &amp;#123; return a - 50 &amp;#125;, // 50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function (a) &amp;#123; return a + 10 &amp;#125; // 60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;_.go는 Multiple Results를 지원한다. _.mr 함수를 함께 사용하면 다음 함수에게 2개 이상의 인자들을 전달할 수 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="파이프라인" scheme="https://kkangil.github.io/tags/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/"/>
    
      <category term="go 함수" scheme="https://kkangil.github.io/tags/go-%ED%95%A8%EC%88%98/"/>
    
      <category term="비동기와 _.go" scheme="https://kkangil.github.io/tags/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%99%80-go/"/>
    
      <category term="_.indent" scheme="https://kkangil.github.io/tags/indent/"/>
    
  </entry>
  
  <entry>
    <title>함수 조립하기</title>
    <link href="https://kkangil.github.io/2019/11/17/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD%ED%95%98%EA%B8%B0/"/>
    <id>https://kkangil.github.io/2019/11/17/함수-조립하기/</id>
    <published>2019-11-17T05:49:58.000Z</published>
    <updated>2019-12-01T09:41:21.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수-조립하기"><a href="#함수-조립하기" class="headerlink" title="함수 조립하기"></a>함수 조립하기</h1><p>함수형 자바스크립트 기법을 잘 활용하면 소프트웨어의 기능을 변경하거나 추가하기가 쉽다. 작은 단위로 쪼갠 함수들을 조합하여 큰 기능을 만들면 조합된 함수 사이사이에 새로운 함수를 추가하는 식으로 쉽게 확장해 나갈 수 있다.</p><p>함수형 자바스크립트 10가지 기법</p><ol><li>함수를 되도록 작게 만들기</li><li>다형성 높은 함수를 만들기</li><li>상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화하기</li><li>동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기</li><li>복잡한 객체 하나를 인자로 사용하기보다는 되도록 일반적인 값 여러개를 인자로 사용하기</li><li>큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기</li></ol><a id="more"></a><ol start="7"><li>어느 곳에서든 바로 실행하거나 혹은 미뤄서 실행할 수 있도록 일반 함수이자 순수 함수로 선언하기</li><li>모델이나 컬렉션 등의 커스텀 객체보다는 기본 객체를 이용하기</li><li>로직의 흐름을 최대한 단방향으로 흐르게 하기</li><li>작은 함수를 모아 큰 함수를 만들기</li></ol><p>이번 장에서는 작은 함수로 큰 함수를 만드는 방법들을 다룬다. 객체지향에 빗대어 표현하면 클래스와 인스턴스에 대해서 처음 다루는 장이라고 할 수도 있겠다.</p><h2 id="고차-함수와-보조-함수"><a href="#고차-함수와-보조-함수" class="headerlink" title="고차 함수와 보조 함수"></a>고차 함수와 보조 함수</h2><p>이번 장에서는 고차 함수의 다양한 사례를 통해 함수 조립에 대한 생각들을 확장하고자 한다. 함수를 주재료로 다루는 함수들을 다룰 것이다.</p><h3 id="한-번만-실행하는-함수"><a href="#한-번만-실행하는-함수" class="headerlink" title="한 번만 실행하는 함수"></a>한 번만 실행하는 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_.once = function (func) &#123;</span><br><span class="line">  var flag, result;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (flag) return result;</span><br><span class="line">    flag = true;</span><br><span class="line">    return result = func.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hi = _.once(function () &#123;</span><br><span class="line">  console.log(&apos;hi&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hi();</span><br><span class="line">// hi</span><br><span class="line">hi();</span><br><span class="line">// 아무일도 일어나지 않음</span><br></pre></td></tr></table></figure><p>_.once는 받아 둔 익명 함수가 한 번만 실행되도록 설정된 함수를 리턴한다. 이런 기능을 구현하기 위해서는 flag 값이 필요하며 flag 값에 따라 실행할 것인지 말 것인지 대해 판단하는 로직이 어딘가에 있어야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = _.once(function () &#123;</span><br><span class="line">  console.log(&apos;A&apos;);</span><br><span class="line">  return &apos;B&apos;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(a());</span><br><span class="line">// A</span><br><span class="line">// B</span><br><span class="line">console.log(a());</span><br><span class="line">// B</span><br></pre></td></tr></table></figure><h3 id="다시-물어-보지-않는-함수"><a href="#다시-물어-보지-않는-함수" class="headerlink" title="다시 물어 보지 않는 함수"></a>다시 물어 보지 않는 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function skip(body) &#123;</span><br><span class="line">  var yes;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return yes || (yes = body.apply(null, arguments));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최초 한번만 실행을 하고 그 이후로는 실행이 되지 않는다. skip은 고차 함수이고 body는 skip이 남겨 놓은 로직을 완성하는 함수다. 함수형 자바스크립트는 함수로 함수를 다루거나 함수로 함수를 만드는 것의 반복이고, 고차 함수 응용의 반복이다.<br>skip은 고차 함수이자 함수를 만드는 함수다. 함수로 함수를 만들 때는 재료로 함수가 사용되기도 하고 일반 값이 사용되기도 한다. 함수로 만들어진 함수는 대부분 클로저다.</p><h3 id="앞서-받은-인자-혹은-상황을-변경해-나가는-경우"><a href="#앞서-받은-인자-혹은-상황을-변경해-나가는-경우" class="headerlink" title="앞서 받은 인자 혹은 상황을 변경해 나가는 경우"></a>앞서 받은 인자 혹은 상황을 변경해 나가는 경우</h3><p>skip같은 함수는 앞서 만든 상황을 변경해 나가는 사례다. 처음에는 false로 시작했지만 true로 변경하여 이후 동작을 다르게 만들기 위해 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function idMaker(start) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return ++start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var messageCid = idMaker(0);</span><br><span class="line">messageCid();</span><br><span class="line">// 1</span><br><span class="line">messageCid();</span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">var postCid = idMaker(11);</span><br><span class="line">postCid()</span><br><span class="line">// 12</span><br><span class="line">postCid()</span><br><span class="line">// 13</span><br></pre></td></tr></table></figure><p>idMaker는 원하는 시작점부터 시작해 실행할 때마다 증가한 고유한 아이디 값을 만드는 함수를 만드는 함수다. idMaker는 메신저 등을 만들 때 사용할 수 있다. 사용자가 메시지를 입력하고 엔터 키를 쳤을 때, 임시로 클라이언트 측 고유 아이디를 만들어 메시지에 해당하는 HTML 요소를 즉시 그려 둔 다음, 서버에게 정보를 보내어 DB에 저장하고 응답으로 온 데이터를, 만들어 두었던 클라이언트 측 고유 아이디를 기준으로 매핑한다.</p><h3 id="앞서-받은-인자를-잘-유지해야-하는-경우"><a href="#앞서-받은-인자를-잘-유지해야-하는-경우" class="headerlink" title="앞서 받은 인자를 잘 유지해야 하는 경우"></a>앞서 받은 인자를 잘 유지해야 하는 경우</h3><p>클로저가 기억하고 있는 외부 변수도 일반 변수처럼 언제든지 값이 변경될 수 있다. 앞선 _.once, skip, idMaker 사례는 값이 변경되는 점을 이용한 기법이다. 이번에는 반대로 값을 잘 유지해야 하는 상황을 살펴 볼 텐데, 이런 상황에서 실수가 많이 생긴다.</p><p>특히 앞서 받은 인자와 나중에 받은 인자를 조합하여 결과를 만들려고 할 때는 실수하기가 쉽다. 이럴 때는 계속 사용할 객체는 원래 상태를 잘 유지하도록, 한 번만 쓰이고 사라져야 할 값은 사라지도록 잘 관리해 주어야 한다.</p><p>앞서 받은 인자의 상태가 변경되지 않도록 concat이나 slice를 이용해 항상 새로운 객체를 만든다거나, _.rest 같은 함수를 이용해 인자의 일부분을 잘 제외시켜야 하는데, 이 것을 어떤 타이밍에 하는지가 중요하다.</p><h2 id="부분-적용"><a href="#부분-적용" class="headerlink" title="부분 적용"></a>부분 적용</h2><h3 id="partial로-함수-만들기"><a href="#partial로-함수-만들기" class="headerlink" title="_.partial로 함수 만들기"></a>_.partial로 함수 만들기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var pc = _.partial(console.log, 1);</span><br><span class="line">pc(2);</span><br><span class="line">// 2가 오른쪽으로 들어감</span><br><span class="line">pc(2, 3);</span><br><span class="line">// 2, 3이 오른쪽으로 들어감</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, 2);</span><br><span class="line">pc(1);</span><br><span class="line">// 1, 2 1이 왼쪽의 _ 자리에 들어감</span><br><span class="line">pc(1, 3);</span><br><span class="line">// 1 2 3  1이 왼쪽의 _자리에 들어가고 3이 오른쪽으로 들어감</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, _, 3);</span><br><span class="line">pc(1);</span><br><span class="line">// 1 undefined 3 1이 왼쪽 _ 자리에 들어가고 두 번째 _는 들어오지 않아 undefined 가 됨</span><br><span class="line">pc(1, 2);</span><br><span class="line">// 1 2 3 1과 2가 순서대로 _, _ 를 채움</span><br><span class="line">pc(1, 2, 4);</span><br><span class="line">// 1 2 3 4 1과 2가 순서대로 _, _를 채우고 3의 오른쪽으로 4가 들어감</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, 2, _, _, 5);</span><br><span class="line">pc(1, 3, 4, 6)</span><br><span class="line">// 1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>_.partial 함수를 이용하면 원하는 위치에 인자를 부분적으로 적용할 수 있다. _.partial을 활용한 다양한 함수 조립 사례를 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var add_all = _.partial(_.reduce, _, function (a, b) &#123; return a + b &#125;);</span><br><span class="line">console.log(add_all([1, 2, 3, 4]));</span><br><span class="line">// 10</span><br><span class="line">console.log(add_all([5, 2]));</span><br><span class="line">// 7</span><br></pre></td></tr></table></figure><p>_.partial은 함수를 다루는 고차 함수다. _.reduce도 고차 함수다. 위 코드 처럼 _.partial을 이용해 _.reduce와 같은 고차 함수에 미리 보조 함수를 적용해 두는식으로 add_all 같은 함수를 구현할 수 있다.</p><p>_.partial은 정말 강력하다. _.partial을 이용하면, 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var method = function (obj, method) &#123;</span><br><span class="line">  return obj[method].apply(obj, _.rest(arguments, 2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var push = _.partial(method, _, &apos;push&apos;);</span><br><span class="line">var shift = _.partial(method, _, &apos;shift&apos;);</span><br><span class="line"></span><br><span class="line">var a = [1, 2];</span><br><span class="line">push(a, 3);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">shift(a);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">var b = method([1, 2, 3], &apos;concat&apos;, 4, 5);</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure><p>이번 method 함수로 함수를 만드는 함수가 아닌 혼자서도 실행할 수 있는 일반 함수가 되었다. 이러한 방식의 이점은 method 같은 함수가 혼자서도 활용 가능한 함수가 된다는 점이다.</p><h3 id="partial과-compose로-함수-만들기"><a href="#partial과-compose로-함수-만들기" class="headerlink" title="_.partial과 _.compose로 함수 만들기"></a>_.partial과 _.compose로 함수 만들기</h3><p>_.partial은 함수를 연속으로 실행해 주는 _.compose 등의 함수와 함께 더 재미있게 사용할 수 있다. _.compose는 오른쪽의 함수를 실행한 결과를 왼쪽의 함수에게 전달하는 것을 반복하는 고차 함수이다. _.compose는 인자로 함수만 받는 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_.compose(console.log, function (a) &#123; return a - 2 &#125;, function (a) &#123; return a + 5 &#125;)(0);</span><br><span class="line">// console.log &lt;- 5 - 2 &lt;- 0 + 5 &lt;- 0</span><br><span class="line"></span><br><span class="line">var falsy_values = _.compose(</span><br><span class="line">  _.partial(_.isEqual, -1), // 1</span><br><span class="line">  _.partial(_.findIndex, _, _.identity) // 2</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(falsy_values([1, true, &#123;&#125;]));</span><br><span class="line">// false</span><br><span class="line">console.log(falsy_values([0, 1, false]));</span><br><span class="line">// false</span><br><span class="line">console.log(falsy_values([0, &quot;&quot;, false]));</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">var some = _.negate(falsy_values); // 3</span><br><span class="line">console.log(some([1, true, &#123;&#125;]));</span><br><span class="line">// true</span><br><span class="line">console.log(some([0, 1, false]));</span><br><span class="line">// true</span><br><span class="line">console.log(some(0, &quot;&quot;, false));</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">var every = _.compose(</span><br><span class="line">  _.partial(_.isEqual, -1),</span><br><span class="line">  _.partial(_.findIndex, _, _.negate(_.identity)) // 4</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(every([1, true, &#123;&#125;]));</span><br><span class="line">// true</span><br><span class="line">console.log(every([0, 1, false]));</span><br><span class="line">// false</span><br><span class="line">console.log(every([0, &quot;&quot;, false]));</span><br><span class="line">// false</span><br></pre></td></tr></table></figure><ol><li>_.isEqual 함수에 -1을 부분 적용하여, 앞에서 나온 결과가 -1과 같은지를 검사하는 함수 만들기</li><li>-1 과 비교하는 함수가 실행되기 전에는 _.findIndex에 _.identity 를 부분 적용해 둔 함수가 실행된다. _.findIndex는 긍정적인 값을 처음 만났을 때의 index를 리턴한다. _.compose 를 통해 두 함수를 역순으로 나열했고, falsy_values 는 배열에 들어있는 모든 값이 부정적인 값인지를 판단하는 함수가 된다.</li><li>받은 함수를 실행한 후, 결과를 반대로 만드는 함수를 리턴하는 함수인 _.negate 와 앞서 조합한 falsy_values를 조합하여 하나라도 긍정적인 값이 있는지를 체크하는 some 함수를 만들었다.</li><li>falay_values를 조합던 코듸의 _.identity 부분만 _.negate로 감싸서 모두 긍정적인 값이 맞는지를 체크하는 every 함수</li></ol><h3 id="더-나은-partial-함수"><a href="#더-나은-partial-함수" class="headerlink" title="더 나은 _.partial 함수"></a>더 나은 _.partial 함수</h3><p>_.partial은 인자를 왼쪽에서부터 하나씩 적용하면서 _로 구분하여 인자가 적용될 위치를 지정해 둘 수 있도록 한다. 이런 _.partial에도 한 가지 아쉬움이 있다. 자바스크립트 함수는 인자 개수가 유동적일 수 있고 함수의 마지막 인자를 중요하게 사용할 수도 있는데, 이 같은 함수화 _.partial은 합이 잘 맞지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function m() &#123;</span><br><span class="line">  var iter = arguments[arguments.length - 1];</span><br><span class="line">  arguments.length--;</span><br><span class="line">  return _.reduce(arguments, iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m(100, 50, add);</span><br><span class="line">// 150</span><br><span class="line">m(100, 50, 10, add);</span><br><span class="line">// 160</span><br><span class="line">m(100, 50, sub);</span><br><span class="line">// 50</span><br><span class="line">m(100, 50, 10, sub);</span><br><span class="line">// 40</span><br><span class="line"></span><br><span class="line">var f1 = _.partial(m, _, _, _, add);</span><br><span class="line">// f1 은 3개의 인자만 더할 수 있다.</span><br><span class="line">f1(1, 1, 1);</span><br><span class="line">// 3</span><br><span class="line">f1(1, 1);</span><br><span class="line">// NaN</span><br><span class="line">f1(1, 1, 1, 1);</span><br><span class="line">// _.reduce에 1이 넘어가면서 에러</span><br></pre></td></tr></table></figure><p>f1의 상황처럼 인자를 유동적으로 다루는 함수는 _.partial로 다루기 좋지 않다. 맨 왼쪽 인자나 맨 왼쪽에서 두 번째 인자를 적용해 두는 것은 가능하지만 맨 오른쪽 인자나 맨 오른쪽에서 두 번째에만 인자를 적용해 두는것은 불가능 하기 때문이다. Lodash 는 이를 위해 _.partialRight를 구현했지만 양쪽 끝 모두를 부분 적용하고, 가운데 부분을 가변적으로 가져가고 싶을 때도 있기에 아직 아쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var ___ = &#123;&#125;;</span><br><span class="line">_.partial = function (fn) &#123;</span><br><span class="line">  var args1 = [], args3, len = arguments.length, ___idx = len;</span><br><span class="line">  for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">    var arg = arguments[i];</span><br><span class="line">    if (arg == ___ &amp;&amp; (___idx = i) &amp;&amp; (args3 = [])) continue;</span><br><span class="line">    if (i &lt; ___idx) args1.push(arg);</span><br><span class="line">    else args3.push(arg);</span><br><span class="line">  &#125;</span><br><span class="line">  return function () &#123; return fn.apply(this, mergeArgs(args1, arguments, args3)) &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function _toUndef(args1, args2, args3) &#123;</span><br><span class="line">  if (args2) args1 = args1.concat(args2);</span><br><span class="line">  if (args3) args1 = args1.concat(args3);</span><br><span class="line">  for (var i = 0, len = args1.length; i &lt; len; i++)</span><br><span class="line">    if (args1[i] == _) args1[i] = undefined;</span><br><span class="line">  return args1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mergeArgs(args1, args2, args3) &#123;</span><br><span class="line">  if (!args2.length) return args3 ? _toUndef(args1, args3) : _toUndef(args1.slice());</span><br><span class="line"></span><br><span class="line">  var n_args1 = args1.slice(), args2 = _.toArray(args2), i = -1, len = n_args1.length;</span><br><span class="line">  while (++i &lt; len) if (n_args1[i] == _) n_args1[i] = args2.shift();</span><br><span class="line">  if (!args3) return _toUndef(n_args1, args2.length ? args2 : undefined);</span><br><span class="line"></span><br><span class="line">  var n_arg3 = args3.slice(), i = n_arg3.length;</span><br><span class="line">  while (i--) if (n_arg3[i] == _) n_arg3[i] = args2.pop();</span><br><span class="line">  return args2.length ? _toUndef(n_args1, args2, n_arg3) : _toUndef(n_args1, n_arg3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>복잡해 보이지만 생각보다 단순하다. 우선 새로운 구분자인 <strong>_ 가 추가 되었다. _.partial을 실행하면 _</strong>를 기준으로 왼편의 인자들을 왼쪽부터 적용하고 오른편의 인자들을 오른쪽부터 적용할 준비를 해 둔 함수를 리턴한다. 부분 적용된 함수를 나중에 실행하면 그때 받은 인자들로 왼쪽과 오른쪽을 먼저 채운 후, 남은 인자들로 가운데 ___자리를 채운다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var pc = _.partial(console.log, ___, 2, 3);</span><br><span class="line">pc(1);</span><br><span class="line">// 1 2 3</span><br><span class="line">pc(1, 4, 5, 6);</span><br><span class="line">// 1 4 5 6 2 3</span><br><span class="line"></span><br><span class="line">var pc = _.partial(console.log, _, 2, ___, 5, _, 7);</span><br><span class="line">pc(1);</span><br><span class="line">// 1 2 5 undefined 7</span><br><span class="line">pc(1, 3, 4);</span><br><span class="line">// 1 2 3 5 4 7</span><br><span class="line">pc(1, 3, 4, 6, 8);</span><br><span class="line">// 1 2 3 4 6 5 8 7</span><br><span class="line"></span><br><span class="line">var add_all = _.partial(m, ___, add);</span><br><span class="line">add_all(1, 2, 3, 4);</span><br><span class="line"></span><br><span class="line">var sub10 = _.partial(m, ___, 10, sub);</span><br><span class="line">sub10(50, 20);</span><br></pre></td></tr></table></figure><p>_.partial을 이용하면 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있고, 코드에 함수 표현식이 나오는것도 많이 줄일 수 있다. 이렇게 하면 _.chain, _.compose, _.pipeline 등의 함수 합성 패턴과도 잘 어울리고 함수를 조립하는 것도 즐거워 진다. 함수에 인자를 미리 적용해 두는 기법은 비동기 상황에서도 효과적으로 쓰인다.</p><h2 id="연속적인-함수-실행"><a href="#연속적인-함수-실행" class="headerlink" title="연속적인 함수 실행"></a>연속적인 함수 실행</h2><h3 id="체인의-아쉬운점"><a href="#체인의-아쉬운점" class="headerlink" title="체인의 아쉬운점"></a>체인의 아쉬운점</h3><p>체인은 메서드를 연속적으로 실행하면서 객체의 상태를 변경해 나가는 기법이다. 체인은 표현력이 좋고 실행 순서를 눈으로 따라가기에도 좋다. 체인 방식은 많은 장점을 가지고 있지만 체인 방식으로만 모든 로직을 구현하기에는 다소 불편한 점이 있다.</p><p>체인 방식은 체인 객체가 가지고 있는 메서드만 이용할 수 있기 때문에 체인 객체와 연관 없는 로직이나 다른 재료를 중간에 섞어 사용하기 어렵다. 정해진 메서드나 규격에 맞춰서 사용해야 하기 때문에 인자를 자유롭게 사용하기 어렵고 다양한 로직을 만들기도 어렵다. 따라서 결과를 완성해 나가는 과정에서 체인을 끊어야 하는 경우가 많다.</p><p>체인 방식은 사용하기는 쉽지만 잘 만들어 두기는 어렵다. this만 리턴하면 되는데 뭐가 어렵냐고 할 수 있지만, 가만히 생각해 보면 잘 쓰이는 체인 API는 그렇게 많지 않다. 잘 쓰이는 체인 API가 되려면 우선 체인 패턴과 잘 어울리는 주제여야 한다.</p><p>체인 방식은 객체가 생성되어야만 메서드를 사용할 수 있기 때문에 반드시 생성 단계를 거쳐야 한다. 그리고 this 등의 상태와 흐름과 깊이에 의존하기 때문에 언제 어디서나 아무 때나 사용이 가능한 순수 함수보다는 접근성면에서 좀 불편하다.</p><h3 id="compose의-아쉬운-점"><a href="#compose의-아쉬운-점" class="headerlink" title="_.compose의 아쉬운 점"></a>_.compose의 아쉬운 점</h3><p>_.compose 함수는 디자인 패턴과 같은 특별한 개념이나 지식 없어도, 바로 코딩 및 설계가 가능하다는 장점이 있다. 인자와 결과만을 생각하면서 작은 함수들을 조합하면 된다. 몇 가지 아쉬운 점이 있는데 그중 가장 큰 아쉬움은, 함수 실행의 순서가 오른쪽에서부터 왼쪽이기 때문에 읽기가 어렵다는 점이다. 함수 실행을 중첩해서 하는 것과 코드의 표현력이 크게 다를 바가 없고, 기능적으로도 특별히 나을 점이 없다.</p><h3 id="파이프라인"><a href="#파이프라인" class="headerlink" title="파이프라인"></a>파이프라인</h3><p>파이프라인은 _.compose의 장점을 그대로 가지고 있다. _.compose와 기본적인 사용법은 동일하다. 다만, 함수 실행 방향은 왼쪽에서부터 오른쪽이다. 왼쪽에서부터 오른쪽, 위에서부터 아래로 표현되어 코드를 읽기 쉽다. 또한 체인과 달리 아무 함수나 사용할 수 있어 자유도가 높다. 여기서는 이런 파이프라인의 장점들을 살펴볼 것이다.</p><p>Michael Fogus의 _.pipeline </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_.pipeline = function () &#123;</span><br><span class="line">  var funs = arguments; // 1. 함수들</span><br><span class="line"></span><br><span class="line">  return function (seed) &#123; // 2. 첫 인자</span><br><span class="line">    return _.reduce(funs,</span><br><span class="line">      function (l, r) &#123; return r(l); &#125;, // 4. 모든 함수를 연속적으로 실행</span><br><span class="line">      seed) // 3. 첫 인자 전달</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var div_square = _.pipeline(</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return a / 2;</span><br><span class="line">  &#125;,</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return a * a;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(div_square(6));</span><br><span class="line">// 9</span><br></pre></td></tr></table></figure><p>_.pipeline은 _.reduce를 이용해서 만들어졌다. _.reduce는 정말 강력한 함수다. 위 상황에서 가지고 있는 데이터는 함수들이고 만들고자 하는 데이터는 최초 인자로부터 시작해 모든 함수를 통과한 마지막 결과이다.</p><ol><li>arguments를 지역 변수 funs에 담았다.</li><li>funs를 기억하는 함수를 리턴한다.</li><li>리턴된 함수가 나중에 실행되면 받은 인자인 seed를 _.reduce 의 마지막 인자로 넘겨주어 seed는 최초의 l이 된다.</li><li>예측해 보건대 l 은 left고 r은 right인 듯 하다. 오른쪽 함수를 r을 실행하며 왼쪽 함수의 결과 l을 넘겨주고 있다. funs의 개수만큼 반복되며 마지막 함수의 결과가 곧 _.pipeline으로 만든 함수의 결과가 된다.</li></ol><h3 id="클래스를-대신하는-파이프라인"><a href="#클래스를-대신하는-파이프라인" class="headerlink" title="클래스를 대신하는 파이프라인"></a>클래스를 대신하는 파이프라인</h3><p>_.pipeline은 작은 함수들을 모아 큰 함수를 만드는 함수다. 파이프라인은 클래스와 기능적인 면과 개념적인 면이 다르지만 비슷한 역할을 대신할 수 있다. 작은 함수들을 조합하여 큰 함수들을 만들고 함수 조합을 조금씩 변경하거나 추가하면서 새로운 로직을 만들어 갈 수 있다.</p><p>회원가입을 예로 들어 보자. 개인 회원과 기업 회원이 있다고 가정하면, 회원 가입과 관련된 작은 로직들을 작은 함수 단위로 쪼개어 나눈 후 약간 변경하여 조합하거나 더할 수 있고, 뺄 수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var users = [];</span><br><span class="line">var companies = [];</span><br><span class="line"></span><br><span class="line">function joined_at(attrs) &#123;</span><br><span class="line">  return _.extend(attrs, &#123; joined_at: new Date() &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function greeting(member) &#123;</span><br><span class="line">  return member.name + &quot; 회원님은 &quot; + member.id + &quot; 번째 회원이십니다. 환영합니다.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var join_user = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  function (member) &#123;</span><br><span class="line">    users.push(member);</span><br><span class="line">    member.id = users.length;</span><br><span class="line">    return member;</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var join_company = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  function (member) &#123;</span><br><span class="line">    companies.push(member);</span><br><span class="line">    member.id = companies.length;</span><br><span class="line">    return member;</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(join_user(&#123; name: &quot;ID&quot; &#125;));</span><br><span class="line">// ID 회원님은 1 번째 회원이십니다. 환영합니다.</span><br><span class="line">console.log(join_user(&#123; name: &quot;JI&quot; &#125;));</span><br><span class="line">// JI 회원님은 2 번째 회원이십니다. 환영합니다.</span><br><span class="line">console.log(join_company(&#123; name: &quot;MARPPLE&quot; &#125;));</span><br><span class="line">// MARPPLE 회원님은 1 번째 회원이십니다. 환영합니다.</span><br></pre></td></tr></table></figure><p>join_user와 join_company는 두 번째 함수만 다르고 첫 번째와 세 번째 함수는 동일하게 조합되었다. 위에서 부터 내려오면서 가입 날짜를 만들고 서로 다른 배열에 담은 후 인사말을 남기고 있다.<br>_.partial을 함께 이용하면 아래와 같은 표현이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function joined_at(attrs) &#123;</span><br><span class="line">  return _.extend(attrs, &#123; joined_at: new Date() &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function join(table, member) &#123;</span><br><span class="line">  table.push(member);</span><br><span class="line">  member.id = table.length;</span><br><span class="line">  return member;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function greeting(member) &#123;</span><br><span class="line">  return member.name + &quot; 회원님은 &quot; + member.id + &quot; 번째 회원이십니다. 환영합니다.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var join_user = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  _.partial(join, users),</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var join_company = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  _.partial(join, companies),</span><br><span class="line">  greeting</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이번에는 _.partial을 이용해 users에 담을지 companies에 담을지를 선택했다. 이런 방식은 로직을 단순하게 한다. 서로 다른 기능을 하지만 조건문이 없다. 각자 자신이 해야 할 일만 순서대로 수행할 뿐이다. 작은 함수는 작성이 쉽고 테스트도 쉬우면 오류도 적기 마련이다. 앞뒤로 받을 인자와 결과만을 생각하면서 문제를 작게 만들면 문제 해결도 쉬워진다.</p><h3 id="더-나은-파이프라인-그리고-Multiple-Results"><a href="#더-나은-파이프라인-그리고-Multiple-Results" class="headerlink" title="더 나은 파이프라인, 그리고 Multiple Results"></a>더 나은 파이프라인, 그리고 Multiple Results</h3><p>Underscore.js의 _.pipeline이나 Lodash의 _.flow에는 아쉬운 점이 있다. 인자를 하나만 받을 수 있다는 점이다. 파이프라인에 사용된 내부 함수들 역시 마찬가지다. 파이프라인 내부에서 function (a, b) { return a + b; } 와 같은 함수는 사용할 수 없다는 얘기다. 물론 객체나 배열에 담아 다음 함수에게 전달할 수도 있겠지만 function(args) { return args[0] + args[1]; } 과 같은 함수는 파이프라인만을 위한 함수라고 봐야 한다. 클로저나 _.partial을 이용해서 인자나 재료를 늘릴 수 있지만 자칫 외부 상황에 의존하는 함수가 될 수 있다.</p><p>함수형 자바스크립트는 순수 함수를 많이 사용할수록, 인자들을 적극 활용할수록 강력해진다. 인자는 특히 2~3개 사용할 때도 많고 개수가 가변적인 경우도 많다. 인자를 2개 이상 필요로 하는 함수들을 파이프라인 사이에 끼워 넣지 못한다는 것은, 곧 파이프라인 사이에 정의된 함수들의 재사용성도 낮아진다는 얘기다.</p><p>만일 언어가 Go였다면 함수의 결과로 Multiple Results를 리턴할 수 있고 파이프라인 중간중간에 여러 개의 인자를 받는 함수들을 얼마든지 끼워 넣을 수 있을 것이다.</p><p>Multiple Results는 함수의 결과값을 여러 개로 리턴하는 개념이다. 자바스크립트에는 이러한 기능이 없지만 이것을 대체하는 기능을 구현할 수 있다. 여러 개의 값을 모아 Multiple Results를 뜻하는 객체로 만든 후 파이프라인 안에서 Multiple Results에 담긴 인자를 다시 여러개로 펼쳐서 실행하도록 구현하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_.mr = function () &#123;</span><br><span class="line">  arguments._mr = true; // 인자들이 담긴 arguments 객체에 _mr로 구분자를 만듬</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.pipeline = function () &#123;</span><br><span class="line">  var funs = arguments;</span><br><span class="line">  return function (seed) &#123;</span><br><span class="line">    return _.reduce(funs,</span><br><span class="line">      function (l, r) &#123;</span><br><span class="line">        // Multiple Results라면 apply로 인자를 펼침.</span><br><span class="line">        return l &amp;&amp; l._mr ? r.apply(null, l) : r(l);</span><br><span class="line">      &#125;,</span><br><span class="line">      // 인자가 여러개면 첫 번째 함수에게도 Multiple Results로 만들어서 넘기기</span><br><span class="line">      arguments.length &lt; 2 ? seed : _.mr.apply(null, arguments)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>apply는 배열이나 arguments 객체를 받아 함수의 인자들로 펼쳐준다. 함수를 실행하기 전 l이 Multiple Results라면 r.apply()를 이용해 r 함수에게 인자를 여러개로 전달할 수 있도록 기능을 추가했다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function square(a) &#123;</span><br><span class="line">  return a * a;</span><br><span class="line">&#125;</span><br><span class="line">function sub(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f1 = _.pipeline(</span><br><span class="line">  add,</span><br><span class="line">  square,</span><br><span class="line">  function (a) &#123;</span><br><span class="line">    return _.mr(a, a / 5); // Multiple Results</span><br><span class="line">  &#125;,</span><br><span class="line">  sub</span><br><span class="line">);</span><br><span class="line">console.log(f1(3, 2));</span><br><span class="line">// 20</span><br></pre></td></tr></table></figure><p>이제 add와 sub 같이 인자를 2개 이상 사용하는 일반 함수들도 파이프라인 사이에 넣을 수 있게 되었다. _.pipeline으로 함수를 정의하면 Multiple Results 를 지원하는 함수가 되어, 함수를 중첩하기만 해도 마치 Go 언어 처럼 동작한다.</p><h2 id="더-나은-함수-조립"><a href="#더-나은-함수-조립" class="headerlink" title="더 나은 함수 조립"></a>더 나은 함수 조립</h2><p>함수를 조립하는 데에도 함수가 사용된다. 함수를 재료로 사용하고, 재료를 함수로 실행하면서 로직을 완성한다. 함수로 함수를 만드는 방법들을 더 정교하게 잘 다루면 훨씬 다양하고 재밌게 조합할 수 있다. _.partial이나 _.pipeline의 기능을 높인다거나 그동안 살펴보았던 함수형 스타일의 함수들에게 부분 커링을 내장하도록 한다거나 하면 함수 조립의 효과를 더욱 높일 수 있다.</p><h3 id="Partial-js의-pipe"><a href="#Partial-js의-pipe" class="headerlink" title="Partial.js의 _.pipe"></a>Partial.js의 _.pipe</h3><p>마이클 포거스의 _.pipeline은 Multiple Results를 지원하지 않는 아쉬움이 있었다. 한 가지 아쉬운 점이 더 있는데, 파이프라인의 내부 함수에서 this를 사용할 수 없다는 점이다. 자바스크립트에서의 함수는 메서드든 아니든 this를 사용할 수 있도록 되어있다. 새로운 기능을 만들 때, 기존의 기본 기능을 유지하는 것은 언제나 중요한 일이다.</p><p>Partial.js의 파이프라인 함수인 _.pipe는 Multiple Results와 this를 모두 지원한다. 그리고 Multiple Results를 사용할 수 있기 때문에 인자를 2개 이상 필요로 하는 함수도 함께 사용할 수 있고, this를 사용할 수 있기 때문에 메서드를 만들거나 this를 사용하는 라이브러리들과 협업이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_.pipe(</span><br><span class="line">  function () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">  &#125;,</span><br><span class="line">  console.log, // 1</span><br><span class="line">  function () &#123;</span><br><span class="line">    this.b = 2;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line">  console.log, // &#123;a: 1, b: 2&#125;</span><br><span class="line">).call(&#123; a: 1 &#125;);</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  method1: _.pipe(</span><br><span class="line">    function () &#123;</span><br><span class="line">      return this.a;</span><br><span class="line">    &#125;,</span><br><span class="line">    console.log, // 10</span><br><span class="line">    function () &#123;</span><br><span class="line">      this.b = 2;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    console.log // &#123;a: 10, b: 2, method1: ƒ&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.method1();</span><br></pre></td></tr></table></figure><h3 id="즉시-실행-파이프라인-go"><a href="#즉시-실행-파이프라인-go" class="headerlink" title="즉시 실행 파이프라인 _.go"></a>즉시 실행 파이프라인 _.go</h3><p>_.go는 _.pipe의 즉시 실행 버전이다. 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 편하기 때문에 첫 번째 인자를 파이프라인에서 사용할 인자로 정했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.go(10,</span><br><span class="line">  function (a) &#123; return a / 2 &#125;,</span><br><span class="line">  function (a) &#123; return a + 2 &#125;,</span><br><span class="line">  console.log // 7</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;함수-조립하기&quot;&gt;&lt;a href=&quot;#함수-조립하기&quot; class=&quot;headerlink&quot; title=&quot;함수 조립하기&quot;&gt;&lt;/a&gt;함수 조립하기&lt;/h1&gt;&lt;p&gt;함수형 자바스크립트 기법을 잘 활용하면 소프트웨어의 기능을 변경하거나 추가하기가 쉽다. 작은 단위로 쪼갠 함수들을 조합하여 큰 기능을 만들면 조합된 함수 사이사이에 새로운 함수를 추가하는 식으로 쉽게 확장해 나갈 수 있다.&lt;/p&gt;
&lt;p&gt;함수형 자바스크립트 10가지 기법&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;함수를 되도록 작게 만들기&lt;/li&gt;
&lt;li&gt;다형성 높은 함수를 만들기&lt;/li&gt;
&lt;li&gt;상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화하기&lt;/li&gt;
&lt;li&gt;동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기&lt;/li&gt;
&lt;li&gt;복잡한 객체 하나를 인자로 사용하기보다는 되도록 일반적인 값 여러개를 인자로 사용하기&lt;/li&gt;
&lt;li&gt;큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="함수 조립" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/"/>
    
      <category term="once" scheme="https://kkangil.github.io/tags/once/"/>
    
      <category term="skip" scheme="https://kkangil.github.io/tags/skip/"/>
    
      <category term="partial" scheme="https://kkangil.github.io/tags/partial/"/>
    
      <category term="compose" scheme="https://kkangil.github.io/tags/compose/"/>
    
      <category term="pipeline" scheme="https://kkangil.github.io/tags/pipeline/"/>
    
      <category term="pipe" scheme="https://kkangil.github.io/tags/pipe/"/>
    
      <category term="go" scheme="https://kkangil.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>함수형 자바스크립트를 위한 문법 다시 보기-2</title>
    <link href="https://kkangil.github.io/2019/10/27/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0-2/"/>
    <id>https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/</id>
    <published>2019-10-27T05:33:33.000Z</published>
    <updated>2019-12-01T09:41:28.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if-else-amp-amp-삼항-연산자-다시-보기"><a href="#if-else-amp-amp-삼항-연산자-다시-보기" class="headerlink" title="if else || &amp;&amp; 삼항 연산자 다시 보기"></a>if else || &amp;&amp; 삼항 연산자 다시 보기</h2><h3 id="if의-괄호"><a href="#if의-괄호" class="headerlink" title="if의 괄호"></a>if의 괄호</h3><p>if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.</p><p>괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.<br><a id="more"></a><br>if (expression) { statements } 중 statements 부분에는 비동기 코드를 활용할 여지가 있고 몇 가지 아이디어를 통해 어느정도 제어가 가능하지만 if의 괄호 부분은 비동기 코드와 거리가 좀 있다. 하지만 괄호 안에서 할 수 있는 일들은 많다. 새로운 객체를 생성할 수도 있고 객체의 key에 값을 할당할 수도 있으며 함수를 실행할 수도 있다. 먼저 에러가 발생하는 코드를 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (var a = 0) console.log(a);</span><br></pre></td></tr></table></figure><p>위 코드는 문법 에러가 난다. 괄호에서는 표현식만 사용할 수 있기 때문이다. 아래 코드는 에러는 나지 않지만 쓸모없는 코드다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (function f1() &#123;&#125;) console.log(&apos;hi&apos;);</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>f1을 정의하는 곳에서는 에러가 나지 않았고 hi도 출력했지만 f1은 실행할 수 없다. f1이 값으로 다뤄져서 유명 함수로 선언되었기 때문이다. f1은 어디에서도 참조할 수 없어 위 코드는 사실상 에러가 나지 않지만 아무런 의미가 없는 코드다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">if (a = 5) console.log(a); // 1</span><br><span class="line"></span><br><span class="line">if (a = 0) console.log(1); // 2</span><br><span class="line">else console.log(a);</span><br><span class="line"></span><br><span class="line">if (!(a = false)) console.log(a); // 3</span><br><span class="line"></span><br><span class="line">if (a = 5 - 5); // 4</span><br><span class="line">else console.log(a)</span><br></pre></td></tr></table></figure><p>미리 선언된 변수에 값을 할당하는 것은 가능하다. 동시에 if의 괄호에는 a가 사용된다. 1에서는 if (5)인 셈이므로 5가 출력된다. 2에서는 if (0) 인 셈이므로 else로 넘어가게 된다. 3에서는 false를 담았고 !으로 반전하여 false가 결과로 나오도록 했다. 4에서는 a에 0이 담기고 else로 넘어간다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">if (obj.a = 5) console.log(obj.a); // 1</span><br><span class="line"></span><br><span class="line">if (obj.b = false) console.log(obj.b); // 2</span><br><span class="line">else console.log(&apos;hi&apos;);</span><br><span class="line"></span><br><span class="line">var c;</span><br><span class="line">if (c = obj.c = true) console.log(c); // 3</span><br></pre></td></tr></table></figure><p>이번에는 if의 괄호 안에서 객체의 key에 값을 할당했다. obj에 값을 할당했고, if의 괄호에서는 obj가 아닌 할당한 값이 쓰인다. 2와 3을 통해 알 수 있다. c에는 obj가 아닌 true가 담긴다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (add(1, 2)) console.log(&apos;hi1&apos;);</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line">if (a = add(1, 2)) console.log(a);</span><br><span class="line"></span><br><span class="line">if (function () &#123; return true; &#125;()) console.log(&apos;hi&apos;)</span><br></pre></td></tr></table></figure><p>함수를 실행할 수도 있고 실행한 결과를 변수에 담으면서 참과 거짓을 판단할 수도 있다. 익명 함수나 유명 함수를 정의하면서 즉시 실행할 수도 있다.</p><p>위에서 확인한 모든 코드들은 자바스크립트의 대부분의 괄호에서 동일하게 동작한다. 이를테면 while문의 괄호에서도 동일하게 동작한다. 괄호 안에서 어떤 코드들을 돌릴 수 있는지 잘 알고 있다면 코드를 더 깔끔하게 정리하거나 코드 구조를 크게 변경하지 않고도 기능을 발전시킬 수 있다.</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="|| &amp;&amp;"></a>|| &amp;&amp;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(0 &amp;&amp; 1) // 0</span><br><span class="line">console.log(1 &amp;&amp; 0) // 0</span><br><span class="line">console.log([] || &#123;&#125;); // []</span><br><span class="line">console.log([] &amp;&amp; &#123;&#125;); // &#123;&#125;</span><br><span class="line">console.log([] &amp;&amp; &#123;&#125; || 0); // &#123;&#125;</span><br><span class="line">console.log(0 || 0 || 0 || 1 || null); // 1</span><br><span class="line">console.log(add(10, -10) || add(10, -10)); // 0</span><br><span class="line">console.log(add(10, -10) || add(10, 10)); //20</span><br><span class="line">var v;</span><br><span class="line">console.log((v = add(10, -10)) || v++ &amp;&amp; 20); // 0</span><br><span class="line">console.log((v = add(10, 10)) || ++v &amp;&amp; 20); // 20</span><br></pre></td></tr></table></figure><p>||과 &amp;&amp;의 활용법은 생각보다 다양하다. 오른쪽으로 더 갈 것인가 말 것인가를 한 줄로 만들어 if else를 대체할 수도 있다. 상황에 따라 if else가 가독성이나 효율이 좋을 수 있고 ||, &amp;&amp; 가 좋을 수도 있다. 다양한 도구를 상황에 맞게 잘 사용하면 된다.</p><h3 id="삼항-연산자"><a href="#삼항-연산자" class="headerlink" title="삼항 연산자"></a>삼항 연산자</h3><p>삼항 연산자는 조건이 간단하고 실행 코드도 간단할 때 많이 사용된다. 보통 값을 담을 때 사용된다. 삼항 연산자를 이용해도 여러 줄을 코딩할 수 있다. 익명 함수, 유명 함수, 화살표 함수 등으로 즉시 실행 패턴을 사용하는 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = false;</span><br><span class="line"></span><br><span class="line">var c = a ? 10 : function f(arr, v) &#123;</span><br><span class="line">  return arr.length ? f(arr, v + arr.shift()) : v;</span><br><span class="line">&#125;([1, 2, 3], 0);</span><br><span class="line"></span><br><span class="line">console.log(c)</span><br></pre></td></tr></table></figure><p>위 코드에서는 a 가 false이므로 삼항 연산자에서 10을 건너뛰고 함수 부분이 실행된다. 함수 정의 끝부분을 보면 알 수 있듯이 즉시 실행했다. 그리고 [1,2,3]과 0을 인자로 받는다. 위와 같이 즉시 실행 함수를 이용하면 어디에서든 한 줄만 작성할 수 있던 곳을 확장할 수 있다. 또한 다른 함수를 실행할 수도 있고 재귀를 돌면서 얼마든지 복잡한 로직도 넣을 수 있다.</p><h2 id="함수-실행의-괄호"><a href="#함수-실행의-괄호" class="headerlink" title="함수 실행의 괄호"></a>함수 실행의 괄호</h2><h3 id="함수-실행을-통해-생기는-새로운-공간"><a href="#함수-실행을-통해-생기는-새로운-공간" class="headerlink" title="함수 실행을 통해 생기는 새로운 공간"></a>함수 실행을 통해 생기는 새로운 공간</h3><p>이전에 가장 특별한 괄호는 함수를 실행하는 괄호라고 했었다. 함수를 실행하는 괄호와 그렇지 않은 다른 괄호의 차이는 무엇일까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5);</span><br><span class="line">(function () &#123; return 10; &#125;);</span><br></pre></td></tr></table></figure><p>위 코드의 괄호 두 가지는 모두 일반적인 괄호다. 함수를 실행하는 괄호가 아닌 일반 괄호에서는 코드가 실행되면 해당 지점에 즉시 값을 만들고 끝난다. 해당 지점에서 만들어진 값을 참조할 수는 있지만 여기서 할 일은 바로 모두 끝난다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var add5 = function (a) &#123; // 새로운 공간</span><br><span class="line">  return a + 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var call = function (f) &#123; // 새로운 공간</span><br><span class="line">  return f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 함수를 실행하는 괄호</span><br><span class="line">add(5);</span><br><span class="line">call(function () &#123; return 10; &#125;);</span><br></pre></td></tr></table></figure><p>함수를 실행하는 괄호는 일반 괄호와 특성이 모두 같지만 한 가지 특성을 더 가지고 있다. 이 괄호를 통해 새로운 <code>실행 컨텍스트</code>가 열린다는 점이다. 이 점은 매우 중요하다. 함수를 실행하는 괄호에서는 코드가 실행되었을 때 해당 지점에 값을 만든 후 끝나지 않고, 이 값이 실행된 함수의 공간으로 넘어간다. 새롭게 열린 공간이 끝나기 전까지는 이전 공간의 상황들도 끝나지 않는다. 이 공간들을 실행 컨텍스트라고 한다.</p><p>새로운 공간이 생긴다는것, 콜 스택에 쌓인다는 것, 태스크 큐와 이벤트 루프에 의해 제어된다는 것, 이것들을 통해 개발자가 시작과 끝을 제어할 수 있다는 점들이 함수를 실행하는 괄호가 가진 가장 특별한 차이다.</p><p>함수가 정의되거나 실행되는 지점에서는 클로저도 만들어질 수 있고, 비동기 상황이 생길 수도 있으며 서로 다른 컨택스트가 연결되는 등의 특별한 일들이 생긴다. 이것들은 함수에 대한 매우 실제적이고 중요한 개념이다.<br>for문을 사용할 때 어떤 지점들을 확인하면서 코드 블록을 반복시키는지, 언제 어떻게 끝나는지 정확히 이해하지 않고는 코딩할 수 없듯이 함수도 마찬가지다.</p><h3 id="기본적인-비동기-상황"><a href="#기본적인-비동기-상황" class="headerlink" title="기본적인 비동기 상황"></a>기본적인 비동기 상황</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3 (1초 뒤)</span><br></pre></td></tr></table></figure><p>코드 라인 순서와 달리 1, 2, 3 으로 실행 되었다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var add = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(10, 5, function (r) &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>비동기 상황이 생기는 함수의 결과는 return 문으로 반환할 수 없다. 비동기 상황이 생기는 함수의 결과를 받는 방법 중 하나는 콜백 함수를 넘겨서 돌려받는 방법이다. add의 마지막 인자로 넘겨진 익명 함수 callback은 add 안에서 모든 상황이 끝날 때 실행된다. 이를 통해 add를 실행한 스코프 내부에서 다시 add의 결과를 받을 수 있게 된다.<br>일반 괄호였다면 10, 5, function등이 그 자리에 정의되고 끝났겠지만 함수를 실행하는 괄호에서는 그 값들이 다른 공간으로 넘어간다. 새롭게 열린 공간에서는 넘겨받은 재료들로 새로우 일을 할 수 있다.</p><h3 id="함수-실행-괄호의-마법과-비동기"><a href="#함수-실행-괄호의-마법과-비동기" class="headerlink" title="함수 실행 괄호의 마법과 비동기"></a>함수 실행 괄호의 마법과 비동기</h3><p>비동기 상황을 제어하는 방법은 함수 실행을 일렬로 나열하는 것이다.</p><p>add 함수 실행 -&gt; setTimeout 함수 실행 -&gt; setTimeout이 1초 뒤 익명 함수를 실행 -&gt; 받아 둔 callback 실행</p><p>위와 같이 함수들의 실행을 일렬로 나열하여 한 가지 일이 순서대로 일어나도록 하는 것이다.<br>이 함수 나열을 숨겨서 비동기 코드가 동기식으로 실행되는 것처럼 보이도록 해볼 것이다. Promise하고 비슷할 것이다. 이 작업을 통해 함수 실행의 괄호에서 다른 공간으로 이동되는 사이에 할 수 있는 일을 확인할 것이다. 이런 기법들을 통해 프로미스의 내부 코드를 예상해 볼 수도 있을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var add = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sub = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(10, 15, function (a) &#123;</span><br><span class="line">  sub(a, 5, function (a) &#123;</span><br><span class="line">    div(a, 10, function (r) &#123;</span><br><span class="line">      console.log(r); // 약 3초 후에 2가 찍힘</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>원래 비동기가 일어나는 함수들은 아래처럼 중첩 실행을 할 수 없다. 함수의 몇 가지 특성을 활용해 비동기 함수도 아래처럼 중첩 실행이 가능하도록 해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(div(sub(add(10, 15), 5), 10));</span><br><span class="line">// undefined가 찍히고 callback이 없다는 에러가 남.</span><br></pre></td></tr></table></figure><p>우선 함수가 실행되는 사이에 무언가를 할 수 있도록 함수로 한 번 감싸서 공간을 만들 것이다. wrap에게 함수를 전달하여 함수를 리턴 받으면 원래 기능을 유지하면서 코드 사이에 공간이 생긴다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function wrap(func) &#123; // 1. 함수 받기</span><br><span class="line">  return function () &#123; // 2. 함수 리턴하기, 이것이 실행됨.</span><br><span class="line">    // 여기에 새로운 공간이 생김, 나중에 함수를 실행했을 때 이 부분을 거쳐감</span><br><span class="line">    return func.apply(arguments); // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = wrap(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(5, 10, function (r) &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1에서 받은 함수를 기억하는 2 클로저를 만들어 리턴했고, add는 2가 된다. 나중에 2가 실행되면 1에서 받아 둔 3 함수를 실행하면서 2가 받은 모든 인자를 넘겨준다. 이전 add와 완전히 동일하게 동작하면서도 사이사이에 코드를 끼워 넣을 수 있는 공간들이 더 생겼다. wrap을 조금만 더 고치고 _async 라고 이름을 바꿔보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function _async(func) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    arguments[arguments.length++] = function (result) &#123; // 1</span><br><span class="line">      _callback(result) // 6</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    func.apply(null, arguments); // 2</span><br><span class="line"></span><br><span class="line">    var _callback; // 3</span><br><span class="line">    function _async_cb_receiver(callback) &#123; // 4</span><br><span class="line">      _callback = callback; // 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(20, 30)(function (r) &#123; // 7</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>우선 마지막 부분 7을 보면 add를 실행하는 방법이 바뀌었다. 한 번에 인자 3개를 넘기지 않고 마치 커링처럼 add에 필요한 재료를 넘긴 후 한 번 더 실행하면서 callback 함수를 넘기고 있다.</p><ol><li>add가 실행되면 인자로 20과 30이 넘어온다. 원래는 callback 함수를 받아야 하므로 arguments에 마지막 값으로 함수를 추가한다. 그리고 그 함수는 나중에 개발자가 넘겨준 callback 함수를 실행할 수 있게 준비해 두었다.</li><li>add를 정의할 때 받아 둔 func를 실행하면서 인자 3개를 넘긴다.</li><li>_callback 이라는 지역 변수를 만들어서 1과 4가 기억해 두도록 했다. 클로저를 활용하여 서로 다른 컨텍스트가 협업할 수 있도록 이어주었다.</li><li>_async_cb_receiver라는 이름을 가진 유명 함수이자 클로저를 만들어 리턴한다.</li><li>_async_cb_receiver가 실행될 때 받은 함수 callback을 _callback에 할당한다.</li><li>1초가 지나면 1이 실행될 것이고 add가 callback을 통해 넘긴 결과인 result를 받아 두었던 _callback을 실행하면서 다시 넘겨주고 있다.</li><li>이 익명 함수가 _callback 이므로 6에서 넘겨진 r을 받게 되고 로그를 남겼다.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var div = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(10, 15)(function (a) &#123;</span><br><span class="line">  sub(a, 5)(function (a) &#123;</span><br><span class="line">    div(a, 10)(function (r) &#123;</span><br><span class="line">      console.log(r);</span><br><span class="line">      // 약 3초 후 2가 찍힘</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="비동기와-재귀"><a href="#비동기와-재귀" class="headerlink" title="비동기와 재귀"></a>비동기와 재귀</h3><p>일반 콜백 패턴의 함수를 실행하는 것과 아직 큰 차이는 없지만 연산에 필요한 실행과 결과를 받기 위한 실행이 분리되었다. 함수를 실행하는 괄호에서는 값을 다른 공간으로 넘겨 새로운 일들을 더 할 수 있다. add, sub, div는 async를 통해 본체에 가기 전 새로운 공간을 가지고 있고, 그 공간에서는 시작과 끝을 제어하고 있다. 이 내부 공간을 손보면 좀 더 재밌는 일을 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _async(func) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    arguments[arguments.length++] = function (result) &#123;</span><br><span class="line">      _callback(result)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 변경된 부분</span><br><span class="line">    (function wait(args) &#123;</span><br><span class="line">      // 새로운 공간 추가</span><br><span class="line">      for (var i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;</span><br><span class="line">          return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      func.apply(null, args);</span><br><span class="line">    &#125;)(arguments);</span><br><span class="line"></span><br><span class="line">    var _callback;</span><br><span class="line">    function _async_cb_receiver(callback) &#123;</span><br><span class="line">      _callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;add&apos;, a, b);</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;sub&apos;, a, b);</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var div = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;div&apos;, a, b);</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var log = _async(function (val) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log(div(sub(add(10, 15), 5), 10));</span><br><span class="line">// 약 4초 뒤 2</span><br><span class="line">log(add(add(10, 10), sub(10, 5)));</span><br><span class="line">// 약 3초 뒤 25</span><br></pre></td></tr></table></figure><p>모두 비동기 함수들 인데도 마치 즉시 완료되는 동기 함수들을 중첩하여 실행한 것처럼 동작하고 있다. 추가된 부분만 다시 자세히 살펴보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 변경 전</span><br><span class="line">func.apply(null, args);</span><br><span class="line"></span><br><span class="line">// 변경 후</span><br><span class="line">(function wait(args) &#123;</span><br><span class="line">  for (var i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">    if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;</span><br><span class="line">      return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  func.apply(null, args);</span><br><span class="line">&#125;)(arguments);</span><br></pre></td></tr></table></figure><p>크게 보면 wait라는 유명 함수를 만들었고 내부에서 재귀를 돌다 func를 실행하도록 변경되었다. 재귀는 인자 중에 <code>_async_cb_receiver</code> 가 있다면 모두 결과값으로 치환될 때까지 돌게 된다.<br>add의 실행 결과는 숫자가 아닌 _async_cb_receiver라는 이름을 가진 함수다. 이 함수에 함수를 넣으면 결과를 받을 수 있다. 이를 이용하여 add의 실행 결과를 받은 sub는 자신의 본체(func) 로 가기 전에 wait로 _async_cb_receiver가 있는지 확인하고, 있다면 실행하여 결과값을 받고 재귀를 돌며 해당 번째 args[i]를 결과값으로 변경한다.</p><p>앞의 예제는 특정 지점에 함수를 정의하거나 함수로 감싸고, 함수를 즉시 실행하거나 재귀를 하는 식으로 기존 로직 사이에 선행 로직이나 후행 로직을 만들면서 프로그램의 순서를 제어할 수 있음을 보여준다. 위 예제에서는 이런 기법을 통해 비동기 상황을 제어하고, 다른 라이브러리들과의 연결 고리를 만드는 중요한 단위가 된다.</p><p>일반 괄호에서는 할 수 없는 일이지만 함수를 실행하는 괄호에서는 새로운 공간들을 레이어처럼 얼마든지 만들 수 있다. 앞의 예제 처럼 본체까지 가기 전 레이어들을 통과하면서 비동기 함수의 결과를 기다렸다가 결과값으로 변형해 넘겨줄 수도 있다. 함수를 실행하는 괄호에서 함수를 실행할 수 있고, 실행한 결과가 함수여서 그 함수를 다시 함수에게 인자로 넘길 수 있고, 그렇게 받은 함수를 실행할 수 있다.</p><p>자바스크립트에서 재귀는 충분히 실용적이라는 이야기를 했었다. 앞의 상황에서는 재귀를 통해 비동기 상황을 제어했다. 재귀는 로직들을 함수라는 단위로 일자로 나열하는 것이다. 비동기 제어의 핵심 역시 함수 실행의 나열이다. 비동기가 발생되면 스택이 초기화되므로 재귀에 대한 부담도 없다. 아무리 많은 재귀가 일어나도 ‘Maximum call stack size exceeded’ 에러는 절대로 발생하지 않는다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;if-else-amp-amp-삼항-연산자-다시-보기&quot;&gt;&lt;a href=&quot;#if-else-amp-amp-삼항-연산자-다시-보기&quot; class=&quot;headerlink&quot; title=&quot;if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기&quot;&gt;&lt;/a&gt;if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기&lt;/h2&gt;&lt;h3 id=&quot;if의-괄호&quot;&gt;&lt;a href=&quot;#if의-괄호&quot; class=&quot;headerlink&quot; title=&quot;if의 괄호&quot;&gt;&lt;/a&gt;if의 괄호&lt;/h3&gt;&lt;p&gt;if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.&lt;/p&gt;
&lt;p&gt;괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.&lt;br&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>함수형 자바스크립트를 위한 문법 다시 보기</title>
    <link href="https://kkangil.github.io/2019/10/20/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0/"/>
    <id>https://kkangil.github.io/2019/10/20/함수형-자바스크립트를-위한-문법-다시-보기/</id>
    <published>2019-10-20T05:29:11.000Z</published>
    <updated>2019-12-01T09:41:32.119Z</updated>
    
    <content type="html"><![CDATA[<p>함수형 자바스크립트를 잘 다루기 위해서는 숲을 보는 것보다 나무의 결을 들여다 보는 것이 중요하다. 자바스크립트 문법과 기본적인 동작에 집중해보자. 함수 하나가 정의되고 실행되고 참조되는 과정, 인자를 받거나 넘기는 과정, 클로저가 되거나 비동기가 일어나는 과정, 괄호, 대괄호, 점, 쉼표 등을 자세히 들여다 보자. 문법적 감각이 좋아지면 원하는 곳 어디에서나 함수를 열고 실행할 수 있게 된다.</p><a id="more"></a><h2 id="객체와-대괄호-다시-보기"><a href="#객체와-대괄호-다시-보기" class="headerlink" title="객체와 대괄호 다시 보기"></a>객체와 대괄호 다시 보기</h2><h3 id="객체와-key"><a href="#객체와-key" class="headerlink" title="객체와 key"></a>객체와 key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1, &quot;b&quot;: 2 &#125;; // 1</span><br><span class="line">obj.c = 3;</span><br><span class="line">obj[&apos;d&apos;] = 4; // 2</span><br><span class="line">var e = &apos;e&apos;;</span><br><span class="line">obj[e] = 5;</span><br><span class="line">function f() &#123; return &apos;f&apos; &#125;;</span><br><span class="line">obj[f()] = 6;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><p>일단 객체의 key 와 value에 대한 부분이다. 객체의 key와 value는 {}, . , [] 등을 통해 설정할 수 있다.<br>그중 어떤 문자열이든 key로 정의할 수 있는 곳이 있는데 1과 2 같은 곳이다. 이 두 가지 방식이 가진 공통점이 있다면 띄어쓰기, 특수 문자, 숫자 등을 가리지 않고 어떤 문자열이든 key로 만들 수 있다는 점이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj2 = &#123; &quot;a a a&quot;: 1 &#125;;</span><br><span class="line">obj2[&quot;b b b&quot;] = 2;</span><br><span class="line">console.log(obj2);</span><br><span class="line"></span><br><span class="line">var obj3 = &#123; &quot;margin-top&quot;: 5 &#125;;</span><br><span class="line">obj3[&quot;padding-bottom&quot;] = 20;</span><br><span class="line">console.log(obj3);</span><br><span class="line"></span><br><span class="line">var obj4 = &#123; 1: 10 &#125;;</span><br><span class="line">obj4[2] = 20;</span><br><span class="line">console.log(obj4);</span><br></pre></td></tr></table></figure><p>그렇다면 {} 안쪽에서 key를 선언하는 것과 [] 안에서 선언하는 것은 차이가 없을까? {}의 문자열 부분에서는 코드를 실행할 수 없고 []의 안쪽에서는 코드를 실행할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj5 = &#123; (true ? &quot;a&quot; : &quot;b&quot;): 1&#125;; // Uncaught SyntaxError</span><br><span class="line">var obj6 = &#123;&#125;;</span><br><span class="line">obj6[true ? &quot;a&quot; : &quot;b&quot;] = 1;</span><br><span class="line">console.log(obj6);</span><br></pre></td></tr></table></figure><p>{} 안쪽의 key 영역에서는 코드를 실행할 수 없다. [] 사이에는 문자열이 담긴 변수도 넣을 수 있고, 연산자도 사용할 수 있으며 함수도 실행할 수 있다. 즉, [] 에서는 코드를 실행할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj5 = &#123; [true ? &quot;a&quot; : &quot;b&quot;]: 1 &#125;</span><br><span class="line">console.log(obj5);</span><br></pre></td></tr></table></figure><p>하지만 ES6 의 경우에서는 {} 안에 [] 를 사용하여 코드를 실행할 수 있게됐다. </p><h3 id="함수나-배열에-달기"><a href="#함수나-배열에-달기" class="headerlink" title="함수나 배열에 달기"></a>함수나 배열에 달기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function obj8() &#123; &#125;</span><br><span class="line">obj8.a = 1;</span><br><span class="line">obj8.b = 2;</span><br><span class="line">console.log(obj8.a); // 1</span><br><span class="line">console.log(obj8.b); // 2</span><br></pre></td></tr></table></figure><p>자바스크립트에서는 함수도 객체다. 그러므로 함수도 key/value 쌍으로 구성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj10 = []</span><br><span class="line">obj10.a = 1;</span><br><span class="line">console.log(obj10.a); // 1</span><br><span class="line">console.log(obj10.length); // 0</span><br></pre></td></tr></table></figure><p>배열도 객체이며 배열에도 숫자가 아닌 key를 사용할 수 있다. 단, 숫자가 아닌 key로 값을 할당할 경우 length는 변하지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj11 = [];</span><br><span class="line">obj11[0] = 1;</span><br><span class="line">obj11[1] = 2;</span><br><span class="line">console.log(obj11);</span><br><span class="line">console.log(obj11.length) // 2</span><br></pre></td></tr></table></figure><p>배열에 숫자로 key를 직접 할당해도 push와 동일하게 동작한다. 자동으로 length도 올라간다.</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>자바스크립트에서는 기본 객체의 메서드나 프로퍼티도 지울 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line">delete obj.a;</span><br><span class="line">delete obj[&apos;b&apos;];</span><br><span class="line">delete obj[&apos;C&apos;.toLocaleLowerCase()];</span><br><span class="line">console.log(obj) // &#123;&#125;</span><br><span class="line"></span><br><span class="line">delete Array.prototype.push;</span><br><span class="line">var arr1 = [1, 2, 3];</span><br><span class="line">arr1.push(4); // Uncaught TypeError: arr1.push is not a function</span><br></pre></td></tr></table></figure><p>다른 언어를 다루었던 개발자라면 delete로 아무거나 지우기, 배열에 숫자가 아닌 key 사용하기 등을 봤을 때, 자바스크립트의 유연함을 난해하다거나 위험하다고 느낄 수 있다. 하지만 이 특징들을 문제가 아닌 자바스크립트의 특성으로 받아들인 후에 더욱 다양한 기법들이 나오기 시작했고 더 잘 동작하기까지했다.</p><h2 id="함수-정의-다시-보기"><a href="#함수-정의-다시-보기" class="headerlink" title="함수 정의 다시 보기"></a>함수 정의 다시 보기</h2><h3 id="기본-정의"><a href="#기본-정의" class="headerlink" title="기본 정의"></a>기본 정의</h3><p>자바스크립트에서 함수를 정의하는 방법은 다양하다. 대표적인 방법들은 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add1(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add2 = function(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var m = &#123;</span><br><span class="line">  add3: function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수를 정의하는 것은 이미 익숙하겠지만 확인해 볼 만한 부분이 있다. 바로 호이스팅인데, 호이스팅에 대해 어느 정도 알고 있더라도 읽어 보기를 권한다.</p><h3 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h3><p>호이스팅(hoisting)이란 변수나 함수가 어디서 선언되든지 해당 스코프 최상단에 위치하게 되어 동일 스코프 어디서든 참조할 수 있는 것을 말한다. 아래의 코드 add1과 add2에는 호이스팅이 적용된다. ‘add2는 실행이 안 될 텐데 호이스팅이 아니지 않나?’하고 생각할 수 있지만 이것은 오해다. 물론 에러가 난 걸로 알 수 있듯이 add2는 선언하기 전 라인에서 실행할 수 없다. 하지만 분명히 add2도 호이스팅이 적용된 것이다. 결론부터 말하면 선언은 되었지만 아직 초기화되지 않은 상태에서 실행했기 때문에 에러가 난 것 이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add1(10, 5); // 15</span><br><span class="line">add2(10, 5); // Uncaught TypeError: add2 is not a function</span><br><span class="line"></span><br><span class="line">function add1(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add2 = function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제에서 add2는 실행되지 않았고, ‘add2 is not a function’ 이라는 에러 메시지가 출력되었다. 이번에는 선언한 적 없는 함수를 실행해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hi();</span><br><span class="line">// Uncaught ReferenceError: hi is not defined</span><br></pre></td></tr></table></figure><p>에러 메시지가 다르다. 자바스크립트에서는 아예 선언된 적이 없는 것을 참조하려고 할 때 이러한 에러가 난다. 실행하지 않고 참조만 하려고 해도 동일한 에러가 난다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(add1); // function add1(a, b) &#123; return a + b &#125;;</span><br><span class="line">console.log(add2); // undefined;</span><br><span class="line"></span><br><span class="line">function add1(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add2 = function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번엔 에러가 나지 않았고 undefined가 출력되었다. 그렇다면 add1과 add2는 어떤 차이에 의해 실행이 되고 안 되는 것 일까?<br>이는 변수 선언과 함수 선언에서의 차이 떄문이다. 변수는 선언 단계와 초기화 단계가 구분되어 있다. 변수는 선언과 초기화가 동시에 이루어지지 않기 때문에 호이스팅에 의해 참조만 가능하고, 아직 값이 담기지 않아 실행은 불가능하다. 반면에 함수 선언은 선언과 동시에 초기화가 이루어지기 때문에 참조뿐 아니라 실행도 가능하다.<br>add2는 변수를 선언하여 익명 함수를 담았고 add1은 함수로 선언했다. 호이스팅에 의해 add1은 미리 실행할 수 있고 add2는 호이스팅에 의해 미리 참조할 수 있지만 값이 없어 실행할 수는 없다.</p><h3 id="호이스팅-활용하기"><a href="#호이스팅-활용하기" class="headerlink" title="호이스팅 활용하기"></a>호이스팅 활용하기</h3><p>함수 선언과 호이스팅을 이용하면 다음과 같이 코드를 작성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return valid() ? a + b : new Error();</span><br><span class="line"></span><br><span class="line">  function valid() &#123;</span><br><span class="line">    return Number.isInteger(a) &amp;&amp; Number.isInteger(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(10, 5)); // 15</span><br><span class="line">console.log(add(10, &apos;&apos;)); // Error(...)</span><br></pre></td></tr></table></figure><p>위와 같이 return 문 아래에 정의한 함수도 실행이 가능하다. 비교적 복잡한 코드를 하단부에 정의하고 실행부 코드는 깔끔하게 유지하는 등으로 활용할 수도 있다.</p><h3 id="괄호없이-즉시-실행하기"><a href="#괄호없이-즉시-실행하기" class="headerlink" title="괄호없이 즉시 실행하기"></a>괄호없이 즉시 실행하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)(100);</span><br></pre></td></tr></table></figure><p>자바스크립트에서는 위와 같이 괄호를 통해 익명 함수를 즉시 실행할 수 있다. 괄호 없이 실행하면 에러가 발생한다. 많은 경우, 참조가 잘못되어 에러가 났다고 생각할 수 있지만 그렇지 않다. 에러가 난 이유는 익명 함수를 잘못 실행한 것이 아니라 익명 함수 선언 자체가 실패했기 떄문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;&#125;</span><br><span class="line">// Uncaught SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure><p>실행 없이 선언만 시도해도 에러가 난다. 그런데 우리는 이와 비슷한데 에러가 나지 않는 코드를 봤었다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>이 예제는 1장에서 봤었던 함수를 값으로 다루는 패턴 중 하나다. 위 코드는 함수를 괄호로 감싸지 않았는데 문법 에러가 나지 않고 정상적으로 동작한다. 이 상황에서 에러가 나지 않는다면 괄호 없이 즉시 실행도 되지 않을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  return function (a) &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>이 코드는 정상적으로 동작한다. f1이라느느 함수 안에 있는 익명 함수는 괄호 없이도 즉시 실행이 되었다. 만일 f1이라는 함수의 return 바로 뒤에서 함수를 즉시 실행하고 싶다면, 그 상황에서는 괄호 없이도 익명 함수를 즉시 실행할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">!function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">true &amp;&amp; function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">1 ? function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1) : 5;</span><br><span class="line"></span><br><span class="line">0, function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">var b = function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">function f2() &#123; &#125;</span><br><span class="line">f2(function (a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1));</span><br><span class="line"></span><br><span class="line">var f3 = function c(a) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;(1);</span><br><span class="line"></span><br><span class="line">new function () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 상황들에서는 괄호 없이도 익명 함수를 즉시 실행할 수 있다. 이 중 !를 이용한 방법은 꽤 알려진 편이다. 이 상황에서의 공통점은 무엇일까? 일단 모두 연산자와 함께 있고, 함수가 값으로 다뤄졌다. 그리고 모두 익명 함수 선언에 대한 오류가 나지 않는다. 앞에서 즉시 실행이 실패했던 것은 익명 함수를 잘못 실행한 것이 아니라 익명 함수 선언 자체를 하지 못해서였다.</p><h3 id="유명-named-함수"><a href="#유명-named-함수" class="headerlink" title="유명(named) 함수"></a>유명(named) 함수</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function f() &#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수를 값으로 다루면서 익명이 아닌 f() 처럼 이름을 지은 함수를 유명 함수라고 한다. 함수를 즉시 실행한다거나 함수를 클로저로 만들어 리턴할 때, 함수를 메서도로 만들 때는 주로 익명 함수를 사용하게 된다. 이와 같은 상황에서 익명 함수 대신 유명 함수로 사용하는 것이 유용할 때가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function () &#123;</span><br><span class="line">  console.log(f1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">// 위험 상황</span><br><span class="line">var f2 = f1;</span><br><span class="line">f1 = &apos;hi~&apos;;</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><p>이렇게 하면 참조가 가능하지만 ‘위험 상황’ 부분처럼 함수 생성 이후 변경이 일어나면 더 이상 자기 자신을 참조하지 못하게 될 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function () &#123;</span><br><span class="line">  console.log(arguments.callee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line">// ƒ () &#123;</span><br><span class="line">//   console.log(arguments.callee)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">var f2 = f1;</span><br><span class="line">f1 = null;</span><br><span class="line">f2();</span><br><span class="line">// ƒ () &#123;</span><br><span class="line">//   console.log(arguments.callee)</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>위 방법은 이 전 코드의 문제를 해결하지만 arguments.callee는 ES5 Strict mode에서 사용할 수 없다. 유명 함수식을 사용하면 arguments.callee를 대체할 수 있다. 유명 함수는 함수가 값으로 사용되는 상황에서 자신을 참조하기 매우 편하다. 함수의 이름이 바뀌든 메서드 안에서 생성한 함수를 다시 참조하고 싶은 상황이든 어떤 상황에서든 상관없이 자기 자신을 정확히 참조할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function f() &#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">var f2 = f1;</span><br><span class="line">f1 = null;</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><h3 id="유명-함수를-이용한-재귀"><a href="#유명-함수를-이용한-재귀" class="headerlink" title="유명 함수를 이용한 재귀"></a>유명 함수를 이용한 재귀</h3><p>유명 함수는 재귀를 만들 때에도 편리하다. 다음은 깊이를 가진 배열을 펴 주는 flatten 함수다. 아래와 같은 함수를 만들 때 재귀와 유명 함수는 특히 유용하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return function f(arr, new_arr) &#123; // 1</span><br><span class="line">    arr.forEach(function (v) &#123;</span><br><span class="line">      Array.isArray(v) ? f(v, new_arr) : new_arr.push(v); // 2</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return new_arr;</span><br><span class="line">  &#125;(arr, []); // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten([1, [2], [3, 4]]));</span><br><span class="line">// [1,2,3,4]</span><br><span class="line">console.log(flatten([1, [2], [[3], 4]]));</span><br><span class="line">// [1,2,3,4]</span><br></pre></td></tr></table></figure><ol><li>flatten 함수가 실행되면 먼저 즉시 실행할 f 라는 이름의 유명 함수로 만든다.</li><li>함수 f를 즉시 실행하면서 새로운 배열 객체를 생성하여 넘겨준다.</li><li>루프를 돌면서 배열이 아닐 때만 값을 push하고 배열인 경우에는 f를 다시 실행하여 배열을 펴고 있다.</li></ol><p>이 코드가 재밌는 점은 즉시 실행과 유명 함수를 이용한 재귀라는 것이다. 만일 재귀로만 이 로직을 구현한다면 함수를 사용하는 개발자가 빈 배열을 항상 직접 넘겨주거나 if문을 체크하는 식으로 재귀를 제어해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function flatten2(arr, new_arr) &#123;</span><br><span class="line">  arr.forEach(function (v) &#123;</span><br><span class="line">    Array.isArray(v) ? flatten2(v, new_arr) : new_arr.push(v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return new_arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flatten2([1, [2], [3, 4]], []) // 항상 빈 Array를 추가로 넘겨 줘야함.</span><br><span class="line"></span><br><span class="line">function flatten3(arr, new_arr) &#123;</span><br><span class="line">  if (!new_arr) return flatten3(arr, []); // if 문이 생김</span><br><span class="line">  arr.forEach(function (v) &#123;</span><br><span class="line">    Array.isArray(v) ? flatten3(v, new_arr) : new_arr.push(v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return new_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>세 가지 방식의 코드 모두 장단점이 있다. flatten2는 if가 없고 가장 빠르지만 함수를 사용할 때 개발자가 직접 배열을 넘겨주어야 한다. flatten3은 사용하기 간단하지만 if가 있다. flatten은 if가 없으면서 사용하기 간단하지만 함수를 한 번 생성한다. </p><h3 id="자바스크립트에서-재귀의-아쉬움"><a href="#자바스크립트에서-재귀의-아쉬움" class="headerlink" title="자바스크립트에서 재귀의 아쉬움"></a>자바스크립트에서 재귀의 아쉬움</h3><p>재귀를 이용하면 복잡한 로직이나 중복되는 로직을 제거할 수 있고 읽기 쉬운 로직을 만들 수 있어 편하다. 그러나 아직까지는 자바스크립트에서 재귀를 사용하는 것에 약간 부담스러운면이 있다. 환경에 따라 다르지만 대략 15,000번 이상 재귀가 일어나면 ‘Maximum call stack exceeded’라는 에러가 발생하고 소프트웨어가 죽는다. 따라서 자바스크립트에서 얼마나 깊은 재귀가 일어날 것인가 유의하며 함수를 작성해야 한다.</p><p>아직 자바스크립트의 실제 동작 환경에서는 꼬리 재귀 최적화가 되지 않았다. 그렇다고 자바스크립트에서 성능 때문에 재귀를 사용할 일이 없다는 것은 잘못된 얘기다. 자바스크립트의 실제 동작 환경에서는 비동기 프로그래밍이 많이 쓰이고 비동기가 일어나면 스택이 초기화 된다. 애초에 비동기 상황이었다면 어차피 스택이 초기화 될 것이므로 재귀 사용을 피할 이유가 없다. </p><h2 id="함수-실행과-인자-그리고-점-다시-보기"><a href="#함수-실행과-인자-그리고-점-다시-보기" class="headerlink" title="함수 실행과 인자 그리고 점 다시 보기"></a>함수 실행과 인자 그리고 점 다시 보기</h2><h3 id="다시-보기"><a href="#다시-보기" class="headerlink" title="() 다시 보기"></a>() 다시 보기</h3><p>함수를 실행하는 방법에는 (), call, apply가 있고, 함수 안에서는 arguments 객체와 this 키워드를 사용할 수 있다. 각각의 사용법과 용도, 특이사항들을 하나씩 확인해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a, b, c) &#123;</span><br><span class="line">  console.log(&apos;a b c:&apos;, a, b, c);</span><br><span class="line">  console.log(this);</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 실행 방법에 따른 차이를 정확히 확인하기 위해 test 함수를 만들었다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">test(10); // 1</span><br><span class="line">// a b c: 10 undefined undefined</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [10]</span><br><span class="line"></span><br><span class="line">test(10, undefined); // 2</span><br><span class="line">// a b c: 10 undefined undefined</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [10, undefined]</span><br><span class="line"></span><br><span class="line">test(10, 20, 30); // 3</span><br><span class="line">// a b c: 10 20 30</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [10, 20, 30]</span><br></pre></td></tr></table></figure><p>arguments는 함수가 실행될 때 넘겨받은 모든 인자를 배열과 비슷한 형태로 담은 객체다. length로 넘겨받은 인자의 수를 확인할 수 있고 index로 순서별 인자를 확인할 수 있다. 2의 경우 1과 거의 유사하지만 arguments 객체가 다르게 생성이 된다. 인자로 undefined를 직접 넘긴 경우와 넘기지 않아 자연히 undefined 상태가 되는 것 사이에는 분명한 차이가 있다.</p><h3 id="인자-다시-보기"><a href="#인자-다시-보기" class="headerlink" title="인자 다시 보기"></a>인자 다시 보기</h3><p>인자는 일반 변수 혹은 객체와 약간 다르게 동작하는 부분이 있다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test2(a, b) &#123;</span><br><span class="line">  b = 10;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2(1); // 1</span><br><span class="line">// [1]</span><br><span class="line">test2(1, 2) // 2</span><br><span class="line">// [1, 10]</span><br></pre></td></tr></table></figure><p>인자는 변수와 달리 객체의 값이 바뀐다. 2는 arguments[1]에 해당하는 값이 넘어왔고, 인자인 b와 arguments[1]은 서로 마치 링크가 걸린 것 처럼 연결되어 있다. b를 고치니 arguments[1]도 바뀌었다. 1에서도 b를 고쳤는데 arguments[1]에 영향을 주지 않는다. 이 부분에 대해서 정확히 알고 있지 않은 상태에서 인자를 변경하는 코드를 작성할 경우, 의도와 다른 상황이 일어날 수 있을 것이다.</p><h3 id="this-다시-보기"><a href="#this-다시-보기" class="headerlink" title="this 다시 보기"></a>this 다시 보기</h3><p>위의 test 함수 내부의 console.log로 확인 하는 예제에서는 모든 this가 window 객체이다. 어떻게 해야 this에 다른 값이 들어갈 수 있을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; name: &quot;obj1&quot; &#125;;</span><br><span class="line">o1.test = test;</span><br><span class="line">o1.test(3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line"></span><br><span class="line">var a1 = [1, 2, 3];</span><br><span class="line">a1.test = test;</span><br><span class="line">a1.test(3, 3, 3);</span><br><span class="line">// a b c: 3 3 3</span><br><span class="line">// this: Array [1, 2, 3, test: f]</span><br><span class="line">// arguments: [3,3,3]</span><br></pre></td></tr></table></figure><p>기존에 있던 test 함수를 o1에 연결한 후 o1.test를 실행하니 this가 o1이 되었다. a1 역시 연결 후 실행하니 this가 a1이 되었다. 자바스크립트에서는 객체에 함수를 붙인 다음 그 함수를 . 으로 접근하여 실행하면 함수 내부의 this가 . 왼쪽의 객체가 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1_test = o1.test;</span><br><span class="line">o1_test(5, 6, 7);</span><br><span class="line">// a b c: 5 6 7</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [5, 6, 7]</span><br></pre></td></tr></table></figure><p>o1.test를 o1_test에 담은 다음 . 없이 o1_test를 실행했더니 this가 다시 window가 되었다. 이런 차이를 알아야 함수를 값으로 잘 다룰 수 있다. 실제로 메서드로 정의된 함수를 일반 함수처럼 사용하는 경우가 있다. o1.test에 붙였기 때문에 o1이 this가 되는 것이 아니라 . 으로 접근하여 실행했기 때문에 o1이 this가 되는 것이다. 어디에 붙어 있는 함수인지보다 어떻게 실행했는지가 중요하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(a1.test)(8, 9, 10);</span><br><span class="line">// a b c: 8 9 10</span><br><span class="line">// this: Array [1, 2, 3, test: f]</span><br><span class="line">// arguments: [8, 9, 10]</span><br><span class="line"></span><br><span class="line">a1[&apos;test&apos;](8, 9, 10);</span><br><span class="line">// a b c: 8 9 10</span><br><span class="line">// this: Array [1, 2, 3, test: f]</span><br><span class="line">// arguments: [8, 9, 10]</span><br></pre></td></tr></table></figure><p>괄호로 전체를 감쌌지만 여전히 this는 a1이 찍히고 있다. 참조를 어떻게 했느냐가 중요하다. [] 를 이용해 test 메서드를 참조 후 실행해도 . 으로 접근하여 실행한 것과 동일한 결과를 낸다.</p><p>자바스크립트에서의 함수는 ‘어떻게 선언했느냐’와 ‘어떻게 실행했느냐’가 모두 중요하다. ‘어떻게 정의했느냐’는 클로저와 스코프와 관련된 부분들을 결정하고 ‘어떻게 실행했느냐’는 this와 arguments를 결정한다.</p><h3 id="call-apply-다시-보기"><a href="#call-apply-다시-보기" class="headerlink" title="call, apply 다시 보기"></a>call, apply 다시 보기</h3><p>자바스크립트에서 함수를 실행하는 대표적인 방법이 2개 더 남아 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.call(undefined, 1, 2, 3);</span><br><span class="line">test.call(null, 1, 2, 3);</span><br><span class="line">test.call(void 0, 1, 2, 3);</span><br></pre></td></tr></table></figure><p>위 3가지 실행 모두 동일한 결과가 나온다. null 이나 undefined를 call의 첫 번째 인자에 넣으면 this는 windnow가 된다. void 0 의 결과도 undefined 이기 때문에 같은 결과가 나온다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.call(o1, 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">test.call(1000, 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Number &#123;1000&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>함수의 메서드인 call은 Function.prototype.call 이다. test는 함수이자 객체이고  test 객체의 call은 함수 자신(test)을 실행하면서 첫 번째 인자로 받은 값을 this로 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">o1.test.call(undefined, 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">o1.test.call([50], 3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Array [50]</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>call을 사용할 경우, 그 앞에서 함수를 .으로 참조했을지라도 call을 통해 넘겨받은 첫 번째 인자에 의해 this가 결정된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test.apply(o1, [3, 2, 1]);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">test.apply(1000, [3, 2, 1]);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Number &#123;1000&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">o1.test.apply(undefined, [3, 2, 1]);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Window &#123;...&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line">o1.test.apply([50], [3, 2, 1])</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Array [50]</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>apply는 call과 동일하게 동작하지만 인자 전달 방식이 다르다. 인자들을 배열이나 배열과 비슷한 객체를 통해 전달한다. 여기서 배열과 비슷하다는 것은 다음과 같은 값들을 사용할 수 있다는 말이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test.apply(o1, &#123; 0: 3, 1: 2, 2: 1, length: 3 &#125;);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Object &#123;name: &quot;obj1&quot;, test: f&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  test.apply(1000, arguments)</span><br><span class="line">&#125;)(3, 2, 1);</span><br><span class="line">// a b c: 3 2 1</span><br><span class="line">// this: Number &#123;1000&#125;</span><br><span class="line">// arguments: [3,2,1]</span><br></pre></td></tr></table></figure><p>{ 0: 3, 1: 2, 2: 1, length: 3 }은 Array도 아니고 Arguments도 아닌 그냥 일반 객체다. 숫자를 키로 사용하고 그에 맞는 length를 가지고 있다. 이와 같이 되어 있는 객체라면 apply를 통해 인자로 전달할 수 있다. 다른 함수를 통해 생성된 arguments도 apply로 전달할 수 있다.</p><h3 id="call의-실용적-사례"><a href="#call의-실용적-사례" class="headerlink" title="call의 실용적 사례"></a>call의 실용적 사례</h3><p>계속해서 확인하고 있는, 일반적이지 않은 이런 기법들은 유명한 자바스크립트 개발자들의 코드에서 자주 등장한다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var slice = Array.prototype.slice;</span><br><span class="line">function toArray(data) &#123;</span><br><span class="line">  return slice.call(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rest(data, n) &#123;</span><br><span class="line">  return slice.call(data, n || 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr1 = toArray(&#123; 0: 1, 1: 2, length: 2 &#125;);</span><br><span class="line">arr1.push(3);</span><br><span class="line">console.log(arr1);</span><br><span class="line">// [1,2,3]</span><br><span class="line"></span><br><span class="line">rest([1, 2, 3]);</span><br><span class="line">// [2, 3]</span><br><span class="line">rest([1, 2, 3], 2);</span><br><span class="line">// [3]</span><br></pre></td></tr></table></figure><p>Array.prototye.slice의 경우, 키를 숫자로 갖고 length를 갖는 객체이기만 하면 Array가 아닌 값이어도 call을 통해 Array.prototype.slice를 동작시킬 수 있다. toArray와 rest 함수는 구현을 <code>Native Helper</code>에게 위임하여 짧은 코드로 성능이 좋은 유틸 함수를 만들었다.</p><p>자바스크립트에서는 this 키워드 못지않게 call, apply, arguments 등도 중요하다. call, apply, arguments, bind 등을 알고 자바스크립트를 다루는 것과 그렇지 않은 것은 정말 큰 차이를 만든다. 그리고 이 모든 기능들은 자바스크립트의 함수와 관련되어 있다. 자바스크립트 진영의 객체지향 관련 라이브러리에도 상속이나 메서드 오버라이드 같은 것을 구현하기 위해서는 apply와 arguments 등을 사용해야 한다. 함수형 자바스크립트에서는 특히나 중요하다. apply, arguments는 좋은 도구들이며 실제로 매우 실용적이다.</p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>오늘은 함수형 프로그래밍을 시작하기 앞서 기본적인 것들을 다시 확인해보는 시간이었다. 이미 알고 있던 내용도 있었지만, 복습하고 확실히 익히고자 하는 마음으로 정리했다. 해당 챕터의 내용이 많아 나머지 내용은 다음 시간에 정리해야겠다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수형 자바스크립트를 잘 다루기 위해서는 숲을 보는 것보다 나무의 결을 들여다 보는 것이 중요하다. 자바스크립트 문법과 기본적인 동작에 집중해보자. 함수 하나가 정의되고 실행되고 참조되는 과정, 인자를 받거나 넘기는 과정, 클로저가 되거나 비동기가 일어나는 과정, 괄호, 대괄호, 점, 쉼표 등을 자세히 들여다 보자. 문법적 감각이 좋아지면 원하는 곳 어디에서나 함수를 열고 실행할 수 있게 된다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="객체" scheme="https://kkangil.github.io/tags/%EA%B0%9D%EC%B2%B4/"/>
    
      <category term="함수의 호이스팅" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%EC%9D%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/"/>
    
      <category term="named function" scheme="https://kkangil.github.io/tags/named-function/"/>
    
      <category term="call, apply, arguments, this" scheme="https://kkangil.github.io/tags/call-apply-arguments-this/"/>
    
  </entry>
  
  <entry>
    <title>함수형 자바스크립트를 위한 기초</title>
    <link href="https://kkangil.github.io/2019/10/13/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88/"/>
    <id>https://kkangil.github.io/2019/10/13/함수형-자바스크립트를-위한-기초/</id>
    <published>2019-10-13T06:52:02.000Z</published>
    <updated>2019-12-01T09:41:24.903Z</updated>
    
    <content type="html"><![CDATA[<p>함수형 자바스크립트를 잘 익히기 위해서는 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데 이를테면 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드 등이 있다.</p><a id="more"></a><h2 id="일급-함수"><a href="#일급-함수" class="headerlink" title="일급 함수"></a>일급 함수</h2><p>자바스크립트에서 함수는 일급 객체이자 일급 함수다. 자바스크립트에서 객체는 일급 객체다. 여기서 <code>일급</code>은 값으로 다룰 수 있다는 의미로, 아래와 같은 조건을 만족해야 한다.</p><ul><li>변수에 담을 수 있다.</li><li>함수나 메서드의 인자로 넘길 수 있다.</li><li>함수나 메서드에서 리턴할 수 있다.</li></ul><p>자바스크립트에서 모든 값은 일급이다. 자바스크립트에서 모든 객체는 일급 객체이며 함수도 객체이자 일급 객체다.<br>일급 함수는 아래와 같은 추가적인 조건을 더 만족한다.</p><ul><li>아무 때나(런타임에서도) 선언이 가능하다.</li><li>익명으로 선언할 수 있다.</li><li>익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123; &#125;</span><br><span class="line">var a = typeof f1 === &apos;function&apos; ? f1 : function () &#123; &#125;;</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line">  return function () &#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function (a, b) &#123; return a + b; &#125;)(10, 5);</span><br><span class="line"></span><br><span class="line">function callAndAdd(a, b) &#123;</span><br><span class="line">  return a() + b();</span><br><span class="line">&#125;</span><br><span class="line">callAndAdd(function () &#123; return 10; &#125;, function () &#123; return 5; &#125;)</span><br></pre></td></tr></table></figure><ul><li>f1은 함수를 값으로 다룰 수 있음을 보여준다.</li><li>f2는 함수를 리턴한다.</li><li>a와 b를 더하는 익명 함수를 선언하였으며, a와 b에 각각 10, 5를 전달하여 즉시 실행했다.</li><li>callAndAdd를 실행하면서 익명 함수들을 선언했고 바로 인자로 사용되었다. callAndAdd는 넘겨받은 함수 둘을 실행하여 결과들을 더한다.</li></ul><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p>스코프에 대한 개념을 잘 알고 있다면 이 글을 읽는 데 더욱 도움이 될 것 이다. 스코프란 변수를 어디에서 어떻게 찾을지를 정한 규칙으로, 여기에서 다루는 스코프는 함수 단위의 변수 참조에 대한 것이다.<br>함수는 변수 참조 범위를 결정하는 중요한 기준이다. 함수가 중첩되어 있다면 스코프들 역시 중첩되어 생겨난다.</p><p><i>클로저는 자신이 생성될 때의 환경을 기억하는 함수다.</i></p><p>이 말을 보다 실용적으로 표현해 보면 <strong>클로저는 자신의 상위 스코프의 변수를 참조할 수 있다</strong>고 할 수 있다.</p><p><i>클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다.</i></p><p>자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다. 자바스크립트의 모든 함수는 상위 스코프를 가지며 모든 함수는 자신이 정의되는 순간(정의되는 곳)의 실행 컨텍스트 안에 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">  var a = 5;</span><br><span class="line">  function myfn() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parent2() &#123;</span><br><span class="line">  var a = 5;</span><br><span class="line">  function parent1() &#123;</span><br><span class="line">    function myfn() &#123;</span><br><span class="line">      console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parent와 parent2의 myfn에서는 a라는 변수를 선언하지 않았지만 사용하고 있다. parent의 변수 a는 myfn을 생성하는 스코프에서 정의되었고 parent2의 변수 a는 myfn을 생성하는 스코프의 상위 스코프에 정의되었다.</p><p>위와 같은 조건을 충족시키지 않는다면 그 함수가 아무리 함수 안에서 선언되었다고 하더라도 일반 함수와 전혀 다를 바가 없다. 클로저가 기억할 환경이라는 것은 외부의 변수들밖에 없기 때문이다. 또한 자신의 상위 스코프에서 알 수 있는 변수를 자신이 사용하고 있지 않다면 그 환경을 기억해야 할 필요가 없다.<br>글로벌 스코프를 제외한 외부 스코프에 있었던 변수 중 클로저 혹은 다른 누군가가 참조하고 있지 않는 모든 변수는 실행 컨텍스트가 끝난 후 가비지 컬렉션 대상이 된다. 어떤 함수가 외부 스코프의 변수를 사용하지 않았고, 그래서 외부 스코프의 환경이 가비지 컬렉션 대상이 된다면 그렇게 내비려 두는 함수를 클로저라고 보기 어렵다.</p><p><i>클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.</i></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = 20;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f1은 클로저처럼 외부 변수를 참조하여 결과를 만든다. 게다가 상위 스코프의 변수를 사용하고 있으므로 앞서 강조했던 조건을 모두 충족시키고 있다. 그런데 왜 클로저가 아닐까?<br>글로벌 스코프에서 선언된 모든 변수는 그 변수를 사용하는 함수가 있는지 없는지와 관계없이 유지된다. a와 b 변수가 f1에 의해 사라지지 못하는 상황이 아니므로 f1은 클로저가 아니다.<br>그렇다면 클로저는 ‘함수 안에서 함수가 생성될 때’만 생성된다고 할 수 있을까? 그렇지 않다. 웹 브라우저에서는 함수 내부가 아니라면 모두 글로벌 스코프지만, 요즘 자바스크립트에서는 함수 내부가 아니면서 글로벌 스코프도 아닌 경우가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f2() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = 20;</span><br><span class="line">  function f3(c, d) &#123;</span><br><span class="line">    return c + d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f4 = f2();</span><br><span class="line">console.log(f4(5, 7));</span><br></pre></td></tr></table></figure><p>위 코드에서는 클로저가 있을까? 특히 f3처럼 함수 안에서 함수를 리턴하면 클로저처럼 보인다. 하지만 이 코드의 f4에 담긴 f3도 클로저가 아니다. f3은 f2 안에서 생성되었고 f3 바로 위에는 a, b라는 지역 변수도 있다. 하지만 f3 안에서 사용하고 있는 변수는 c,d이고 두 변수는 모두 f3에서 정의되었다. 자신이 생성될 때의 스코프가 알고 있는 변수 a, b는 사용하지 않았다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 자신이 스스로 정의한 c, d는 f3이 실행되고 나면 없어진다. 다시 실행되면 c, d를 다시 생성하고 리턴 후에 변수는 사라진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f4() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var b = 20;</span><br><span class="line">  function f5() &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f4());</span><br></pre></td></tr></table></figure><p>그렇다면 위 코드에서는 클로저가 있을까? 정확한 표현은 <code>있었다</code>이다. 결과적으로는 클로저는 없다고 볼 수 있다. f4가 실행되고 a, b가 할당된 후 f5가 정의된다. 그리고 f5에서는 a, b가 사용되고 있으므로 f5는 자신이 생성된 환경을 기억하는 클로저가 된다. 그런데 f4의 마지막 라인을 보면 f5를 실행하여 리턴한다. 결국 f5를 참조하고 있는 곳이 어디에도 없기 때문에 f5는 사라지고, f5가 사라지면 a, b도 결국 사라질 수 있기에 클로저는 f4가 실행되는 사이에만 생겼다가 사라진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f6() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  function f7(b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f8 = f6();</span><br><span class="line">console.log(f8(20));</span><br><span class="line">console.log(f8(10));</span><br></pre></td></tr></table></figure><p>드디어 클로저 코드를 사용했다. f7은 진짜 클로저다. 이제 a는 사라지지 않는다. f7이 a를 사용하기에 a를 기억해야 하고 f7이 f8에 담겼기 때문에 클로저가 되었다. 원래대로라면 f6의 지역 변수는 모두 사라져야 하지만 f6 실행이 끝났어도 f7이 a를 기억하는 클로저가 되었기 때문에 a는 사라지지 않으며, f8을 실행할 때마다 새로운 변수인 b와 함께 사용되어 결과를 만든다.</p><p>혹시 위 상황에 메모리 누수가 있다고 볼 수 있을까? 그렇지 않다. 메모리가 해제되지 않는 것과 메모리 누수는 다르다. 메모리 누수는 메모리가 해제되지 않을 때 일어나는 것은 맞지만, 위 상황을 메모리 누수라고 할 수는 없다. a는 한 번 생겨날 뿐, 계속해서 생겨나거나 하지 않는다. 메모리 누수란 개발자가 의도하지 않았는데 메모리가 해제되지 않고 계속 남는 것을 말하며, 메모리 누수가 지속적으로 반복될 때는 치명적인 문제를 만든다. f8이 아무리 많이 실행되더라도 이미 할당된 a가 그대로 유지되기 때문에 메모리 누수는 일어나지 않는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f9() &#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  var f10 = function (c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line">  var b = 20;</span><br><span class="line">  return f10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f11 = f9();</span><br><span class="line">console.log(f11(30));</span><br></pre></td></tr></table></figure><p>위 코드는 에러없이 정상 동작한다. 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수라고 했었는데, 여기서 ‘때’는 생각하는 것보다 조금 길다고 했었다.<br>f10에는 익명 함수를 담았다. f10이 생성되기 딱 이전 시점에는 b가 20으로 초기화되지 않았다. 클로저는 자신이 생성되는 스코프의 모든 라인, 어느곳에서 선언된 변수든지 참조하고 기억할 수 있다. 그리고 그것은 변수이기에 클로저가 생성된 이후 언제라도 그 값은 변경될 수 있다.</p><p>클로저는 자바스크립트에서 절차지향 프로그래밍, 객체지향 프로그래밍, 함수형 프로그매일 모두를 지탱하는 매우 중요한 기능이자 개념이다. 분명 클로저는 메모리 누수 같은 위험성을 가지고 있다. 그러나 메모리 누수나 성능 저하의 문제는 클로저의 단점이나 문제가 아니다.</p><h2 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h2><p>고차 함수란, 함수를 다루는 함수를 말한다.</p><ol><li>함수를 인자를 받아 대신 실행하는 함수</li><li>함수를 리턴하는 함수</li><li>함수를 인자를 받아서 또 다른 함수를 리턴하는 함수</li></ol><p>고차 함수을 시작하기전 정의를 보고 클로저와의 차이점이 궁금해져 검색해봤다. </p><blockquote><p><i>“Closures are also functions. But when a function captures state upon its creation, we call it a closure.”</i><br>즉, 클로저 역시 함수지만, 함수가 생성될 때 state를 점유하고 있다면 우리는 그것을 클로저라고 합니다.</p></blockquote><p>출처: <a href="https://azsha.tistory.com/100" target="_blank" rel="noopener">https://azsha.tistory.com/100</a> [Azsha’s Forge]</p><p>사실상 함수형 프로그래밍의 절반은 고차 함수를 적극적으로 활용하는 프로그래밍이라고도 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function callWith10(val, func) &#123;</span><br><span class="line">  return func(10, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(callWith10(20, add));</span><br><span class="line">console.log(callWith10(5, sub));</span><br></pre></td></tr></table></figure><p>여기서 add와 sub는 일반 함수다. 함수를 인자로 받거나 함수를 리턴하지 않기 때문이다. callWith10은 고차 함수다. 함수를 받아 내부에서 대신 실행하기 때문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function constant(val) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var always10 = constant(10);</span><br><span class="line">console.log(always10()); // 10</span><br><span class="line">console.log(always10()); // 10</span><br><span class="line">console.log(always10()); // 10</span><br></pre></td></tr></table></figure><p>constant 함수는 실행 당시 받았던 10이라는 값을 받아 내부에서 익명 함수를 클로저로 만들어 val를 기억하게 만든 수 리턴한다. 리턴된 함수에는 always10 이라는 이름을 지어주었다. always10을 실행하면 항상 10을 리턴한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function callWith(val1) &#123;</span><br><span class="line">  return function (val2, func) &#123;</span><br><span class="line">    return func(val1, val2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var callWith10 = callWith(10);</span><br><span class="line">console.log(callWith10(20, add)); // 30</span><br><span class="line"></span><br><span class="line">var callWith5 = callWith(5);</span><br><span class="line">console.log(callWith5(5, sub)); // 0</span><br></pre></td></tr></table></figure><p>callWith는 함수를 리턴하는 함수다. val1을 받아서 val1을 기억하는 함수를 리턴했다. 리턴된 함수는 이후에 val2와 func를 받아 대신 func를 실행해 준다. 함수를 리턴하는 함수를 사옹할 경우 다음처럼 변수에 담지 않고 바로 실행해도 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(callWith(30)(20, add));</span><br><span class="line">console.log(callWith(5)(5, sub));</span><br></pre></td></tr></table></figure><p>인자는 숫가자 아닌 값도 활용이 가능하다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_.get = function (list, index) &#123;</span><br><span class="line">  return list[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users = [</span><br><span class="line">  &#123; id: 2, name: &quot;HA&quot;, age: 25 &#125;,</span><br><span class="line">  &#123; id: 4, name: &quot;PJ&quot;, age: 28 &#125;,</span><br><span class="line">  &#123; id: 5, name: &quot;JE&quot;, age: 27 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var callWithUsers = callWith(users);</span><br><span class="line">console.log(callWithUsers(2, _.get));</span><br></pre></td></tr></table></figure></p><h2 id="콜백-함수라-잘못-불리는-보조-함수"><a href="#콜백-함수라-잘못-불리는-보조-함수" class="headerlink" title="콜백 함수라 잘못 불리는 보조 함수"></a>콜백 함수라 잘못 불리는 보조 함수</h2><p>콜백 함수를 받아 자신이 해야 할 일을 모두 끝낸 후 결과를 되돌려 주는 함수도 고차 함수다. 보통은 비동기가 일어나는 상황에서 사용되며 콜백 함수를 통해 다시 원래 위치로 돌아오기 위해 사용되는 패턴이다. 콜백 패턴은 클로저 등과 함께 사용할 수 있는 매우 강력한 표현이자 비동기 프로그래밍에 있어 없어서는 안 될 매우 중요한 패턴이다. 콜백 패턴은 끝이 나면 컨텍스트를 다시 돌려주는 단순한 협업 로직을 가진다.</p><p>button.click(function() {})과 같은 코드의 익명 함수도 콜백 함수라고 표현되는 것을 많이 보았지만, 이 익명 함수는 ‘이벤트 리스너’라고 칭하는 것이 적합하다. 함수가 고차 함수에서 쓰이는 역할의 이름으로 불러주면 된다. _.each([1,2,3], function() {})에서의 익명 함수는 callback이 아니라 <code>iteratee</code>이며 _.filter(users, function() {})에서의 익명 함수는 <code>predicate</code>다. callback은 종료가 되었을 때 단 한 번 실행되지만 <code>iteratee</code>나 <code>predicate</code>, <code>listener</code>등은 종료될 때 실행되지 않으며 상황에 따라 여러 번 실행되기도 하고 각각 다른 역할을 한다.</p><h2 id="함수를-리턴하는-함수와-부분-적용"><a href="#함수를-리턴하는-함수와-부분-적용" class="headerlink" title="함수를 리턴하는 함수와 부분 적용"></a>함수를 리턴하는 함수와 부분 적용</h2><p>앞서 곳곳에서 미리 필요한 인자를 넘겨 두고 그 인자를 기억하는 클로저를 리턴하는 함수들을 확인했다. 클로저로 만들어진 함수가 추가적으로 인자를 받아 로직을 완성해 나가는 패턴을 갖는다. 이와 유사한 기법들로 bind, curry, partial 등이 있다. 이런 기법들을 통틀어 칭하는 특별한 용어는 없지만 다음과 같은 공통점을 갖는다.</p><p><i>기억하는 인자 혹은 변수가 있는 클로저를 리턴한다.</i></p><p>bind는 this와 인자들이 부분적으로 적용된 함수를 리턴한다. bind의 경우 인자보다는 주로 함수 안에서 사용될 this를 적용해 두는데 많이 사용한다. 그 이유는 아마 this 적용을 스킵할 수 없다는 점과 인자의 부분 적용을 왼쪽에서 부터 순서대로 할 수 있는 점 때문일 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var add10 = add.bind(null, 10);</span><br><span class="line">console.log(add10(20)); // 30</span><br></pre></td></tr></table></figure><p>bind는 첫 번째 인자로 bind가 리턴할 함수에서 사용될 this를 받는다. 두 번째 인자부터 함수에 미리 적용될 인자들이다. 인자를 미리 적용해 두기 위해 this로 사용될 첫 번째 인자에 null을 넣은 후 10을 넣었다. add10과 같이 this를 사용하지 않는 함수이면서 왼쪽에서 부터 순서대로만 인자를 적용하면 되는 상황에서는 원하는 결과를 얻을 수 있다. bind의 아쉬운 점은 두 가지다. 인자를 왼쪽에서 부터 순서대로만 적용할 수 있다는 점과 bind를 한 번 실행한 함수의 this는 무엇을 적용해 두었든 앞으로 바꿀 수 없다는 점이다.<br>bind는 왼쪽에서 부터 원하는 만큼의 인자를 지정해 둘 수 있지만 원하는 지점을 비워 두고 적용할 수는 없다. 예를 들어 어떤 함수가 필요로 하는 인자가 3개가 있는데 그 중 두 번째 인자만을 적용해 두고 싶다면 bind로는 이것을 할 수 없다. 이러한 점을 개선한 방식이 있는데 바로 partial 이다.</p><h3 id="존-레식의-partial"><a href="#존-레식의-partial" class="headerlink" title="존 레식의 partial"></a>존 레식의 partial</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.partial = function () &#123;</span><br><span class="line">  var fn = this, args = Array.prototype.slice.call(arguments); // 1</span><br><span class="line">  return function () &#123; // 2</span><br><span class="line">    var arg = 0;</span><br><span class="line">    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) // 5</span><br><span class="line">      if (args[i] === undefined) args[i] = arguments[arg++]; // 6</span><br><span class="line"></span><br><span class="line">    return fn.apply(this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function abc(a, b, c) &#123;</span><br><span class="line">  console.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ac = abc.partial(undefined, &apos;b&apos;, undefined); // 3 </span><br><span class="line">ac(&apos;a&apos;, &apos;c&apos;); // 4</span><br><span class="line">// a, b, c</span><br></pre></td></tr></table></figure><ol><li>우선 <code>partial</code>이 실행되면 fn에 자기 자신인 this를 담는다. 여기서 자기 자신은 abc 같은 함수다. args에는 partial이 실행될 때 넘어온 인자들을 배열로 변경하여 args에 담아 둔다.</li><li>fn과 args는 리턴된 익명 함수가 기억하게 되므로 지워지지 않는다.</li><li>abc.partial을 실행할 때 첫 번째 인자와 세 번쩨 인자로 넘긴 undefined 자리는 나중에 ac가 실행될 때 채워질 것이다. </li><li>ac를 실행하면서 넘긴 ‘a’와 ‘c’는 </li><li>리턴된 익명 함수의 arguments에 담겨 있다.</li><li>for를 돌면서 미리 받아 두었던 args에 undefined가 들어 있던 자리를 arguments의 앞에서 부터 꺼내면서 모두 채운다. 다 채우고 나면 미리 받아 두었던 fn을 apply로 실행하면서 인자들을 배열로 넘긴다.</li></ol><p>사실 partial은 구현이 잘 된 것은 아니다. 함수의 인자로 undefined를 사용하고 싶을 수도 있는데 undefined가 인자를 비워 두기 우한 구분자로 사용되고 있기 때문에, undefined를 미리 적용하고 싶다면 방법이 없다. 또한 초기에 partial을 실행할 때 나중에 실제로 실행될 함수에서 사용할 인자의 개수만큼 꼭 미리 채워 놓아야만 한다. 이 처럼 partial이 가진 제약은 ‘인자 개수 동적으로 사용하기’나 ‘arguments 객체 활용’과 같은 자바스크립트의 유연함을 반영하지 못한다는 점에서 특히 아쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">  var result = 0;</span><br><span class="line">  for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    result += arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 2, 3, 4, 5));</span><br><span class="line"></span><br><span class="line">var add2 = add.partial(undefined, 2);</span><br><span class="line">console.log(add2(1, 3, 4, 5)); // 3</span><br><span class="line"></span><br><span class="line">var add3 = add.partial(undefined, undefined, 3, undefined, undefined);</span><br><span class="line">console.log(add3(1, 2, 4, 5)); // 15</span><br><span class="line"></span><br><span class="line">console.log(add3(50, 50, 50, 50)); // 15 (bug)</span><br><span class="line">console.log(add3(100, 100, 100, 100)); // 15 (bug)</span><br></pre></td></tr></table></figure><p>위 상황에서 add2는 3, 4, 5 인자를 무시하게 된다. add3처럼 하면 1, 2, 4, 5를 모두 사용할 수 있게 되지만 undefined로라도 인자 개수를 채워놔야 해서 코드가 깔끔하지 못하고 partial 이후에는 역시 4개 이상의 인자를 사용할 수 없다는 단점이 생긴다.<br>위 코드에는 치명적인 문제가 있다. 의도한 것인지는 모르겠지만 그가 만든 partial 함수로 만든 함수는 재사용이 사실상 불가능하다. 한번 partial을 통해 만들어진 함수를 실행하고 나면 클로저로 생성된 args의 상태를 직접 변경하기 때문에, 다음번에 다시 실행해도 같은 args를 바라보고 이전에 적용된 인자가 남는다. 결과적으로 partial로 만들어진 함수는 단 한 번만 정상적으로 동작한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.partial = function () &#123;</span><br><span class="line">  var fn = this, _args = arguments;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(_args);</span><br><span class="line">    var arg = 0;</span><br><span class="line">    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++)</span><br><span class="line">      if (args[i] === undefined) args[i] = arguments[arg++];</span><br><span class="line"></span><br><span class="line">    return fn.apply(this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같이 두 줄만 변경하면 두 번 이상 실행해도 정상적으로 동작한다. 클로저가 기억할 변수에는 원본을 남기고 리턴된 함수가 실행될 때마다 복사하여 원본을 지키는 방식을 사용한다. </p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>오늘은 본격적인 함수형 프로그래밍 시작에 앞서 기본이 될 기능들을 확인해 봤다. 일급 함수 같은 처음 듣는 용어도 있었고, 고차 함수 같은 경우는 내가 실무에서도 사용하고 있지만 정확한 용어도 모르고 사용하고 있었다. 또한 클로저, callback의 존재?는 알고 있었지만 정확한 개념이 부족했다는 것을 느꼈다. 오늘 내용의 모든 기능들의 대한 설명이 이 포스트로는 부족하지만 실력 향상에 많은 도움이 될 것같다. 기록해 두고 자주 보면서 내 것으로 만들어야 할 것 같다. </p><p>partial 같은 함수를 보고 들었던 생각은 함수형 프로그래밍의 끝은 어디 일까가 궁금해졌다. 정말 나는 생각도 못했던 기능이고 저게 그래서 실무에서 필요할까? 라는 생각을 했다. 하지만 partial과 같은 helper 함수들을 구현해 놓고 사용하면 생산성이 눈에 띄게 좋아질 것 같다고 생각한다.</p><p>이제 1장의 내용이 끝났는데 다음 장의 내용은 함수형 자바스크립트를 위한 문법 다시보기 이다. 이미 알고 있던 내용일 지더라도 기초를 더 다지기 위해 소홀히 보지 않아야겠다. </p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수형 자바스크립트를 잘 익히기 위해서는 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데 이를테면 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드 등이 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="일급 함수" scheme="https://kkangil.github.io/tags/%EC%9D%BC%EA%B8%89-%ED%95%A8%EC%88%98/"/>
    
      <category term="클로저" scheme="https://kkangil.github.io/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"/>
    
      <category term="고차 함수" scheme="https://kkangil.github.io/tags/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/"/>
    
      <category term="partial function" scheme="https://kkangil.github.io/tags/partial-function/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 - 시작2</title>
    <link href="https://kkangil.github.io/2019/09/29/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%912/"/>
    <id>https://kkangil.github.io/2019/09/29/함수형-프로그래밍-시작2/</id>
    <published>2019-09-29T06:27:54.000Z</published>
    <updated>2019-12-01T09:40:56.647Z</updated>
    
    <content type="html"><![CDATA[<p>이전 포스트에서 함수형 프로그래밍의 간략한 소개와 몇가지 예제 코드를 구현했었다. 오늘은 이전 포스트에 이어 다음 내용을 진행하려고 한다.</p><h2 id="회원-목록-중-한명-찾기"><a href="#회원-목록-중-한명-찾기" class="headerlink" title="회원 목록 중 한명 찾기"></a>회원 목록 중 한명 찾기</h2><p>회원 목록 중 id 값으로 해당 id 값을 가진 회원 한 명을 찾고자 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  filter(users, function (user) &#123; return user.id === 3 &#125;)[0]</span><br><span class="line">)</span><br><span class="line">// &#123;id: 3, name: &quot;BJ&quot;, age: 32&#125;</span><br></pre></td></tr></table></figure><p>filter를 통해 걸러낸 후 [0]으로 user를 얻어냈고 원하는 결과를 얻어냈기는 했다. 위 처럼 filter를 사용하여 찾을 수 있지만 filter 함수는 무조건 list.length 만큼 predicate가 실행되기 때문에 효율적이지 못하고, 동일 조건에 값이 두 개 이상이라면 두 개 이상의 값을 찾는다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user;</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].id === 3) &#123;</span><br><span class="line">    user = users[i];</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(user);</span><br></pre></td></tr></table></figure><p>원하는 user를 찾은 후 break로 for문을 빠져나왔다. 앞선 filter를 통해 찾은 것보다 훨씬 효율적이다.<br>하지만 위 코드는 재사용이 불가능 하므로 위 코드를 함수로 만들어서 재사용 가능하도록 만들어 보려고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function findById(list, id) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].id === id) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findById(users, 3));</span><br><span class="line">console.log(findById(users, 5));</span><br></pre></td></tr></table></figure><p>findById는 list와 id를 받아 루프를 돌다가 id가 동일한 객체를 만나면 그 값을 리턴한다.<br>만약 동일한 객체를 찾지 못한다면 기본 리턴 값인 undefined 가 리턴된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findByName</span><br><span class="line"> */</span><br><span class="line">function findByName(list, name) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].name === name) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findByName(users, &apos;BJ&apos;));</span><br><span class="line">console.log(findByName(users, &apos;JE&apos;));</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * findByAge</span><br><span class="line"> */</span><br><span class="line">function findByAge(list, age) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i].age === age) &#123;</span><br><span class="line">      return list[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findByAge(users, 28));</span><br><span class="line">console.log(findByAge(users, 25));</span><br></pre></td></tr></table></figure><p>findById 와 동일하게 이름과 나이로도 찾을 수 있는 함수를 만들었다. 하지만 위의 세 함수 사이에 중복이 있다는 점이 아쉽다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findBy</span><br><span class="line"> */</span><br><span class="line">function findBy(key, list, val) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (list[i][key] === val) return list[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(findBy(&apos;name&apos;, users, &apos;BJ&apos;));</span><br><span class="line">console.log(findBy(&apos;id&apos;, users, 2));</span><br><span class="line">console.log(findBy(&apos;age&apos;, users, 28));</span><br></pre></td></tr></table></figure><p>위와 같이 함수에 key 라는 인자를 하나 추가함으로써 세 함수를 공통으로 사용할 수 있게됐다. 위 함수는 key로 value를 얻을 수 있는 객체들을 가진 배열이라면 무엇이든 받을 수 있다. 객체의 key 값이 무엇이든지 간에 찾아줄 수 있으므로 훨씬 많은 경우를 대응할 수 있는 함수가 되었다.<br>하지만 위 함수에서도 아직 아쉬운 점이 존재한다.</p><ul><li>key가 아닌 메서드를 통해 값을 얻어야 할 때</li><li>두 가지 이상의 조건이 필요할 때</li><li>===이 아닌 다른 조건으로 찾고자 할 때</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function User(id, name, age) &#123;</span><br><span class="line">  this.getId = function () &#123;</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">  this.getName = function () &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line">  this.getAge = function () &#123;</span><br><span class="line">    return age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users2 = [</span><br><span class="line">  new User(1, &quot;ID&quot;, 32),</span><br><span class="line">  new User(2, &quot;HA&quot;, 25),</span><br><span class="line">  new User(3, &quot;BJ&quot;, 32),</span><br><span class="line">  new User(4, &quot;PJ&quot;, 28),</span><br><span class="line">  new User(5, &quot;JE&quot;, 27),</span><br><span class="line">  new User(6, &quot;JM&quot;, 32),</span><br><span class="line">  new User(7, &quot;HI&quot;, 24),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">console.log(findBy(&apos;age&apos;, users2, 25));</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure><p>user의 나이를 .getAge() 로 얻어내야 하기 때문에 findBy 함수로는 위 상황을 대응할 수 없을을 알 수 있다. 이름에 ‘P’ 가 포함된 user를 찾고 싶다거나 아니가 32이면서 이름이 ‘JM’인 user를 찾고 싶다거나 하는 것도 불가능하다.</p><h2 id="값에서-함수로"><a href="#값에서-함수로" class="headerlink" title="값에서 함수로"></a>값에서 함수로</h2><p>앞서 만들었던 filter나 map처럼, 인자로 키와 값 대신 함수를 사용해 보려고 한다. 그렇게 하면 모든 상황에 대응 가능한 find 함수를 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function find(list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) return list[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  find(users2, function (u) &#123; return u.getAge() === 25 &#125;).getName()</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.name.indexOf(&apos;P&apos;) !== -1 &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.age === 32 &amp;&amp; u.name === &apos;JM&apos; &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users2, function (u) &#123; return u.getAge() &lt; 30 &#125;).getName()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>find의 인자로 key와 val 대신 predicate 함수 하나를 받았다. 값 대신 함수를 받았다. 덕분에 if 안쪽에서 할 수 있는 일이 정말 많아졌다. 메서드를 사용하거나 두가지 이상의 조건을 사용하는 것도 잘 동작한다.<br>find는 이제 배열에 어떤 값이 들어 있든 사용할 수 있게 되었다. <strong>함수형 자바스크립트는 이처럼 다형성이 높은 기법을 많이 사용하며 이러한 기법은 정말 실용적이다</strong></p><p>filter, map, find 함수들은 들어온 데이터가 무엇이든지 루프들 돌리거나 분기를 만들거나 push를 하거나 predicate를 실행하거나 등의 자기 할 일을 한다. find는 전달 받을 데이터와 데이터의 특성에 맞는 보조 함수(predicate)도 함께 전달받는다. 들어온 데이터의 특성은 보조 함수가 대응해 주기 때문에 find 함수는 데이터의 특성에서 완전히 분리될 수 있다. 이러한 방식은 다형성을 높이며 동시에 안정성도 높인다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 다형성</span><br><span class="line"> */</span><br><span class="line">console.log(</span><br><span class="line">  map(</span><br><span class="line">    filter(users, function (u) &#123; return u.age &gt;= 30 &#125;),</span><br><span class="line">    function (u) &#123; return u.name &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  map(</span><br><span class="line">    filter(users2, function (u) &#123; return u.getAge() &gt; 30 &#125;), // 메서드 실행으로 변경</span><br><span class="line">    function (u) &#123; return u.getName() &#125; // 메서드 실행으로 변경</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="함수를-만드는-함수와-find-filter-조합하기"><a href="#함수를-만드는-함수와-find-filter-조합하기" class="headerlink" title="함수를 만드는 함수와 find, filter 조합하기"></a>함수를 만드는 함수와 find, filter 조합하기</h2><p>User등의 커스텀 객체가 아닌 자바스크립트 기본 객체로 만들어진 users를 사용한 예제로 다시 돌아가 보자. 함수로 함수를 만들어 find 함수와 함께 사용하면 코드를 더욱 간결하게 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function bmatch1(key, val) &#123;</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return obj[key] === val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(find(users, bmatch1(&apos;id&apos;, 1)));</span><br><span class="line">console.log(find(users, bmatch1(&apos;name&apos;, &apos;BJ&apos;)));</span><br><span class="line">console.log(find(users, bmatch1(&apos;age&apos;, 28)));</span><br></pre></td></tr></table></figure><p>bmatch1의 실행 결과는 함수다. key와 val을 미리 받아서 나중에 들어올 obj와 비교하는 익명 함수 클로저로 만들어 리턴한다. bmatch1을 통해 id, name, age를 비교하는 predicate 3개를 만들어 find에 넘겼다.<br>bmatch1은 함수를 리턴하기 때문에 filter나 map과도 조합이 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(filter(users, bmatch1(&apos;age&apos;, 32)));</span><br><span class="line">console.log(map(users, bmatch1(&apos;age&apos;, 32)));</span><br></pre></td></tr></table></figure><p>bmatch1은 하나의 key에 대한 value만 비교할 수 있다. 여러 개의 key에 해당하는 value들을 비교하는 함수를 만들어보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function object(key, val) &#123;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  obj[key] = val;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function match(obj, obj2) &#123;</span><br><span class="line">  for (var key in obj2) &#123;</span><br><span class="line">    if (obj[key] !== obj2[key]) return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bmatch(obj2, val) &#123;</span><br><span class="line">  if (arguments.length == 2) obj2 = object(obj2, val);</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return match(obj, obj2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  match(find(users, bmatch(&apos;id&apos;, 3)), find(users, bmatch(&apos;name&apos;, &apos;BJ&apos;)))</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, function (u) &#123; return u.age === 32 &amp;&amp; u.name === &apos;JM&apos; &#125;)</span><br><span class="line">);</span><br><span class="line">console.log(</span><br><span class="line">  find(users, bmatch(&#123; name: &apos;JM&apos;, age: 32 &#125;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이제는 (key, val)와 ({key: val}) 두 가지 방식으로 사용할 수 있다. ({key: val}) 방식을 사용하면 두 가지 이상의 값이 모두 동일한지도 확인할 수 있다. bmatch1을 bmatch로 발전시키면서 유용한 함수인 match와 object도 만들어졌다. 이처럼 작은 기능을 하는 함수로 쪼개거나 재조합하는 식으로 코드를 발전시키는것도 좋은 방법이다.</p><p>find를 조금만 고치면 값 비교만 하는 <code>Array.prototype.indexOf</code>보다 활용도가 훨씬 높은 findIndex를 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * findIndex</span><br><span class="line"> */</span><br><span class="line">function findIndex(list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) return i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(findIndex(users, bmatch(&#123; name: &apos;JM&apos;, age: 32 &#125;))) // 5</span><br><span class="line">console.log(findIndex(users, bmatch(&#123; age: 36 &#125;))) // -1</span><br><span class="line">console.log(findIndex(users, bmatch(&apos;id&apos;, 2))); // 1</span><br></pre></td></tr></table></figure><h2 id="고차함수"><a href="#고차함수" class="headerlink" title="고차함수"></a>고차함수</h2><p>앞서 구현했던 filter, map, find, findIndex, bvalue, bmatch 같은 함수들은 모두 고차 함수다.<br>고차 함수란, 함수를 인자로 받거나 함수를 리턴하는 함수를 말한다. 당연히 둘 다 하는 경우도 고차 함수다. 보통 고차 함수는 함수를 인자로 받아 필요한 때에 실행하거나 클로저를 만들어 리턴한다.</p><p><code>Underscore.js</code>는 유명한 함수형 자바스크립트 라이브러리다. <code>Underscore.js</code> 의 _.map, _.filter, _.find, _.findIndex는 iteratee와 predicate가 사용할 인자를 몇 가지 더 제공한다. 재료가 많으면 더 다양한 로직을 만들 수 있다. 앞서 구현했던 고차 함수들을 <code>Underscore.js</code>에 가깝게 고쳐 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_.map = function (list, iteratee) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    new_list.push(iteratee(list[i], i, list))</span><br><span class="line">  &#125;</span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.filter = function (list, predicate) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) new_list.push(list[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.find = function (list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) return list[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.findIndex = function (list, predicate) &#123;</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i], i, list)) return i</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원래는 iteratee(list[i])처럼 한 개의 인자를 넘겼지만, 이제는 iteratee(list[i], i, list) 처럼 두 개의 인자를 추가했다. 이제 iteratee와 predicate 함수가 받는 인자가 많아져 좀 더 다양한 일을 할 수 있게 되었다. predicate도 iteratee와 동일하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  _.filter([1, 2, 3, 4], function (val, idx) &#123;</span><br><span class="line">    return idx &gt; 1;</span><br><span class="line">  &#125;)</span><br><span class="line">) // [3, 4]</span><br><span class="line">console.log(</span><br><span class="line">  _.filter([1, 2, 3, 4], function (val, idx) &#123;</span><br><span class="line">    return idx % 2 === 0;</span><br><span class="line">  &#125;)</span><br><span class="line">) // [1,3]</span><br></pre></td></tr></table></figure><h2 id="function-identity"><a href="#function-identity" class="headerlink" title="function identity"></a>function identity</h2><p>정말 쓸모 없어 보이는 이상한 함수 하나를 소개한다. 이것은 <code>Underscore.js</code>에 있는 함수이기도 하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.identity = function (v) &#123; return v &#125;;</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(_.identity(10)) // 10</span><br></pre></td></tr></table></figure><p>받은 인자를 그냥 그대로 뱉는 함수다. _.identity 같은 아무런 기능이 없는 함수는 대체 언제 사용해야 하는 걸까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(_.filter([true, 0, 10, &apos;a&apos;, false, null], _.identity));</span><br><span class="line">// [true, 10, &apos;a&apos;]</span><br></pre></td></tr></table></figure><p>_.filter를 _.identity와 함께 사용했더니 <code>Truthy Values</code>만 남았다. 이렇게 놓고 보니 _.identity가 생각보다 실용적으로 보인다. _.identity를 다른 고차 함수와 조합하는 식으로 아래와 같은 유용한 함수들을 만들 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return !!_.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return _.filter(list, _.identity).length === list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_.some([0, null, 2])); // true</span><br><span class="line">console.log(_.some([0, null, false])); // false</span><br><span class="line"></span><br><span class="line">console.log(_.every([0, null, true])); // false</span><br><span class="line">console.log(_.every([&#123;&#125;, true, 2])); // true</span><br></pre></td></tr></table></figure><p>_.some은 배열에 들어 있는 값 중 하나라도 긍정적인 값이 있으면 true, 하나도 없다면 false를 리턴한다.<br>_.every는 모두 긍정적인 값이어야 true를 리턴한다. _.some, _.every는 if나 predicate 등과 함께 사용할 때 매우 유용하다.<br>_.every는 filter를 사용했기 때문에 항상 루프를 끝까지 돌게 된다. 정말 쓸모 없어 보이지만 함수 두 개를 더 만들면 로직을 개선할 수 있다.</p><h2 id="연산자-대신-함수로"><a href="#연산자-대신-함수로" class="headerlink" title="연산자 대신 함수로"></a>연산자 대신 함수로</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function not(v) &#123; return !v; &#125;</span><br><span class="line">function beq(a) &#123;</span><br><span class="line">  return function (b) &#123;</span><br><span class="line">    return a === b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!를 써도 되는데 <code>not</code>이 왜 필요할까? ===로 비교하면 되는데 <code>beq</code>는 왜 필요할까? 굳이 not과 beq를 함수로 만들 필요가 있을까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return !!_.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return beq(-1)(_.findIndex(list, not));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_.some([0, null, 2, 0])); // true</span><br><span class="line">console.log(_.some([0, null, false])); // false</span><br><span class="line"></span><br><span class="line">console.log(_.every([0, null, true])); // false</span><br><span class="line">console.log(_.every([&#123;&#125;, true, 2])); // true</span><br></pre></td></tr></table></figure><p>not은 연산자 !가 아닌 함수이기 때문에 _.findIndex와 함께 사용할 수 있다. list의 값 중 하나라도 부정적인 값을 만나면 predicate가 not이므로 true를 리턴하여 해당번째 i 값을 리턴하게 된다. 중간에 부정적인 값을 한 번이라고 만나면 루프가 중단된다. 만일 부정적인 값이 하나도 없다면 -1을 리턴한다.<br>_.every는 쓸모 없어 보이는 정말 작은 함수 not 덕분에 로직이 개선되었다. 좀 더 함수를 쪼개보다. 함수가 가능하면 한 가지 일만 하게끔 말이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function positive(list) &#123;</span><br><span class="line">  return _.find(list, _.identity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function negetiveIndex(list) &#123;</span><br><span class="line">  return _.findIndex(list, not);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.some = function (list) &#123;</span><br><span class="line">  return not(not(positive(list)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.every = function (list) &#123;</span><br><span class="line">  return beq(-1)(negetiveIndex(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="함수-합성"><a href="#함수-합성" class="headerlink" title="함수 합성"></a>함수 합성</h2><p>함수를 쪼갤수록 함수 합성은 쉬워진다. 다음은 다양한 함수 합성 기법 중 하나인 <code>Underscore.js</code>의 _.compose다. _.compose는 오른쪽의 함수의 결과를 바로 왼쪽의 함수에게 전달한다. 그리고 해당 함수의 결과를 다시 자신의 왼쪽의 함수에게 전달하는 고차 함수다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_.compose = function () &#123;</span><br><span class="line">  var args = arguments;</span><br><span class="line">  var start = args.length - 1;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var i = start;</span><br><span class="line">    var result = args[start].apply(this, arguments);</span><br><span class="line">    while (i--) result = args[i].call(this, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var greet = function (name) &#123; return &apos;hi: &apos; + name; &#125;;</span><br><span class="line">var exclaim = function (statement) &#123; return statement.toUpperCase() + &apos;!&apos;; &#125;;</span><br><span class="line">var welcome = _.compose(greet, exclaim);</span><br><span class="line">console.log(welcome(&apos;moe&apos;));</span><br></pre></td></tr></table></figure><p>welcome을 실행하면 먼저 exclaim을 실행하면서 “moe”를 인자로 넘겨준다. exclaim 의 결과는 대문자로 변환된 “MOE!”이고 그 결과는 다시 greet의 인자로 넘어가 최종 결과로 “hi: MOE!”를 리턴한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.some = _.compose(not, not, positive);</span><br><span class="line">_.every = _.compose(beq(-1), negetiveIndex);</span><br></pre></td></tr></table></figure><p>_.compose로 _.some과 _.every를 더 간결하게 표현했다. 맨 오른쪽의 함수가 인자를 받아 결과를 만들고 결과는 다시 그 왼쪽의 함수에게 인자로 전달된다. 오른쪽에서 부터 왼쪽으로 연속적으로 실행되어 최종 결과를 만든다.</p><p>값 대신 함수로, for와 if 대신 고차 함수와 보조 함수로, 연산자 대신 함수로, 함수 합성 등 앞서 설명한 함수적 기법들을 사용하면 코드도 간결해지고 함수명을 통해 로직을 더 명확히 전달할 수 있어 읽기 좋은 코드가 된다.</p><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>저번 포스트에서는 함수를 조합해서 사용한다는 것에 정확한 이해가 부족했는데, 이번 포스트를 통해 어느정도의 이해는 된것같다. 이번 포스트에서 제일 크게 느낀점은 “기능 단위로 최대한 작게 함수를 쪼개 놓고 이 함수들을 조합하여 하나의 고차 함수를 사용한다.” 이다.<br>if나 for 같은 로직도 함수 단위로 쪼개면서 재사용성을 고려해서 만들어 놓는 다면 코드의 품질 뿐만 아니라 가독성도 좋아지고 유지 보수도 좋아질 것이라는 생각이 들었다. 운영되고 있는 프로젝트에서 에러가 발생해서 고쳐야 하는 경우나 리팩토링을 해야하는 경우 복잡한 로직이라면 이해하기 쉽지 않은 경우가 있다.<br>내가 짜놓은 코드라도 그때 당시의 고려했던 점이나 여러 경우를 전부 기억하지 못해 수정에 어려움이 있을때가 많다. 이때 만약 함수 단위로 구현해 놓았으면 에러가 발생한 부분이나 고쳐야 할 부분을 함수만 파악하고 고치면 되기때문에 편할 것 같다는 생각이 들었다.</p><p>합성함수 (_.compose)의 arguments 부분이 아직 정확하게 이해 되지는 않지만 뒤에서 arguments에 대해 다시 다뤄준다고 했으니 합성함수의 동작방식만 이해하고 넘어가야겠다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이전 포스트에서 함수형 프로그래밍의 간략한 소개와 몇가지 예제 코드를 구현했었다. 오늘은 이전 포스트에 이어 다음 내용을 진행하려고 한다.&lt;/p&gt;
&lt;h2 id=&quot;회원-목록-중-한명-찾기&quot;&gt;&lt;a href=&quot;#회원-목록-중-한명-찾기&quot; class=&quot;headerlink&quot; title=&quot;회원 목록 중 한명 찾기&quot;&gt;&lt;/a&gt;회원 목록 중 한명 찾기&lt;/h2&gt;&lt;p&gt;회원 목록 중 id 값으로 해당 id 값을 가진 회원 한 명을 찾고자 한다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  filter(users, function (user) &amp;#123; return user.id === 3 &amp;#125;)[0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#123;id: 3, name: &amp;quot;BJ&amp;quot;, age: 32&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter를 통해 걸러낸 후 [0]으로 user를 얻어냈고 원하는 결과를 얻어냈기는 했다. 위 처럼 filter를 사용하여 찾을 수 있지만 filter 함수는 무조건 list.length 만큼 predicate가 실행되기 때문에 효율적이지 못하고, 동일 조건에 값이 두 개 이상이라면 두 개 이상의 값을 찾는다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="함수형 자바스크립트의 실용성 2" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%8B%A4%EC%9A%A9%EC%84%B1-2/"/>
    
      <category term="filter" scheme="https://kkangil.github.io/tags/filter/"/>
    
      <category term="map" scheme="https://kkangil.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>함수형 프로그래밍 - 시작</title>
    <link href="https://kkangil.github.io/2019/09/28/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%91/"/>
    <id>https://kkangil.github.io/2019/09/28/함수형-프로그래밍-시작/</id>
    <published>2019-09-28T06:49:18.000Z</published>
    <updated>2019-09-28T09:07:34.419Z</updated>
    
    <content type="html"><![CDATA[<p>최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.<br>함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에<br>터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.</p><p>기본적으로 <code>함수형 자바스크립트 프로그래밍</code> 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.</p><p>도서 링크: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p><h1 id="함수형-자바스크립트-소개"><a href="#함수형-자바스크립트-소개" class="headerlink" title="함수형 자바스크립트 소개"></a>함수형 자바스크립트 소개</h1><ul><li>함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.</li><li>함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유<ol><li>오류를 줄이기 위함.</li><li>조합성 혹은 모듈화 수준을 높이기 위함.</li></ol></li></ul><h2 id="함수형-프로그래밍을-검색하면-나오는-예제"><a href="#함수형-프로그래밍을-검색하면-나오는-예제" class="headerlink" title="함수형 프로그래밍을 검색하면 나오는 예제"></a>함수형 프로그래밍을 검색하면 나오는 예제</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addMaker(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addMaker(10)(5);</span><br></pre></td></tr></table></figure><p>함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.<br>함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.</p><p><code>addMaker</code>는 함수를 값으로 다루는 함수다. <code>addMaker</code>에서는 단 하나의 값이 선언되며 그 값은 함수다.<br><code>addMaker(10)</code>의 결과는 function(b) { return 10 + b }; 와 같다.<br>이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add5 = addMaker(5);</span><br><span class="line">add5(3) // 8</span><br><span class="line">add5(4) // 9</span><br></pre></td></tr></table></figure><p>위와 같이 변수에 값을 할당해서 사용할 수 도 있다.</p><h2 id="값으로써의-함수와-클로저"><a href="#값으로써의-함수와-클로저" class="headerlink" title="값으로써의 함수와 클로저"></a>값으로써의 함수와 클로저</h2><p>위의 예제들을 보면 함수는 값을 리턴할 수 있고 함수는 값이 될 수 있다. <code>addMaker</code>는 내부에서 함수를 정의하고 리턴했다. <code>addMaker</code>가 리턴한 익명 함수는 클로저가 되었다.<br>리턴된 익명 함수 내부에서 a가 정의된 적은 없지만 a를 참조하고 있고 a는 부모 스코프에 있다.</p><p><code>addMaker</code>가 실행된 후, 어디서도 <code>addMaker</code>의 인자인 a 값을 변경시키지 않고 있기 때문에 항상 동일한 값을 갖는다. 때문에 위 상황에서 a는 불변하며 상수로 쓰이게 된다. 이 상황에서의 a는 불변하지만, 모든 경우의 클로저가 그렇지는 않다. 클로저가 기억하는 변수의 값은 변할 수 있다.</p><hr><h2 id="함수형-자바스크립트의-실용성"><a href="#함수형-자바스크립트의-실용성" class="headerlink" title="함수형 자바스크립트의 실용성"></a>함수형 자바스크립트의 실용성</h2><p>절차지향적으로 작성된 코드를 함수형으로 변경하면서 함수형 자바스크립트의 실용성을 알아보고자 한다.</p><h3 id="회원-목록-중-여러명-찾기"><a href="#회원-목록-중-여러명-찾기" class="headerlink" title="회원 목록 중 여러명 찾기"></a>회원 목록 중 여러명 찾기</h3><p>회원 목록 중 특정 나이의 회원들만 뽑거나 특정 조건의 회원 한 명을 찾는 코드들을 함수형 자바스크립트로 리팩토링 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var users = [</span><br><span class="line">  &#123; id: 1, name: &apos;ID&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 2, name: &apos;HA&apos;, age: 25 &#125;,</span><br><span class="line">  &#123; id: 3, name: &apos;BJ&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 4, name: &apos;PJ&apos;, age: 28 &#125;,</span><br><span class="line">  &#123; id: 5, name: &apos;JE&apos;, age: 27 &#125;,</span><br><span class="line">  &#123; id: 6, name: &apos;JM&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 7, name: &apos;HI&apos;, age: 24 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(temp_users[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &gt;= 30) temp_users.push(users[i])</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(temp_users[i].name);</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>1에서는 users 중에 age가 30 미만인 users[i]만 모아서 몇 명인지를 출력하고 2에서는 그들의 나이만 다시 모아 출력한다. 3에서는 나이가 30 이상인 temp_users가 몇 명인지를 출력하고 4에서는 그들의 이름만 다시 모아 출력한다.</p><p>위 코드를 함수형으로 리팩토링 하기 위해 먼저 중복되는 부분을 찾아본다. 1과 3의 for문에서 users를 돌며 특정 조건의 users[i]를 새로운 배열에 담고 있는데, if 문의 조건절 부분을 제외하고는 모두 동일한 코드이다. 30 부분은 변수로 바꿀 수 있겠지만 .age, &lt;, &gt;= 등은 쉽지 않아 보인다. 이때 함수를 활용하면 이런 부분까지도 쉽게 추상화 할 수 있다.</p><h3 id="for에서-filter로-if에서-predicate로"><a href="#for에서-filter로-if에서-predicate로" class="headerlink" title="for에서 filter로, if에서 predicate로"></a>for에서 filter로, if에서 predicate로</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 기존코드</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// refactoring</span><br><span class="line">function filter(list, predicate) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) new_list.push(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter 함수는 인자로 list와 predicate 함수를 받는다. 루프를 도며 list의 i번째의 값을 predicate에 넘겨준다. predicate 함수는 list.length 만큼 실행되며, predicate 함수의 결과가 참일 때만 new_list.push를 실행한다.<br>filter 함수는 predicate 함수 내부에서 어떤 일을 하는지 모른다. id를 조회할지 age를 조회할지 어떤 조건을 만들지를 filter는 전혀 모른다. 오직 predicate 결과에만 의존한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// filter 사용</span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30)</span><br><span class="line"></span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = users_under_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(users_under_30[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = users_over_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(users_over_30[i].name)</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>filter 함수를 실행하면서 predicate 자리에 익명 함수를 정의해서 넘겼다. predicate 익명 함수의 리턴값(<code>boolean</code>)에 따라서 push를 해줄지 안해줄지가 결정된다. 기존 코드와 비교해 코드가 짧아졌고 재사용성 높은 함수 filter를 얻게됐다.</p><h3 id="함수형-프로그래밍-관점으로-filter-보기"><a href="#함수형-프로그래밍-관점으로-filter-보기" class="headerlink" title="함수형 프로그래밍 관점으로 filter 보기"></a>함수형 프로그래밍 관점으로 filter 보기</h3><p>함수형 프로그래밍 관점에서 filter와 predicate 사이에는 많은 이야기가 담겨있다. filter 함수에는 for도 있고 if도 있지만, filter 함수는 항상 동일하게 동작하는 함수다. <strong>동일한 인자가 들어오면 항상 동일하게 동작한다.</strong> filter 함수의 로직은 외부나 내부의 어떤 상태 변화에도 의존하지 않는다. <code>new_list</code>의 값을 바꾸고 있지만 그 변화에 의존하는 다른 로직이 없다. <code>new_list</code>가 완성될 떄까지는 외부에서 어떠한 접근도 할 수 없기 때문에 filter의 결과도 달라질 수 없다. <code>new_list</code>가 완성되고 나면 <code>new_list</code>를 리턴해버리고 filter는 완전히 종료된다.</p><p>filter의 if는 predicate의 결과에만 의존한다. filter를 사용하는 부분을 다시 보면 filter와 users, filter가 사용할 predicate 함수만 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(users, function(user) &#123; return user.age &lt; 30 &#125;)</span><br></pre></td></tr></table></figure></p><p>절차지향 프로그래밍과 달리 함수형 프로그래밍 에서는 <strong>항상 동일하게 동작하는 함수</strong> 를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다. 내부에서 관리하고 있는 상태를 따로 두지않고 넘겨진 인자에만 의존한다. 동일한 인자가 들어오면 항상 동일한 값을 리턴 하도록 한다.</p><h3 id="map-함수"><a href="#map-함수" class="headerlink" title="map 함수"></a>map 함수</h3><p>리팩토링의 핵심은 중복을 제거하고 의도를 드러내는 것이다. 기존 코드를 보면 회원 목록을 통해 나이와 이름들을 추출하는데 두 코드에도 중복이 있다. 둘 다 for문에서 사용하는 회원 목록을 활용해 같은 크기의 새로운 배열을 만들고 원재료와 1:1로 매핑되는 다른 값을 만들어 담고 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// map 사용</span><br><span class="line">function map(list, iteratee) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    new_list.push(iteratee(list[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30.length)</span><br><span class="line"></span><br><span class="line">var ages = map(users_under_30, function (user) &#123; return user.age &#125;);</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30.length)</span><br><span class="line"></span><br><span class="line">var names = map(users_over_30, function (user) &#123; return user.name &#125;);</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>코드가 매우 단순해 진것을 확인할 수 있다. for도 없고 if도 없다. new_list에 무엇을 push 할지에 대해 iteratee 함수에게 위임했다.</p><h3 id="실행-결과로-바로-실행하기"><a href="#실행-결과로-바로-실행하기" class="headerlink" title="실행 결과로 바로 실행하기"></a>실행 결과로 바로 실행하기</h3><p>함수의 리턴값을 바로 다른 함수의 인자로 사용하면 변수 할당을 줄일 수 있다.<br>filter 함수의 결과가 배열이므로 map의 첫 번째 인자로 바로 사용 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 함수 중첩</span><br><span class="line">var ages = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.age &#125;</span><br><span class="line">)</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var names = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.name &#125;</span><br><span class="line">)</span><br><span class="line">console.log(names);</span><br><span class="line"></span><br><span class="line">// 함수 중첩 2</span><br><span class="line">function log_length(value) &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.age &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.name &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>filter 함수는 predicate를 통해 값을 필터링하여 map에게 전달하고 map은 받은 iteratee를 통해 새로운 값들을 만들어 log_length에게 전달한다. log_length는 length를 출력한 후 받은 인자를 그대로 console.log에게 전달하고 console.log는 받은 값을 출력한다.</p><h3 id="함수를-값으로-다룬-예제의-실용성"><a href="#함수를-값으로-다룬-예제의-실용성" class="headerlink" title="함수를 값으로 다룬 예제의 실용성"></a>함수를 값으로 다룬 예제의 실용성</h3><p>위에 만들었던 <code>addMaker</code> 와 비슷한 패턴의 함수가 실제로도 많이 사용된다.<br><code>addMaker</code>와 비슷한 패턴의 함수인 <code>bvalue</code> 함수를 만들어 보려고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function bvalue(key) &#123;</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bvalue(&apos;a&apos;)(&#123; a: &apos;hi&apos;, b: &apos;hello&apos; &#125;)); // hi</span><br></pre></td></tr></table></figure><p>bvalue를 실행할 때 넘겨준 인자 key를 나중에 obj를 받을 익명 함수가 기억한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * bvalue로 map의 iteratee 만들기</span><br><span class="line"> */</span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      bvalue(&apos;age&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      bvalue(&apos;name&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>map이 사용할 iteratee 함수를 bvalue가 리턴한 함수로 대체했다. 익명 함수 선언이 사라져 코드가 더욱 짧아졌다.</p><p>화살표 함수로 사용하기<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &lt; 30),</span><br><span class="line">      user =&gt; user.age</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &gt;= 30),</span><br><span class="line">      user =&gt; user.name</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var under_30 = user =&gt; user.age &lt; 30;</span><br><span class="line">var over_30 = user =&gt; user.age &gt;= 30;</span><br><span class="line">var ages = list =&gt; map(list, user =&gt; user.age);</span><br><span class="line">var names = list =&gt; map(list, user =&gt; user.name);</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, function (user) &#123; return user[key] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ages = bvalues(&apos;age&apos;);</span><br><span class="line">var names = bvalues(&apos;name&apos;);</span><br><span class="line">var under_30 = function (user) &#123; return user.age &lt; 30 &#125;;</span><br><span class="line">var over_30 = function (user) &#123; return user.age &gt;= 30 &#125;;</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  var value = bvalue(key);</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 화살표 함수 사용</span><br><span class="line">var bvalues = key =&gt; list =&gt; &#123;</span><br><span class="line">  var value = bvalue(key)</span><br><span class="line">  return map(list, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>Conclusion<br>어려운 점이 공부를 하면 할수록 많이 생기겠지만, 새로운 관점에서의 프로그래밍인 것 같아 흥미롭게 느껴진다.<br>본인은 아직 주니어라 절차지향적 사고 방식이 강한데 함수형 프로그래밍 공부하면서 새로운 사고 방식에 대해서도 생각해 봐야할 것 같다. 이번 챕터의 첫 코드(절차지향적 코드)는 쉽다고 느껴졌지만, 함수형으로 리팩토링 해 나가는 과정에서는 이게 정확히 어떤 방식으로 동작하는가, 인자값은 어떻게 넘겨 주는가에 대한 고민이 생기는것을 느끼면서 함수형 프로그래밍에 더 알고 싶어졌다.</p><p>처음에는 함수형 프로그래밍 방식이 “그래서 왜 좋은건데?”에 대한 의문이 있었는데 마지막 코드를 보고 재새용성이 뛰어나다는것을 느꼈다. 프로젝트를 시작할때 잘 구현해 놓은 함수는 계속 재사용하면서 코딩의 속도와 편리함을 제공해 줄 것 같다고 생각했다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.&lt;br&gt;함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에&lt;br&gt;터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.&lt;/p&gt;
&lt;p&gt;기본적으로 &lt;code&gt;함수형 자바스크립트 프로그래밍&lt;/code&gt; 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.&lt;/p&gt;
&lt;p&gt;도서 링크: &lt;a href=&quot;http://www.yes24.com/Product/Goods/56885507&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;함수형 자바스크립트 프로그래밍&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;함수형-자바스크립트-소개&quot;&gt;&lt;a href=&quot;#함수형-자바스크립트-소개&quot; class=&quot;headerlink&quot; title=&quot;함수형 자바스크립트 소개&quot;&gt;&lt;/a&gt;함수형 자바스크립트 소개&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.&lt;/li&gt;
&lt;li&gt;함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유&lt;ol&gt;
&lt;li&gt;오류를 줄이기 위함.&lt;/li&gt;
&lt;li&gt;조합성 혹은 모듈화 수준을 높이기 위함.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;함수형-프로그래밍을-검색하면-나오는-예제&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍을-검색하면-나오는-예제&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍을 검색하면 나오는 예제&quot;&gt;&lt;/a&gt;함수형 프로그래밍을 검색하면 나오는 예제&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function addMaker(a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return function(b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addMaker(10)(5);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.&lt;br&gt;함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addMaker&lt;/code&gt;는 함수를 값으로 다루는 함수다. &lt;code&gt;addMaker&lt;/code&gt;에서는 단 하나의 값이 선언되며 그 값은 함수다.&lt;br&gt;&lt;code&gt;addMaker(10)&lt;/code&gt;의 결과는 function(b) { return 10 + b }; 와 같다.&lt;br&gt;이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Sequelize model 정의</title>
    <link href="https://kkangil.github.io/2019/04/28/Sequelize-model-%EC%A0%95%EC%9D%98/"/>
    <id>https://kkangil.github.io/2019/04/28/Sequelize-model-정의/</id>
    <published>2019-04-28T05:45:40.000Z</published>
    <updated>2019-04-28T05:47:51.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sequelize-model-정의"><a href="#sequelize-model-정의" class="headerlink" title="sequelize model 정의"></a>sequelize model 정의</h2><ul><li>sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 <code>define</code> 메소드를 이용해 정의하고자 한다.</li><li>model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128)</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><code>define</code> 함수의 첫번째 파라미터는 테이블의 이름에 해당된다. 또한 express 프로젝트에서도 해당 이름으로 데이터베이스에 접근할 수 있다.</li><li>두번째 파라미터는 컬럼을 정의하는 것이다. 위의 예시는 가장 기본적인 컬럼을 생성한 것이고 나머지 옵션들은 밑에서 확인해 보도록 한다.</li></ul><h2 id="column-option"><a href="#column-option" class="headerlink" title="column option"></a>column option</h2><ul><li>sequelize model 생성시 sequelize 는 고유 키값을 정의해 주지 않아도, 다른 설정이 없다면 id 로 생성해주며 row 생성시 자동으로 1씩 증가한다.</li><li>id 이외에 createdAt(생성일), updatedAt(수정일) 도 같이 생성해준다.</li><li>defaultValue: row가 생성될때 기본값을 설정해줄 수 있다. (etc. Sequelize.NOW)</li><li>allowNull: false로 설정해주면 빈값으로 생성시 에러가 난다.(default true)</li><li>unique: 테이블내의 고유한 값(boolean)</li><li>primaryKey: 고유 키값 설정 여부</li><li>autoIncrement: 자동으로 값을 증가시켜준다. (Integer 에서만 사용 가능)</li><li>field: 객체 키값과 다르게 custom으로 컬럼명을 사용할 수 있게해준다.</li><li>comment: 해당 컬럼에 대한 설명을 달 수 있다. 컬럼 생성에 영향을 미치지는 않는다. 주석같은 개념</li></ul><h2 id="Getters-amp-setters"><a href="#Getters-amp-setters" class="headerlink" title="Getters &amp; setters"></a>Getters &amp; setters</h2><ul><li><p>컬럼 option에 getter와 setter를 추가해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false,</span><br><span class="line">      get() &#123;</span><br><span class="line">        const job = this.getDataValue(&apos;job&apos;)</span><br><span class="line">        return `$&#123;this.getDataValue(&apos;username&apos;)&#125; ($&#123;this.getDataValue(&apos;job&apos;)&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false,</span><br><span class="line">      set(job) &#123;</span><br><span class="line">        this.setDataValue(&apos;job&apos;, job.toUpperCase())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const userSample = async () =&gt; &#123;</span><br><span class="line">  const user = await User.create(&#123; username: &apos;kkangil&apos;, job: &apos;developer&apos; &#125;)</span><br><span class="line">  console.log(user.get(&apos;username&apos;)) // kkangil (DEVELOPER)</span><br><span class="line">  console.log(user.get(&apos;job&apos;)) // DEVELOPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getDataValue</code> 를 사용하여 자신의 컬럼 뿐만 아니라 테이블의 컬럼 데이터도 가져올 수 있다.</p></li><li><code>setDataValue</code> 를 사용하여 생성이나 수정 시 데이터 값을 수정, 변경할 수 있다. </li><li>컬럼 객체 내부에 설정해 주지 않고, <code>define</code> 함수의 세번째 파라미터로도 사용이 가능하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    getterMethods: &#123;</span><br><span class="line">      getUser() &#123;</span><br><span class="line">        return `$&#123;this.username&#125; ($&#123;this.job&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="validate-column"><a href="#validate-column" class="headerlink" title="validate column"></a>validate column</h2><ul><li><p>데이터 타입 이외에도 <code>validate</code> 를 사용해서 유효성 확인 후 에러를 반환해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;Foo&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      validate: &#123;</span><br><span class="line">        is: /^[a-z]+$/i, // 정규식 사용해서 유효성 확인</span><br><span class="line">        not: /^[a-z]+$/i,</span><br><span class="line">        isEmail: true, // 이메일 유효성 확인</span><br><span class="line">        isInt: true,</span><br><span class="line">        notNull: true,</span><br><span class="line">        isNull: true,</span><br><span class="line">        notEmpty: true, // string 빈값 확인</span><br><span class="line">        equals: &apos;specific value&apos;, // 특정 값으로만 생성 가능</span><br><span class="line">        contains: &apos;foo&apos;, // 해당 값을 포함하고 있는지 확인</span><br><span class="line">        notContains: &apos;bar&apos;,</span><br><span class="line">        notIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        isIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        len: [2,10], // 2자리 ~ 10자리</span><br><span class="line">        max: 23,</span><br><span class="line">        min: 10,</span><br><span class="line">        isCreditCard: true // 신용카드 유효성 확인</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>제공되는 <code>validate</code> 가 아닌 직접 만들어서 사용하는 기능도 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    isEven(value) &#123;</span><br><span class="line">      if (parseInt(value) % 2 !== 0) &#123;</span><br><span class="line">        throw new Error(&apos;Only even values are allowed!&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throw new Error의 메시지가 에러로 리턴된다.</p></li><li><p>직접 만들어서 사용하지 않아도 메시지를 설정해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    notNull: &#123;</span><br><span class="line">      msg: &quot;Must&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    isIn: &#123;</span><br><span class="line">      args: [[&apos;en&apos;, &apos;zh&apos;]],</span><br><span class="line">      msg: &quot;Must be English or Chinese&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>allowNull</code> 을 사용한다면 <code>notNull</code> 의 <code>msg</code>를 설정해주면 에러메시지로 사용가능하다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    validate: &#123;</span><br><span class="line">      checkUsernameAndJob() &#123;</span><br><span class="line">        if (!(this.username &amp;&amp; this.job)) &#123;</span><br><span class="line">          throw new Error(&apos;이름과 직업을 입력해주세요.&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>define</code> 함수의 세번째 파라미터 객체에 validate 를 설정해주면 하나의 컬럼이 아닌 테이블의 모든 컬럼의 유효성은 같이 확인 할 수 있다.</li></ul><h2 id="model-configuration"><a href="#model-configuration" class="headerlink" title="model configuration"></a>model configuration</h2><ul><li><code>define</code> 함수의 세번째 파라미터 객체의 설정값<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  ..., &#123;</span><br><span class="line">    modelName: &apos;bar&apos;, // 모델 이름 설정</span><br><span class="line">    timestamps: false, // createdAt, updatedAt 생성하지 않음</span><br><span class="line">    paranoid: true, // 데이터를 삭제하지 않고 현재 시간으로 deletedAt 데이터가 추가된다.</span><br><span class="line">    underscored: true, // 자동으로 컬럼명을 snake 네임으로 변경한다.</span><br><span class="line">    tableName: &apos;my_bar&apos;, // 테이블 이름 설정</span><br><span class="line">    createdAt: false, // createdAt 사용하지 않음</span><br><span class="line">    updatedAt: &apos;updateTimestamp&apos;, // updatedAt 컬럼명 정의</span><br><span class="line">    deletedAt: &apos;destroyTime&apos;, // deletedAt 컬럼명 정의 (paranoid가 true로 설정되어 있어야함.)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>참고 <a href="http://docs.sequelizejs.com/manual/models-definition.html" target="_blank" rel="noopener">sequelize docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sequelize-model-정의&quot;&gt;&lt;a href=&quot;#sequelize-model-정의&quot; class=&quot;headerlink&quot; title=&quot;sequelize model 정의&quot;&gt;&lt;/a&gt;sequelize model 정의&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 &lt;code&gt;define&lt;/code&gt; 메소드를 이용해 정의하고자 한다.&lt;/li&gt;
&lt;li&gt;model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;return sequelize.define(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;User&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    username: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING(128)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    job: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Sequelize" scheme="https://kkangil.github.io/categories/Sequelize/"/>
    
    
      <category term="Sequelize" scheme="https://kkangil.github.io/tags/Sequelize/"/>
    
      <category term="MySQL" scheme="https://kkangil.github.io/tags/MySQL/"/>
    
      <category term="model 정의" scheme="https://kkangil.github.io/tags/model-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 3. 사용방법2</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-3-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%952/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-3-사용방법2/</id>
    <published>2019-04-19T03:54:04.000Z</published>
    <updated>2019-04-19T03:56:23.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const reducer = (state, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;INCREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count + 1 &#125;;</span><br><span class="line">    case &quot;DECREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count - 1 &#125;;</span><br><span class="line">    case &quot;HANDLE_CHANGE&quot;:</span><br><span class="line">      return &#123; ...state, [action.target.name]: action.target.value &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const CountReducer = () =&gt; &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, &#123;</span><br><span class="line">    count: 0,</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    nickname: &quot;&quot;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const handleChange = e =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &quot;HANDLE_CHANGE&quot;, target: e.target &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;INCREMENT&quot; &#125;)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;DECREMENT&quot; &#125;)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.name&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.nickname&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default CountReducer;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>이전에 useState로 구현했었던 count와 input 컴포넌트를 위의 코드와 같이 reducer를 사용해서 구현할 수 있다.</li><li>useState 또는 useReducer 어떤것이 더 좋다 안좋다는 없지만, 상황에 따라 유연하게 사용할 줄 알아야 할것같다.</li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>두번째 파라미터 배열 값을 전달받아 해당 값이 변경 될때만 첫번째 파라미터 함수를 실행한다. 해당 기능을 사용하면 불필요한 함수 호출을 줄일 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Sum = () =&gt; &#123;</span><br><span class="line">  const [num, setNum] = useState(&quot;&quot;);</span><br><span class="line">  const [numList, setNumList] = useState([]);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = () =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const sumValue = useMemo(() =&gt; &#123;</span><br><span class="line">    if (!numList.length) return 0;</span><br><span class="line">    const sum = numList.reduce((a, b) =&gt; a + b);</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;, [numList]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Sum</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;num&#125; onChange=&#123;e =&gt; setNum(e.target.value)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClickAdd&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number list: &#123;numList.join(&quot;, &quot;)&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number total: &#123;sumValue&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Sum;</span><br></pre></td></tr></table></figure><ul><li>sumValue 함수에 <code>useMemo</code>를 사용하지 않으면, input 값이 변경될때도 해당 로직이 불필요하게 실행된다.</li><li>useMemo를 사용해 줌으로써 불필요하게 실행되지 않도록 하고, <code>numList</code>의 값이 변경될때마다 해당 로직이 실행된다.</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useMemo와 거의 비슷한 기능으로 렌더링 성능을 최적화 하기위해 주로 사용된다. 쓰지 않아도 문제되지는 않지만 렌더링 해야할 컴포넌트 개수나 로직이 많아진다면 고려해 봐야한다. 해당 기능은 이벤트 함수를 필요할때만 생성해 주는 기능이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = useCallback(e =&gt; &#123;</span><br><span class="line">    setNum(e.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br></pre></td></tr></table></figure><ul><li>위의 onChange 함수와 handleClickAdd 함수를 useCallback을 사용하는 함수로 변경했다.</li><li>두번째 파라미터 배열은 해당 값이 변경될때만 함수를 생성해 주는것이다. 빈 배열이라면 최초에만 생성해주고 이후 다시 생성되지 않는다.</li><li>handleChange 는 빈배열, handleClickAdd 은 두개의 값을 판단하고 있는데, 이는 handleChange는 단순히 <code>num</code> 의 값만 변경해 주고 있어 초기에만 생성해 줘도 되는것이다. handleClickAdd 함수는 이벤트가 실행 될때마다 값을 가져와서 사용해 주고 있기때문에 배열에 해당 값들을 명시해줘야한다.</li></ul><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>useRef는 함수형 컴포넌트에서도 ref 기능을 사용할 수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const inputElement = useRef(null);</span><br><span class="line">const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">      inputElement.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br><span class="line">&lt;input value=&#123;num&#125; onChange=&#123;handleChange&#125; ref=&#123;inputElement&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li>useRef는 다른 Hook과 다르게 최초 선언을 배열 형태로 선언해 주지 않는다.</li><li>ref 값이 변경되어도 리렌더링 되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h2&gt;&lt;p&gt;redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import React, &amp;#123; useReducer &amp;#125; from &amp;quot;react&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const reducer = (state, action) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  switch (action.type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;INCREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count + 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;DECREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count - 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;HANDLE_CHANGE&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, [action.target.name]: action.target.value &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const CountReducer = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const [state, dispatch] = useReducer(reducer, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count: 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &amp;quot;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nickname: &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const handleChange = e =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch(&amp;#123; type: &amp;quot;HANDLE_CHANGE&amp;quot;, target: e.target &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;p&amp;gt;current count: &amp;#123;state.count&amp;#125;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;INCREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;increase&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;DECREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;decrease&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.name&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.nickname&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export default CountReducer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useReducer" scheme="https://kkangil.github.io/tags/useReducer/"/>
    
      <category term="useMemo" scheme="https://kkangil.github.io/tags/useMemo/"/>
    
      <category term="useCallback" scheme="https://kkangil.github.io/tags/useCallback/"/>
    
      <category term="useRef" scheme="https://kkangil.github.io/tags/useRef/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 2. 사용방법1</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-2-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%951/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-2-사용방법1/</id>
    <published>2019-04-19T03:52:51.000Z</published>
    <updated>2019-04-19T03:53:43.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h3><p>useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.</p><p>사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><ul><li>useState를 사용하여 count state를 생성해 주었으며 초기값은 0으로 맞춰 주었다.</li><li>state 사용은 기존의 class에서 사용하던 this.state.count가 아닌 count로만 사용해야 한다.</li><li>setCount 파라미터로 값을 넘겨주면 해당 값으로 state가 변경된다.</li></ul><h3 id="여러개의-state-사용"><a href="#여러개의-state-사용" class="headerlink" title="여러개의 state 사용"></a>여러개의 state 사용</h3><p>여러개의 state를 사용해야 한다면, 기존 class 방식에서는 state 객체 안에 키와 값을 설정해 주면 됐지만, 함수형 컴포넌트에서는 useState를 여러번 써줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;name ? `$&#123;name&#125;&apos;s` : &quot;&quot;&#125; current count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="재사용-가능한-useState-함수-컴포넌트"><a href="#재사용-가능한-useState-함수-컴포넌트" class="headerlink" title="재사용 가능한 useState 함수 컴포넌트"></a>재사용 가능한 useState 함수 컴포넌트</h3><p>동일한 stateful 로직을 사용한다면 컴포넌트를 분리해서 사용하는것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const useInputOption = props =&gt; &#123;</span><br><span class="line">  const [value, setValue] = useState(props || &quot;&quot;);</span><br><span class="line">  const onChange = e =&gt; &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const nameInputOption = useInputOption(&quot;&quot;);</span><br><span class="line">  const nickInputOption = useInputOption(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input &#123;...nameInputOption&#125; /&gt;</span><br><span class="line">      &lt;input &#123;...nickInputOption&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;nameInputOption.value ? `$&#123;nameInputOption.value&#125;&apos;s` : &quot;&quot;&#125; current</span><br><span class="line">        count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>input의 value와 onChange 이벤트 함수를 return 해주는 <code>useInputOption</code> 컴포넌트를 만들었다.</li><li>코드가 간결해지고 재사용성이 높아진다.</li></ul><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect는 함수형 컴포넌트에서도 라이프사이클과 같은 기능을 사용할 수 있게 해준다.<br><code>componentDidMount</code> 와 <code>componentDidUpdate</code>, <code>componentWillUnmount</code> 를 합쳐놓은 것이다.<br>useEffect 함수는 state 변수를 하나만 관리하는것이 좋다. 즉 여러개의 useEffect 함수를 사용하는것을 추천해주고 있다.</p><h3 id="사용방법-1"><a href="#사용방법-1" class="headerlink" title="사용방법"></a>사용방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const User = () =&gt; &#123;</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default User;</span><br></pre></td></tr></table></figure><ul><li>해당 코드를 확인해보면 render 가 될때마다 console.log 가 찍히는것을 확인할 수 있다. 이것은 <code>componentDidMount</code> 와 <code>componentDidUpdate</code> 라이프사이클과 일치한다.</li></ul><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><ul><li>useEffect 함수에 두번째 파라미터로 빈배열을 넣으면 최초 렌더링이 될때만 실행되고 name이 변경되더라도 실행되지 않는다.</li></ul><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>배열에 원하는 값을 넣어주면 해당 값이 변할때만 실행된다.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      console.log(&quot;unmount&quot;, name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>return 함수는 렌더링이 될때마다 실행되는 함수이다. name을 확인해보면 변경되기 이전의 값이 찍히는것을 확인할 수 있다.</li><li>두번째 파라미터에 빈 배열을 담아서 실행하면 unmount 될때만 return 함수가 실행된다.</li></ul><h2 id="Promise-처리"><a href="#Promise-처리" class="headerlink" title="Promise 처리"></a>Promise 처리</h2><p>useEffect와 useState를 사용하여 promise 컴포넌트 또한 재사용이 가능하도록 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const usePromise = (&#123; promise, initialData, arr &#125;) =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState(initialData);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(false);</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    try &#123;</span><br><span class="line">      const result = await promise();</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      setError(true);</span><br><span class="line">    &#125;</span><br><span class="line">    setLoading(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, arr || []);</span><br><span class="line"></span><br><span class="line">  return &#123; data, loading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getNames = async () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt;</span><br><span class="line">    setTimeout(() =&gt; resolve([&#123; name: &quot;kkangil&quot; &#125;, &#123; name: &quot;kkangil2&quot; &#125;]), 1000)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Names = () =&gt; &#123;</span><br><span class="line">  const &#123; data: names, loading, error &#125; = usePromise(&#123;</span><br><span class="line">    promise: getNames,</span><br><span class="line">    initialData: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (loading) return &lt;div&gt;로딩중...&lt;/div&gt;;</span><br><span class="line">  if (error) return &lt;div&gt;에러&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;names.map((row, index) =&gt; (</span><br><span class="line">        &lt;div key=&#123;index&#125;&gt;&#123;row.name&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="usePromise"><a href="#usePromise" class="headerlink" title="usePromise"></a>usePromise</h3><ul><li>파라미터로 호출해야하는 <code>promise</code> 함수, 최초 초기화 데이터 <code>initialData</code>, useEffect 함수 2번째 파라미터 배열 <code>arr</code>을 객체로 받는다.</li><li><code>useEffect</code> 함수에서 async/await을 사용하면 warning이 발생한다. 그렇기 때문에 async/await 함수를 따로 만들어 해당 함수를 useEffect에서 실행 시켜준다.</li></ul><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><ul><li>initialData에 빈배열을 넣어주지 않으면 return의 <code>names.map</code> 에서 에러가 발생한다. 해당 에러를 막기 위해 빈 배열로 초기화해줬다. <code>names</code> 값이 존재할때만 map 을 사용하는 방법도 있지만, 추후 재사용을 위해 데이터 초기값을 설정해줄 수 있도록 했다.</li></ul><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>useContext는 함수형 컴포넌트에서 Context를 쉽게 사용할 수 있게 해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const backgroundColorContext = createContext(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">const Context = () =&gt; &#123;</span><br><span class="line">  const backgroundColor = useContext(backgroundColorContext);</span><br><span class="line">  const style = &#123;</span><br><span class="line">    width: &quot;50px&quot;,</span><br><span class="line">    height: &quot;50px&quot;,</span><br><span class="line">    borderRadius: &quot;50%&quot;,</span><br><span class="line">    background: backgroundColor</span><br><span class="line">  &#125;;</span><br><span class="line">  return &lt;div style=&#123;style&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Context;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useState&quot;&gt;&lt;a href=&quot;#useState&quot; class=&quot;headerlink&quot; title=&quot;useState&quot;&gt;&lt;/a&gt;useState&lt;/h2&gt;&lt;h3 id=&quot;사용방법&quot;&gt;&lt;a href=&quot;#사용방법&quot; class=&quot;headerlink&quot; title=&quot;사용방법&quot;&gt;&lt;/a&gt;사용방법&lt;/h3&gt;&lt;p&gt;useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useState" scheme="https://kkangil.github.io/tags/useState/"/>
    
      <category term="useEffect" scheme="https://kkangil.github.io/tags/useEffect/"/>
    
      <category term="useContext" scheme="https://kkangil.github.io/tags/useContext/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 1. hooks 란?</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-1-hooks-%EB%9E%80/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-1-hooks-란/</id>
    <published>2019-04-19T03:48:12.000Z</published>
    <updated>2019-04-19T03:52:29.003Z</updated>
    
    <content type="html"><![CDATA[<p>리액트 16.8 버전에서 <code>Hooks</code> 라는 새로운 기능이 추가 되었다.<br>해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.<br>이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.</p><a id="more"></a><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-intro.html</a></p><h2 id="Hooks-특징"><a href="#Hooks-특징" class="headerlink" title="Hooks 특징"></a>Hooks 특징</h2><ul><li>현재 진행중인 프로젝트가 있다면 코드를 다시 짜지 않아도, 바로 사용할 수 있다. </li><li>어떠한 변화 없이 기능이 추가 되었기 때문에 이전 버전과의 호환성이 100%이다.</li><li>16.8.0 이후 버전에서 사용가능하다.</li></ul><blockquote><p>Hooks로 class를 대신할 수 있게됐지만, 리액트는 class를 제거할 계획이 없다고 밝혔다. 리액트에 대한 여러가지 컨셉(props, state, context, refs, and lifecycle)을 대체할 수 없는 대신, 더욱 직관적으로 제공한다고 한다.</p></blockquote><h2 id="Hooks가-나오게된-배경"><a href="#Hooks가-나오게된-배경" class="headerlink" title="Hooks가 나오게된 배경"></a>Hooks가 나오게된 배경</h2><h3 id="Component-사이에서-stateful-한-로직의-재사용이-어렵다"><a href="#Component-사이에서-stateful-한-로직의-재사용이-어렵다" class="headerlink" title="Component 사이에서 stateful 한 로직의 재사용이 어렵다."></a>Component 사이에서 stateful 한 로직의 재사용이 어렵다.</h3><ul><li>리액트는 컴포넌트에 재활용하는 방법인 “attach” 방법을 제공하지 않는다.</li><li>이런 문제들을 해결하기 위해 다양한 패턴이 사용되었다. (render propr, HOC …) 이런 패턴을 사용했을 때, 재구조화를 해야하고 이는 번거롭고 어려워질 수 있다. 또한 이런 패턴을 <code>DevTools</code> 에서 확인해 보면 wrapper 지옥에 빠져있는 수많은 컴포넌트를 볼 수 있다.</li><li>Hooks 는 컴포넌트로 부터 stateful 한 로직을 추출해 낼 수 있으며 이것은 의존성과 재사용성을 테스트할 수 있다. </li></ul><h3 id="이해하기-어려운-복잡한-컴포넌트"><a href="#이해하기-어려운-복잡한-컴포넌트" class="headerlink" title="이해하기 어려운 복잡한 컴포넌트"></a>이해하기 어려운 복잡한 컴포넌트</h3><ul><li>처음은 가벼운 컴포넌트였지만, 개발을 진행하다보면 수많은 side effects와 stateful 로직이 걷잡을 수 없이 많아진다.</li><li>각각의 라이프 사이클은 자주 연관성이 없는 로직을 섞어 사용하곤 한다. 예를 들어 컴포넌트는 <code>componentDidMount</code>와 <code>componentDidUpdate</code> 라이프사이클에서 데이터를 fetch 할 수 있다. 하지만 몇몇 <code>componentDidMount</code> 메소드는 이벤트를 설정하는 데 연관 없는 로직 들을 포함할 수 있으며 <code>componentWillUnmount</code>는 cleanup을 수행할 수도 있다. 함께 변경되는 관련 코드는 분리되지만 연관 없는 코드들은 단일 메소드로 결합한다. 이것은 버그와 무결성을 쉽게 발생시킨다.</li><li>많은 경우 컴포넌트들을 작게 만드는 것은 불가능하다. stateful 로직은 모든곳에 있기 때문이다. 또한 이것은 테스트하는 것도 어렵다. 이것이 사람들이 state 를 관리하는 라이브러리를 함께 사용하는것을 선호하는 이유중 하나이다. 그러나 너무 추상적이라고 소개하고 다른 파일 사이를 건너뛰는것을 요구하며 컴포넌트 재사용을 더욱 어렵게 만든다.</li><li>이러한 이슈들을 해결하기 위해 Hooks는 라이프사이클 메소드를 기초로한 분리에 초점을 맞추는 것보다는 컴포넌트들을 연관성을 기초로 더 작은 함수로 분리할 수 있게 한다.</li></ul><h3 id="사람과-기계를-혼란시키는-Classes"><a href="#사람과-기계를-혼란시키는-Classes" class="headerlink" title="사람과 기계를 혼란시키는 Classes"></a>사람과 기계를 혼란시키는 Classes</h3><ul><li>코드를 재사용성과 구조적으로 만드는 것은 어려울뿐만 아니라 리액트를 배울때 classes는 큰 진입장벽이다. 다른 대부분의 언어들과는 다른 Javascript가 어떻게 동작하는지 이해하고 있어야한다. 이벤트 핸들러는 항상 바인딩이 되어야 하는것을 기억해야 한다. 안정적인 문법의 제안이 없다면, 코드는 매우 장황해진다.</li><li>사람들은 props, state, 단방향 데이터 흐름에 대해 이해하고 있지만 여전히 classes는 어려워한다.</li><li>이러한 문제를 해결하기 위해서 Hooks는 classes 없이 리액트의 특징들을 사용할 수 있게 해준다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;리액트 16.8 버전에서 &lt;code&gt;Hooks&lt;/code&gt; 라는 새로운 기능이 추가 되었다.&lt;br&gt;해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.&lt;br&gt;이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 정의" scheme="https://kkangil.github.io/tags/hooks-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>Next.js with pm2 ecosystem</title>
    <link href="https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/"/>
    <id>https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/</id>
    <published>2019-04-17T15:29:19.000Z</published>
    <updated>2019-04-17T15:47:37.770Z</updated>
    
    <content type="html"><![CDATA[<p><code>Next.js</code>는 Client-Side-Rendering 을 사용하는 react가 아닌 <code>SSR(Server-Side-Rendering)</code> 방식을 사용하는 react framework 이다.<br>해당 글은 <code>Next.js</code>에서 배포시 참고하면 좋을 내용으로 <code>Next.js</code>가 뿐만 아니라 react, Node 에서도 사용 가능하다.</p><a id="more"></a><h2 id="pm2-ecosystem"><a href="#pm2-ecosystem" class="headerlink" title="pm2 ecosystem"></a>pm2 ecosystem</h2><p>pm2 ecosystem이란, 실행할 인스턴스의 설정을 JSON 형식으로 관리할 수 있고, pm2 에서 제공해 주는 option 을 보다 쉽게 관리 할수 있도록 도와준다. pm2 명령어로 직접 실행시킬 수 있지만, ecosystem을 사용함으로써 어떤 서버나 환경에서도 같은 설정을 사용해서 서버를 실행할 수 있다는 점이 장점이다.</p><ol><li>ecosystem.config.js 를 최상위 폴더에 생성한다.</li><li>작성방법</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  apps: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;chungeoram&quot;,</span><br><span class="line">      script: &quot;./server.js&quot;,</span><br><span class="line">      watch: true,</span><br><span class="line">      interpreter: &apos;/home/ubuntu/.nvm/versions/node/v8.11.3/bin/node&apos;,</span><br><span class="line">      &quot;env_public-develop&quot;: &#123;</span><br><span class="line">        NODE_ENV: &quot;public-develop&quot;,</span><br><span class="line">        PORT: 1111,</span><br><span class="line">        API_END_POINT: &apos;http://endpoint/api&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      env_production: &#123;</span><br><span class="line">        NODE_ENV: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name: pm2 에서 관리하는 이름</li><li>script: 앱을 구동할 경로</li><li>watch: 파일이 변경되면 자동으로 재시작 유무</li><li>ignore_watch: 배열안에 있는 리스트는 watch 대상에서 무시한다.</li><li>exec_mode: 클러스터 모드로 구동instances: 클러스터로 구동될시 몇개까지 구동할것인지 선택(0 : cpu갯수)</li><li>merge_logs: 클러스터로 구동할시 로그를 한파일에 기록</li><li>interpreter: 해석기 절대 경로(default: node)</li><li>log_date_format: 로그에 출력될 날짜와 시간값의 형식</li><li>error_file: 에러 파일 위치</li><li>out_file: 기본 출력 로그 위치</li><li>env_{value}<ul><li>value는 <code>process.env.NODE_ENV</code> 값과 매칭된다. 예를 들어 현재 <code>process.env.NODE_ENV</code>가 <code>public-develop</code> 일때, <code>env_public-develop</code> 내부의 값이 사용된다. 내부의 값들은 <code>process.env</code> 객체 내로 값이 할당되며, <code>process.env.PORT</code> , <code>process.env.API_END_POINT</code> 로 값을 배포 환경의 따라 다르게 사용가능하다.</li></ul></li></ul><ol start="3"><li>pm2 구동방법<br>package.json script에 명령어를 추가해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;pm2 start ecosystem.config.js --env production&quot;,</span><br><span class="line">    &quot;start-public&quot;: &quot;pm2 start ecosystem.config.js --env public-develop&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon server.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>$ yarn build → $ yarn start</li><li>app 빌드 후 명령어를 사용해서, pm2를 구동시켜 준다. pm2 start {파일이름} –env {value} 와 같은 형식으로 명령어를 추가한다. 여기서 환경변수는 ecosystem.config.js 의 env_{value}와 매칭 된다.</li></ul><h2 id="Next-js-에서-process-env-변수-사용-주의사항"><a href="#Next-js-에서-process-env-변수-사용-주의사항" class="headerlink" title="Next.js 에서 process.env 변수 사용 주의사항"></a>Next.js 에서 process.env 변수 사용 주의사항</h2><p><code>Next.config.js</code> 에서 <code>sass</code>, <code>webpack</code> 등의 처리 후 export 하는 과정에서, process.env 객체가 비어있는 문제를 발견했다. 하지만, api.js config.js 등 환경 변수에 따라 값을 변경해줘야 하기 때문에 process.env 객체가 비어있으면 안된다. 해당 문제를 처리하기 위해 Next.js 에서 <code>publicRuntimeConfig</code> 라는 옵션을 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const withSass = require(&apos;@zeit/next-sass&apos;)</span><br><span class="line">const withCSS = require(&apos;@zeit/next-css&apos;)</span><br><span class="line"></span><br><span class="line">const publicRuntimeConfig = &#123;</span><br><span class="line">  API_END_POINT: process.env.API_END_POINT,</span><br><span class="line">  NODE_ENV: process.env.NODE_ENV,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = withCSS(withSass(&#123;</span><br><span class="line">  publicRuntimeConfig,</span><br><span class="line">  webpack: config =&gt; &#123;</span><br><span class="line">    // Fixes npm packages that depend on `fs` module</span><br><span class="line">    config.node = &#123;</span><br><span class="line">      fs: &apos;empty&apos;,</span><br><span class="line">      module: &apos;empty&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>필요한 process.env 의 값을 <code>publicRuntimeConfig</code> 객체에 담아주고 Next.js 의 옵션 값에 할당해준다.할당해 주게되면, Next.js 의 config 값으로 저장되게 된다.이후 Next.js의 config 값을 불러오는 함수를 추가해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import getConfig from &apos;next/config&apos;;</span><br><span class="line"></span><br><span class="line">export const getNodeEnv = () =&gt; &#123;</span><br><span class="line">  const &#123; publicRuntimeConfig &#125; = getConfig();</span><br><span class="line"></span><br><span class="line">  const realNodeEnv = publicRuntimeConfig.NODE_ENV || process.env.NODE_ENV;</span><br><span class="line">  const apiEndPoint = publicRuntimeConfig.API_END_POINT;</span><br><span class="line"></span><br><span class="line">  return &#123; realNodeEnv, apiEndPoint &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>해당 함수는 Next.js의 config에서 publicRuntimeConfig 를 가져와 return 해준다.이제 process.env 환경변수를 사용하고 싶다면, process.env.API_END_POINT 와 같이 직접적으로 사용하는것이 아닌, 해당 함수를 사용해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import config from &apos;./config&apos;</span><br><span class="line">import &#123; getNodeEnv &#125; from &apos;@/utils/env&apos;</span><br><span class="line"></span><br><span class="line">const env = getNodeEnv()</span><br><span class="line">const endPoint = env.apiEndPoint || config.apiEndPoint</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  AUTH_TOKEN: &#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    path: () =&gt; `$&#123;endPoint&#125;/auth/authenticate-token`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Next.js&lt;/code&gt;는 Client-Side-Rendering 을 사용하는 react가 아닌 &lt;code&gt;SSR(Server-Side-Rendering)&lt;/code&gt; 방식을 사용하는 react framework 이다.&lt;br&gt;해당 글은 &lt;code&gt;Next.js&lt;/code&gt;에서 배포시 참고하면 좋을 내용으로 &lt;code&gt;Next.js&lt;/code&gt;가 뿐만 아니라 react, Node 에서도 사용 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="Deploy" scheme="https://kkangil.github.io/categories/Deploy/"/>
    
    
      <category term="Next.js" scheme="https://kkangil.github.io/tags/Next-js/"/>
    
      <category term="deploy Next.js" scheme="https://kkangil.github.io/tags/deploy-Next-js/"/>
    
      <category term="pm2" scheme="https://kkangil.github.io/tags/pm2/"/>
    
      <category term="pm2-ecosystem" scheme="https://kkangil.github.io/tags/pm2-ecosystem/"/>
    
  </entry>
  
  <entry>
    <title>Deep clone</title>
    <link href="https://kkangil.github.io/2019/04/18/Deep-clone/"/>
    <id>https://kkangil.github.io/2019/04/18/Deep-clone/</id>
    <published>2019-04-17T15:01:31.000Z</published>
    <updated>2019-04-17T15:35:10.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a>이슈</h2><ol><li>react에서 setState를 하지 않았음에도 state가 변경되는 현상</li><li>api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상</li></ol><p>react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.<br>해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.<br>해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; a: 1, b: 2 &#125;</span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state = &#123;...this.state&#125;;</span><br><span class="line">  state[e.target.name] = e.target.value;</span><br><span class="line">  this.setState(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 본인이 input 의 onChange 이벤트 함수로 거의 복붙하면서 변형없이 사용하는 이벤트 함수이다.<br>최근 state 변수 선언 즉, state 객체를 복사하고 사용하는 과정에 있어 동일한 이슈가 많이 발생하고 있어, 해당 함수를 단순히 복사하는것이 아닌 이해가 필요하고 상황에 따라 변형해서 사용해야할 필요있다.</p><h2 id="Object-copy"><a href="#Object-copy" class="headerlink" title="Object copy"></a>Object copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;...this.state&#125;</span><br></pre></td></tr></table></figure><p>state 변수는 react state 객체를 복사한것이다. 해당 문법은 es9 문법으로 특정 값만 바꿀때 유용하다.<br>해당 문법의 es5 버전은 .assign() 메소드이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;&#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object3 = Object.assign(&#123; c: 3 &#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object4 = Object.assign(&#123;&#125;, object1);</span><br><span class="line">object4.a = 100</span><br><span class="line"></span><br><span class="line">const object5 = &#123;...object1&#125;</span><br><span class="line">object5.a = 100</span><br><span class="line"></span><br><span class="line">console.log(object2.a); //100</span><br><span class="line">console.log(object2.b); //2</span><br><span class="line">console.log(object3.a); //100</span><br><span class="line">console.log(object3.b); //2</span><br><span class="line">console.log(object3.c); //3</span><br><span class="line">console.log(object4.a); //100</span><br><span class="line">console.log(object5.a); //100</span><br></pre></td></tr></table></figure><ul><li>object2 : 빈 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object3: c: 3 값이 담겨있는 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object4: 현재 우리 회사에서 사용하는 handleChange를 es5로 바꾼 방법</li><li>object5: Spread syntax(…) es8 문법사용<br>하지만 state 내부에 객체를 변경하려고 할때 문제가 발생한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state &#123;...this.state&#125;</span><br><span class="line">  state.b.c = 3</span><br><span class="line">  this.setState(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2단계 이상 깊이의 object는 복사가 원활하지 않는것을 확인할 수 있다. 복사본의 값을 변경했는데 원본의 값도 변경되는 알수 없는 현상이 발생한다.<br>MDN: 깊은 클로닝에 대해서, Object.assign() 은 속성의 값을 복사하기때문에 다른 대안을 사용해야합니다. 출처 값이 객체에 대한 참조인 경우, 참조 값만을 복사합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(&#123;&#125;, org);</span><br><span class="line">obj.a.b = 100; </span><br><span class="line">console.log(obj.a.b);  //expected: 2 but actual: 100</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;...org&#125;;</span><br><span class="line">obj2.a.b = 100; </span><br><span class="line">console.log(org.a.b);  //expected: 2 but actual: 100</span><br></pre></td></tr></table></figure><p>해당 현상은 깊은 클로닝(deep cloning) 방식을 사용해야한다.<br>객체 복사 방식 변경 : 객체를 string 으로 변경하고 다시 파싱해주는 방법</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = JSON.parse(JSON.stringify(org)); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br><span class="line">lodash 메소드 사용</span><br><span class="line">import _ from &apos;lodash&apos;; const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = _.cloneDeep(org); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br></pre></td></tr></table></figure><h2 id="Array-copy"><a href="#Array-copy" class="headerlink" title="Array copy"></a>Array copy</h2><p>2단계 이상 깊이의 배열을 복사할때는 맵을 사용해서 객체 하나하나 복사해준 후 return 해주는 방식을 사용해서 에러발생을 막아야합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    a: [&#123;</span><br><span class="line">      b: 1</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">      b: 2</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj1 = &#123;...org&#125;</span><br><span class="line">const arr = org.obj.a // x</span><br><span class="line"></span><br><span class="line">const arr2 = org.obj.a.map(row =&gt; &#123;</span><br><span class="line">return &#123;...row&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>참고<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;이슈&quot;&gt;&lt;a href=&quot;#이슈&quot; class=&quot;headerlink&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;이슈&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;react에서 setState를 하지 않았음에도 state가 변경되는 현상&lt;/li&gt;
&lt;li&gt;api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.&lt;br&gt;해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.&lt;br&gt;해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://kkangil.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://kkangil.github.io/tags/Javascript/"/>
    
      <category term="syntax" scheme="https://kkangil.github.io/tags/syntax/"/>
    
      <category term="deep-clone" scheme="https://kkangil.github.io/tags/deep-clone/"/>
    
  </entry>
  
  <entry>
    <title>리액트 라이프사이클</title>
    <link href="https://kkangil.github.io/2019/04/17/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/"/>
    <id>https://kkangil.github.io/2019/04/17/리액트-라이프사이클/</id>
    <published>2019-04-17T14:48:33.000Z</published>
    <updated>2019-04-17T15:34:52.842Z</updated>
    
    <content type="html"><![CDATA[<p>React를 사용하기 전 <code>라이프사이클</code>에 대해 확실하게 알고 사용하는 것이 좋다.<br><code>라이프사이클</code> 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.<br>github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.<a href="https://github.com/kkangil/react-lifecycle" target="_blank" rel="noopener">code 보기</a></p><a id="more"></a><h2 id="주요-라이프사이클"><a href="#주요-라이프사이클" class="headerlink" title="주요 라이프사이클"></a>주요 라이프사이클</h2><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><ul><li>렌더가 된 이후 실행되는 라이프사이클로 최초 API 요청 사용에 적합한 라이프 사이클</li></ul><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><ul><li>component 의 상태값이 변경되었을때 render 직전에 호출되는 라이프 사이클</li><li>Boolean 값을 return 해야하며, false 를 return 하면 렌더를 하지 않음.</li><li>렌더를 하지 않으므로 이후 라이프사이클도 먹히지 않음.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><ul><li>component가 DOM 에서 삭제(해당 컴포넌트 미표시)할때 마지막으로 실행되는 메소드</li><li>interval 이나 비동기 API 제거에 주로 쓰임.</li></ul><h2 id="16-3-이후-변경된-라이프사이클"><a href="#16-3-이후-변경된-라이프사이클" class="headerlink" title="16.3 이후 변경된 라이프사이클"></a>16.3 이후 변경된 라이프사이클</h2><ul><li>렌더링 제어에 많은 방법이 있기때문에 라이프사이클 사용에 혼란이 생김.</li><li>실제 커뮤니티에서도 어떤 라이프사이클이 좋다 안좋다 성능 이슈가 많음. 대표적으로 componentWillMount 와 componentDidMount 둘중 어떤 라이프사이클에서 API를 호출해야하는지.</li><li>향후 componentWillMount, componentWillReceiveProps, componentWillUpdate 라이프사이클이 삭제되고 <code>UNSAFE_</code> 라이프사이클만 동작할것이라고 예고</li><li>이를 대체하기 위해 새로운 라이프사이클 추가</li></ul><h3 id="라이프사이클-동작-순서"><a href="#라이프사이클-동작-순서" class="headerlink" title="라이프사이클 동작 순서"></a>라이프사이클 동작 순서</h3><ul><li>최초 진입: <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code> 순으로 실행.</li><li>props 변경: <code>getDerivedStateFromProps</code> -&gt; <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li><li>state 변경: <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li></ul><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><ul><li>componentDidMount 보다 먼저 실행</li><li>window 객체 접근 가능(storage 사용 가능)</li><li>props 와 state가 변경되었을때는 최초 실행</li><li>파리미터로 변경될 props 와 state가 넘어옴. this.state 접근 불가능</li><li>return 되는 객체값으로 state 가 변경된다. (해당 라이프사이클에서는 state 변경만 해주는것이 바람직하다고 판단됨.) state를 변경해주고 싶지 않을때에는 null 을 return 해주면된다.</li><li>최초 페이지 진입시 <code>componentDidMount</code> 라이프사이클에서 fetch 실행</li><li>react 공식문서에서는 props 가 변경되었을때 fetch가 필요하다면 해당 라이프사이클에서 API(data fetching) 요청 하는것이 아닌 <code>componentDidUpdate</code> 라이프 사이클에서 fetch 하도록 유도하고 있음.</li></ul><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><ul><li><code>componentWillUpdate</code> 의 대체 라이프사이클</li><li>DOM이 업데이트 되기 직전이 실행</li><li><code>componentDidUpdate</code> 전에 실행되며 해당 라이프사이클의 return 값이 componentDidUpdate 3번째 파라미터로 전달됨.</li><li>기존 <code>componentWillUpdate</code> 와 같이 해당 라이프사이클 안에서 this.setState()를 사용하는 경우 무한루프에 빠지게 됨.</li><li>자주 사용되지는 않을것으로 판단됨.</li></ul><h2 id="Error-Boundary"><a href="#Error-Boundary" class="headerlink" title="Error Boundary"></a>Error Boundary</h2><ul><li>렌더 과정에서 에러가 생겼을경우 앱이 죽는것이 아니라 UI 변경과 같은 대안으로 앱이 죽지 않도록 하는 방식</li><li>해당 class를 최상단에 두고 라이프사이클을 이용해서 조작할 수 있다.</li></ul><h3 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError"></a>getDerivedStateFromError</h3><ul><li>16.6 버전에 추가된 라이프 사이클</li><li>해당 라이프 사이클은 렌더 중에 호출되며 fallback UI를 렌더링 하기 위한 메소드이다.</li><li>렌더 중에 호출되기 때문에 side effect(API call, 함수 호출) 을 사용하지 않는것이 좋다.</li><li>react 공식 문서에서는 componentDidCatch 라이프 사이클을 추천한다.</li><li>return 객체는 state 가 해당 객체로 변경된다.</li></ul><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><ul><li>해당 라이프사이클은 에러를 기록하거나 트래킹하기 위한 작업을 위해 주로 사용된다. (ex Sentry)</li><li>해당 라이프 사이클에서도 state 를 변경하여 UI 를 변경해줄수 있지만 추천되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React를 사용하기 전 &lt;code&gt;라이프사이클&lt;/code&gt;에 대해 확실하게 알고 사용하는 것이 좋다.&lt;br&gt;&lt;code&gt;라이프사이클&lt;/code&gt; 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.&lt;br&gt;github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.&lt;a href=&quot;https://github.com/kkangil/react-lifecycle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code 보기&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://kkangil.github.io/tags/React/"/>
    
      <category term="lifecycle" scheme="https://kkangil.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kkangil.github.io/2019/04/17/hello-world/"/>
    <id>https://kkangil.github.io/2019/04/17/hello-world/</id>
    <published>2019-04-17T11:51:34.545Z</published>
    <updated>2019-04-17T15:35:24.643Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><table><thead><tr><th>설정</th><th>설명</th><th>기본 값</th></tr></thead><tbody><tr><td>layout</td><td>레이아웃</td><td></td></tr><tr><td>title</td><td>타이틀</td><td></td></tr><tr><td>date</td><td>발행일</td><td>파일이 생성된 날짜</td></tr><tr><td>updated</td><td>갱신일</td><td>파일이 업로드된 날짜</td></tr><tr><td>tags</td><td>태그 (page에서는 사용 불가능)</td><td></td></tr><tr><td>categories</td><td>카테고리 (page에서는 사용 불가능)</td><td></td></tr><tr><td>permalink</td><td>포스트의 기본 permalink를 override합니다.</td><td></td></tr><tr><td>comments</td><td>포스트에서 comment 기능을 사용할지 여부</td><td>true</td></tr></tbody></table><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://kkangil.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://kkangil.github.io/tags/hexo/"/>
    
      <category term="hexo 시작" scheme="https://kkangil.github.io/tags/hexo-%EC%8B%9C%EC%9E%91/"/>
    
  </entry>
  
</feed>
