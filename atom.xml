<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkangil&#39;s Blog</title>
  
  <subtitle>kkangil&#39;s develop Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkangil.github.io/"/>
  <updated>2019-09-28T09:07:34.419Z</updated>
  <id>https://kkangil.github.io/</id>
  
  <author>
    <name>kkangil</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>함수형 프로그래밍 - 시작</title>
    <link href="https://kkangil.github.io/2019/09/28/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%91/"/>
    <id>https://kkangil.github.io/2019/09/28/함수형-프로그래밍-시작/</id>
    <published>2019-09-28T06:49:18.000Z</published>
    <updated>2019-09-28T09:07:34.419Z</updated>
    
    <content type="html"><![CDATA[<p>최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.<br>함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에<br>터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.</p><p>기본적으로 <code>함수형 자바스크립트 프로그래밍</code> 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.</p><p>도서 링크: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p><h1 id="함수형-자바스크립트-소개"><a href="#함수형-자바스크립트-소개" class="headerlink" title="함수형 자바스크립트 소개"></a>함수형 자바스크립트 소개</h1><ul><li>함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.</li><li>함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유<ol><li>오류를 줄이기 위함.</li><li>조합성 혹은 모듈화 수준을 높이기 위함.</li></ol></li></ul><h2 id="함수형-프로그래밍을-검색하면-나오는-예제"><a href="#함수형-프로그래밍을-검색하면-나오는-예제" class="headerlink" title="함수형 프로그래밍을 검색하면 나오는 예제"></a>함수형 프로그래밍을 검색하면 나오는 예제</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addMaker(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addMaker(10)(5);</span><br></pre></td></tr></table></figure><p>함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.<br>함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.</p><p><code>addMaker</code>는 함수를 값으로 다루는 함수다. <code>addMaker</code>에서는 단 하나의 값이 선언되며 그 값은 함수다.<br><code>addMaker(10)</code>의 결과는 function(b) { return 10 + b }; 와 같다.<br>이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add5 = addMaker(5);</span><br><span class="line">add5(3) // 8</span><br><span class="line">add5(4) // 9</span><br></pre></td></tr></table></figure><p>위와 같이 변수에 값을 할당해서 사용할 수 도 있다.</p><h2 id="값으로써의-함수와-클로저"><a href="#값으로써의-함수와-클로저" class="headerlink" title="값으로써의 함수와 클로저"></a>값으로써의 함수와 클로저</h2><p>위의 예제들을 보면 함수는 값을 리턴할 수 있고 함수는 값이 될 수 있다. <code>addMaker</code>는 내부에서 함수를 정의하고 리턴했다. <code>addMaker</code>가 리턴한 익명 함수는 클로저가 되었다.<br>리턴된 익명 함수 내부에서 a가 정의된 적은 없지만 a를 참조하고 있고 a는 부모 스코프에 있다.</p><p><code>addMaker</code>가 실행된 후, 어디서도 <code>addMaker</code>의 인자인 a 값을 변경시키지 않고 있기 때문에 항상 동일한 값을 갖는다. 때문에 위 상황에서 a는 불변하며 상수로 쓰이게 된다. 이 상황에서의 a는 불변하지만, 모든 경우의 클로저가 그렇지는 않다. 클로저가 기억하는 변수의 값은 변할 수 있다.</p><hr><h2 id="함수형-자바스크립트의-실용성"><a href="#함수형-자바스크립트의-실용성" class="headerlink" title="함수형 자바스크립트의 실용성"></a>함수형 자바스크립트의 실용성</h2><p>절차지향적으로 작성된 코드를 함수형으로 변경하면서 함수형 자바스크립트의 실용성을 알아보고자 한다.</p><h3 id="회원-목록-중-여러명-찾기"><a href="#회원-목록-중-여러명-찾기" class="headerlink" title="회원 목록 중 여러명 찾기"></a>회원 목록 중 여러명 찾기</h3><p>회원 목록 중 특정 나이의 회원들만 뽑거나 특정 조건의 회원 한 명을 찾는 코드들을 함수형 자바스크립트로 리팩토링 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var users = [</span><br><span class="line">  &#123; id: 1, name: &apos;ID&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 2, name: &apos;HA&apos;, age: 25 &#125;,</span><br><span class="line">  &#123; id: 3, name: &apos;BJ&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 4, name: &apos;PJ&apos;, age: 28 &#125;,</span><br><span class="line">  &#123; id: 5, name: &apos;JE&apos;, age: 27 &#125;,</span><br><span class="line">  &#123; id: 6, name: &apos;JM&apos;, age: 32 &#125;,</span><br><span class="line">  &#123; id: 7, name: &apos;HI&apos;, age: 24 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(temp_users[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &gt;= 30) temp_users.push(users[i])</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = temp_users.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(temp_users[i].name);</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>1에서는 users 중에 age가 30 미만인 users[i]만 모아서 몇 명인지를 출력하고 2에서는 그들의 나이만 다시 모아 출력한다. 3에서는 나이가 30 이상인 temp_users가 몇 명인지를 출력하고 4에서는 그들의 이름만 다시 모아 출력한다.</p><p>위 코드를 함수형으로 리팩토링 하기 위해 먼저 중복되는 부분을 찾아본다. 1과 3의 for문에서 users를 돌며 특정 조건의 users[i]를 새로운 배열에 담고 있는데, if 문의 조건절 부분을 제외하고는 모두 동일한 코드이다. 30 부분은 변수로 바꿀 수 있겠지만 .age, &lt;, &gt;= 등은 쉽지 않아 보인다. 이때 함수를 활용하면 이런 부분까지도 쉽게 추상화 할 수 있다.</p><h3 id="for에서-filter로-if에서-predicate로"><a href="#for에서-filter로-if에서-predicate로" class="headerlink" title="for에서 filter로, if에서 predicate로"></a>for에서 filter로, if에서 predicate로</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 기존코드</span><br><span class="line">var temp_users = [];</span><br><span class="line">for (var i = 0, len = users.length; i &lt; len; i++) &#123;</span><br><span class="line">  if (users[i].age &lt; 30) temp_users.push(users[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(temp_users.length);</span><br><span class="line"></span><br><span class="line">// refactoring</span><br><span class="line">function filter(list, predicate) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (predicate(list[i])) new_list.push(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter 함수는 인자로 list와 predicate 함수를 받는다. 루프를 도며 list의 i번째의 값을 predicate에 넘겨준다. predicate 함수는 list.length 만큼 실행되며, predicate 함수의 결과가 참일 때만 new_list.push를 실행한다.<br>filter 함수는 predicate 함수 내부에서 어떤 일을 하는지 모른다. id를 조회할지 age를 조회할지 어떤 조건을 만들지를 filter는 전혀 모른다. 오직 predicate 결과에만 의존한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// filter 사용</span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30)</span><br><span class="line"></span><br><span class="line">var ages = [];</span><br><span class="line">for (var i = 0, len = users_under_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  ages.push(users_under_30[i].age);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30);</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for (var i = 0, len = users_over_30.length; i &lt; len; i++) &#123;</span><br><span class="line">  names.push(users_over_30[i].name)</span><br><span class="line">&#125;</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>filter 함수를 실행하면서 predicate 자리에 익명 함수를 정의해서 넘겼다. predicate 익명 함수의 리턴값(<code>boolean</code>)에 따라서 push를 해줄지 안해줄지가 결정된다. 기존 코드와 비교해 코드가 짧아졌고 재사용성 높은 함수 filter를 얻게됐다.</p><h3 id="함수형-프로그래밍-관점으로-filter-보기"><a href="#함수형-프로그래밍-관점으로-filter-보기" class="headerlink" title="함수형 프로그래밍 관점으로 filter 보기"></a>함수형 프로그래밍 관점으로 filter 보기</h3><p>함수형 프로그래밍 관점에서 filter와 predicate 사이에는 많은 이야기가 담겨있다. filter 함수에는 for도 있고 if도 있지만, filter 함수는 항상 동일하게 동작하는 함수다. <strong>동일한 인자가 들어오면 항상 동일하게 동작한다.</strong> filter 함수의 로직은 외부나 내부의 어떤 상태 변화에도 의존하지 않는다. <code>new_list</code>의 값을 바꾸고 있지만 그 변화에 의존하는 다른 로직이 없다. <code>new_list</code>가 완성될 떄까지는 외부에서 어떠한 접근도 할 수 없기 때문에 filter의 결과도 달라질 수 없다. <code>new_list</code>가 완성되고 나면 <code>new_list</code>를 리턴해버리고 filter는 완전히 종료된다.</p><p>filter의 if는 predicate의 결과에만 의존한다. filter를 사용하는 부분을 다시 보면 filter와 users, filter가 사용할 predicate 함수만 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(users, function(user) &#123; return user.age &lt; 30 &#125;)</span><br></pre></td></tr></table></figure></p><p>절차지향 프로그래밍과 달리 함수형 프로그래밍 에서는 <strong>항상 동일하게 동작하는 함수</strong> 를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다. 내부에서 관리하고 있는 상태를 따로 두지않고 넘겨진 인자에만 의존한다. 동일한 인자가 들어오면 항상 동일한 값을 리턴 하도록 한다.</p><h3 id="map-함수"><a href="#map-함수" class="headerlink" title="map 함수"></a>map 함수</h3><p>리팩토링의 핵심은 중복을 제거하고 의도를 드러내는 것이다. 기존 코드를 보면 회원 목록을 통해 나이와 이름들을 추출하는데 두 코드에도 중복이 있다. 둘 다 for문에서 사용하는 회원 목록을 활용해 같은 크기의 새로운 배열을 만들고 원재료와 1:1로 매핑되는 다른 값을 만들어 담고 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// map 사용</span><br><span class="line">function map(list, iteratee) &#123;</span><br><span class="line">  var new_list = [];</span><br><span class="line">  for (var i = 0, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    new_list.push(iteratee(list[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var users_under_30 = filter(users, function (user) &#123; return user.age &lt; 30 &#125;);</span><br><span class="line">console.log(users_under_30.length)</span><br><span class="line"></span><br><span class="line">var ages = map(users_under_30, function (user) &#123; return user.age &#125;);</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var users_over_30 = filter(users, function (user) &#123; return user.age &gt; 30 &#125;);</span><br><span class="line">console.log(users_over_30.length)</span><br><span class="line"></span><br><span class="line">var names = map(users_over_30, function (user) &#123; return user.name &#125;);</span><br><span class="line">console.log(names);</span><br></pre></td></tr></table></figure><p>코드가 매우 단순해 진것을 확인할 수 있다. for도 없고 if도 없다. new_list에 무엇을 push 할지에 대해 iteratee 함수에게 위임했다.</p><h3 id="실행-결과로-바로-실행하기"><a href="#실행-결과로-바로-실행하기" class="headerlink" title="실행 결과로 바로 실행하기"></a>실행 결과로 바로 실행하기</h3><p>함수의 리턴값을 바로 다른 함수의 인자로 사용하면 변수 할당을 줄일 수 있다.<br>filter 함수의 결과가 배열이므로 map의 첫 번째 인자로 바로 사용 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 함수 중첩</span><br><span class="line">var ages = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.age &#125;</span><br><span class="line">)</span><br><span class="line">console.log(ages);</span><br><span class="line"></span><br><span class="line">var names = map(</span><br><span class="line">  filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">  function (user) &#123; return user.name &#125;</span><br><span class="line">)</span><br><span class="line">console.log(names);</span><br><span class="line"></span><br><span class="line">// 함수 중첩 2</span><br><span class="line">function log_length(value) &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.age &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      function (user) &#123; return user.name &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>filter 함수는 predicate를 통해 값을 필터링하여 map에게 전달하고 map은 받은 iteratee를 통해 새로운 값들을 만들어 log_length에게 전달한다. log_length는 length를 출력한 후 받은 인자를 그대로 console.log에게 전달하고 console.log는 받은 값을 출력한다.</p><h3 id="함수를-값으로-다룬-예제의-실용성"><a href="#함수를-값으로-다룬-예제의-실용성" class="headerlink" title="함수를 값으로 다룬 예제의 실용성"></a>함수를 값으로 다룬 예제의 실용성</h3><p>위에 만들었던 <code>addMaker</code> 와 비슷한 패턴의 함수가 실제로도 많이 사용된다.<br><code>addMaker</code>와 비슷한 패턴의 함수인 <code>bvalue</code> 함수를 만들어 보려고한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function bvalue(key) &#123;</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bvalue(&apos;a&apos;)(&#123; a: &apos;hi&apos;, b: &apos;hello&apos; &#125;)); // hi</span><br></pre></td></tr></table></figure><p>bvalue를 실행할 때 넘겨준 인자 key를 나중에 obj를 받을 익명 함수가 기억한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * bvalue로 map의 iteratee 만들기</span><br><span class="line"> */</span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &lt; 30 &#125;),</span><br><span class="line">      bvalue(&apos;age&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, function (user) &#123; return user.age &gt;= 30 &#125;),</span><br><span class="line">      bvalue(&apos;name&apos;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>map이 사용할 iteratee 함수를 bvalue가 리턴한 함수로 대체했다. 익명 함수 선언이 사라져 코드가 더욱 짧아졌다.</p><p>화살표 함수로 사용하기<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &lt; 30),</span><br><span class="line">      user =&gt; user.age</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  log_length(</span><br><span class="line">    map(</span><br><span class="line">      filter(users, user =&gt; user.age &gt;= 30),</span><br><span class="line">      user =&gt; user.name</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var under_30 = user =&gt; user.age &lt; 30;</span><br><span class="line">var over_30 = user =&gt; user.age &gt;= 30;</span><br><span class="line">var ages = list =&gt; map(list, user =&gt; user.age);</span><br><span class="line">var names = list =&gt; map(list, user =&gt; user.name);</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, function (user) &#123; return user[key] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ages = bvalues(&apos;age&apos;);</span><br><span class="line">var names = bvalues(&apos;name&apos;);</span><br><span class="line">var under_30 = function (user) &#123; return user.age &lt; 30 &#125;;</span><br><span class="line">var over_30 = function (user) &#123; return user.age &gt;= 30 &#125;;</span><br><span class="line"></span><br><span class="line">console.log(log_length(ages(filter(users, under_30))));</span><br><span class="line">console.log(log_length(names(filter(users, over_30))));</span><br><span class="line"></span><br><span class="line">function bvalues(key) &#123;</span><br><span class="line">  var value = bvalue(key);</span><br><span class="line">  return function (list) &#123;</span><br><span class="line">    return map(list, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 화살표 함수 사용</span><br><span class="line">var bvalues = key =&gt; list =&gt; &#123;</span><br><span class="line">  var value = bvalue(key)</span><br><span class="line">  return map(list, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>Conclusion<br>어려운 점이 공부를 하면 할수록 많이 생기겠지만, 새로운 관점에서의 프로그래밍인 것 같아 흥미롭게 느껴진다.<br>본인은 아직 주니어라 절차지향적 사고 방식이 강한데 함수형 프로그래밍 공부하면서 새로운 사고 방식에 대해서도 생각해 봐야할 것 같다. 이번 챕터의 첫 코드(절차지향적 코드)는 쉽다고 느껴졌지만, 함수형으로 리팩토링 해 나가는 과정에서는 이게 정확히 어떤 방식으로 동작하는가, 인자값은 어떻게 넘겨 주는가에 대한 고민이 생기는것을 느끼면서 함수형 프로그래밍에 더 알고 싶어졌다.</p><p>처음에는 함수형 프로그래밍 방식이 “그래서 왜 좋은건데?”에 대한 의문이 있었는데 마지막 코드를 보고 재새용성이 뛰어나다는것을 느꼈다. 프로젝트를 시작할때 잘 구현해 놓은 함수는 계속 재사용하면서 코딩의 속도와 편리함을 제공해 줄 것 같다고 생각했다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.&lt;br&gt;함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에&lt;br&gt;터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다.&lt;/p&gt;
&lt;p&gt;기본적으로 &lt;code&gt;함수형 자바스크립트 프로그래밍&lt;/code&gt; 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다.&lt;/p&gt;
&lt;p&gt;도서 링크: &lt;a href=&quot;http://www.yes24.com/Product/Goods/56885507&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;함수형 자바스크립트 프로그래밍&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;함수형-자바스크립트-소개&quot;&gt;&lt;a href=&quot;#함수형-자바스크립트-소개&quot; class=&quot;headerlink&quot; title=&quot;함수형 자바스크립트 소개&quot;&gt;&lt;/a&gt;함수형 자바스크립트 소개&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다.&lt;/li&gt;
&lt;li&gt;함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유&lt;ol&gt;
&lt;li&gt;오류를 줄이기 위함.&lt;/li&gt;
&lt;li&gt;조합성 혹은 모듈화 수준을 높이기 위함.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;함수형-프로그래밍을-검색하면-나오는-예제&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍을-검색하면-나오는-예제&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍을 검색하면 나오는 예제&quot;&gt;&lt;/a&gt;함수형 프로그래밍을 검색하면 나오는 예제&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function addMaker(a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return function(b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addMaker(10)(5);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.&lt;br&gt;함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addMaker&lt;/code&gt;는 함수를 값으로 다루는 함수다. &lt;code&gt;addMaker&lt;/code&gt;에서는 단 하나의 값이 선언되며 그 값은 함수다.&lt;br&gt;&lt;code&gt;addMaker(10)&lt;/code&gt;의 결과는 function(b) { return 10 + b }; 와 같다.&lt;br&gt;이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다.&lt;/p&gt;
    
    </summary>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
    
      <category term="javascript" scheme="https://kkangil.github.io/tags/javascript/"/>
    
      <category term="함수형 프로그래밍" scheme="https://kkangil.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>Sequelize model 정의</title>
    <link href="https://kkangil.github.io/2019/04/28/Sequelize-model-%EC%A0%95%EC%9D%98/"/>
    <id>https://kkangil.github.io/2019/04/28/Sequelize-model-정의/</id>
    <published>2019-04-28T05:45:40.000Z</published>
    <updated>2019-04-28T05:47:51.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sequelize-model-정의"><a href="#sequelize-model-정의" class="headerlink" title="sequelize model 정의"></a>sequelize model 정의</h2><ul><li>sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 <code>define</code> 메소드를 이용해 정의하고자 한다.</li><li>model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128)</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><code>define</code> 함수의 첫번째 파라미터는 테이블의 이름에 해당된다. 또한 express 프로젝트에서도 해당 이름으로 데이터베이스에 접근할 수 있다.</li><li>두번째 파라미터는 컬럼을 정의하는 것이다. 위의 예시는 가장 기본적인 컬럼을 생성한 것이고 나머지 옵션들은 밑에서 확인해 보도록 한다.</li></ul><h2 id="column-option"><a href="#column-option" class="headerlink" title="column option"></a>column option</h2><ul><li>sequelize model 생성시 sequelize 는 고유 키값을 정의해 주지 않아도, 다른 설정이 없다면 id 로 생성해주며 row 생성시 자동으로 1씩 증가한다.</li><li>id 이외에 createdAt(생성일), updatedAt(수정일) 도 같이 생성해준다.</li><li>defaultValue: row가 생성될때 기본값을 설정해줄 수 있다. (etc. Sequelize.NOW)</li><li>allowNull: false로 설정해주면 빈값으로 생성시 에러가 난다.(default true)</li><li>unique: 테이블내의 고유한 값(boolean)</li><li>primaryKey: 고유 키값 설정 여부</li><li>autoIncrement: 자동으로 값을 증가시켜준다. (Integer 에서만 사용 가능)</li><li>field: 객체 키값과 다르게 custom으로 컬럼명을 사용할 수 있게해준다.</li><li>comment: 해당 컬럼에 대한 설명을 달 수 있다. 컬럼 생성에 영향을 미치지는 않는다. 주석같은 개념</li></ul><h2 id="Getters-amp-setters"><a href="#Getters-amp-setters" class="headerlink" title="Getters &amp; setters"></a>Getters &amp; setters</h2><ul><li><p>컬럼 option에 getter와 setter를 추가해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false,</span><br><span class="line">      get() &#123;</span><br><span class="line">        const job = this.getDataValue(&apos;job&apos;)</span><br><span class="line">        return `$&#123;this.getDataValue(&apos;username&apos;)&#125; ($&#123;this.getDataValue(&apos;job&apos;)&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false,</span><br><span class="line">      set(job) &#123;</span><br><span class="line">        this.setDataValue(&apos;job&apos;, job.toUpperCase())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const userSample = async () =&gt; &#123;</span><br><span class="line">  const user = await User.create(&#123; username: &apos;kkangil&apos;, job: &apos;developer&apos; &#125;)</span><br><span class="line">  console.log(user.get(&apos;username&apos;)) // kkangil (DEVELOPER)</span><br><span class="line">  console.log(user.get(&apos;job&apos;)) // DEVELOPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getDataValue</code> 를 사용하여 자신의 컬럼 뿐만 아니라 테이블의 컬럼 데이터도 가져올 수 있다.</p></li><li><code>setDataValue</code> 를 사용하여 생성이나 수정 시 데이터 값을 수정, 변경할 수 있다. </li><li>컬럼 객체 내부에 설정해 주지 않고, <code>define</code> 함수의 세번째 파라미터로도 사용이 가능하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    getterMethods: &#123;</span><br><span class="line">      getUser() &#123;</span><br><span class="line">        return `$&#123;this.username&#125; ($&#123;this.job&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="validate-column"><a href="#validate-column" class="headerlink" title="validate column"></a>validate column</h2><ul><li><p>데이터 타입 이외에도 <code>validate</code> 를 사용해서 유효성 확인 후 에러를 반환해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;Foo&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      validate: &#123;</span><br><span class="line">        is: /^[a-z]+$/i, // 정규식 사용해서 유효성 확인</span><br><span class="line">        not: /^[a-z]+$/i,</span><br><span class="line">        isEmail: true, // 이메일 유효성 확인</span><br><span class="line">        isInt: true,</span><br><span class="line">        notNull: true,</span><br><span class="line">        isNull: true,</span><br><span class="line">        notEmpty: true, // string 빈값 확인</span><br><span class="line">        equals: &apos;specific value&apos;, // 특정 값으로만 생성 가능</span><br><span class="line">        contains: &apos;foo&apos;, // 해당 값을 포함하고 있는지 확인</span><br><span class="line">        notContains: &apos;bar&apos;,</span><br><span class="line">        notIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        isIn: [[&apos;foo&apos;, &apos;bar&apos;]],</span><br><span class="line">        len: [2,10], // 2자리 ~ 10자리</span><br><span class="line">        max: 23,</span><br><span class="line">        min: 10,</span><br><span class="line">        isCreditCard: true // 신용카드 유효성 확인</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>제공되는 <code>validate</code> 가 아닌 직접 만들어서 사용하는 기능도 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    isEven(value) &#123;</span><br><span class="line">      if (parseInt(value) % 2 !== 0) &#123;</span><br><span class="line">        throw new Error(&apos;Only even values are allowed!&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throw new Error의 메시지가 에러로 리턴된다.</p></li><li><p>직접 만들어서 사용하지 않아도 메시지를 설정해 줄 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">  type: DataTypes.INTEGER,</span><br><span class="line">  validate: &#123;</span><br><span class="line">    notNull: &#123;</span><br><span class="line">      msg: &quot;Must&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    isIn: &#123;</span><br><span class="line">      args: [[&apos;en&apos;, &apos;zh&apos;]],</span><br><span class="line">      msg: &quot;Must be English or Chinese&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>allowNull</code> 을 사용한다면 <code>notNull</code> 의 <code>msg</code>를 설정해주면 에러메시지로 사용가능하다.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  &quot;User&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    job: &#123;</span><br><span class="line">      type: DataTypes.STRING,</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    validate: &#123;</span><br><span class="line">      checkUsernameAndJob() &#123;</span><br><span class="line">        if (!(this.username &amp;&amp; this.job)) &#123;</span><br><span class="line">          throw new Error(&apos;이름과 직업을 입력해주세요.&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>define</code> 함수의 세번째 파라미터 객체에 validate 를 설정해주면 하나의 컬럼이 아닌 테이블의 모든 컬럼의 유효성은 같이 확인 할 수 있다.</li></ul><h2 id="model-configuration"><a href="#model-configuration" class="headerlink" title="model configuration"></a>model configuration</h2><ul><li><code>define</code> 함수의 세번째 파라미터 객체의 설정값<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">return sequelize.define(</span><br><span class="line">  ..., &#123;</span><br><span class="line">    modelName: &apos;bar&apos;, // 모델 이름 설정</span><br><span class="line">    timestamps: false, // createdAt, updatedAt 생성하지 않음</span><br><span class="line">    paranoid: true, // 데이터를 삭제하지 않고 현재 시간으로 deletedAt 데이터가 추가된다.</span><br><span class="line">    underscored: true, // 자동으로 컬럼명을 snake 네임으로 변경한다.</span><br><span class="line">    tableName: &apos;my_bar&apos;, // 테이블 이름 설정</span><br><span class="line">    createdAt: false, // createdAt 사용하지 않음</span><br><span class="line">    updatedAt: &apos;updateTimestamp&apos;, // updatedAt 컬럼명 정의</span><br><span class="line">    deletedAt: &apos;destroyTime&apos;, // deletedAt 컬럼명 정의 (paranoid가 true로 설정되어 있어야함.)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>참고 <a href="http://docs.sequelizejs.com/manual/models-definition.html" target="_blank" rel="noopener">sequelize docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sequelize-model-정의&quot;&gt;&lt;a href=&quot;#sequelize-model-정의&quot; class=&quot;headerlink&quot; title=&quot;sequelize model 정의&quot;&gt;&lt;/a&gt;sequelize model 정의&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 &lt;code&gt;define&lt;/code&gt; 메소드를 이용해 정의하고자 한다.&lt;/li&gt;
&lt;li&gt;model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;return sequelize.define(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;User&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    username: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING(128)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    job: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: DataTypes.STRING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Sequelize" scheme="https://kkangil.github.io/categories/Sequelize/"/>
    
    
      <category term="Sequelize" scheme="https://kkangil.github.io/tags/Sequelize/"/>
    
      <category term="MySQL" scheme="https://kkangil.github.io/tags/MySQL/"/>
    
      <category term="model 정의" scheme="https://kkangil.github.io/tags/model-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 3. 사용방법2</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-3-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%952/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-3-사용방법2/</id>
    <published>2019-04-19T03:54:04.000Z</published>
    <updated>2019-04-19T03:56:23.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const reducer = (state, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;INCREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count + 1 &#125;;</span><br><span class="line">    case &quot;DECREMENT&quot;:</span><br><span class="line">      return &#123; ...state, count: state.count - 1 &#125;;</span><br><span class="line">    case &quot;HANDLE_CHANGE&quot;:</span><br><span class="line">      return &#123; ...state, [action.target.name]: action.target.value &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const CountReducer = () =&gt; &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, &#123;</span><br><span class="line">    count: 0,</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    nickname: &quot;&quot;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const handleChange = e =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &quot;HANDLE_CHANGE&quot;, target: e.target &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;INCREMENT&quot; &#125;)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;DECREMENT&quot; &#125;)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.name&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">        &lt;input name=&quot;name&quot; value=&#123;state.nickname&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default CountReducer;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>이전에 useState로 구현했었던 count와 input 컴포넌트를 위의 코드와 같이 reducer를 사용해서 구현할 수 있다.</li><li>useState 또는 useReducer 어떤것이 더 좋다 안좋다는 없지만, 상황에 따라 유연하게 사용할 줄 알아야 할것같다.</li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>두번째 파라미터 배열 값을 전달받아 해당 값이 변경 될때만 첫번째 파라미터 함수를 실행한다. 해당 기능을 사용하면 불필요한 함수 호출을 줄일 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Sum = () =&gt; &#123;</span><br><span class="line">  const [num, setNum] = useState(&quot;&quot;);</span><br><span class="line">  const [numList, setNumList] = useState([]);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = () =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const sumValue = useMemo(() =&gt; &#123;</span><br><span class="line">    if (!numList.length) return 0;</span><br><span class="line">    const sum = numList.reduce((a, b) =&gt; a + b);</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;, [numList]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Sum</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;num&#125; onChange=&#123;e =&gt; setNum(e.target.value)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;handleClickAdd&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number list: &#123;numList.join(&quot;, &quot;)&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;number total: &#123;sumValue&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Sum;</span><br></pre></td></tr></table></figure><ul><li>sumValue 함수에 <code>useMemo</code>를 사용하지 않으면, input 값이 변경될때도 해당 로직이 불필요하게 실행된다.</li><li>useMemo를 사용해 줌으로써 불필요하게 실행되지 않도록 하고, <code>numList</code>의 값이 변경될때마다 해당 로직이 실행된다.</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useMemo와 거의 비슷한 기능으로 렌더링 성능을 최적화 하기위해 주로 사용된다. 쓰지 않아도 문제되지는 않지만 렌더링 해야할 컴포넌트 개수나 로직이 많아진다면 고려해 봐야한다. 해당 기능은 이벤트 함수를 필요할때만 생성해 주는 기능이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = useCallback(e =&gt; &#123;</span><br><span class="line">    setNum(e.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br></pre></td></tr></table></figure><ul><li>위의 onChange 함수와 handleClickAdd 함수를 useCallback을 사용하는 함수로 변경했다.</li><li>두번째 파라미터 배열은 해당 값이 변경될때만 함수를 생성해 주는것이다. 빈 배열이라면 최초에만 생성해주고 이후 다시 생성되지 않는다.</li><li>handleChange 는 빈배열, handleClickAdd 은 두개의 값을 판단하고 있는데, 이는 handleChange는 단순히 <code>num</code> 의 값만 변경해 주고 있어 초기에만 생성해 줘도 되는것이다. handleClickAdd 함수는 이벤트가 실행 될때마다 값을 가져와서 사용해 주고 있기때문에 배열에 해당 값들을 명시해줘야한다.</li></ul><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>useRef는 함수형 컴포넌트에서도 ref 기능을 사용할 수 있게 해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const inputElement = useRef(null);</span><br><span class="line">const handleClickAdd = useCallback(() =&gt; &#123;</span><br><span class="line">    if (+num) &#123;</span><br><span class="line">      const newNumList = [...numList];</span><br><span class="line">      newNumList.push(+num);</span><br><span class="line">      setNumList(newNumList);</span><br><span class="line">      setNum(&quot;&quot;);</span><br><span class="line">      inputElement.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [numList, num]);</span><br><span class="line">&lt;input value=&#123;num&#125; onChange=&#123;handleChange&#125; ref=&#123;inputElement&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li>useRef는 다른 Hook과 다르게 최초 선언을 배열 형태로 선언해 주지 않는다.</li><li>ref 값이 변경되어도 리렌더링 되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h2&gt;&lt;p&gt;redux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import React, &amp;#123; useReducer &amp;#125; from &amp;quot;react&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const reducer = (state, action) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  switch (action.type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;INCREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count + 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;DECREMENT&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, count: state.count - 1 &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case &amp;quot;HANDLE_CHANGE&amp;quot;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;#123; ...state, [action.target.name]: action.target.value &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const CountReducer = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const [state, dispatch] = useReducer(reducer, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count: 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &amp;quot;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nickname: &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const handleChange = e =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch(&amp;#123; type: &amp;quot;HANDLE_CHANGE&amp;quot;, target: e.target &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;p&amp;gt;current count: &amp;#123;state.count&amp;#125;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;INCREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;increase&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button onClick=&amp;#123;() =&amp;gt; dispatch(&amp;#123; type: &amp;quot;DECREMENT&amp;quot; &amp;#125;)&amp;#125;&amp;gt;decrease&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.name&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;input name=&amp;quot;name&amp;quot; value=&amp;#123;state.nickname&amp;#125; onChange=&amp;#123;handleChange&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export default CountReducer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useReducer" scheme="https://kkangil.github.io/tags/useReducer/"/>
    
      <category term="useMemo" scheme="https://kkangil.github.io/tags/useMemo/"/>
    
      <category term="useCallback" scheme="https://kkangil.github.io/tags/useCallback/"/>
    
      <category term="useRef" scheme="https://kkangil.github.io/tags/useRef/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 2. 사용방법1</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-2-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%951/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-2-사용방법1/</id>
    <published>2019-04-19T03:52:51.000Z</published>
    <updated>2019-04-19T03:53:43.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h3><p>useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.</p><p>사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;current count: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><ul><li>useState를 사용하여 count state를 생성해 주었으며 초기값은 0으로 맞춰 주었다.</li><li>state 사용은 기존의 class에서 사용하던 this.state.count가 아닌 count로만 사용해야 한다.</li><li>setCount 파라미터로 값을 넘겨주면 해당 값으로 state가 변경된다.</li></ul><h3 id="여러개의-state-사용"><a href="#여러개의-state-사용" class="headerlink" title="여러개의 state 사용"></a>여러개의 state 사용</h3><p>여러개의 state를 사용해야 한다면, 기존 class 방식에서는 state 객체 안에 키와 값을 설정해 주면 됐지만, 함수형 컴포넌트에서는 useState를 여러번 써줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;name ? `$&#123;name&#125;&apos;s` : &quot;&quot;&#125; current count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="재사용-가능한-useState-함수-컴포넌트"><a href="#재사용-가능한-useState-함수-컴포넌트" class="headerlink" title="재사용 가능한 useState 함수 컴포넌트"></a>재사용 가능한 useState 함수 컴포넌트</h3><p>동일한 stateful 로직을 사용한다면 컴포넌트를 분리해서 사용하는것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const useInputOption = props =&gt; &#123;</span><br><span class="line">  const [value, setValue] = useState(props || &quot;&quot;);</span><br><span class="line">  const onChange = e =&gt; &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Counter = props =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const nameInputOption = useInputOption(&quot;&quot;);</span><br><span class="line">  const nickInputOption = useInputOption(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input &#123;...nameInputOption&#125; /&gt;</span><br><span class="line">      &lt;input &#123;...nickInputOption&#125; /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &#123;nameInputOption.value ? `$&#123;nameInputOption.value&#125;&apos;s` : &quot;&quot;&#125; current</span><br><span class="line">        count: &#123;count&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;increase&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;decrease&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>input의 value와 onChange 이벤트 함수를 return 해주는 <code>useInputOption</code> 컴포넌트를 만들었다.</li><li>코드가 간결해지고 재사용성이 높아진다.</li></ul><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect는 함수형 컴포넌트에서도 라이프사이클과 같은 기능을 사용할 수 있게 해준다.<br><code>componentDidMount</code> 와 <code>componentDidUpdate</code>, <code>componentWillUnmount</code> 를 합쳐놓은 것이다.<br>useEffect 함수는 state 변수를 하나만 관리하는것이 좋다. 즉 여러개의 useEffect 함수를 사용하는것을 추천해주고 있다.</p><h3 id="사용방법-1"><a href="#사용방법-1" class="headerlink" title="사용방법"></a>사용방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const User = () =&gt; &#123;</span><br><span class="line">  const [name, setName] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &lt;input value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default User;</span><br></pre></td></tr></table></figure><ul><li>해당 코드를 확인해보면 render 가 될때마다 console.log 가 찍히는것을 확인할 수 있다. 이것은 <code>componentDidMount</code> 와 <code>componentDidUpdate</code> 라이프사이클과 일치한다.</li></ul><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><ul><li>useEffect 함수에 두번째 파라미터로 빈배열을 넣으면 최초 렌더링이 될때만 실행되고 name이 변경되더라도 실행되지 않는다.</li></ul><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>배열에 원하는 값을 넣어주면 해당 값이 변할때만 실행된다.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;completed render&quot;, name);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      console.log(&quot;unmount&quot;, name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name]);</span><br></pre></td></tr></table></figure><ul><li>return 함수는 렌더링이 될때마다 실행되는 함수이다. name을 확인해보면 변경되기 이전의 값이 찍히는것을 확인할 수 있다.</li><li>두번째 파라미터에 빈 배열을 담아서 실행하면 unmount 될때만 return 함수가 실행된다.</li></ul><h2 id="Promise-처리"><a href="#Promise-처리" class="headerlink" title="Promise 처리"></a>Promise 처리</h2><p>useEffect와 useState를 사용하여 promise 컴포넌트 또한 재사용이 가능하도록 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const usePromise = (&#123; promise, initialData, arr &#125;) =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState(initialData);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(false);</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    try &#123;</span><br><span class="line">      const result = await promise();</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      setError(true);</span><br><span class="line">    &#125;</span><br><span class="line">    setLoading(false);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, arr || []);</span><br><span class="line"></span><br><span class="line">  return &#123; data, loading, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getNames = async () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt;</span><br><span class="line">    setTimeout(() =&gt; resolve([&#123; name: &quot;kkangil&quot; &#125;, &#123; name: &quot;kkangil2&quot; &#125;]), 1000)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Names = () =&gt; &#123;</span><br><span class="line">  const &#123; data: names, loading, error &#125; = usePromise(&#123;</span><br><span class="line">    promise: getNames,</span><br><span class="line">    initialData: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (loading) return &lt;div&gt;로딩중...&lt;/div&gt;;</span><br><span class="line">  if (error) return &lt;div&gt;에러&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;names.map((row, index) =&gt; (</span><br><span class="line">        &lt;div key=&#123;index&#125;&gt;&#123;row.name&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="usePromise"><a href="#usePromise" class="headerlink" title="usePromise"></a>usePromise</h3><ul><li>파라미터로 호출해야하는 <code>promise</code> 함수, 최초 초기화 데이터 <code>initialData</code>, useEffect 함수 2번째 파라미터 배열 <code>arr</code>을 객체로 받는다.</li><li><code>useEffect</code> 함수에서 async/await을 사용하면 warning이 발생한다. 그렇기 때문에 async/await 함수를 따로 만들어 해당 함수를 useEffect에서 실행 시켜준다.</li></ul><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><ul><li>initialData에 빈배열을 넣어주지 않으면 return의 <code>names.map</code> 에서 에러가 발생한다. 해당 에러를 막기 위해 빈 배열로 초기화해줬다. <code>names</code> 값이 존재할때만 map 을 사용하는 방법도 있지만, 추후 재사용을 위해 데이터 초기값을 설정해줄 수 있도록 했다.</li></ul><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>useContext는 함수형 컴포넌트에서 Context를 쉽게 사용할 수 있게 해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const backgroundColorContext = createContext(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">const Context = () =&gt; &#123;</span><br><span class="line">  const backgroundColor = useContext(backgroundColorContext);</span><br><span class="line">  const style = &#123;</span><br><span class="line">    width: &quot;50px&quot;,</span><br><span class="line">    height: &quot;50px&quot;,</span><br><span class="line">    borderRadius: &quot;50%&quot;,</span><br><span class="line">    background: backgroundColor</span><br><span class="line">  &#125;;</span><br><span class="line">  return &lt;div style=&#123;style&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Context;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useState&quot;&gt;&lt;a href=&quot;#useState&quot; class=&quot;headerlink&quot; title=&quot;useState&quot;&gt;&lt;/a&gt;useState&lt;/h2&gt;&lt;h3 id=&quot;사용방법&quot;&gt;&lt;a href=&quot;#사용방법&quot; class=&quot;headerlink&quot; title=&quot;사용방법&quot;&gt;&lt;/a&gt;사용방법&lt;/h3&gt;&lt;p&gt;useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 사용방법" scheme="https://kkangil.github.io/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"/>
    
      <category term="useState" scheme="https://kkangil.github.io/tags/useState/"/>
    
      <category term="useEffect" scheme="https://kkangil.github.io/tags/useEffect/"/>
    
      <category term="useContext" scheme="https://kkangil.github.io/tags/useContext/"/>
    
  </entry>
  
  <entry>
    <title>리액트 Hooks: 1. hooks 란?</title>
    <link href="https://kkangil.github.io/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-1-hooks-%EB%9E%80/"/>
    <id>https://kkangil.github.io/2019/04/19/리액트-Hooks-1-hooks-란/</id>
    <published>2019-04-19T03:48:12.000Z</published>
    <updated>2019-04-19T03:52:29.003Z</updated>
    
    <content type="html"><![CDATA[<p>리액트 16.8 버전에서 <code>Hooks</code> 라는 새로운 기능이 추가 되었다.<br>해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.<br>이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.</p><a id="more"></a><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-intro.html</a></p><h2 id="Hooks-특징"><a href="#Hooks-특징" class="headerlink" title="Hooks 특징"></a>Hooks 특징</h2><ul><li>현재 진행중인 프로젝트가 있다면 코드를 다시 짜지 않아도, 바로 사용할 수 있다. </li><li>어떠한 변화 없이 기능이 추가 되었기 때문에 이전 버전과의 호환성이 100%이다.</li><li>16.8.0 이후 버전에서 사용가능하다.</li></ul><blockquote><p>Hooks로 class를 대신할 수 있게됐지만, 리액트는 class를 제거할 계획이 없다고 밝혔다. 리액트에 대한 여러가지 컨셉(props, state, context, refs, and lifecycle)을 대체할 수 없는 대신, 더욱 직관적으로 제공한다고 한다.</p></blockquote><h2 id="Hooks가-나오게된-배경"><a href="#Hooks가-나오게된-배경" class="headerlink" title="Hooks가 나오게된 배경"></a>Hooks가 나오게된 배경</h2><h3 id="Component-사이에서-stateful-한-로직의-재사용이-어렵다"><a href="#Component-사이에서-stateful-한-로직의-재사용이-어렵다" class="headerlink" title="Component 사이에서 stateful 한 로직의 재사용이 어렵다."></a>Component 사이에서 stateful 한 로직의 재사용이 어렵다.</h3><ul><li>리액트는 컴포넌트에 재활용하는 방법인 “attach” 방법을 제공하지 않는다.</li><li>이런 문제들을 해결하기 위해 다양한 패턴이 사용되었다. (render propr, HOC …) 이런 패턴을 사용했을 때, 재구조화를 해야하고 이는 번거롭고 어려워질 수 있다. 또한 이런 패턴을 <code>DevTools</code> 에서 확인해 보면 wrapper 지옥에 빠져있는 수많은 컴포넌트를 볼 수 있다.</li><li>Hooks 는 컴포넌트로 부터 stateful 한 로직을 추출해 낼 수 있으며 이것은 의존성과 재사용성을 테스트할 수 있다. </li></ul><h3 id="이해하기-어려운-복잡한-컴포넌트"><a href="#이해하기-어려운-복잡한-컴포넌트" class="headerlink" title="이해하기 어려운 복잡한 컴포넌트"></a>이해하기 어려운 복잡한 컴포넌트</h3><ul><li>처음은 가벼운 컴포넌트였지만, 개발을 진행하다보면 수많은 side effects와 stateful 로직이 걷잡을 수 없이 많아진다.</li><li>각각의 라이프 사이클은 자주 연관성이 없는 로직을 섞어 사용하곤 한다. 예를 들어 컴포넌트는 <code>componentDidMount</code>와 <code>componentDidUpdate</code> 라이프사이클에서 데이터를 fetch 할 수 있다. 하지만 몇몇 <code>componentDidMount</code> 메소드는 이벤트를 설정하는 데 연관 없는 로직 들을 포함할 수 있으며 <code>componentWillUnmount</code>는 cleanup을 수행할 수도 있다. 함께 변경되는 관련 코드는 분리되지만 연관 없는 코드들은 단일 메소드로 결합한다. 이것은 버그와 무결성을 쉽게 발생시킨다.</li><li>많은 경우 컴포넌트들을 작게 만드는 것은 불가능하다. stateful 로직은 모든곳에 있기 때문이다. 또한 이것은 테스트하는 것도 어렵다. 이것이 사람들이 state 를 관리하는 라이브러리를 함께 사용하는것을 선호하는 이유중 하나이다. 그러나 너무 추상적이라고 소개하고 다른 파일 사이를 건너뛰는것을 요구하며 컴포넌트 재사용을 더욱 어렵게 만든다.</li><li>이러한 이슈들을 해결하기 위해 Hooks는 라이프사이클 메소드를 기초로한 분리에 초점을 맞추는 것보다는 컴포넌트들을 연관성을 기초로 더 작은 함수로 분리할 수 있게 한다.</li></ul><h3 id="사람과-기계를-혼란시키는-Classes"><a href="#사람과-기계를-혼란시키는-Classes" class="headerlink" title="사람과 기계를 혼란시키는 Classes"></a>사람과 기계를 혼란시키는 Classes</h3><ul><li>코드를 재사용성과 구조적으로 만드는 것은 어려울뿐만 아니라 리액트를 배울때 classes는 큰 진입장벽이다. 다른 대부분의 언어들과는 다른 Javascript가 어떻게 동작하는지 이해하고 있어야한다. 이벤트 핸들러는 항상 바인딩이 되어야 하는것을 기억해야 한다. 안정적인 문법의 제안이 없다면, 코드는 매우 장황해진다.</li><li>사람들은 props, state, 단방향 데이터 흐름에 대해 이해하고 있지만 여전히 classes는 어려워한다.</li><li>이러한 문제를 해결하기 위해서 Hooks는 classes 없이 리액트의 특징들을 사용할 수 있게 해준다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;리액트 16.8 버전에서 &lt;code&gt;Hooks&lt;/code&gt; 라는 새로운 기능이 추가 되었다.&lt;br&gt;해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.&lt;br&gt;이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다.&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React-Hooks" scheme="https://kkangil.github.io/tags/React-Hooks/"/>
    
      <category term="Hooks" scheme="https://kkangil.github.io/tags/Hooks/"/>
    
      <category term="hooks 정의" scheme="https://kkangil.github.io/tags/hooks-%EC%A0%95%EC%9D%98/"/>
    
  </entry>
  
  <entry>
    <title>Next.js with pm2 ecosystem</title>
    <link href="https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/"/>
    <id>https://kkangil.github.io/2019/04/18/Next-js-with-pm2-ecosystem/</id>
    <published>2019-04-17T15:29:19.000Z</published>
    <updated>2019-04-17T15:47:37.770Z</updated>
    
    <content type="html"><![CDATA[<p><code>Next.js</code>는 Client-Side-Rendering 을 사용하는 react가 아닌 <code>SSR(Server-Side-Rendering)</code> 방식을 사용하는 react framework 이다.<br>해당 글은 <code>Next.js</code>에서 배포시 참고하면 좋을 내용으로 <code>Next.js</code>가 뿐만 아니라 react, Node 에서도 사용 가능하다.</p><a id="more"></a><h2 id="pm2-ecosystem"><a href="#pm2-ecosystem" class="headerlink" title="pm2 ecosystem"></a>pm2 ecosystem</h2><p>pm2 ecosystem이란, 실행할 인스턴스의 설정을 JSON 형식으로 관리할 수 있고, pm2 에서 제공해 주는 option 을 보다 쉽게 관리 할수 있도록 도와준다. pm2 명령어로 직접 실행시킬 수 있지만, ecosystem을 사용함으로써 어떤 서버나 환경에서도 같은 설정을 사용해서 서버를 실행할 수 있다는 점이 장점이다.</p><ol><li>ecosystem.config.js 를 최상위 폴더에 생성한다.</li><li>작성방법</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  apps: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;chungeoram&quot;,</span><br><span class="line">      script: &quot;./server.js&quot;,</span><br><span class="line">      watch: true,</span><br><span class="line">      interpreter: &apos;/home/ubuntu/.nvm/versions/node/v8.11.3/bin/node&apos;,</span><br><span class="line">      &quot;env_public-develop&quot;: &#123;</span><br><span class="line">        NODE_ENV: &quot;public-develop&quot;,</span><br><span class="line">        PORT: 1111,</span><br><span class="line">        API_END_POINT: &apos;http://endpoint/api&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      env_production: &#123;</span><br><span class="line">        NODE_ENV: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name: pm2 에서 관리하는 이름</li><li>script: 앱을 구동할 경로</li><li>watch: 파일이 변경되면 자동으로 재시작 유무</li><li>ignore_watch: 배열안에 있는 리스트는 watch 대상에서 무시한다.</li><li>exec_mode: 클러스터 모드로 구동instances: 클러스터로 구동될시 몇개까지 구동할것인지 선택(0 : cpu갯수)</li><li>merge_logs: 클러스터로 구동할시 로그를 한파일에 기록</li><li>interpreter: 해석기 절대 경로(default: node)</li><li>log_date_format: 로그에 출력될 날짜와 시간값의 형식</li><li>error_file: 에러 파일 위치</li><li>out_file: 기본 출력 로그 위치</li><li>env_{value}<ul><li>value는 <code>process.env.NODE_ENV</code> 값과 매칭된다. 예를 들어 현재 <code>process.env.NODE_ENV</code>가 <code>public-develop</code> 일때, <code>env_public-develop</code> 내부의 값이 사용된다. 내부의 값들은 <code>process.env</code> 객체 내로 값이 할당되며, <code>process.env.PORT</code> , <code>process.env.API_END_POINT</code> 로 값을 배포 환경의 따라 다르게 사용가능하다.</li></ul></li></ul><ol start="3"><li>pm2 구동방법<br>package.json script에 명령어를 추가해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;precommit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;pm2 start ecosystem.config.js --env production&quot;,</span><br><span class="line">    &quot;start-public&quot;: &quot;pm2 start ecosystem.config.js --env public-develop&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon server.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>$ yarn build → $ yarn start</li><li>app 빌드 후 명령어를 사용해서, pm2를 구동시켜 준다. pm2 start {파일이름} –env {value} 와 같은 형식으로 명령어를 추가한다. 여기서 환경변수는 ecosystem.config.js 의 env_{value}와 매칭 된다.</li></ul><h2 id="Next-js-에서-process-env-변수-사용-주의사항"><a href="#Next-js-에서-process-env-변수-사용-주의사항" class="headerlink" title="Next.js 에서 process.env 변수 사용 주의사항"></a>Next.js 에서 process.env 변수 사용 주의사항</h2><p><code>Next.config.js</code> 에서 <code>sass</code>, <code>webpack</code> 등의 처리 후 export 하는 과정에서, process.env 객체가 비어있는 문제를 발견했다. 하지만, api.js config.js 등 환경 변수에 따라 값을 변경해줘야 하기 때문에 process.env 객체가 비어있으면 안된다. 해당 문제를 처리하기 위해 Next.js 에서 <code>publicRuntimeConfig</code> 라는 옵션을 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const withSass = require(&apos;@zeit/next-sass&apos;)</span><br><span class="line">const withCSS = require(&apos;@zeit/next-css&apos;)</span><br><span class="line"></span><br><span class="line">const publicRuntimeConfig = &#123;</span><br><span class="line">  API_END_POINT: process.env.API_END_POINT,</span><br><span class="line">  NODE_ENV: process.env.NODE_ENV,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = withCSS(withSass(&#123;</span><br><span class="line">  publicRuntimeConfig,</span><br><span class="line">  webpack: config =&gt; &#123;</span><br><span class="line">    // Fixes npm packages that depend on `fs` module</span><br><span class="line">    config.node = &#123;</span><br><span class="line">      fs: &apos;empty&apos;,</span><br><span class="line">      module: &apos;empty&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return config</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>필요한 process.env 의 값을 <code>publicRuntimeConfig</code> 객체에 담아주고 Next.js 의 옵션 값에 할당해준다.할당해 주게되면, Next.js 의 config 값으로 저장되게 된다.이후 Next.js의 config 값을 불러오는 함수를 추가해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import getConfig from &apos;next/config&apos;;</span><br><span class="line"></span><br><span class="line">export const getNodeEnv = () =&gt; &#123;</span><br><span class="line">  const &#123; publicRuntimeConfig &#125; = getConfig();</span><br><span class="line"></span><br><span class="line">  const realNodeEnv = publicRuntimeConfig.NODE_ENV || process.env.NODE_ENV;</span><br><span class="line">  const apiEndPoint = publicRuntimeConfig.API_END_POINT;</span><br><span class="line"></span><br><span class="line">  return &#123; realNodeEnv, apiEndPoint &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>해당 함수는 Next.js의 config에서 publicRuntimeConfig 를 가져와 return 해준다.이제 process.env 환경변수를 사용하고 싶다면, process.env.API_END_POINT 와 같이 직접적으로 사용하는것이 아닌, 해당 함수를 사용해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import config from &apos;./config&apos;</span><br><span class="line">import &#123; getNodeEnv &#125; from &apos;@/utils/env&apos;</span><br><span class="line"></span><br><span class="line">const env = getNodeEnv()</span><br><span class="line">const endPoint = env.apiEndPoint || config.apiEndPoint</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  AUTH_TOKEN: &#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    path: () =&gt; `$&#123;endPoint&#125;/auth/authenticate-token`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Next.js&lt;/code&gt;는 Client-Side-Rendering 을 사용하는 react가 아닌 &lt;code&gt;SSR(Server-Side-Rendering)&lt;/code&gt; 방식을 사용하는 react framework 이다.&lt;br&gt;해당 글은 &lt;code&gt;Next.js&lt;/code&gt;에서 배포시 참고하면 좋을 내용으로 &lt;code&gt;Next.js&lt;/code&gt;가 뿐만 아니라 react, Node 에서도 사용 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="Deploy" scheme="https://kkangil.github.io/categories/Deploy/"/>
    
    
      <category term="Next.js" scheme="https://kkangil.github.io/tags/Next-js/"/>
    
      <category term="deploy Next.js" scheme="https://kkangil.github.io/tags/deploy-Next-js/"/>
    
      <category term="pm2" scheme="https://kkangil.github.io/tags/pm2/"/>
    
      <category term="pm2-ecosystem" scheme="https://kkangil.github.io/tags/pm2-ecosystem/"/>
    
  </entry>
  
  <entry>
    <title>Deep clone</title>
    <link href="https://kkangil.github.io/2019/04/18/Deep-clone/"/>
    <id>https://kkangil.github.io/2019/04/18/Deep-clone/</id>
    <published>2019-04-17T15:01:31.000Z</published>
    <updated>2019-04-17T15:35:10.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a>이슈</h2><ol><li>react에서 setState를 하지 않았음에도 state가 변경되는 현상</li><li>api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상</li></ol><p>react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.<br>해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.<br>해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; a: 1, b: 2 &#125;</span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state = &#123;...this.state&#125;;</span><br><span class="line">  state[e.target.name] = e.target.value;</span><br><span class="line">  this.setState(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 본인이 input 의 onChange 이벤트 함수로 거의 복붙하면서 변형없이 사용하는 이벤트 함수이다.<br>최근 state 변수 선언 즉, state 객체를 복사하고 사용하는 과정에 있어 동일한 이슈가 많이 발생하고 있어, 해당 함수를 단순히 복사하는것이 아닌 이해가 필요하고 상황에 따라 변형해서 사용해야할 필요있다.</p><h2 id="Object-copy"><a href="#Object-copy" class="headerlink" title="Object copy"></a>Object copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;...this.state&#125;</span><br></pre></td></tr></table></figure><p>state 변수는 react state 객체를 복사한것이다. 해당 문법은 es9 문법으로 특정 값만 바꿀때 유용하다.<br>해당 문법의 es5 버전은 .assign() 메소드이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;&#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object3 = Object.assign(&#123; c: 3 &#125;, object1, &#123;a: 100&#125;);</span><br><span class="line">const object4 = Object.assign(&#123;&#125;, object1);</span><br><span class="line">object4.a = 100</span><br><span class="line"></span><br><span class="line">const object5 = &#123;...object1&#125;</span><br><span class="line">object5.a = 100</span><br><span class="line"></span><br><span class="line">console.log(object2.a); //100</span><br><span class="line">console.log(object2.b); //2</span><br><span class="line">console.log(object3.a); //100</span><br><span class="line">console.log(object3.b); //2</span><br><span class="line">console.log(object3.c); //3</span><br><span class="line">console.log(object4.a); //100</span><br><span class="line">console.log(object5.a); //100</span><br></pre></td></tr></table></figure><ul><li>object2 : 빈 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object3: c: 3 값이 담겨있는 객체에 object1을 복사한 후 a 의 값을 변경</li><li>object4: 현재 우리 회사에서 사용하는 handleChange를 es5로 바꾼 방법</li><li>object5: Spread syntax(…) es8 문법사용<br>하지만 state 내부에 객체를 변경하려고 할때 문제가 발생한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleChange = e =&gt; &#123;</span><br><span class="line">  const state &#123;...this.state&#125;</span><br><span class="line">  state.b.c = 3</span><br><span class="line">  this.setState(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2단계 이상 깊이의 object는 복사가 원활하지 않는것을 확인할 수 있다. 복사본의 값을 변경했는데 원본의 값도 변경되는 알수 없는 현상이 발생한다.<br>MDN: 깊은 클로닝에 대해서, Object.assign() 은 속성의 값을 복사하기때문에 다른 대안을 사용해야합니다. 출처 값이 객체에 대한 참조인 경우, 참조 값만을 복사합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(&#123;&#125;, org);</span><br><span class="line">obj.a.b = 100; </span><br><span class="line">console.log(obj.a.b);  //expected: 2 but actual: 100</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;...org&#125;;</span><br><span class="line">obj2.a.b = 100; </span><br><span class="line">console.log(org.a.b);  //expected: 2 but actual: 100</span><br></pre></td></tr></table></figure><p>해당 현상은 깊은 클로닝(deep cloning) 방식을 사용해야한다.<br>객체 복사 방식 변경 : 객체를 string 으로 변경하고 다시 파싱해주는 방법</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = JSON.parse(JSON.stringify(org)); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br><span class="line">lodash 메소드 사용</span><br><span class="line">import _ from &apos;lodash&apos;; const org = &#123; a : &#123;b : 2&#125;&#125;;</span><br><span class="line">const obj = _.cloneDeep(org); obj.a.b = 100;</span><br><span class="line">console.log(org.a.b); // 2</span><br></pre></td></tr></table></figure><h2 id="Array-copy"><a href="#Array-copy" class="headerlink" title="Array copy"></a>Array copy</h2><p>2단계 이상 깊이의 배열을 복사할때는 맵을 사용해서 객체 하나하나 복사해준 후 return 해주는 방식을 사용해서 에러발생을 막아야합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const org = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    a: [&#123;</span><br><span class="line">      b: 1</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">      b: 2</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj1 = &#123;...org&#125;</span><br><span class="line">const arr = org.obj.a // x</span><br><span class="line"></span><br><span class="line">const arr2 = org.obj.a.map(row =&gt; &#123;</span><br><span class="line">return &#123;...row&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>참고<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;이슈&quot;&gt;&lt;a href=&quot;#이슈&quot; class=&quot;headerlink&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;이슈&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;react에서 setState를 하지 않았음에도 state가 변경되는 현상&lt;/li&gt;
&lt;li&gt;api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.&lt;br&gt;해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.&lt;br&gt;해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다.&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://kkangil.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://kkangil.github.io/tags/Javascript/"/>
    
      <category term="syntax" scheme="https://kkangil.github.io/tags/syntax/"/>
    
      <category term="deep-clone" scheme="https://kkangil.github.io/tags/deep-clone/"/>
    
  </entry>
  
  <entry>
    <title>리액트 라이프사이클</title>
    <link href="https://kkangil.github.io/2019/04/17/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/"/>
    <id>https://kkangil.github.io/2019/04/17/리액트-라이프사이클/</id>
    <published>2019-04-17T14:48:33.000Z</published>
    <updated>2019-04-17T15:34:52.842Z</updated>
    
    <content type="html"><![CDATA[<p>React를 사용하기 전 <code>라이프사이클</code>에 대해 확실하게 알고 사용하는 것이 좋다.<br><code>라이프사이클</code> 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.<br>github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.<a href="https://github.com/kkangil/react-lifecycle" target="_blank" rel="noopener">code 보기</a></p><a id="more"></a><h2 id="주요-라이프사이클"><a href="#주요-라이프사이클" class="headerlink" title="주요 라이프사이클"></a>주요 라이프사이클</h2><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><ul><li>렌더가 된 이후 실행되는 라이프사이클로 최초 API 요청 사용에 적합한 라이프 사이클</li></ul><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><ul><li>component 의 상태값이 변경되었을때 render 직전에 호출되는 라이프 사이클</li><li>Boolean 값을 return 해야하며, false 를 return 하면 렌더를 하지 않음.</li><li>렌더를 하지 않으므로 이후 라이프사이클도 먹히지 않음.</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><ul><li>component가 DOM 에서 삭제(해당 컴포넌트 미표시)할때 마지막으로 실행되는 메소드</li><li>interval 이나 비동기 API 제거에 주로 쓰임.</li></ul><h2 id="16-3-이후-변경된-라이프사이클"><a href="#16-3-이후-변경된-라이프사이클" class="headerlink" title="16.3 이후 변경된 라이프사이클"></a>16.3 이후 변경된 라이프사이클</h2><ul><li>렌더링 제어에 많은 방법이 있기때문에 라이프사이클 사용에 혼란이 생김.</li><li>실제 커뮤니티에서도 어떤 라이프사이클이 좋다 안좋다 성능 이슈가 많음. 대표적으로 componentWillMount 와 componentDidMount 둘중 어떤 라이프사이클에서 API를 호출해야하는지.</li><li>향후 componentWillMount, componentWillReceiveProps, componentWillUpdate 라이프사이클이 삭제되고 <code>UNSAFE_</code> 라이프사이클만 동작할것이라고 예고</li><li>이를 대체하기 위해 새로운 라이프사이클 추가</li></ul><h3 id="라이프사이클-동작-순서"><a href="#라이프사이클-동작-순서" class="headerlink" title="라이프사이클 동작 순서"></a>라이프사이클 동작 순서</h3><ul><li>최초 진입: <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code> 순으로 실행.</li><li>props 변경: <code>getDerivedStateFromProps</code> -&gt; <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li><li>state 변경: <code>shouldComponentUpdate</code> -&gt; <code>render</code> -&gt; <code>getSnapshotBeforeUpdate</code> -&gt; <code>componentDidUpdate</code> 순으로 실행</li></ul><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><ul><li>componentDidMount 보다 먼저 실행</li><li>window 객체 접근 가능(storage 사용 가능)</li><li>props 와 state가 변경되었을때는 최초 실행</li><li>파리미터로 변경될 props 와 state가 넘어옴. this.state 접근 불가능</li><li>return 되는 객체값으로 state 가 변경된다. (해당 라이프사이클에서는 state 변경만 해주는것이 바람직하다고 판단됨.) state를 변경해주고 싶지 않을때에는 null 을 return 해주면된다.</li><li>최초 페이지 진입시 <code>componentDidMount</code> 라이프사이클에서 fetch 실행</li><li>react 공식문서에서는 props 가 변경되었을때 fetch가 필요하다면 해당 라이프사이클에서 API(data fetching) 요청 하는것이 아닌 <code>componentDidUpdate</code> 라이프 사이클에서 fetch 하도록 유도하고 있음.</li></ul><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><ul><li><code>componentWillUpdate</code> 의 대체 라이프사이클</li><li>DOM이 업데이트 되기 직전이 실행</li><li><code>componentDidUpdate</code> 전에 실행되며 해당 라이프사이클의 return 값이 componentDidUpdate 3번째 파라미터로 전달됨.</li><li>기존 <code>componentWillUpdate</code> 와 같이 해당 라이프사이클 안에서 this.setState()를 사용하는 경우 무한루프에 빠지게 됨.</li><li>자주 사용되지는 않을것으로 판단됨.</li></ul><h2 id="Error-Boundary"><a href="#Error-Boundary" class="headerlink" title="Error Boundary"></a>Error Boundary</h2><ul><li>렌더 과정에서 에러가 생겼을경우 앱이 죽는것이 아니라 UI 변경과 같은 대안으로 앱이 죽지 않도록 하는 방식</li><li>해당 class를 최상단에 두고 라이프사이클을 이용해서 조작할 수 있다.</li></ul><h3 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError"></a>getDerivedStateFromError</h3><ul><li>16.6 버전에 추가된 라이프 사이클</li><li>해당 라이프 사이클은 렌더 중에 호출되며 fallback UI를 렌더링 하기 위한 메소드이다.</li><li>렌더 중에 호출되기 때문에 side effect(API call, 함수 호출) 을 사용하지 않는것이 좋다.</li><li>react 공식 문서에서는 componentDidCatch 라이프 사이클을 추천한다.</li><li>return 객체는 state 가 해당 객체로 변경된다.</li></ul><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><ul><li>해당 라이프사이클은 에러를 기록하거나 트래킹하기 위한 작업을 위해 주로 사용된다. (ex Sentry)</li><li>해당 라이프 사이클에서도 state 를 변경하여 UI 를 변경해줄수 있지만 추천되지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React를 사용하기 전 &lt;code&gt;라이프사이클&lt;/code&gt;에 대해 확실하게 알고 사용하는 것이 좋다.&lt;br&gt;&lt;code&gt;라이프사이클&lt;/code&gt; 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.&lt;br&gt;github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.&lt;a href=&quot;https://github.com/kkangil/react-lifecycle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code 보기&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://kkangil.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://kkangil.github.io/tags/React/"/>
    
      <category term="lifecycle" scheme="https://kkangil.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kkangil.github.io/2019/04/17/hello-world/"/>
    <id>https://kkangil.github.io/2019/04/17/hello-world/</id>
    <published>2019-04-17T11:51:34.545Z</published>
    <updated>2019-04-17T15:35:24.643Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><table><thead><tr><th>설정</th><th>설명</th><th>기본 값</th></tr></thead><tbody><tr><td>layout</td><td>레이아웃</td><td></td></tr><tr><td>title</td><td>타이틀</td><td></td></tr><tr><td>date</td><td>발행일</td><td>파일이 생성된 날짜</td></tr><tr><td>updated</td><td>갱신일</td><td>파일이 업로드된 날짜</td></tr><tr><td>tags</td><td>태그 (page에서는 사용 불가능)</td><td></td></tr><tr><td>categories</td><td>카테고리 (page에서는 사용 불가능)</td><td></td></tr><tr><td>permalink</td><td>포스트의 기본 permalink를 override합니다.</td><td></td></tr><tr><td>comments</td><td>포스트에서 comment 기능을 사용할지 여부</td><td>true</td></tr></tbody></table><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://kkangil.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://kkangil.github.io/tags/hexo/"/>
    
      <category term="hexo 시작" scheme="https://kkangil.github.io/tags/hexo-%EC%8B%9C%EC%9E%91/"/>
    
  </entry>
  
</feed>
