<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kkangil&#39;s Blog</title>
    <link>https://kkangil.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>공부와 유익한 개발 정보들을 기록하기 위한 블로그입니다.</description>
    <pubDate>Sun, 07 Jun 2020 06:46:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Canvas의 기초-3</title>
      <link>https://kkangil.github.io/2020/06/07/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-3/</link>
      <guid>https://kkangil.github.io/2020/06/07/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-3/</guid>
      <pubDate>Sun, 07 Jun 2020 04:55:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 글에 이어서 canvas 의 기초에 대해 더 알아보려한다. 이번 포스트에는 애니메이션, 이벤트에 대해서 알아본다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이전 글에 이어서 canvas 의 기초에 대해 더 알아보려한다. 이번 포스트에는 애니메이션, 이벤트에 대해서 알아본다.</p><a id="more"></a><h2 id="애니메이션-만들기"><a href="#애니메이션-만들기" class="headerlink" title="애니메이션 만들기"></a>애니메이션 만들기</h2><p>캔버스 화면에서 이미지가 움직이는 애니메이션을 만드는 방법을 알아보려한다. setInterval 함수를 사용해서 구현해본다.</p><h3 id="사각형을-x-축으로-왼쪽에서-오른쪽으로-움직이기"><a href="#사각형을-x-축으로-왼쪽에서-오른쪽으로-움직이기" class="headerlink" title="사각형을 x 축으로 왼쪽에서 오른쪽으로 움직이기"></a>사각형을 x 축으로 왼쪽에서 오른쪽으로 움직이기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> ctxWidth = canvas.width;</span><br><span class="line"><span class="keyword">var</span> ctxHeight = canvas.height;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, ctxWidth, ctxHeight);</span><br><span class="line">    ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">    ctx.fillRect(x, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-animation1.png" alt="사각형을 x축으로 이동"></p><p>interval 에서 제일 먼저 <code>clearRect</code> 를 사용하여 캔버스를 깨끗이 지워줘야 한다. 이 부분이 없으면 빨간색 선이<br>그려진다.</p><h3 id="두개의-사각형을-만들고-애니메이션을-멈추게-하기"><a href="#두개의-사각형을-만들고-애니메이션을-멈추게-하기" class="headerlink" title="두개의 사각형을 만들고 애니메이션을 멈추게 하기"></a>두개의 사각형을 만들고 애니메이션을 멈추게 하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> ctxWidth = canvas.width;</span><br><span class="line"><span class="keyword">var</span> ctxHeight = canvas.height;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, ctxWidth, ctxHeight);</span><br><span class="line">    ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">    ctx.fillRect(x, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">10</span>, y, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    x++;</span><br><span class="line">    y++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 영역 제한</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; ctxWidth) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; ctxHeight) &#123;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(animateInterval);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>조건을 추가하여 x,y 값이 canvas 의 넓이, 높이값 보다 클 경우 0 으로 초기화 시켜준다.</li><li>canvas 에 이벤트를 추가하여 클릭했을때 애니메이션이 멈추게 했다.</li></ul><p><img src="/images/canvas-animation2.png" alt="사각형을 x, y축으로 이동"></p><h2 id="클릭한-곳에-사각형-그리기"><a href="#클릭한-곳에-사각형-그리기" class="headerlink" title="클릭한 곳에 사각형 그리기"></a>클릭한 곳에 사각형 그리기</h2><p>여기서부터는 게임을 만드는 것의 기본을 간단한 소스를 통해 확인해 본다. </p><p>마우스를 클릭한 곳으로 이동한다든지, 마우스를 클릭한 곳에 건물을 지을때 자주 볼 수 있다. 먼저 캔버스 위에<br>마우스로 클릭한 곳의 좌표를 얻어, 그 곳에 사각형을 그리는 것을 확인해 보자.</p><h3 id="마우스로-클릭한-곳의-좌표-얻기"><a href="#마우스로-클릭한-곳의-좌표-얻기" class="headerlink" title="마우스로 클릭한 곳의 좌표 얻기"></a>마우스로 클릭한 곳의 좌표 얻기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mouseX = e.clientX;</span><br><span class="line">    <span class="keyword">var</span> mouseY = e.clientY;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`x: <span class="subst">$&#123;mouseX&#125;</span> / y: <span class="subst">$&#123;mouseY&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-clickXY.png" alt="클릭한 곳의 x, y, 좌표"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mouseX = e.clientX - ctx.canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> mouseY = e.clientY - ctx.canvas.offsetTop;</span><br><span class="line">    ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">    <span class="comment">// 마우스 클릭한 곳에서 사각형의 중심이 되어 생성</span></span><br><span class="line">    ctx.fillRect(mouseX - <span class="number">10</span>, mouseY - <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-clickRect.png" alt="클릭한 곳에 사각형 그리기"></p><h2 id="백그라운드-이미지-애니메이션-만들기"><a href="#백그라운드-이미지-애니메이션-만들기" class="headerlink" title="백그라운드 이미지 애니메이션 만들기"></a>백그라운드 이미지 애니메이션 만들기</h2><p>이미지 애니메이션을 만들어보자. 스크롤 게임이나 기타 여러 게임에서 배경의 움직임은 공간을 넓게 쓰는 효과를<br>주기 위해 사용하는 방법이다.</p><h3 id="이미지-애니메이션-만들기"><a href="#이미지-애니메이션-만들기" class="headerlink" title="이미지 애니메이션 만들기"></a>이미지 애니메이션 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> bgImages = <span class="keyword">new</span> Image();</span><br><span class="line">bgImages.src = <span class="string">'images/space.png'</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(bgImages, x-- ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">-600</span>) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-movingImage.png" alt="이미지 애니메이션"></p><ul><li>위 이미지는 넓이가 1200px 이다. 이미지가 절반 지나갔을 때 x 좌표값을 초기화 한다.</li></ul><h2 id="이미지를-키보드로-움직이기"><a href="#이미지를-키보드로-움직이기" class="headerlink" title="이미지를 키보드로 움직이기"></a>이미지를 키보드로 움직이기</h2><h3 id="위-배경에-이어서-비행기-만들어보기"><a href="#위-배경에-이어서-비행기-만들어보기" class="headerlink" title="위 배경에 이어서 비행기 만들어보기"></a>위 배경에 이어서 비행기 만들어보기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.src = <span class="string">'images/space.png'</span>;</span><br><span class="line"><span class="keyword">var</span> fighterImage = <span class="keyword">new</span> Image();</span><br><span class="line">fighterImage.src = <span class="string">'images/fighter.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Background</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = bgImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = bgImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(bgImage, <span class="keyword">this</span>.x--, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">-600</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = fighterImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = fighterImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(fighterImage, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> background = <span class="keyword">new</span> Background();</span><br><span class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.x = <span class="number">30</span>;</span><br><span class="line">player.y = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    background.render();</span><br><span class="line">    player.render();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-fighter1.png" alt="배경과 비행기"></p><ul><li>배경 움직이는 소스(Background) 비행기 그리는 소스(Player) 로 만들어 render 함수로 그려준다.</li></ul><h3 id="키보드를-눌렀을-때-비행기가-움직이도록-하기"><a href="#키보드를-눌렀을-때-비행기가-움직이도록-하기" class="headerlink" title="키보드를 눌렀을 때 비행기가 움직이도록 하기"></a>키보드를 눌렀을 때 비행기가 움직이도록 하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.src = <span class="string">'images/space.png'</span>;</span><br><span class="line"><span class="keyword">var</span> fighterImage = <span class="keyword">new</span> Image();</span><br><span class="line">fighterImage.src = <span class="string">'images/fighter.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> speed = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> keyCodeValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Background</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = bgImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = bgImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(bgImage, <span class="keyword">this</span>.x--, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">-600</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.w = fighterImage.width;</span><br><span class="line">    <span class="keyword">this</span>.h = fighterImage.height;</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(fighterImage, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> background = <span class="keyword">new</span> Background();</span><br><span class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Player();</span><br><span class="line">player.x = <span class="number">30</span>;</span><br><span class="line">player.y = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// animate 함수에서 매 시간당 업데이트 되는 것을 체크한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (keyCodeValue) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">            player.y -= speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">            player.y += speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">            player.x -= speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            player.x += speed;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    background.render();</span><br><span class="line">    player.render();</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animateInterval = setInterval(animate, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 키보드를 클릭하였을때 반응</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'keydown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 키보드의 키값을 가져온다.</span></span><br><span class="line">    keyCodeValue = <span class="built_in">String</span>.fromCharCode(e.keyCode);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 키보드 해제</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    keyCodeValue = <span class="string">''</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-fighter2.png" alt="움직이는 비행기"></p><ul><li>비행기가 화면에서 움직일 속도를 speed 변수로 선언한다.</li><li>update 함수를 실행하는 동안에 키보드를 누르면 wasd 키를 확인하여 비행기의 좌표값에 속도를 더해서 변경한다.</li></ul><h2 id="JSON-객체와-배열-처리하기"><a href="#JSON-객체와-배열-처리하기" class="headerlink" title="JSON 객체와 배열 처리하기"></a>JSON 객체와 배열 처리하기</h2><h3 id="JSON-객체를-배열로-처리하여-사각형을-캔버스에-그리기"><a href="#JSON-객체를-배열로-처리하여-사각형을-캔버스에-그리기" class="headerlink" title="JSON 객체를 배열로 처리하여 사각형을 캔버스에 그리기"></a>JSON 객체를 배열로 처리하여 사각형을 캔버스에 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> buildings = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"house"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">100</span>, <span class="attr">w</span>:<span class="number">50</span>, <span class="attr">h</span>:<span class="number">50</span>, <span class="attr">bg</span>: <span class="string">'magenta'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"hospital"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">100</span>, <span class="attr">w</span>:<span class="number">50</span>, <span class="attr">h</span>:<span class="number">50</span>, <span class="attr">bg</span>: <span class="string">'green'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"firestation"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">100</span>, <span class="attr">w</span>:<span class="number">50</span>, <span class="attr">h</span>:<span class="number">50</span>, <span class="attr">bg</span>: <span class="string">'orange'</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = buildings[i];</span><br><span class="line">    ctx.fillStyle = b.bg;</span><br><span class="line">    ctx.fillRect(b.x, b.y, b.w, b.h);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-jsonArray.png" alt="json 배열"></p><h3 id="JSON-객체를-배열로-처리하여-이미지-그리기"><a href="#JSON-객체를-배열로-처리하여-이미지-그리기" class="headerlink" title="JSON 객체를 배열로 처리하여 이미지 그리기"></a>JSON 객체를 배열로 처리하여 이미지 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> buildings = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Airport"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">0</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Bank"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">100</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"CarRepair"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">200</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"GasStation"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">300</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Hospital"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">400</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Temple"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">500</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buildingImage = <span class="keyword">new</span> Image();</span><br><span class="line">buildingImage.src = <span class="string">'images/buildings.png'</span>;</span><br><span class="line"></span><br><span class="line">buildingImage.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = buildings[i];</span><br><span class="line">        ctx.drawImage(buildingImage, b.sx, b.sy, b.w, b.h, b.x, b.y, b.w, b.h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-jsonArrayImage.png" alt="json 배열 이미지"></p><h2 id="마우스-충돌-체크하기"><a href="#마우스-충돌-체크하기" class="headerlink" title="마우스 충돌 체크하기"></a>마우스 충돌 체크하기</h2><p>위의 빌딩 소스를 이어서 진행한다.</p><p>결과 화면에서 빌딩의 위치를 가지고 있는 json 객체 데이터의 좌표를 체크하여 마우스를 클릭한 좌표와 비교하고<br>빌딩의 이름을 가져와 화면에 출력한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> buildings = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Airport"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">0</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Bank"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">100</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"CarRepair"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">50</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">200</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"GasStation"</span>, <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">300</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Hospital"</span>, <span class="attr">x</span>: <span class="number">150</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">400</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">"Temple"</span>, <span class="attr">x</span>: <span class="number">250</span>, <span class="attr">y</span>:<span class="number">150</span>, <span class="attr">w</span>:<span class="number">64</span>, <span class="attr">h</span>:<span class="number">64</span>, <span class="attr">sx</span>:<span class="number">500</span>, <span class="attr">sy</span>:<span class="number">0</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배경 이미지</span></span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.src = <span class="string">'images/background.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 빌딩 이미지</span></span><br><span class="line"><span class="keyword">var</span> buildingImage = <span class="keyword">new</span> Image();</span><br><span class="line">buildingImage.src = <span class="string">'images/buildings.png'</span>;</span><br><span class="line"></span><br><span class="line">buildingImage.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(bgImage, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = buildings[i];</span><br><span class="line">        ctx.drawImage(buildingImage, b.sx, b.sy, b.w, b.h, b.x, b.y, b.w, b.h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mouseX = e.clientX - ctx.canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> mouseY = e.clientY - ctx.canvas.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buildings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> bData = buildings[i];</span><br><span class="line">        <span class="comment">// 마우스 좌표를 체크하여 빌딩의 이름을 가져온다.</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            mouseX &gt;= bData.x &amp;&amp;</span><br><span class="line">            mouseX &lt; bData.x + bData.w &amp;&amp;</span><br><span class="line">            mouseY &gt;= bData.y &amp;&amp;</span><br><span class="line">            mouseY &lt; bData.y + bData.h</span><br><span class="line">        ) &#123;</span><br><span class="line">            ctx.clearRect(<span class="number">100</span>, <span class="number">260</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">            ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">            ctx.fillRect(<span class="number">100</span>, <span class="number">260</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">            ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">            ctx.textAlign = <span class="string">'center'</span>;</span><br><span class="line">            ctx.font = <span class="string">'bold 20px Arial, sans-serif'</span>;</span><br><span class="line">            ctx.fillText(bData.id, <span class="number">200</span>, <span class="number">280</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-clickBuilding.png" alt="화면에서 공항을 클릭한 화면"></p><p>참조: <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11228559">HTML5 캔버스</a><br><a href="https://github.com/kkangil/canvas-practice">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/06/07/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Canvas의 기초-2</title>
      <link>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-2/</link>
      <guid>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-2/</guid>
      <pubDate>Sun, 31 May 2020 06:40:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;이전 포스트에 이어 Canvas의 기초에 대해 더 알아보려 한다.&lt;/p&gt;
&lt;h2 id=&quot;글씨-쓰기&quot;&gt;&lt;a href=&quot;#글씨-쓰기&quot; class=&quot;headerlink&quot; title=&quot;글씨 쓰기&quot;&gt;&lt;/a&gt;글씨 쓰기&lt;/h2&gt;&lt;h3 id=&quot;글씨-그리기&quot;&gt;&lt;a href=&quot;#글씨-그리기&quot; class=&quot;headerlink&quot; title=&quot;글씨 그리기&quot;&gt;&lt;/a&gt;글씨 그리기&lt;/h3&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이전 포스트에 이어 Canvas의 기초에 대해 더 알아보려 한다.</p><h2 id="글씨-쓰기"><a href="#글씨-쓰기" class="headerlink" title="글씨 쓰기"></a>글씨 쓰기</h2><h3 id="글씨-그리기"><a href="#글씨-그리기" class="headerlink" title="글씨 그리기"></a>글씨 그리기</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">120</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">140</span>, <span class="number">200</span>);</span><br><span class="line">ctx.fillText(<span class="string">'The fillText() method draws filled text on the canvas.'</span>, <span class="number">50</span>, <span class="number">160</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-fillText.png" alt="글씨 그리기"></p><blockquote><p>context.fillText(text, x, y, maxWidth)<br>text: 화면에 표시될 글씨<br>x: x 좌표<br>y: y 좌표<br>maxWidth: 화면에 표시될 최대 폭(선택 사항)</p></blockquote><h3 id="글씨-크기를-크게-변경하기"><a href="#글씨-크기를-크게-변경하기" class="headerlink" title="글씨 크기를 크게 변경하기"></a>글씨 크기를 크게 변경하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 28px Arial, sans-serif'</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello Canvas World!"</span>, <span class="number">50</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-font.png" alt="글씨 크기 변경"></p><h3 id="글씨의-외곽선-그리기"><a href="#글씨의-외곽선-그리기" class="headerlink" title="글씨의 외곽선 그리기"></a>글씨의 외곽선 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 40px Arial, sans-serif'</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello Canvas World!"</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">2</span>;</span><br><span class="line">ctx.strokeText(<span class="string">"Hello Canvas World!"</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>strokeText</code> 함수로 외곽선만 있는 글씨를 표시한다.</p><p><img src="/images/canvas-strokeText.png" alt="글씨의 외곽선"></p><h3 id="글씨의-좌우-정렬-알아보기"><a href="#글씨의-좌우-정렬-알아보기" class="headerlink" title="글씨의 좌우 정렬 알아보기"></a>글씨의 좌우 정렬 알아보기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 30px Arial, sans-serif'</span>;</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"start"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"end"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"left"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"right"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.textAlign = <span class="string">"center"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"Hello World!"</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.moveTo(<span class="number">200</span>, <span class="number">20</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">370</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-textAlign.png" alt="글씨 정렬"></p><p>textAlign</p><ul><li>start: 시작점 기준(기본)</li><li>end: 끝점 기준</li><li>left: 글씨의 왼쪽 기준</li><li>right: 글씨의 오른쪽 기준</li><li>center: 중심 기준</li></ul><h3 id="글씨의-상하정렬"><a href="#글씨의-상하정렬" class="headerlink" title="글씨의 상하정렬"></a>글씨의 상하정렬</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#6495ED'</span>;</span><br><span class="line">ctx.font = <span class="string">'italic bold 22px Arial, sans-serif'</span>;</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"top"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"top!"</span>, <span class="number">10</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"bottom"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"bottom!"</span>, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"middle"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"middle!"</span>, <span class="number">130</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"alphabetic"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"alphabetic!"</span>, <span class="number">220</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.textBaseline = <span class="string">"hanging"</span>;</span><br><span class="line">ctx.fillText(<span class="string">"hanging!"</span>, <span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.moveTo(<span class="number">0</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">400</span>, <span class="number">150</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-textBaseline.png" alt="글씨 상하정렬"></p><p>textBaseline (베이스 라인 기준)</p><ul><li>top: 글씨의 위에 정렬</li><li>bottom: 글씨의 바닥에 정렬</li><li>center: 글씨의 중간에 정렬</li><li>alphabetic: 기본값</li><li>hanging: 글씨의 바로 위에 정렬</li></ul><h2 id="그림자-그리기"><a href="#그림자-그리기" class="headerlink" title="그림자 그리기"></a>그림자 그리기</h2><h3 id="사각형의-그림자"><a href="#사각형의-그림자" class="headerlink" title="사각형의 그림자"></a>사각형의 그림자</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.shadowColor = <span class="string">'rgba(0, 0, 0, 0.3)'</span>;</span><br><span class="line">ctx.shadowOffsetX = <span class="number">5</span>;</span><br><span class="line">ctx.shadowOffsetY = <span class="number">5</span>;</span><br><span class="line">ctx.shadowBlur = <span class="number">3</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-shadow.png" alt="그림자"></p><ul><li>shadowColor: 그림자의 색상</li><li>shadowOffsetX: 그림자의 간격을 x: 5 만큼 이동</li><li>shadowOffsetY: 그림자의 간격을 y: 5 만큼 이동</li><li>shadowBlur: 그림자의 흐림도</li></ul><h2 id="이동-회전-스케일-변형하기"><a href="#이동-회전-스케일-변형하기" class="headerlink" title="이동, 회전, 스케일, 변형하기"></a>이동, 회전, 스케일, 변형하기</h2><h3 id="위치-이동시키기"><a href="#위치-이동시키기" class="headerlink" title="위치 이동시키기"></a>위치 이동시키기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.translate(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-translate.png" alt="위치 이동"></p><p><code>translate</code> 를 사용하여 다음에 나오는 객체를 이동시킨다. css 의 translate 같다.</p><h3 id="크기-변형하기"><a href="#크기-변형하기" class="headerlink" title="크기 변형하기"></a>크기 변형하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.scale(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-scale.png" alt="크기 이동"></p><p>위의 예제에서는 크기를 절반으로 줄였다. 기준점(0,0)으로 하여 크기를 줄이기 때문에 제자리에서 크기가 줄지 않고,<br>위치가 상단(25,25)으로 이동한다.</p><h3 id="회전시키기"><a href="#회전시키기" class="headerlink" title="회전시키기"></a>회전시키기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">3</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.rotate(<span class="number">5</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.rotate(<span class="number">5</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-rotate.png" alt="회전"></p><h3 id="사각형-형태-변형하기"><a href="#사각형-형태-변형하기" class="headerlink" title="사각형 형태 변형하기"></a>사각형 형태 변형하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">3</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.transform(<span class="number">1.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.5</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-transform.png" alt="변형하기"></p><blockquote><p>context.transform(s1, sk1, sk2, s2, m1, m2)<br>s1: 수평으로 확대<br>sk1: 수평으로 기울임<br>sk2: 수직으로 기울임<br>s2: 수직으로 확대<br>m1: 수평으로 이동<br>m2: 수직으로 이동</p></blockquote><h4 id="기울기"><a href="#기울기" class="headerlink" title="기울기"></a>기울기</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">ctx.transform(<span class="number">1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><img src="/images/canvas-transform2.png" alt="기울기"></p><h4 id="transform-vs-setTransform"><a href="#transform-vs-setTransform" class="headerlink" title="transform vs setTransform"></a>transform vs setTransform</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'yellow'</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">3</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.transform(<span class="number">1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.setTransform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-setTransform.png" alt="setTransform"></p><h2 id="색상-보정하기"><a href="#색상-보정하기" class="headerlink" title="색상 보정하기"></a>색상 보정하기</h2><p>캔버스에서 일부분을 가져와서 색상을 바꾸어 그린다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.putImageData(src, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">200</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-getImageData.png" alt="일부분 잘라오기"></p><h3 id="getImageData"><a href="#getImageData" class="headerlink" title="getImageData"></a>getImageData</h3><p>context.getImageData(x, y, width, height)</p><ul><li>x: 왼쪽 상단의 x 좌표</li><li>y: 왼쪽 상단의 y 좌표</li><li>width: 사각형 영역의 폭</li><li>height: 사각형 영역의 높이</li></ul><h3 id="putImageData"><a href="#putImageData" class="headerlink" title="putImageData"></a>putImageData</h3><p>context.putImageData(imgData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight)</p><ul><li>imgData: getImageData 로 가져온 이미지 값</li><li>x: 왼쪽 상단의 X 좌표</li><li>y: 왼쪽 상단의 y 좌표</li><li>dirtyX: 가져올 이미지의 x 좌표</li><li>dirtyY: 가져올 이미지의 y 좌표</li><li>dirtyWidth: 가져와서 그릴 사각형 영역의 폭</li><li>dirtyHeight: 가져와서 그릴 사각형 영역의 높이</li></ul><h3 id="지정한-부분의-색상을-흑백으로-바꾸어-출력하기"><a href="#지정한-부분의-색상을-흑백으로-바꾸어-출력하기" class="headerlink" title="지정한 부분의 색상을 흑백으로 바꾸어 출력하기"></a>지정한 부분의 색상을 흑백으로 바꾸어 출력하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> pixels = src.data;</span><br><span class="line"><span class="keyword">var</span> numPixels = pixels.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; numPixels; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> avg = (pixels[i*<span class="number">4</span>] + pixels[i*<span class="number">4</span>+<span class="number">1</span>] + pixels[i*<span class="number">4</span>+<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line">    pixels[i*<span class="number">4</span>] = avg; <span class="comment">// Red;</span></span><br><span class="line">    pixels[i*<span class="number">4</span>+<span class="number">1</span>] = avg; <span class="comment">// Green;</span></span><br><span class="line">    pixels[i*<span class="number">4</span>+<span class="number">2</span>] = avg; <span class="comment">// Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx.putImageData(src, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">200</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-imageDataToBlack.png" alt="흑백으로 변경"></p><p>이미지를 data 로 가져와 확인해보면 rgba 배열로 되어 있다. 각 픽셀의 색상 값을 흑백으로 변경하여 다시 저장한다.</p><h2 id="합성하기"><a href="#합성하기" class="headerlink" title="합성하기"></a>합성하기</h2><p>두 개 이상의 이미지를 합성하여 새로운 이미지를 만들거나 효과를 주는 방법을 알아본다.</p><p>합성에는 다양한 방법이 있는데, 대표적인 방법은 알파값을 이용하여 투명한 이미지를 기존 이미지 위에 올려서<br>색상에 간섭하여 그리는 것이다.</p><h3 id="알파값-적용하기"><a href="#알파값-적용하기" class="headerlink" title="알파값 적용하기"></a>알파값 적용하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'rgba(63, 169, 245, 1)'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.globalAlpha = <span class="number">0.5</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-alpha.png" alt="알파값 적용"></p><p><code>globalAlpha</code> 값이 0.5 적용된 파란색 사각형을 겹쳐서 그리게 적용한다.</p><h3 id="두-개의-이미지를-합성하여-그리기"><a href="#두-개의-이미지를-합성하여-그리기" class="headerlink" title="두 개의 이미지를 합성하여 그리기"></a>두 개의 이미지를 합성하여 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.globalCompositeOperation = <span class="string">'source-over'</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-composite.png" alt="이미지 합성"></p><h4 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h4><ul><li>source-over: 이미지 위에 겹쳐 그린다. (기본)</li><li>source-atop: 첫 번째 이미지를 그리고 두 번째 이미지의 겹치는 부분만 그린다.</li><li>source-in: 첫 번째 이미지를 그리지 않고 두 번째 이미지의 겹치지 않는 부분만 그린다.</li><li>source-out: 첫 번째 이미지를 그리지 않고 그 영역 안에 두 번째 이미지만 그린다.</li><li>destination-atop: 첫 번째 이미지를 위로 올리고 두 번째 이미지 전체를 그린다.</li><li>destination-in: 첫 번째 이미지를 위로 올리고 두 번째와 겹치는 부분만 그린다.</li><li>destination-out: 첫 번째 이미지만 그리고 두 번째 이미지와 겹치는 부분을 지운다.</li><li>destination-over: 첫 번째 이미지를 위로 올려 그리고 두 번째 이미지를 아래로 그린다.</li><li>lighter: 전체를 그리고 겹친 부분을 가산 혼합한다.</li><li>copy: 두 번째 이미지만 남기고 다른 부분은 제거한다.</li><li>xor: 전체를 그리고 겹친 부분을 지운다.</li></ul><p><img src="/images/canvas-compositeType.png" alt="이미지 합성 type"></p><p>참조: <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11228559">HTML5 캔버스</a><br><a href="https://github.com/kkangil/canvas-practice">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Canvas의 기초 - 1</title>
      <link>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88/</link>
      <guid>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88/</guid>
      <pubDate>Sun, 31 May 2020 04:36:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;HTML 에서는 태그를 중심으로 화면에 글자, 그림 등을 배치하고 CSS 를 이용하여 레이아웃을 그리지만, 캔버스는&lt;br&gt;하나의 화면에 자바스크립트에서 지원하는 캔버스 함수를 이용하여 그린다.&lt;/p&gt;
&lt;p&gt;캔버스의 기본적인 사용법은 소스와 같이 html 태그 안에 넣으면 된다. 캔버스 내에서는 css 가 제어되지 않기 때문에&lt;br&gt;자바스크립트를 이용하여 코드를 구성해야 한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>HTML 에서는 태그를 중심으로 화면에 글자, 그림 등을 배치하고 CSS 를 이용하여 레이아웃을 그리지만, 캔버스는<br>하나의 화면에 자바스크립트에서 지원하는 캔버스 함수를 이용하여 그린다.</p><p>캔버스의 기본적인 사용법은 소스와 같이 html 태그 안에 넣으면 된다. 캔버스 내에서는 css 가 제어되지 않기 때문에<br>자바스크립트를 이용하여 코드를 구성해야 한다.</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"ko"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas 01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span>CANVAS를 지원하지 않습니다.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>만약 캔버스가 지원되지 않는 브라우저이면, 캔버스 태그 안의 문구가 표시된다. script 태그에 캔버스 코드를 넣는다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>getContext</code> 함수에 2d를 그린다고 선언하여, ctx 변수에 적용한다. 3d는 캔버스가 아닌 WebGL 과 같은 기능을 사용해야<br>한다.</p><h2 id="선-그리기"><a href="#선-그리기" class="headerlink" title="선 그리기"></a>선 그리기</h2><h3 id="선-그리기-1"><a href="#선-그리기-1" class="headerlink" title="선 그리기"></a>선 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>3: 선 그리기를 시작한다.<br>4: 시작점으로 이동한다.<br>5: 선의 끝점으로 이동한다.<br>6: 선을 그린다.</p><p><img src="/images/canvas-선그리기.png" alt="선그리기"></p><h3 id="사각형-그리기"><a href="#사각형-그리기" class="headerlink" title="사각형 그리기"></a>사각형 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형그리기.png" alt="사각형그리기"></p><h3 id="내부에-색-채우기"><a href="#내부에-색-채우기" class="headerlink" title="내부에 색 채우기"></a>내부에 색 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">ctx.stroke();</span><br><span class="line">ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p>fillStyle 을 사용해 내부의 색을 지정해 줄 수 있다. fillStyle 없이 fill 함수만 실행할 경우 검정색으로 채워진다.</p><p><img src="/images/canvas-색채우기.png" alt="색 채우기"></p><h3 id="선의-색을-다른-색으로-채우고-두께-변경하기"><a href="#선의-색을-다른-색으로-채우고-두께-변경하기" class="headerlink" title="선의 색을 다른 색으로 채우고 두께 변경하기"></a>선의 색을 다른 색으로 채우고 두께 변경하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선의 색 변경</span></span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 색 채우기</span></span><br><span class="line">ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-선색변경.png" alt="선의 색 변경"></p><h3 id="선의-끝-부분-처리하기"><a href="#선의-끝-부분-처리하기" class="headerlink" title="선의 끝 부분 처리하기"></a>선의 끝 부분 처리하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineCap = <span class="string">"butt"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineCap = <span class="string">"round"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineCap = <span class="string">"square"</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-선의끝부분처리.png" alt="선의 끝부분 처리"></p><p><code>lineCap</code> 을 사용하면 선의 끝 부분을 처리할 수 있다.</p><ul><li>butt: 선의 끝 부분을 좌표에 맞추어 마무리한다. 기본값</li><li>round: 선의 끝을 둥글린다. 선 두께를 반지름으로 한다.</li><li>square: 선의 끝을 사각형으로 처리한다. 선 두께만큼 길어진다.</li></ul><h3 id="선의-꺾인-부분-처리하기"><a href="#선의-꺾인-부분-처리하기" class="headerlink" title="선의 꺾인 부분 처리하기"></a>선의 꺾인 부분 처리하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineJoin = <span class="string">'miter'</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">ctx.lineJoin = <span class="string">"round"</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">290</span>);</span><br><span class="line">ctx.lineJoin = <span class="string">"bevel"</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-선의꺾인부분처리.png" alt="선의 꺾인 부분 처리하기"></p><p><code>lineJoin</code> 를 사용하면 꺾인 부분을 처리할 수 있다.</p><ul><li>miter: 각진 모서리 형태로 기본값이다.</li><li>round: 둥근 모서리 형태</li><li>bevel: 잘려나간 모서리 형태 </li></ul><h3 id="선의-간격을-조정하여-점선-만들기"><a href="#선의-간격을-조정하여-점선-만들기" class="headerlink" title="선의 간격을 조정하여 점선 만들기"></a>선의 간격을 조정하여 점선 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"#0000ff"</span>;</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">ctx.setLineDash([<span class="number">20</span>]);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">ctx.setLineDash([<span class="number">20</span>, <span class="number">10</span>]);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">290</span>);</span><br><span class="line">ctx.setLineDash([<span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">10</span>]);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-점선처리.png" alt="점선 만들기"></p><p><code>setLineDash</code> 를 사용하여 점선을 만든다.</p><ol><li>선의 간격이 20씩 벌어져 있다.</li><li>선의 길이: 20, 간격: 10 만큼 벌어져 있다.</li><li>선의 길이: 20, 간격: 10 과 선의 길이: 50, 간격: 10 이 번갈아 가면서 그려진다.</li></ol><h2 id="사각형-그리기-1"><a href="#사각형-그리기-1" class="headerlink" title="사각형 그리기"></a>사각형 그리기</h2><p>이전에는 선(line)을 이용하여 사각형을 그렸었는데 Rect 함수를 이용하여 사각형을 그릴 수 있다.</p><h3 id="사각형-그리기-2"><a href="#사각형-그리기-2" class="headerlink" title="사각형 그리기"></a>사각형 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">150</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형.png" alt="사각형"></p><p><code>strokeRect</code> 함수를 사용하면 사각형을 쉽게 그릴 수 있다.</p><blockquote><p>strokeRect(x, y, width, height);</p></blockquote><h3 id="사각형-색-채우기"><a href="#사각형-색-채우기" class="headerlink" title="사각형 색 채우기"></a>사각형 색 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">"magenta"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">"green"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">150</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">150</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형색채우기.png" alt="사각형 색 채우기"></p><h3 id="내부를-사각형으로-지우기"><a href="#내부를-사각형으로-지우기" class="headerlink" title="내부를 사각형으로 지우기"></a>내부를 사각형으로 지우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.clearRect(<span class="number">70</span>, <span class="number">70</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-사각형내부지우기.png" alt="내부를 사각형으로 지우기"></p><h2 id="원-그리기"><a href="#원-그리기" class="headerlink" title="원 그리기"></a>원 그리기</h2><h3 id="기본-원-그리기"><a href="#기본-원-그리기" class="headerlink" title="기본 원 그리기"></a>기본 원 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.arc(<span class="number">150</span>, <span class="number">150</span>, <span class="number">100</span>,<span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-원그리기.png" alt="원 그리기"></p><p><code>arc</code> 함수를 실행하여 원을 그릴 수 있다.</p><blockquote><p>context.arc(x, y, r, sAngle, eAngle, counterclockwise);<br>x: x 좌표<br>y: y 좌표<br>r: 반지름<br>sAngle: 시작하는 각도<br>eAngle: 끝나는 각도<br>counterclockwise: 시계 방향으로 회전</p></blockquote><h3 id="선과-호를-연결하여-라운드-코너-그리기"><a href="#선과-호를-연결하여-라운드-코너-그리기" class="headerlink" title="선과 호를 연결하여 라운드 코너 그리기"></a>선과 호를 연결하여 라운드 코너 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.arcTo(<span class="number">350</span>, <span class="number">50</span>, <span class="number">350</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">350</span>, <span class="number">200</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-호그리기.png" alt="호 그리기"></p><p><code>arcTo</code> 함수를 사용하여 호를 그릴 수 있다.</p><blockquote><p>context.arcTo(x1, y1, x2, y2, r)<br>x1: 시작하는 점의 x 좌표<br>y1: 시작하는 점의 y 좌표<br>x2: 끝나는 점의 x 좌표<br>y2: 끝나는 점의 y 좌표<br>r: 호의 반지름</p></blockquote><h3 id="quadraticCurve-그리기"><a href="#quadraticCurve-그리기" class="headerlink" title="quadraticCurve 그리기"></a>quadraticCurve 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.quadraticCurveTo(<span class="number">200</span>, <span class="number">100</span>, <span class="number">350</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">350</span>, <span class="number">200</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-quadraticCurve.png" alt="quadraticCurveTo"></p><p><code>quadraticCurveTo</code> 함수를 이용하여 하나의 조절점의 커브를 그린다.</p><blockquote><p>context.quadraticCurve(cpx, cpy, x, y)<br>cpx: 조절하는 점의 x 좌표<br>cpy: 조절하는 점의 y 좌표<br>x: 끝나는 점의 x 좌표<br>y: 끝나는 점의 y 좌표</p></blockquote><h3 id="bezierCurve-그리기"><a href="#bezierCurve-그리기" class="headerlink" title="bezierCurve 그리기"></a>bezierCurve 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">ctx.bezierCurveTo(<span class="number">200</span>,<span class="number">70</span>, <span class="number">100</span>,<span class="number">150</span>, <span class="number">350</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">350</span>, <span class="number">200</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-bezierCurve.png" alt="bezierCurveTo"></p><p><code>bezierCurveTo</code> 함수를 이용하여 두 조절점의 커브를 그린다.</p><blockquote><p>context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)<br>cp1x: 조절하는 점 1번째의 x 좌표<br>cp1y: 조절하는 점 1번째의 y 좌표<br>cp2x: 조절하는 점 2번째의 x 좌표<br>cp2y: 조절하는 점 2번째의 y 좌표<br>x: 끝나는 점의 x 좌표<br>y: 끝나는 점의 y 좌표</p></blockquote><h2 id="내부-채우기"><a href="#내부-채우기" class="headerlink" title="내부 채우기"></a>내부 채우기</h2><h3 id="Gradient-로-내부-채우기"><a href="#Gradient-로-내부-채우기" class="headerlink" title="Gradient 로 내부 채우기"></a>Gradient 로 내부 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> grad = ctx.createLinearGradient(<span class="number">50</span>, <span class="number">50</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">grad.addColorStop(<span class="number">0</span>, <span class="string">'red'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">1</span>/<span class="number">6</span>, <span class="string">'orange'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">2</span>/<span class="number">6</span>, <span class="string">'yellow'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">3</span>/<span class="number">6</span>, <span class="string">'green'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">4</span>/<span class="number">6</span>, <span class="string">'aqua'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">5</span>/<span class="number">6</span>, <span class="string">'blue'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">1</span>, <span class="string">'purple'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">5</span>;</span><br><span class="line">ctx.fillStyle = grad;</span><br><span class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-gradient.png" alt="gradient"></p><p>그라데이션으로 색을 채우기 위해 <code>createLinearGradient</code> 함수를 사용했다.</p><blockquote><p>ctx.createLinearGradient(x0, y0, x1, y1);<br>x0: 시작하는 점의 x 좌표<br>y0: 시작하는 점의 y 좌표<br>x1: 끝나는 점의 x 좌표<br>y1: 끝나는 점의 y 좌표</p></blockquote><h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial gradient"></a>radial gradient</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> grad = ctx.createRadialGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>);</span><br><span class="line">grad.addColorStop(<span class="number">0</span>, <span class="string">'red'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">0.5</span>, <span class="string">'yellow'</span>);</span><br><span class="line">grad.addColorStop(<span class="number">1</span>, <span class="string">'black'</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">5</span>;</span><br><span class="line">ctx.fillStyle = grad;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">ctx.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-radialGradient.png" alt="radial gradient"></p><blockquote><p>ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);<br>x0: 시작하는 점의 x 좌표<br>y0: 시작하는 점의 y 좌표<br>r0: 시작하는 곳의 반지름<br>x1: 끝나는 점의 x 좌표<br>y1: 끝나는 점의 y 좌표<br>r1: 끝 나는 곳의 반지름</p></blockquote><h3 id="패턴으로-사각형-채우기"><a href="#패턴으로-사각형-채우기" class="headerlink" title="패턴으로 사각형 채우기"></a>패턴으로 사각형 채우기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> flower = <span class="keyword">new</span> Image();</span><br><span class="line">flower.src = <span class="string">"images/flower.png"</span>;</span><br><span class="line">flower.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pattern = ctx.createPattern(flower, <span class="string">"repeat"</span>);</span><br><span class="line">    ctx.fillStyle = pattern;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-pattern.png" alt="createPattern"></p><p><code>createPattern</code> 를 이미지를 넘겨주어 실행한다.</p><p>context.createPattern(image, “repeat”);</p><ul><li>repeat: 패턴을 반복하여 채운다.</li><li>repeat-x: x축으로 반복하여 채운다.</li><li>repeat-y: y축으로 반복하여 채운다.</li><li>no-repeat: 반복하지 않는다.</li></ul><h2 id="이미지-그리기"><a href="#이미지-그리기" class="headerlink" title="이미지 그리기"></a>이미지 그리기</h2><h3 id="이미지를-원래-크기대로-그리기"><a href="#이미지를-원래-크기대로-그리기" class="headerlink" title="이미지를 원래 크기대로 그리기"></a>이미지를 원래 크기대로 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> myPic = <span class="keyword">new</span> Image();</span><br><span class="line">myPic.src = <span class="string">'images/duck.jpg'</span>;</span><br><span class="line">myPic.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(myPic, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-image.png" alt="이미지 그리기"></p><blockquote><p>context.drawImage(img, x, y)</p></blockquote><h3 id="이미지의-크기를-변형하여-그리기"><a href="#이미지의-크기를-변형하여-그리기" class="headerlink" title="이미지의 크기를 변형하여 그리기"></a>이미지의 크기를 변형하여 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> myPic = <span class="keyword">new</span> Image();</span><br><span class="line">myPic.src = <span class="string">'images/duck.jpg'</span>;</span><br><span class="line">myPic.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(myPic, <span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-image2.png" alt="이미지 크기 변형"></p><blockquote><p>context.drawImage(img, x, y, width, height)</p></blockquote><h3 id="이미지를-잘라-일부만-그리기"><a href="#이미지를-잘라-일부만-그리기" class="headerlink" title="이미지를 잘라 일부만 그리기"></a>이미지를 잘라 일부만 그리기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> myPic = <span class="keyword">new</span> Image();</span><br><span class="line">myPic.src = <span class="string">'images/duck.jpg'</span>;</span><br><span class="line">myPic.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(myPic, <span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas-image3.png" alt="이미지 일부만 그리기"></p><blockquote><p>context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height)<br>sx: 소스 이미지에서 잘라 가져올 시작점의 x 좌표<br>sy: 소스 이미지에서 잘라 가져올 시작점의 y 좌표<br>swidth: 소스 이미지에서 잘라 가져올 시작점 기준의 이미지 폭<br>sheight: 소스 이미지에서 잘라 가져올 시작점 기준의 이미지 높이</p></blockquote><p>참조: <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=11228559">HTML5 캔버스</a><br><a href="https://github.com/kkangil/canvas-practice">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React recoiljs 알아보기</title>
      <link>https://kkangil.github.io/2020/05/24/React-recoiljs-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/</link>
      <guid>https://kkangil.github.io/2020/05/24/React-recoiljs-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/</guid>
      <pubDate>Sun, 24 May 2020 07:51:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;최근 react 에서 새로운 상태관리 라이브러리를 발표했다. 주요 컨셉으로는 atom,selector 라는 단위를 통해&lt;br&gt;derived state 를 효과적으로 처리하고 상태의 코드 분할이 가능하게 한다고 한다.&lt;/p&gt;
&lt;p&gt;리액트의 기본 설정은 create-react-app 을 사용하려고 한다. react-app 생성 후 recoiljs 를 설치해주면&lt;br&gt;사용 준비가 끝난것이다.&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;figcaption&gt;&lt;span&gt;script&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm i recoil&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>최근 react 에서 새로운 상태관리 라이브러리를 발표했다. 주요 컨셉으로는 atom,selector 라는 단위를 통해<br>derived state 를 효과적으로 처리하고 상태의 코드 분할이 가능하게 한다고 한다.</p><p>리액트의 기본 설정은 create-react-app 을 사용하려고 한다. react-app 생성 후 recoiljs 를 설치해주면<br>사용 준비가 끝난것이다.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i recoil</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p>아직 나온지 얼마 되지 않은 라이브러리라서 구조화에 대한 내용이 많이 없다. 현재는 src 내부에<br><code>recoil</code> 이라는 폴더를 만들고 component 단위 별로 파일을 생성하려고 한다.</p><h2 id="RecoilRoot"><a href="#RecoilRoot" class="headerlink" title="RecoilRoot"></a>RecoilRoot</h2><p>redux, mobx 등 다른 상태관리 라이브러리에도 provider 가 있듯이 recoil 도 RecoilRoot 라는 hoc 가 존재한다.<br><code>props</code> 로 <code>initializeState</code> 를 전달해 줄 수 있지만 지금은 일단 넘어가려 한다.</p><p>create-react-app 으로 생성한 app 기준 index.js 에 App 을 RecoilRoot 로 감싸주면 된다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;RecoilRoot&#125; <span class="keyword">from</span> <span class="string">'recoil'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">      &lt;RecoilRoot&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">      &lt;<span class="regexp">/RecoilRoot&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>React.StrictMode&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://recoiljs.org/docs/api-reference/core/RecoilRoot">RecoilRoot 공식 문서</a></p><h2 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h2><p>리액트의 state 와 같다라고 생각해도 된다. 즉, 상태 값이라는 것이다. 기본적으로 <code>atom</code> 함수를 실행하고<br>이때 인자로 option 을 넘겨준다. option 중 <code>key</code> 와 <code>default</code> 는 필수 값이다.</p><p>key 는 unique 한 id 여야 하고 default 는 이름에서 유추할 수 있듯이 해당 상태 값의 초기값이다.</p><p>count component 를 만들면서 확인해 보자.</p><p>우선 recoil 폴더에 count.js 파일을 만든 후 아래와 같이 atom state 를 생성해 줬다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> countState = atom(&#123;</span><br><span class="line">    key: <span class="string">"countState"</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이후 Count Component 를 아래와 같이 생성했다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useRecoilState&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;countState&#125; <span class="keyword">from</span> <span class="string">"../recoil/count"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useRecoilState(countState);</span><br><span class="line">    <span class="keyword">const</span> incrementByOne = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            Count: &#123;count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOne&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure><p>위의  <code>useRecoilState</code> 훅은 밑에서 자세히 설명하도록 하겠다.</p><h2 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h2><p><code>selector</code> 도 <code>atom</code> 과 마찬가지로 값으로 쓰인다. 차이점은 atom 은 오로지 현재 값만 가져오고<br>setState 할때도 넘겨주는 값만을 사용할 수 있다. 하지만 selector 는 option 에 <code>get</code> 과 <code>set</code> 을 넘겨줘서<br>사용할 수 있다.</p><p>option 에 역시 key 는 필수이며 unique 해야한다. get 또한 필수로 넘겨줘야 하며 set 은 optional 이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> countEvenState = selector(&#123;</span><br><span class="line">    key: <span class="string">"countEvenState"</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(countState) % 2 === 0,</span><br><span class="line">    <span class="keyword">set</span>: (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt; <span class="keyword">set</span>(countState, newValue)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>먼저 selector recoil state 를 생성했다. 위 값을 불러올때 짝수면 true, 홀수면 false 를 가져온다.</p><p><code>get</code> 은 함수를 전달해줘야한다. 이때 인자 객체에 get 이라는 함수가 있는데, 이 함수를 사용하여 상태값을<br>불러와 사용한다. 이때 get 에 전달해줘야 하는 값은 recoil state 여야 한다.</p><p>위의 예제에서는 <code>set</code> 이 필요 없을 수 있으나, 어떤 식으로 사용해야 하는지 알 수 있게 추가한 것이다.<br>set 은 첫번째 인자로 객체, 두번째 인자로 새로운 값이 넘어오고, 첫번째 인자 객체의 set 을 사용하여<br>state 값을 바꾼다. 이때 첫번째 인자는 역시 recoil state 여야 하고 두번째 인자로 바뀔 값을 넘겨준다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useRecoilState(countState);</span><br><span class="line">    <span class="keyword">const</span> [evenCount, setEvenCount] = useRecoilState(countEvenState);</span><br><span class="line">    <span class="keyword">const</span> incrementByOne = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> incrementByOneEvenCount = <span class="function"><span class="params">()</span> =&gt;</span> setEvenCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            Count: &#123;count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOne&#125;&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;br /</span>&gt;</span><br><span class="line">            Even Count: &#123;evenCount ? <span class="string">'짝수'</span> : <span class="string">'홀수'</span>&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOneEvenCount&#125;&gt;Even Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Count component 를 위와 같이 변경하였다. Even Increment 버튼을 클릭하면 count 의 값도 같이 바뀌는 것을<br>확인할 수 있다. set 에서 count 의 값을 변경해 주기 때문이다.</p><h2 id="recoil-hooks"><a href="#recoil-hooks" class="headerlink" title="recoil hooks"></a>recoil hooks</h2><h3 id="recoil-state-값-사용"><a href="#recoil-state-값-사용" class="headerlink" title="recoil state 값 사용"></a>recoil state 값 사용</h3><p>recoil state 는 훅을 이용하여 사용해야 한다. 위 예제의 <code>useRecoilState</code> 같은 훅이다. 현재까지 세가지 방법의<br>recoil state 사용법이 있다.</p><ul><li>useRecoilValue: 값만을 불러올 수 있다. 즉 이 훅은 set 함수를 반환하지 않는다.</li><li>useSetRecoilState: set 함수만을 불러올 수 있다.</li><li>useRecoilState: 값, set 함수 두가지 다 불러올 수 있다.</li></ul><p>위 예제에서는 useRecoilState 만을 사용하였는데 현재 setCount 는 사용하지 않으므로 <code>useRecoilValue</code> 로 리팩토링<br>하는 것이 좋을 것 같다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useRecoilValue(countState);</span><br><span class="line">    <span class="keyword">const</span> [evenCount, setEvenCount] = useRecoilState(countEvenState);</span><br><span class="line">    <span class="keyword">const</span> incrementByOneEvenCount = <span class="function"><span class="params">()</span> =&gt;</span> setEvenCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            Count: &#123;count&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            Even Count: &#123;evenCount ? <span class="string">'짝수'</span> : <span class="string">'홀수'</span>&#125;</span><br><span class="line">            &lt;br /&gt;</span><br><span class="line">            &lt;button onClick=&#123;incrementByOneEvenCount&#125;&gt;Even Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useResetRecoilState"><a href="#useResetRecoilState" class="headerlink" title="useResetRecoilState"></a>useResetRecoilState</h3><p>recoil state 를 default 값으로 초기화 시킬때 사용한다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resetCount = useResetRecoilState(countState);</span><br><span class="line">&lt;button onClick=&#123;resetCount&#125;&gt;reset&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="useRecoilValueLoadable"><a href="#useRecoilValueLoadable" class="headerlink" title="useRecoilValueLoadable"></a>useRecoilValueLoadable</h3><p>밑에서 다시 언급하겠지만 이 훅은 주로 비동기 selector 를 쓸때 사용된다. React.Suspense 로 loading 처리를 할 수 있지만<br>위 훅을 사용하면 현재 상태(state) 와 값(contents)을 반환해준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countLoadable = useRecoilValueLoadable(countEvenState);</span><br><span class="line"><span class="built_in">console</span>.log(countLoadable);</span><br></pre></td></tr></table></figure><h3 id="useRecoilCallback"><a href="#useRecoilCallback" class="headerlink" title="useRecoilCallback"></a>useRecoilCallback</h3><p>recoil state 를 불러오지 않았을때도 callback 함수를 전달해주어 해당 callback 에서 recoil state 에 접근 가능하도록<br>해준다.</p><p>아래는 공식 문서의 예제이다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, useRecoilCallback&#125; <span class="keyword">from</span> <span class="string">'recoil'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> itemsInCart = atom(&#123;</span><br><span class="line">  key: <span class="string">'itemsInCart'</span>,</span><br><span class="line">  <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CartInfoDebug</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> logCartItems = useRecoilCallback(<span class="keyword">async</span> (&#123;getPromise&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> numItemsInCart = <span class="keyword">await</span> getPromise(itemsInCart);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Items in cart: '</span>, numItemsInCart);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;logCartItems&#125;&gt;Log Cart Items&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="비동기-처리"><a href="#비동기-처리" class="headerlink" title="비동기 처리"></a>비동기 처리</h2><p>프로젝트를 진행함에 있어 API 호출과 같은 비동기 처리가 중요하다. recoil 에서도 역시 비동기 처리에 대한<br>가이드를 전달해준다.</p><p>recoil 폴더에 name.js 라는 파일을 추가한 후 아래와 같이 recoil state 를 생성했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, selector&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = <span class="function"><span class="params">name</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123;name&#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> currentUserNameState = atom(&#123;</span><br><span class="line">    key: <span class="string">'currentUserNameState'</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">"Kkangil"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> currentUserName = selector(&#123;</span><br><span class="line">    key: <span class="string">'currentUserName'</span>,</span><br><span class="line">    <span class="keyword">get</span>: async (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> getName(<span class="keyword">get</span>(currentUserNameState));</span><br><span class="line">        return response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>selector</code> 의 get option 에서 async/await 처리가 가능하다. 이후 UserName 이라는 Component 를 생성해줬다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useRecoilValue&#125; <span class="keyword">from</span> <span class="string">"recoil"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;currentUserName&#125; <span class="keyword">from</span> <span class="string">"../recoil/name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserName);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> UserName;</span><br></pre></td></tr></table></figure><p>이렇게 Component 를 생성해 준 후 확인해보면 React.Suspense 를 사용해야 한다는 에러가 발생한다.<br>index.js 에 React.Suspense 를 추가해주자.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">      &lt;RecoilRoot&gt;</span><br><span class="line">          &lt;React.Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;App /</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/React.Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>RecoilRoot&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.StrictMode&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="유틸리티"><a href="#유틸리티" class="headerlink" title="유틸리티"></a>유틸리티</h2><p>아쉽지만 현재 버전 0.0.7 에서는 제공하고 있지 않은것 같다. 추후 버전 업이 됐을때 기대해봐도 좋을것 같다.</p><h3 id="atomFamily"><a href="#atomFamily" class="headerlink" title="atomFamily"></a>atomFamily</h3><p>atom 을 사용하다가 한가지 의문이 들었다. 초기값을 설정해 주는것은 알겠는데 동적으로 초기값을 설정해 줄 수는<br>없을까? 역시 존재했다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">atomFamily</span>&lt;<span class="title">T</span>, <span class="title">Parameter</span>&gt;(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">default</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">    | RecoilValue&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Promise</span>&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | T</span></span></span><br><span class="line"><span class="function"><span class="params">    | (Parameter =&gt; T | RecoilValue&lt;T&gt; | <span class="built_in">Promise</span>&lt;T&gt;),</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dangerouslyAllowMutability?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>): <span class="title">RecoilState</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><p>공식 문서에서 제공해주고 있는 atomFamily 의 type 정의이다. default 부분을 보면 RecoilValue, Promise 그리고 함수로<br>정의되어 있는것을 확인할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> countStateByFamily = atomFamily(&#123;</span><br><span class="line">    key: <span class="string">"countState"</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">defaultValue</span> =&gt;</span> defaultValue</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count2</span>(<span class="params">&#123;number&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = useRecoilValue(countStateByFamily(number));</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="selectorFamily"><a href="#selectorFamily" class="headerlink" title="selectorFamily"></a>selectorFamily</h3><p>atom 과 마찬가지로 selector 도 값을 넘겨주어 사용할 수 있다. atom 과 다른점은 selector 의 get 과 set 은<br>이미 함수를 사용하고 있었다. 값을 넘겨주기 위해 함수가 함수를 리턴해주는 형식이 된다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myNumberState = atom(&#123;</span><br><span class="line">  key: <span class="string">'MyNumber'</span>,</span><br><span class="line">  <span class="keyword">default</span>: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMultipliedState = selectorFamily(&#123;</span><br><span class="line">  key: <span class="string">'MyMultipliedNumber'</span>,</span><br><span class="line">  <span class="keyword">get</span>: (multiplier) =&gt; (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(myNumberState) * multiplier;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>: (multiplier) =&gt; (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt; &#123;</span><br><span class="line">    <span class="keyword">set</span>(myNumberState, newValue / multiplier);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  <span class="keyword">const</span> number = useRecoilValue(myNumberState);</span><br><span class="line">  <span class="keyword">const</span> multipliedNumber = useRecoilValue(myMultipliedState(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;number&#125; / &#123;multipliedNumber&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>아직 버전이 0.0.7 이고 개발이 더 필요해 보인다. 언제 정식 출시 될지도 모르곘지만 기존에 주로 사용되던<br>redux, mobx 와 비교를 해보자면 훨씬 더 간단하고 간결하게 사용할 수 있을것 같다. redux 에서의 action, reducer,<br>middleware 등 작업에 걸리는 시간을 줄일 수 있을것 같다. 그리고 함수형 컴포넌트와 잘 어울릴것 같다.</p><p>참고: <a href="https://recoiljs.org/docs/introduction/installation">RecoilRoot 공식 문서</a><br>Github: <a href="https://github.com/kkangil/react-recoiljs">kkangil</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/24/React-recoiljs-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Storybook 마크다운으로 작성하기</title>
      <link>https://kkangil.github.io/2020/05/17/Storybook-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/</link>
      <guid>https://kkangil.github.io/2020/05/17/Storybook-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Sun, 17 May 2020 07:23:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;우선 이 글에서는 리액트, 타입스크립트를 사용하는 스토리북 세팅이 다 갖춰졌다는 것을 가정하고 써보려고 한다.&lt;br&gt;스토리북은 단위 컴포넌트 테스트를 가능하게 해주고 협업에 있어 엄청난 장점을 갖는다고 생각한다.&lt;br&gt;하지만, 스토리북에서 제공해 주는 Canvas 만 사용했었다. 이로 인해 디테일한 설명, Props 의 type 등 불편한 점이&lt;br&gt;많았다. 이 문제를 어떻게 해결할 수 있을까 라는 고민을 하며 찾아보니 마크다운 문법으로 스토리북을 작성할 수 있다는&lt;br&gt;것을 알게 되었다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>우선 이 글에서는 리액트, 타입스크립트를 사용하는 스토리북 세팅이 다 갖춰졌다는 것을 가정하고 써보려고 한다.<br>스토리북은 단위 컴포넌트 테스트를 가능하게 해주고 협업에 있어 엄청난 장점을 갖는다고 생각한다.<br>하지만, 스토리북에서 제공해 주는 Canvas 만 사용했었다. 이로 인해 디테일한 설명, Props 의 type 등 불편한 점이<br>많았다. 이 문제를 어떻게 해결할 수 있을까 라는 고민을 하며 찾아보니 마크다운 문법으로 스토리북을 작성할 수 있다는<br>것을 알게 되었다.</p><a id="more"></a><h2 id="addon-docs"><a href="#addon-docs" class="headerlink" title="addon-docs"></a>addon-docs</h2><p>우선 .storybook 폴더에 main.js 파일이 존재한다. 이 파일은 스토리북에 대한 설정을 잡아주는 파일이라고 생각하면 된다.</p><p><code>addons</code>, <code>webpack</code> 등의 설정을 해줄 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    addons: [</span><br><span class="line">        <span class="string">'@storybook/addon-knobs/register'</span>,</span><br><span class="line">        <span class="string">'@storybook/addon-actions/register'</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    webpackFinal: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">        config.module.rules.push(&#123;</span><br><span class="line">            test: <span class="regexp">/\.(ts|tsx)$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [[<span class="string">'react-app'</span>, &#123; <span class="attr">flow</span>: <span class="literal">false</span>, <span class="attr">typescript</span>: <span class="literal">true</span> &#125;]],</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="built_in">require</span>.resolve(<span class="string">"react-docgen-typescript-loader"</span>),</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        tsconfigPath: path.join(__dirname, <span class="string">"../tsconfig.json"</span>),</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        config.resolve.extensions.push(<span class="string">'.js'</span>, <span class="string">'.ts'</span>, <span class="string">'.tsx'</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>기존 main.js 의 설정이었다. 사실 스토리북에서 마크다운으로 작성하기 위한 설정은 쉬웠다.</p><p><code>@storybook/addon-docs</code> 를 install 해주고 <code>addons</code> 에 넣어주면 거의 끝났다고 보면 된다.</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @storybook/addon-docs</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    addons: [</span><br><span class="line">        <span class="string">'@storybook/addon-docs/preset'</span>,</span><br><span class="line">        <span class="string">'@storybook/addon-knobs/register'</span>,</span><br><span class="line">        <span class="string">'@storybook/addon-actions/register'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이제 마지막 한가지만 더 추가해주면 된다. 본인은 .storybook 폴더 내부에 config.js 파일이 존재하고 해당 파일에서<br><code>path</code> 와 <code>filter</code> 를 설정해준다. 이때 mdx 도 <code>filter</code> 파일 조건에 추가만 해주면 된다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure(<span class="built_in">require</span>.context(<span class="string">'../`stories`'</span>, <span class="literal">true</span>, /\.stories\.(mdx|tsx)$/), <span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><h2 id="mdx-작성"><a href="#mdx-작성" class="headerlink" title="mdx 작성"></a>mdx 작성</h2><p>이제 기존 storybook 파일을 .jsx 또는 .tsx 에서 .mdx 로 바꾸면 된다.<br>addon-docs 문서를 보면 다른 좋은 기능들이 많지만 본인은 거의 아래의 것들만 사용했다.</p><ul><li>Meta</li><li>Title</li><li>Subtitle</li><li>Story</li><li>Preview</li><li>Props</li></ul><h3 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Meta title=<span class="string">"components/Button"</span> component=&#123;Button&#125; decorators=&#123;[withKnobs]&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li><code>title</code> 은 스토리북 상의 경로에 해당한다. component 라는 폴더 밑에 Button 을 생성한다.</li><li><code>component</code> 는 import 한 리액트 컴포넌트를 전달해주면 된다.</li><li><code>decorators</code> 는 여러개 넘겨줄 수 있는데 addon-knobs 를 사용하기 때문에 withKnobs 만 넘겨주었다.</li></ul><h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Title&gt;Button&lt;<span class="regexp">/Title&gt;</span></span><br></pre></td></tr></table></figure><p><code>Title</code> 은 해당 문서의 제목 즉, h1 태그가 된다. (#)</p><h3 id="Subtitle"><a href="#Subtitle" class="headerlink" title="Subtitle"></a>Subtitle</h3><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Subtitle&gt;Button Component&lt;<span class="regexp">/Subtitle&gt;</span></span><br></pre></td></tr></table></figure><p><code>Subtitle</code> 은 h2 태그에 해당한다. (##)</p><h3 id="Preview-Story"><a href="#Preview-Story" class="headerlink" title="Preview, Story"></a>Preview, Story</h3><p><code>Preview</code> 와  <code>Story</code> 는 거의 세트로 사용했다. <code>Preview</code> 를 사용하면 문서에 영역이 생기는데 이 영역에<br><code>Story</code>가 들어가게 된다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Preview&gt;</span><br><span class="line">    &lt;Story name=<span class="string">"default"</span>&gt;</span><br><span class="line">        &lt;Button/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Story&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Preview&gt;</span><br></pre></td></tr></table></figure><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p>마지막으로 Props 는 컴포넌트에 <code>defaultProps</code> 가 존재하거나 <code>interface</code> 가 정의되어 있다면 해당 컴포넌트의<br>타입과 필수값들을 테이블로 나열해 준다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Props <span class="keyword">of</span>=&#123;Button&#125;/&gt;</span><br></pre></td></tr></table></figure><h2 id="스토리북에서-리액트-문법-사용하기"><a href="#스토리북에서-리액트-문법-사용하기" class="headerlink" title="스토리북에서 리액트 문법 사용하기"></a>스토리북에서 리액트 문법 사용하기</h2><p>추가로 스토리북에서 리액트의 기능 <code>useState</code>, <code>useEffect</code> 또는 함수를 만들어서 사용할 수 없을까에 대한<br>고민을 하게 되었고 역시나 사용할 수 있었다.</p><p>Story 태그에 js 문법을 이용하여 함수를 사용하고 컴포넌트를 리턴해주면 된다. </p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Preview&gt;</span><br><span class="line">    &lt;Story name=<span class="string">"default"</span>&gt;</span><br><span class="line">        &#123;() =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> [state, setState] = useState([]);</span><br><span class="line">            <span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;Button</span><br><span class="line">                    handleClick=&#123;handleClick&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/Story&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Preview&gt;</span><br></pre></td></tr></table></figure><p>아직 풀리지 않는 이상한 점도 있다. Story 태그에 함수를 사용할때 공백줄이 있으면 에러가 발생한다.<br>이 문제에 대해 구글링 해본 결과 이슈로 올라오고 있는데 아직까지 해결되지는 않은것 같다.</p><p>즉 이 코드는 동작하지만,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState([]);</span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 코드에서는 에러가 발생한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState([]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.npmjs.com/package/@storybook/addon-docs">@storybook/addon-docs</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/05/17/Storybook-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jest 메서드-toBe</title>
      <link>https://kkangil.github.io/2020/02/23/jest-%EB%A9%94%EC%84%9C%EB%93%9C-toBe/</link>
      <guid>https://kkangil.github.io/2020/02/23/jest-%EB%A9%94%EC%84%9C%EB%93%9C-toBe/</guid>
      <pubDate>Sun, 23 Feb 2020 06:46:45 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;toBe-value&quot;&gt;&lt;a href=&quot;#toBe-value&quot; class=&quot;headerlink&quot; title=&quot;.toBe(value)&quot;&gt;&lt;/a&gt;.toBe(value)&lt;/h2&gt;&lt;p&gt;.toBe(value) 메서드는 expect 의 값과 비교할때 사용한다. 이것은 Object.is() 를 사용하여 비교하는데 === 연산자를 사용하는 것보다 테스트하기에 더 좋다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; can = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&#39;pamplemousse&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ounces: &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;describe(&lt;span class=&quot;string&quot;&gt;&#39;the can&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  test(&lt;span class=&quot;string&quot;&gt;&#39;has 12 ounces&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expect(can.ounces).toBe(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  test(&lt;span class=&quot;string&quot;&gt;&#39;has a sophisticated name&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expect(can.name).toBe(&lt;span class=&quot;string&quot;&gt;&#39;pamplemousse&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="toBe-value"><a href="#toBe-value" class="headerlink" title=".toBe(value)"></a>.toBe(value)</h2><p>.toBe(value) 메서드는 expect 의 값과 비교할때 사용한다. 이것은 Object.is() 를 사용하여 비교하는데 === 연산자를 사용하는 것보다 테스트하기에 더 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> can = &#123;</span><br><span class="line">  name: <span class="string">'pamplemousse'</span>,</span><br><span class="line">  ounces: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'the can'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'has 12 ounces'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can.ounces).toBe(<span class="number">12</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'has a sophisticated name'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can.name).toBe(<span class="string">'pamplemousse'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>.toBe(value) 메서드에는 소수를 쓰지 않는것이 좋다. 예를 들면 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="number">0.1</span> + <span class="number">0.2</span>).toBe(<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p>위와 같은 경우이다. 자바스크립트에서는 0.1 + 0.2 가 0.3이 아니기 때문이다.</p><h2 id="toHaveBeenCalled"><a href="#toHaveBeenCalled" class="headerlink" title=".toHaveBeenCalled()"></a>.toHaveBeenCalled()</h2><p>mock 함수가 실행됐는지를 테스트하는 메서드이다.<br>mock 함수가 실행됐으면 테스트에 성공하는데 반대로 해당 함수를 실행하지 않는 것이 원하는 결과라면 .not 을 사용해서 테스트 코드를 구성하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drinkAll</span>(<span class="params">callback, flavour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flavour !== <span class="string">'octopus'</span>) &#123;</span><br><span class="line">    callback(flavour);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'drinkAll'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drinks something lemon-flavoured'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>);</span><br><span class="line">    expect(drink).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'does not drink something octopus-flavoured'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>);</span><br><span class="line">    expect(drink).not.toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenCalledTimes-number"><a href="#toHaveBeenCalledTimes-number" class="headerlink" title=".toHaveBeenCalledTimes(number)"></a>.toHaveBeenCalledTimes(number)</h2><p>mock 함수가 몇번 실행됐는지를 확인할때 사용하는 메서드이다. 인자의 number 만큼 실행됐으면 테스트는 성공한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenCalledTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenCalledWith-arg1-arg2-…"><a href="#toHaveBeenCalledWith-arg1-arg2-…" class="headerlink" title="toHaveBeenCalledWith(arg1, arg2, …)"></a>toHaveBeenCalledWith(arg1, arg2, …)</h2><p>mock 함수가 실행됐을때 인자값을 테스트할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'registration applies correctly to orange La Croix'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage = <span class="keyword">new</span> LaCroix(<span class="string">'orange'</span>);</span><br><span class="line">  register(beverage);</span><br><span class="line">  <span class="keyword">const</span> f = jest.fn();</span><br><span class="line">  applyToAll(f);</span><br><span class="line">  expect(f).toHaveBeenCalledWith(beverage);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenLastCalledWith-arg1-arg2-…"><a href="#toHaveBeenLastCalledWith-arg1-arg2-…" class="headerlink" title="toHaveBeenLastCalledWith(arg1, arg2, …)"></a>toHaveBeenLastCalledWith(arg1, arg2, …)</h2><p>mock 함수가 여러번 실행되었을때 마지막 실행의 인자값을 비교할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'applying to all flavors does mango last'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  applyToAllFlavors(drink);</span><br><span class="line">  expect(drink).toHaveBeenLastCalledWith(<span class="string">'mango'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveBeenNthCalledWith-nthCall-arg1-arg2-…"><a href="#toHaveBeenNthCalledWith-nthCall-arg1-arg2-…" class="headerlink" title=".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)"></a>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)</h2><p>mock 함수가 여러번 실행되었을때 순서를 지정하여 인자값을 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveReturned"><a href="#toHaveReturned" class="headerlink" title=".toHaveReturned()"></a>.toHaveReturned()</h2><p>mock 함수가 실행되었고 return 이 되었는지를 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinks returns'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  drink();</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturned();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveReturnedTimes-number"><a href="#toHaveReturnedTimes-number" class="headerlink" title=".toHaveReturnedTimes(number)"></a>.toHaveReturnedTimes(number)</h2><p>mock 함수가 실행되었고 몇번 return 이 되었는지를 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns twice'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  drink();</span><br><span class="line">  drink();</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturnedTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveReturnedWith-value"><a href="#toHaveReturnedWith-value" class="headerlink" title=".toHaveReturnedWith(value)"></a>.toHaveReturnedWith(value)</h2><p>mock 함수가 실행되었고 어떤 값이 리턴되었는지 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns La Croix'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage = &#123;<span class="attr">name</span>: <span class="string">'La Croix'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">beverage</span> =&gt;</span> beverage.name);</span><br><span class="line"></span><br><span class="line">  drink(beverage);</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturnedWith(<span class="string">'La Croix'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveLastReturnedWith-value"><a href="#toHaveLastReturnedWith-value" class="headerlink" title=".toHaveLastReturnedWith(value)"></a>.toHaveLastReturnedWith(value)</h2><p>마지막으로 실행된 mock 함수의 return 값을 테스트하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns La Croix (Orange) last'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage1 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Lemon)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> beverage2 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Orange)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">beverage</span> =&gt;</span> beverage.name);</span><br><span class="line"></span><br><span class="line">  drink(beverage1);</span><br><span class="line">  drink(beverage2);</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveLastReturnedWith(<span class="string">'La Croix (Orange)'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveNthReturnedWith-nthCall-value"><a href="#toHaveNthReturnedWith-nthCall-value" class="headerlink" title=".toHaveNthReturnedWith(nthCall, value)"></a>.toHaveNthReturnedWith(nthCall, value)</h2><p>mock 함수가 여러번 실행되었을때 순서를 지정하여 return 값을 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns expected nth calls'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beverage1 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Lemon)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> beverage2 = &#123;<span class="attr">name</span>: <span class="string">'La Croix (Orange)'</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">beverage</span> =&gt;</span> beverage.name);</span><br><span class="line"></span><br><span class="line">  drink(beverage1);</span><br><span class="line">  drink(beverage2);</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveNthReturnedWith(<span class="number">1</span>, <span class="string">'La Croix (Lemon)'</span>);</span><br><span class="line">  expect(drink).toHaveNthReturnedWith(<span class="number">2</span>, <span class="string">'La Croix (Orange)'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toHaveLength-number"><a href="#toHaveLength-number" class="headerlink" title=".toHaveLength(number)"></a>.toHaveLength(number)</h2><p>length 속성을 가진 객체에서 길이를 비교할때 사용한다. array 와 string 의 길이를 비교할 때 유용하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">'abc'</span>).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">''</span>).not.toHaveLength(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="toHaveProperty-keyPath-value"><a href="#toHaveProperty-keyPath-value" class="headerlink" title=".toHaveProperty(keyPath, value?)"></a>.toHaveProperty(keyPath, value?)</h2><p>객체에 keyPath 의 속성이 있는지 테스트할때 사용한다. 두번째 인자 value 는 인자값으로 keyPath 만 사용했을 경우에는 해당 속성이 있는지만 확인하지만 value 까지 사용하면 keyPath 속성의 값도 같이 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">    <span class="string">'nice.oven'</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'ceiling.height'</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'this house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Example Referencing</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bath'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bedrooms'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'pool'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deep referencing using dot notation</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.area'</span>, <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.amenities'</span>, [</span><br><span class="line">    <span class="string">'oven'</span>,</span><br><span class="line">    <span class="string">'stove'</span>,</span><br><span class="line">    <span class="string">'washer'</span>,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'kitchen.open'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deep referencing using an array containing the keyPath</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'area'</span>], <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(</span><br><span class="line">    [<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>],</span><br><span class="line">    [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">  );</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>, <span class="number">0</span>], <span class="string">'oven'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'nice.oven'</span>]);</span><br><span class="line">  expect(houseForSale).not.toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'open'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Referencing keys with dot in the key itself</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'ceiling.height'</span>], <span class="string">'tall'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeCloseTo-number-numDigits"><a href="#toBeCloseTo-number-numDigits" class="headerlink" title=".toBeCloseTo(number, numDigits?)"></a>.toBeCloseTo(number, numDigits?)</h2><p>소수를 비교할때 근사치로 비교한다. numDigits 를 사용하면 소수 몇번째 자리까지만 비교할 수 있다.<br>자바스크립트에서 0.1 + 0.2 는 0.3 이 아닌 0.30000000000000004 이므로 이 메서드를 사용하면 테스트가 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'adding works sanely with decimals'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">0.2</span> + <span class="number">0.1</span>).toBeCloseTo(<span class="number">0.3</span>, <span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeDefined"><a href="#toBeDefined" class="headerlink" title="toBeDefined()"></a>toBeDefined()</h2><p>expect 의 값이 정의 되어있는지를 확인한다. 즉, undefined 이 아닌지 확인한다. (null 도 true)<br>.not 을 붙이면 undefined 인지 확인할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeDefined'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">null</span>).toBeDefined();</span><br><span class="line">  expect(<span class="literal">undefined</span>).not.toBeDefined();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeFalsy"><a href="#toBeFalsy" class="headerlink" title=".toBeFalsy()"></a>.toBeFalsy()</h2><p>자바스크립트에서 다음 6개의 부정값에 대해서 테스트하는 메서드이다.<br><code>false</code>, <code>0</code>, <code>&#39;&#39;</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">".toBeFalsy()"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">0</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">false</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">null</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">undefined</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="string">''</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">NaN</span>).toBeFalsy();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeTruthy"><a href="#toBeTruthy" class="headerlink" title=".toBeTruthy()"></a>.toBeTruthy()</h2><p>.toBeFalsy 에서 사용되는 6개의 부정값 이외의 값은 truthy 하다.</p><h2 id="toBeGreaterThan-number-bigint"><a href="#toBeGreaterThan-number-bigint" class="headerlink" title=".toBeGreaterThan(number | bigint)"></a>.toBeGreaterThan(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 큰지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeGreaterThan"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">11</span>).toBeGreaterThan(<span class="number">10</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeGreaterThanOrEqual-number-bigint"><a href="#toBeGreaterThanOrEqual-number-bigint" class="headerlink" title=".toBeGreaterThanOrEqual(number | bigint)"></a>.toBeGreaterThanOrEqual(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 크거나 같은지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeGreaterThanOrEqual"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">11</span>).toBeGreaterThanOrEqual(<span class="number">11</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeLessThan-number-bigint"><a href="#toBeLessThan-number-bigint" class="headerlink" title=".toBeLessThan(number | bigint)"></a>.toBeLessThan(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 작은지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeLessThan"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">9</span>).toBeLessThan(<span class="number">10</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeLessThanOrEqual-number-bigint"><a href="#toBeLessThanOrEqual-number-bigint" class="headerlink" title=".toBeLessThanOrEqual(number | bigint)"></a>.toBeLessThanOrEqual(number | bigint)</h2><p>expect 의 값이 number | bigint 보다 작거나 같은지 확인하는 메서드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toBeLessThanOrEqual"</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">11</span>).toBeLessThanOrEqual(<span class="number">11</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="toBeInstanceOf-Class"><a href="#toBeInstanceOf-Class" class="headerlink" title=".toBeInstanceOf(Class)"></a>.toBeInstanceOf(Class)</h2><p>instance 객체를 비교할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(A);</span><br><span class="line">expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).toBeInstanceOf(<span class="built_in">Function</span>);</span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(<span class="built_in">Function</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h2 id="toBeNull"><a href="#toBeNull" class="headerlink" title=".toBeNull()"></a>.toBeNull()</h2><p>expect 값이 null 인지 확인하는 메서드이다.<br>.toBe(null) 을 사용하는 것과 동일하지만 테스트가 실패했을때 에러 메시지가 조금 더 보기 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bloop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'bloop returns null'</span>, () =&gt; &#123;</span><br><span class="line">  expect(bloop()).toBeNull();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toBeUndefined"><a href="#toBeUndefined" class="headerlink" title=".toBeUndefined()"></a>.toBeUndefined()</h2><p>expect 값이 undefined 인지 확인하는 메서드이다.<br>toBeNull 과 마찬가지로 toBe(undefined)를 사용할 수도 있지만 에러 메시지가 조금 더 좋다고 한다.</p><h2 id="toBeNaN"><a href="#toBeNaN" class="headerlink" title=".toBeNaN()"></a>.toBeNaN()</h2><p>expect 값이 NaN 확인하는 메서드이다.</p><h2 id="toContain-item"><a href="#toContain-item" class="headerlink" title=".toContain(item)"></a>.toContain(item)</h2><p>배열 또는 문자에서 item 을 포함하고 있는지 확인하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toContain"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>];</span><br><span class="line">  <span class="keyword">const</span> b = <span class="string">"foo_bar"</span></span><br><span class="line"></span><br><span class="line">  expect(a).toContain(<span class="string">"bar"</span>);</span><br><span class="line">  expect(a).not.toContain(<span class="string">"baz"</span>);</span><br><span class="line">  expect(b).toContain(<span class="string">"bar"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toContainEqual-item"><a href="#toContainEqual-item" class="headerlink" title="toContainEqual(item)"></a>toContainEqual(item)</h2><p>배열에서 일반 특별한 구조를 가진 value (ex. JSON) 를 포함하고 있는지 확인할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toContain"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, &#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;];</span><br><span class="line"></span><br><span class="line">  expect(a).toContain(&#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>toContain 메서드를 사용하면 위의 테스트는 실패되지만 이 경우 toContainEqual 메서드를 사용하면 성공한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"toContainEqual"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, &#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;];</span><br><span class="line">  </span><br><span class="line">  expect(a).toContainEqual(&#123; <span class="attr">delicious</span>: <span class="literal">true</span>, <span class="attr">sour</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toEqual-value"><a href="#toEqual-value" class="headerlink" title="toEqual(value)"></a>toEqual(value)</h2><p>toBe 는 정확하게 테스트하기 위해 Object.is 를 사용한다. 만약 오브젝트의 값을 체크하기를 원한다면 대신 toEqual 를 사용해야한다. toEqual 는 오브젝트 또는 배열의 모든 필드 값을 재귀적으로 체크한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> can1 = &#123;</span><br><span class="line">  flavor: <span class="string">'grapefruit'</span>,</span><br><span class="line">  ounces: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> can2 = &#123;</span><br><span class="line">  flavor: <span class="string">'grapefruit'</span>,</span><br><span class="line">  ounces: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'the La Croix cans on my desk'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'have all the same properties'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can1).toEqual(can2);</span><br><span class="line">  &#125;);</span><br><span class="line">  test(<span class="string">'are not the exact same can'</span>, () =&gt; &#123;</span><br><span class="line">    expect(can1).not.toBe(can2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>toBe 를 사용한 expect(can1).not.toBe(can2); 의 경우 can1 의 객체와 can2 의 객체가 동일한 객체가 아니기 때문에 테스트에 성공한다.</p><h2 id="toMatch-regexpOrString"><a href="#toMatch-regexpOrString" class="headerlink" title=".toMatch(regexpOrString)"></a>.toMatch(regexpOrString)</h2><p>정규식에 대해 문자열을 테스트 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'an essay on the best flavor'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'mentions grapefruit'</span>, () =&gt; &#123;</span><br><span class="line">    expect(essayOnTheBestFlavor()).toMatch(<span class="regexp">/grapefruit/</span>);</span><br><span class="line">    expect(essayOnTheBestFlavor()).toMatch(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'grapefruit'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="toMatchObject-object"><a href="#toMatchObject-object" class="headerlink" title=".toMatchObject(object)"></a>.toMatchObject(object)</h2><p>객체 부분 속성에 대해 일치하는지 테스트한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> desiredHouse = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    wallColor: expect.stringMatching(<span class="regexp">/white|yellow/</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  expect(houseForSale).toMatchObject(desiredHouse);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="toThrow-error"><a href="#toThrow-error" class="headerlink" title=".toThrow(error?)"></a>.toThrow(error?)</h2><p>특정 함수가 호출될 때 에러를 던진다는 것을 테스트하려면 toThrow를 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'throws on octopus'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    drinkFlavor(<span class="string">'octopus'</span>);</span><br><span class="line">  &#125;).toThrow();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>참조: <a href="https://jestjs.io/docs/en/expect#tobevalue">Jest 공식 문서</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/23/jest-%EB%A9%94%EC%84%9C%EB%93%9C-toBe/#disqus_thread</comments>
    </item>
    
    <item>
      <title>렌더링</title>
      <link>https://kkangil.github.io/2020/02/16/%EB%A0%8C%EB%8D%94%EB%A7%81/</link>
      <guid>https://kkangil.github.io/2020/02/16/%EB%A0%8C%EB%8D%94%EB%A7%81/</guid>
      <pubDate>Sun, 16 Feb 2020 08:07:24 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;렌더링-과정&quot;&gt;&lt;a href=&quot;#렌더링-과정&quot; class=&quot;headerlink&quot; title=&quot;렌더링 과정&quot;&gt;&lt;/a&gt;렌더링 과정&lt;/h2&gt;&lt;p&gt;렌더링이란 논리적인 문서(DOM)의 표현식을 그래픽 표현식으로 변형시키는 과정이다. 이 과정은 다음과 같이 크게 2단계를 거쳐 이뤄진다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM 요소와 스타일에 기반을 둔 레이아웃 계산&lt;/li&gt;
&lt;li&gt;계산된 요소의 화면 표현&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;일반적인 전체 흐름은 브라우저에 문서가 로딩됨에 따라 DOM 트리의 구성이 진행되면 레이아웃을 계산한 후 문서에 요소를 그린다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="렌더링-과정"><a href="#렌더링-과정" class="headerlink" title="렌더링 과정"></a>렌더링 과정</h2><p>렌더링이란 논리적인 문서(DOM)의 표현식을 그래픽 표현식으로 변형시키는 과정이다. 이 과정은 다음과 같이 크게 2단계를 거쳐 이뤄진다.</p><ol><li>DOM 요소와 스타일에 기반을 둔 레이아웃 계산</li><li>계산된 요소의 화면 표현</li></ol><p>일반적인 전체 흐름은 브라우저에 문서가 로딩됨에 따라 DOM 트리의 구성이 진행되면 레이아웃을 계산한 후 문서에 요소를 그린다.</p><a id="more"></a><h3 id="렌더링이-진행되는-과정"><a href="#렌더링이-진행되는-과정" class="headerlink" title="렌더링이 진행되는 과정"></a>렌더링이 진행되는 과정</h3><h4 id="DOM-트리-생성"><a href="#DOM-트리-생성" class="headerlink" title="DOM 트리 생성"></a>DOM 트리 생성</h4><p>브라우저는 HTML 태그를 파싱해 DOM 트리를 구성한다. DOM은 데이터의 표현식으로 모든 HTML 태그에는 그에 상응하는 노드가 있으며, 태그 사이에는 텍스트 데이터가 포함될 수 있는데 이 또한 텍스트 노드의 표현식이다.</p><p>각 태그는 태그 데이터의 표현식인 DOM 요소로 1:1로 대응해 표현되며, DOM 요소 노드는 트리 형태로 구성된다. 이를 DOM 트리라 한다.</p><h4 id="스타일-구조체-생성"><a href="#스타일-구조체-생성" class="headerlink" title="스타일 구조체 생성"></a>스타일 구조체 생성</h4><p>스타일 정보를 통해 스타일 구조체를 생성한다. 스타일 정보는 단계적으로 처리되며, 가장 마지막 단계의 스타일 정보가 이전 스타일보다 우선으로 적용된다. 스타일 정보는 다음과 같이 3단계로 나누어 처리된다.</p><ol><li>브라우저 자체에 포함된 기본 스타일 정보</li><li>사용자 정의 스타일</li><li>HTML 인라인 스타일</li></ol><h4 id="렌더-트리-생성"><a href="#렌더-트리-생성" class="headerlink" title="렌더 트리 생성"></a>렌더 트리 생성</h4><p>DOM 트리와 스타일 구조를 통해 렌더 트리를 생성한다.<br>렌더 트리는 DOM 트리와는 다르게 각 노드에 스타일 정보가 설정되어 있고 화면에 표현되는 노드로 구성된다. 어떤 노드의 스타일이 ‘display: none’ 으로 설정되어 있으면 해당 노드는 렌더 트리에 포함되지 않는다. 그렇기 때문에 DOM 트리와 렌더 트리의 노드는 서로 1:1로 대응되지 않는다. head, title, script 등과 같이 화면에 표현되는 노드가 아니므로 DOM 트리에는 포함되어 있지만 렌더 트리에는 포함되어 있지 않다.</p><h4 id="레이아웃-처리"><a href="#레이아웃-처리" class="headerlink" title="레이아웃 처리"></a>레이아웃 처리</h4><p>렌더 트리의 각 노드의 크기가 계산되고 문서에서 정확한 위치에 배치되도록 위치를 계산한다. 루트에서 하위 노드로 반복되며 진행한다.</p><h4 id="페인트"><a href="#페인트" class="headerlink" title="페인트"></a>페인트</h4><p>렌더 트리를 순회하면서 페인트 함수를 호출해 노드를 화면에 표현한다.</p><hr/><h3 id="리플로우-reflow-와-리페인트-repaint"><a href="#리플로우-reflow-와-리페인트-repaint" class="headerlink" title="리플로우(reflow) 와 리페인트(repaint)"></a>리플로우(reflow) 와 리페인트(repaint)</h3><p>렌더링이 모두 완료된 상태에서 사용자의 인터랙션 또는 기능에 따라 화면의 일부 영역에 변경 요인이 발생한다. 이러한 작업이 발생하면 구성돼 있는 렌더 트리가 변경되어야 하며 리플로우 또는 리페인트가 발생한다.</p><h4 id="리플로우"><a href="#리플로우" class="headerlink" title="리플로우"></a>리플로우</h4><p>변경이 필요한 렌더 트리에 대한 유효성 확인 작업과 함께 노드의 크기와 위치를 다시 계산한다. 노드의 ‘크기’ 또는 ‘위치’가 바뀌어 현재 레이아웃에 영향을 미쳐 배치를 <code>다시</code> 해야 할 때 리플로우가 발생한다.</p><p>특정 요소에 리플로우가 발생하면 요소의 DOM 구조에 따라 자식 요소와 부모 요소 역시 다시 계산될 수 있으며, 경우에 따라서는 문서 전체에 리플로우가 발생할 수도 있다.</p><h4 id="리페인트"><a href="#리페인트" class="headerlink" title="리페인트"></a>리페인트</h4><p>변경 영역의 결과를 표현하기 위해 화면이 업데이트 되는것을 의미한다. 리플로우각 발생하거나 배경색 변경 등의 단순한 스타일 변경과 같은 작업이 발생하는 경우다.</p><p>리플로우와 리페인트 모두 처리 비용이 발생하지만 리페인트보다 리플로우의 비용이 훨씬 높다. 리플로우는 변경 범위에 따라 전체 페이지의 레이아웃을 변경해야 할 수도 있기 때문이다. 어느 경우든 리플로우와 리페인트는 코드를 작성할 때 최소화해야 한다.</p><h4 id="발생-요인"><a href="#발생-요인" class="headerlink" title="발생 요인"></a>발생 요인</h4><ul><li>DOM 노드의 변경</li><li>DOM 노드의 노출 속성을 통한 변경: display: none 은 리플로우와 리페인트를 발생시키지만 비슷한 속성인 visibility: hidden 은 요소가 차지한 영역을 유지해 레이아웃에 영향을 주지 않으므로 리페인트만 발생한다.</li><li>스크립트 애니메이션: 애니메이션은 DOM 노드의 이동과 스타일 변경이 짧은 시간 내에 수차례 반복해 발생되는 작업이다.</li><li>스타일</li><li>사용자의 액션</li></ul><hr/><h2 id="리플로우-최소화-방법"><a href="#리플로우-최소화-방법" class="headerlink" title="리플로우 최소화 방법"></a>리플로우 최소화 방법</h2><h3 id="작업-그룹핑"><a href="#작업-그룹핑" class="headerlink" title="작업 그룹핑"></a>작업 그룹핑</h3><p>DOM 요소의 정보를 요청하고 변경하는 코드는 같은 형태의 작업끼리 그룹으로 묶어 실행시키는 것이 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width = <span class="built_in">document</span>.getElementById(<span class="string">"layer1"</span>).style.width;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer2"</span>).style.width = width;</span><br><span class="line">  <span class="keyword">var</span> height = <span class="built_in">document</span>.getElementById(<span class="string">"layer3"</span>).style.height;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer4"</span>).style.height = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 요소의 스타일 정보를 요청하고, 반환된 값을 다른 요소의 스타일 변경하는 데 사용한다. 그 후 다시 다른 요소에 동일한 형태의 작업이 반복된다. 이 코드를 실행하면 리플로우가 여러 번 발생할 수 있다.<br>스타일 조회 -&gt; 변경 -&gt; 리플로우 -&gt; 스타일 조회 -&gt; 변경 -&gt; 리플로우</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width = <span class="built_in">document</span>.getElementById(<span class="string">"layer1"</span>).style.width;</span><br><span class="line">  <span class="keyword">var</span> height = <span class="built_in">document</span>.getElementById(<span class="string">"layer3"</span>).style.height;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer2"</span>).style.width = width;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"layer4"</span>).style.height = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 비슷한 형태의 작업 끼리 그룹으로 묶어 실행되도록 순서를 변경하면 렌더링 처리를 향상시킬 수 있다.</p><p>스타일 조회 -&gt; 스타일 조회 -&gt; 변경 -&gt; 변경 -&gt; 리플로우</p><h3 id="실행-사이클"><a href="#실행-사이클" class="headerlink" title="실행 사이클"></a>실행 사이클</h3><p>브라우저에서 자바스크립트 실행은 <code>이벤트 루프</code> 모델을 따른다. 기본적으로 브라우저는 이벤트가 발생하면 바로 처리가 가능하도록 유휴(idle) 상태에 머무른다. 그러다 어떤 요청에 의해 유휴 상태가 해제되면 작업이 실행된다. 작업이 실행되면 브라우저는 작업의 실행 결과에 따른 리페인트가 완료될 때까지 기다린다. 이러한 실행 사이클로 인해 타이머를 사용하면 수차례의 리플로우와 리페인트가 발생될 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reflow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).style.height = <span class="string">"50px"</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"box2"</span>).style.height = <span class="string">"70px"</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>타이머의 설정 시간을 0으로 설정해도 브라우저가 유휴 상태(stack 이 비워져 있는 상태)가 아니면 그 상태가 되기까지 실행되지 않는다. 첫 번째 요소에 대한 작업이 한 사이클 내에서 실행되고, 타이머의 실행은 먼저 실행된 사이클이 끝난 다음에 진행된다. 이로 인해 결과적으로는 리플로우와 리페인트가 두 번 발생하게 된다. 이와 같이 리플로우와 리페인트가 일어날 수 있는 작업은 가능하면 한 실행 사이클 안에서 실행하도록 처리하는 편이 효과적이다.</p><h3 id="노출-제어를-통한-리플로우-최소화-방법"><a href="#노출-제어를-통한-리플로우-최소화-방법" class="headerlink" title="노출 제어를 통한 리플로우 최소화 방법"></a>노출 제어를 통한 리플로우 최소화 방법</h3><p>요소의 스타일을 변경하면 리페인트는 반드시 일어나며, 변경 형태에 따라 리플로우도 일어난다.</p><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>기본적으로 리플로우와 리페인트는 모두 화면에 변경된 사항이 반영되는 시점에 발생한다. 여러 속성의 스타일을 변경하는 중간 단계에서는 화면에 표시하지 않고, 작업이 완료되고 최종 결과가 반영되는 마지막 시점에 요소를 다시 표시한다면 리플로우와 리페인트의 발생 횟수를 크게 줄일 수 있다.</p><p>이 코드는 값을 여러번 변경하며 값이 변경될 때마다 리플로우와 리페인트가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">50</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  element.style.width = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  element.style.borderWidth = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 다음과 같이 요소를 보이지 않게 하고 모든 변경이 반영된 이후에 표시하면 처음과 마지막 시점 두 번으로 리플로우 발생 횟수가 줄어든다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span><br><span class="line"></span><br><span class="line">element.style.display = <span class="string">"none"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">50</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  element.style.width = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  element.style.borderWidth = i + <span class="string">"px"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.style.display = <span class="string">"block"</span>;</span><br></pre></td></tr></table></figure><p>display 의 none, block 을 이용한 최소화 방법이다.</p><h4 id="노드-복제"><a href="#노드-복제" class="headerlink" title="노드 복제"></a>노드 복제</h4><p>변경하려는 요소의 노드를 복제한 후 복제된 노드에 필요한 작업을 실행하는 방법이다. 복제된 노드는 DOM 트리에 추가된 상태가 아니므로 렌더링 성능에 영향을 줄 수 있는 작업을 실행하더라도 리플로우나 리페인트가 발생하지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span><br><span class="line"><span class="keyword">var</span> clone = element.cloneNode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  clone.style.width = i + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentNode.replaceChild(clone, element);</span><br></pre></td></tr></table></figure><p>작업이 모두 완료된 이후 복제된 노드를 원래 노드와 치환해 DOM 트리에 변경된 사항이 적용되게 한다. 그러면 치환 시점에만 리플로우와 리페인트가 발생하는 것이므로 display 속성을 사용하는것 보다 적게 발생한다.</p><h4 id="캐싱"><a href="#캐싱" class="headerlink" title="캐싱"></a>캐싱</h4><p>여기서의 캐싱은 별도의 변수에 자주 사용하는 값을 저장하는 것이다. 특정 속성과 메서드를 사용하기만 해도 리플로우 발생하는 경우가 있다. 자주 사용하는 속성의 값이나 메서드의 반환값을 변수에 저장하면 직접 속성이나 메서드를 호출하는 횟수를 줄여 성능을 향상 시킬 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (condition) &#123;</span><br><span class="line">  el.style.width = el.scrollWidth + <span class="string">"px"</span>;</span><br><span class="line">  el.style.height = el.scrollHeight + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scrollWidth 와 scrollHeight 메서드는 호출하기만 해도 리플로우가 발생한다. 이 경우 값을 최대한 별도의 변수에 캐싱해 자주 호출되지 않게 하면 리플로우의 발생 빈도를 낮출 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollWidth = el.scrollWidth;</span><br><span class="line"><span class="keyword">var</span> scrollHeight = el.scrollHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (condition) &#123;</span><br><span class="line">  el.style.width = scrollWidth + <span class="string">"px"</span>;</span><br><span class="line">  el.style.height = scrollHeight + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="하드웨어-가속-렌더링"><a href="#하드웨어-가속-렌더링" class="headerlink" title="하드웨어 가속 렌더링"></a>하드웨어 가속 렌더링</h2><p>브라우저는 웹 페이지 컨텐츠 렌더링 작업의 대부분을 CPU 에 의존해 왔다. 하지만 모바일 기기에도 GPU 가 기본으로 포함되고, 비디오, 3D 그래픽 등과 같이 화려하고 용량이 큰 컨텐트의 소비가 늘어 이를 활용하는 방법에 대한 고민도 커졌다.</p><p>GPU를 렌더링에 활용하면 성능에 이점이 있다. 일반적인 렌더링은 CPU 에서 렌더링 요소에 대한 연산 작업을 처리하면 그 결과값을 사용해 GPU 가 출력하는 과정을 거친다. 그러나 CPU 에서 처리되던 작업이 GPU 에 위임되면 처리 결과값을 GPU 로 전달하는 과정이 생략될 수 있고 CPU 도 다른 작업에 더 집중할 수 있다.</p><p>GPU 의 기본적인 하드웨어 디자인은 대용량의 픽셀 데이터를 조합하고 그리는 작업을 하게 되어 있으므로 CPU 보다 GPU 가 렌더링 작업을 최적으로 실행할 수 있다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/16/%EB%A0%8C%EB%8D%94%EB%A7%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jest 메서드 - expect</title>
      <link>https://kkangil.github.io/2020/02/16/jest-%EB%A9%94%EC%84%9C%EB%93%9C-expect/</link>
      <guid>https://kkangil.github.io/2020/02/16/jest-%EB%A9%94%EC%84%9C%EB%93%9C-expect/</guid>
      <pubDate>Sun, 16 Feb 2020 05:59:50 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;expect-value&quot;&gt;&lt;a href=&quot;#expect-value&quot; class=&quot;headerlink&quot; title=&quot;expect(value)&quot;&gt;&lt;/a&gt;expect(value)&lt;/h3&gt;&lt;p&gt;expect 함수는 값을 테스트 하고 싶을 때 사용한다. 드물게 expect 함수만 사용해서 테스트를 할 수 있지만 값을 테스트하기 위해 &lt;code&gt;matcher&lt;/code&gt; 함수를 함께 사용한다.&lt;/p&gt;
&lt;h3 id=&quot;expect-extend-matchers&quot;&gt;&lt;a href=&quot;#expect-extend-matchers&quot; class=&quot;headerlink&quot; title=&quot;expect.extend(matchers)&quot;&gt;&lt;/a&gt;expect.extend(matchers)&lt;/h3&gt;&lt;p&gt;expect.extend 함수를 사용하여 Jest 에서 제공하는 matcher 가 아닌 직접 만들어서 사용할 수 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="expect-value"><a href="#expect-value" class="headerlink" title="expect(value)"></a>expect(value)</h3><p>expect 함수는 값을 테스트 하고 싶을 때 사용한다. 드물게 expect 함수만 사용해서 테스트를 할 수 있지만 값을 테스트하기 위해 <code>matcher</code> 함수를 함께 사용한다.</p><h3 id="expect-extend-matchers"><a href="#expect-extend-matchers" class="headerlink" title="expect.extend(matchers)"></a>expect.extend(matchers)</h3><p>expect.extend 함수를 사용하여 Jest 에서 제공하는 matcher 가 아닌 직접 만들어서 사용할 수 있다.</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">expect.extend(&#123;</span><br><span class="line">  toBeWithinRange(received, floor, ceiling) &#123;</span><br><span class="line">    <span class="keyword">const</span> pass = received &gt;= floor &amp;&amp; received &lt;= ceiling;</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> not to be within range <span class="subst">$&#123;floor&#125;</span> - <span class="subst">$&#123;ceiling&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">true</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> to be within range <span class="subst">$&#123;floor&#125;</span> - <span class="subst">$&#123;ceiling&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">false</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'numeric ranges'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">100</span>).toBeWithinRange(<span class="number">90</span>, <span class="number">110</span>);</span><br><span class="line">  expect(<span class="number">101</span>).not.toBeWithinRange(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">  expect(&#123; <span class="attr">apples</span>: <span class="number">6</span>, <span class="attr">bananas</span>: <span class="number">3</span> &#125;).toEqual(&#123;</span><br><span class="line">    apples: expect.toBeWithinRange(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    bananas: expect.not.toBeWithinRange(<span class="number">11</span>, <span class="number">20</span>),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>toBeWithinRange</code> 라는 matcher 를 만드는 방법이다. expect 의 값이 첫번째 인자로 넘어간다. 성공 했을경우 성공 사유 message 와 pass를 true로 return 해준다. 살패 했을경우는 반대로 실패 사유 message 와 pass 를 false 로 return 해준다.</p><p>expect.extend 는 비동기 함수 호출도 지원한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">expect.extend(&#123;</span><br><span class="line">  <span class="keyword">async</span> toBeDivisibleByExternalValue(received) &#123;</span><br><span class="line">    <span class="keyword">const</span> externalValue = <span class="keyword">await</span> getExternalValueFromRemoteSource();</span><br><span class="line">    <span class="keyword">const</span> pass = received % externalValue == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> not to be divisible by <span class="subst">$&#123;externalValue&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">true</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="string">`expected <span class="subst">$&#123;received&#125;</span> to be divisible by <span class="subst">$&#123;externalValue&#125;</span>`</span>,</span><br><span class="line">        pass: <span class="literal">false</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'is divisible by external value'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="number">100</span>).toBeDivisibleByExternalValue();</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="number">101</span>).not.toBeDivisibleByExternalValue();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Custom-Matchers-API"><a href="#Custom-Matchers-API" class="headerlink" title="Custom Matchers API"></a>Custom Matchers API</h4><p>Macher 들은 항상 두개의 key 를 포함하고 있는 객체를 리턴해야한다. pass 는 성공/실패 여부이고 message 는 테스트가 실패 했을 경우 보여진다. .not() 메서드를 사용하면 실패 했을때 pass: true 의 message 가 보여진다.</p><h3 id="expect-anything"><a href="#expect-anything" class="headerlink" title="expect.anything"></a>expect.anything</h3><p>null 과 undefined 을 제외한 모든 값들과 일치한다. 즉, null 과 undefined 외의 모든 값들은 동일하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'map calls its argument with a non-null argument'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">  [<span class="number">1</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> mock(x));</span><br><span class="line">  expect(mock).toBeCalledWith(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위의 테스트 코드는 성공할 것이다. 하지만 <code>expect(mock).toBeCalledWith(2);</code> 로 바꾸게 된다면 배열의 length 가 1 이므로 실패할 것이다. 만약 mock() 함수가 몇번 실행이 되는지 상관없이 테스트 케이스를 성공 처리 하고 싶을때 anything 을 사용하는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(mock).toBeCalledWith(expect.anything());</span><br></pre></td></tr></table></figure><h3 id="expect-any-constructor"><a href="#expect-any-constructor" class="headerlink" title="expect.any(constructor)"></a>expect.any(constructor)</h3><p>expect.any(constructor) matches anything that was created with the given constructor</p><p>expect.any 는 주어진 생성자와 값이 해당 생성자에 일치하는 지를 테스트 한다. <code>toEqual</code> 과 <code>toBeCalledWith</code> 함수에 값대신 해당 메서드를 사용할 수 있다.</p><p>randocall 함수의 return 값이 Number 인지 테스트하는 코드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randocall</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">6</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'randocall calls its callback with a number'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">  randocall(mock);</span><br><span class="line">  expect(mock).toBeCalledWith(expect.any(<span class="built_in">Number</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="expect-arrayContaining-array"><a href="#expect-arrayContaining-array" class="headerlink" title="expect.arrayContaining(array)"></a>expect.arrayContaining(array)</h3><p>기대값이 expect.arrayContaining(array) 메서드에 주어지는 배열의 요소를 모두 포함하고 있는지 확인할 때 사용하는 메서드이다. <code>toEqual</code> 과 <code>toBeCalledWith</code> 함수에 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>];</span><br><span class="line">  it(<span class="string">'matches even if received contains additional elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'does not match if received does not contain expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">  expect([<span class="string">'Alice'</span>, <span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>첫번째 테스트의 경우 기대값 요소에 ‘Alice’, ‘Bob’ 이 포함되어 있기 때문에 성공한다. 두번째의 경우는 ‘Alice’ 를 포함하고 있지 않기 때문에 실패한다. 세번째 테스트 경우처럼 배열 요소에 중복이 있어도 상관없이 테스트는 성공한다.</p><p>expect.not.arrayContaining(array) 메서드도 사용 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="string">'Samantha'</span>];</span><br><span class="line">  it(<span class="string">'matches if the actual array does not contain the expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Eve'</span>]).toEqual(</span><br><span class="line">      expect.not.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="expect-objectContaining-object"><a href="#expect-objectContaining-object" class="headerlink" title="expect.objectContaining(object)"></a>expect.objectContaining(object)</h3><p>객체의 key 와 value 를 포함하고 있는지 테스트할때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'objectContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'matches if the actual object does contain expected key: value pairs'</span>, () =&gt; &#123;</span><br><span class="line">    expect(&#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;).toEqual(expect.objectContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>foo</code> 라는 key 가 없어서 위 테스트는 실패한다. 만약 { bar: ‘baz’ } 를 { foo: ‘baz’ } 객체로 변경해서 테스트 해보면 실패하는것을 확인할 수 있다. objectContaining 는 key/value 쌍으로 동일해야 성공한다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'onPress gets called with the right thing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onPress = jest.fn();</span><br><span class="line">  simulatePresses(onPress);</span><br><span class="line">  expect(onPress).toBeCalledWith(</span><br><span class="line">    expect.objectContaining(&#123;</span><br><span class="line">      x: expect.any(<span class="built_in">Number</span>),</span><br><span class="line">      y: expect.any(<span class="built_in">Number</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>objectContaining 객체의 value 에 특정한 값이 아니라 any, anything 도 사용할 수 있다. expect.not.objectContaining(object) 메서드도 사용 가능하다.</p><h3 id="expect-stringContaining-string"><a href="#expect-stringContaining-string" class="headerlink" title="expect.stringContaining(string)"></a>expect.stringContaining(string)</h3><p>expect.stringContaining(string) 은 주어지는 문자를 포함하고 있는지 테스트한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'stringContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'matches if the received value does contain the expected substring'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'Hello world!'</span>).toEqual(expect.stringContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>expect.not.stringContaining(string) 도 사용 가능하다.</p><h3 id="expect-stringMatching-string-regexp"><a href="#expect-stringMatching-string-regexp" class="headerlink" title="expect.stringMatching(string | regexp)"></a>expect.stringMatching(string | regexp)</h3><p>주어진 string 이나 정규식에 일치하는지 테스트할 때 사용한다. string 이 주어지는 경우 완전하게 일치 해야하며 정규식을 사용하는 경우는 해당 정규식에 일치하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'stringMatching in arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^Alic/</span>),</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^[BR]ob/</span>),</span><br><span class="line">  ];</span><br><span class="line">  it(<span class="string">'matches even if received contains additional elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alicia'</span>, <span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'does not match if received does not contain expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).not.toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="expect-assertions-number"><a href="#expect-assertions-number" class="headerlink" title="expect.assertions(number)"></a>expect.assertions(number)</h3><p>test 함수의 callback 함수 내부에서 테스트가 몇번이 일어나는지 확인하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'assertions count'</span>, () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">2</span>);</span><br><span class="line">  expect(<span class="literal">true</span>).toBeTruthy();</span><br><span class="line">  expect(<span class="literal">null</span>).toBeFalsy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 테스트코드에서 expect.assertions 을 제외하고 두개의 테스트를 하고있다.</p><h3 id="expect-hasAssertions"><a href="#expect-hasAssertions" class="headerlink" title="expect.hasAssertions()"></a>expect.hasAssertions()</h3><p>expect.hasAssertions() 함수는 test 함수의 callback 함수 내부에서 테스트가 최소 한번 실행되고 있는지 테스트하는 함수다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'has assertions'</span>, () =&gt; &#123;</span><br><span class="line">  expect.hasAssertions();</span><br><span class="line">  expect(<span class="literal">null</span>).toBeFalsy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="resolves"><a href="#resolves" class="headerlink" title="resolves"></a>resolves</h3><p>성공된 Promise 의 value 를 가져올때 사용한다. resolves 를 사용하지 않으면 received value 는 {} 가 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>async/await 과도 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'async/await resolves to lemon'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.not.toBe(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="rejects"><a href="#rejects" class="headerlink" title="rejects"></a>rejects</h3><p>rejects 는 resolves 와는 반대로 실패된 Promise 의 reason 을 가져올 때 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(</span><br><span class="line">    <span class="string">'octopus'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>참조: <a href="https://jestjs.io/docs/en/expect">Jest 공식 문서</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/16/jest-%EB%A9%94%EC%84%9C%EB%93%9C-expect/#disqus_thread</comments>
    </item>
    
    <item>
      <title>jest 메서드 - globals</title>
      <link>https://kkangil.github.io/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/</link>
      <guid>https://kkangil.github.io/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/</guid>
      <pubDate>Sun, 09 Feb 2020 08:01:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;Jest 제공 메서드들 중 Globals 메서드에 대해서 정리해보려 한다. Jest 공식 문서에 나와 있는 Globals 메서드 정의는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Globals 메서드를 사용해서 전역 환경을 설정한다. 이것은 필수로 설정해 줄 필요는 없다.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Jest 제공 메서드들 중 Globals 메서드에 대해서 정리해보려 한다. Jest 공식 문서에 나와 있는 Globals 메서드 정의는 다음과 같다.</p><blockquote><p>Globals 메서드를 사용해서 전역 환경을 설정한다. 이것은 필수로 설정해 줄 필요는 없다.</p></blockquote><a id="more"></a><h3 id="afterAll-fn-timeout"><a href="#afterAll-fn-timeout" class="headerlink" title="afterAll(fn, timeout)"></a>afterAll(fn, timeout)</h3><p>이름에서 유추할 수 있듯이 테스트가 진행되는 동안 매번 실행되는 것이 아니라 모든 테스트가 완료 되었을 때 실행된다. 만약 인자의 함수가 Promise 이거나 generator 일 경우, Jest 는 완료를 기다린다.</p><p>다른 테스트와 공유되는 전역 환경 상태를 초기화 할때 주로 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanUpDatabase</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  db.cleanUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  cleanUpDatabase(globalDatabase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트가 모두 완료될 때 실행된다.</p><h3 id="afterEach-fn-timeout"><a href="#afterEach-fn-timeout" class="headerlink" title="afterEach(fn, timeout)"></a>afterEach(fn, timeout)</h3><p>afterAll 메서드와 달리 afterEach는 하나의 테스트가 완료될 때마다 실행된다. 각 테스트에 의해 생성된 임시 상태 또는 변수를 초기화 하는 경우 주로 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanUpDatabase</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  db.cleanUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  cleanUpDatabase(globalDatabase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 완료될 때 실행된다.</p><h3 id="beforeAll-fn-timeout"><a href="#beforeAll-fn-timeout" class="headerlink" title="beforeAll(fn, timeout)"></a>beforeAll(fn, timeout)</h3><p>afterAll과 정반대라고 생각하면 된다. 이 메서드는 테스트가 실행되기전 최초에 한번 실행된다. 각 테스트를 진행하기 위해 데이터를 설정해 줄때 주로 사용된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Clears the database and adds some testing data.</span></span><br><span class="line">  <span class="comment">// Jest will wait for this promise to resolve before running tests.</span></span><br><span class="line">  <span class="keyword">return</span> globalDatabase.clear().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> globalDatabase.insert(&#123;<span class="attr">testData</span>: <span class="string">'foo'</span>&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트를 하기전에 실행된다.</p><h3 id="beforeEach-fn-timeout"><a href="#beforeEach-fn-timeout" class="headerlink" title="beforeEach(fn, timeout)"></a>beforeEach(fn, timeout)</h3><p>하나의 테스트가 시작되기 전에 실행된다. descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 시작되기 전 실행된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalDatabase = makeGlobalDatabase();</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Clears the database and adds some testing data.</span></span><br><span class="line">  <span class="comment">// Jest will wait for this promise to resolve before running tests.</span></span><br><span class="line">  <span class="keyword">return</span> globalDatabase.clear().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> globalDatabase.insert(&#123;<span class="attr">testData</span>: <span class="string">'foo'</span>&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>중복된 코드를 제거할때 유용하게 사용할 수 있다.</p><h3 id="describe-name-fn"><a href="#describe-name-fn" class="headerlink" title="describe(name, fn)"></a>describe(name, fn)</h3><p>describe 메서드는 몇몇의 관계가 있는 테스트들을 그룹으로 묶어 생성할 때 사용한다. test 메서드를 최상위에서 바로 실행시킬 수 있지만, describe 메서드로 관련있는 테스트 끼리 묶어서 작성하게 되면 가독성이 높아진다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myBeverage = &#123;</span><br><span class="line">  delicious: <span class="literal">true</span>,</span><br><span class="line">  sour: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'my beverage'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'is delicious'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'is not sour'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>describe 메서드 함수 내부에서 다시 describe로 그룹화를 할 수 있다.</p><h3 id="describe-each-table-name-fn-timeout"><a href="#describe-each-table-name-fn-timeout" class="headerlink" title="describe.each(table)(name, fn, timeout)"></a>describe.each(table)(name, fn, timeout)</h3><p>여러가지 다른 데이터로 중복되는 테스트를 수행할때 describe.each를 활용할 수 있다. 하나의 테스트 케이스로  값이 다른 데이터들로 테스를 수행하는 것이다.</p><ul><li>table: 인자로 배열을 넘기면 fn 함수의 인자로 사용 가능하다.</li><li>name: 테스트의 이름 printf formatting 기법을 사용할 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe.each([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">])(<span class="string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; &#123;</span><br><span class="line">  test(<span class="string">`returns <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).toBe(expected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be greater than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeGreaterThan(expected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">`returned value not be less than <span class="subst">$&#123;expected&#125;</span>`</span>, () =&gt; &#123;</span><br><span class="line">    expect(a + b).not.toBeLessThan(expected);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>describe.each<code>table</code> 형식으로도 사용 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe.each<span class="string">`</span></span><br><span class="line"><span class="string">  a    | b    | expected</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;<span class="number">2</span>&#125;</span> | <span class="subst">$&#123;<span class="number">1</span>&#125;</span> | <span class="subst">$&#123;<span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="describe-only-name-fn"><a href="#describe-only-name-fn" class="headerlink" title="describe.only(name, fn)"></a>describe.only(name, fn)</h3><p>오직 하나의 describe 그룹의 테스트만 수행하고 싶을 때 사용한다. 다른 describe 테스트들은 skip 된다.<br><code>describe.only.each</code> 메서드도 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe.only(<span class="string">'my beverage'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'is delicious'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'is not sour'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'my other beverage'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... will be skipped</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="describe-skip-name-fn"><a href="#describe-skip-name-fn" class="headerlink" title="describe.skip(name, fn)"></a>describe.skip(name, fn)</h3><p>특정한 describe 그룹을 테스트 하고 싶지 않을때 사용한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'my beverage'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'is delicious'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.delicious).toBeTruthy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'is not sour'</span>, () =&gt; &#123;</span><br><span class="line">    expect(myBeverage.sour).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe.skip(<span class="string">'my other beverage'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... will be skipped</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>describe.skip.each(table)(name, fn)</code> 메서드도 사용가능하다.</p><h3 id="test-name-fn-timeout"><a href="#test-name-fn-timeout" class="headerlink" title="test(name, fn, timeout)"></a>test(name, fn, timeout)</h3><p>test 메서드를 사용하여 테스트를 수행할 수 있다. Promise나 비동기 방법을 지원한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'did not rain'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'has lemon in it'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetchBeverageList().then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    expect(list).toContain(<span class="string">'lemon'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="test-each-table-name-fn-timeout"><a href="#test-each-table-name-fn-timeout" class="headerlink" title="test.each(table)(name, fn, timeout)"></a>test.each(table)(name, fn, timeout)</h3><p>describe.each(table)(name, fn, timeout)와 개념은 동일하다. 하지만 describe는 그룹화이기 때문에 여러가지 테스트를 동시에 수행할 수 있지만 test.each는 단일 테스트에 대한 each 이다.</p><h3 id="test-only-name-fn-timeout"><a href="#test-only-name-fn-timeout" class="headerlink" title="test.only(name, fn, timeout)"></a>test.only(name, fn, timeout)</h3><p>describe.only 와 개념은 동일하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.only(<span class="string">'it is raining'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBeGreaterThan(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'it is not snowing'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfSnow()).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>오직 한가지의 test만 수행되며 describe 내부의 test들도 수행되지 않는다.</p><p><code>test.only.each(table)(name, fn)</code> 메서드도 사용할 수 있다.</p><h3 id="test-skip-name-fn"><a href="#test-skip-name-fn" class="headerlink" title="test.skip(name, fn)"></a>test.skip(name, fn)</h3><p>수행하고 싶지 않은 테스트를 건너뛰게 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'it is raining'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfRain()).toBeGreaterThan(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test.skip(<span class="string">'it is not snowing'</span>, () =&gt; &#123;</span><br><span class="line">  expect(inchesOfSnow()).toBe(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>test.skip.each(table)(name, fn)</code> 도 사용가능하다.</p><h3 id="test-todo-name"><a href="#test-todo-name" class="headerlink" title="test.todo(name)"></a>test.todo(name)</h3><p>추가되어야할 테스트 TODO를 남겨놓을 수 있다. 해당 메서드를 사용하면 다른 테스트들과 달리 강조되어 표시된다. 인자로 callback을 넘기면 에러가 발생한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">test.todo(<span class="string">'add should be associative'</span>);</span><br></pre></td></tr></table></figure><p>참조: <a href="https://jestjs.io/docs/en/api">Jest 공식 문서</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/#disqus_thread</comments>
    </item>
    
    <item>
      <title>성능을 높이는 코드 스타일</title>
      <link>https://kkangil.github.io/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/</link>
      <guid>https://kkangil.github.io/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/</guid>
      <pubDate>Sun, 09 Feb 2020 05:58:17 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;객체의-생성-초기화-성능&quot;&gt;&lt;a href=&quot;#객체의-생성-초기화-성능&quot; class=&quot;headerlink&quot; title=&quot;객체의 생성, 초기화 성능&quot;&gt;&lt;/a&gt;객체의 생성, 초기화 성능&lt;/h2&gt;&lt;p&gt;많이 사용하지만 성능을 생각하지 않고 작성하는 코드에 객체 선언과 초기화 구문이 있다. 배열(Array) 형식의 객체와 오브젝트(Object) 형식의 객체를 생성하고 초기화하는 방법의 성능을 측정해 보고 두 코드 사이에 어떤 차이점이 있는지 비교해 보고자 한다.&lt;/p&gt;
&lt;h3 id=&quot;배열의-생성-초기화-성능-비교&quot;&gt;&lt;a href=&quot;#배열의-생성-초기화-성능-비교&quot; class=&quot;headerlink&quot; title=&quot;배열의 생성, 초기화 성능 비교&quot;&gt;&lt;/a&gt;배열의 생성, 초기화 성능 비교&lt;/h3&gt;&lt;p&gt;배열을 생성자 혹인 리터럴([]) 형식을 사용해 객체를 생성할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Array() 생성자 사용&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 리터럴 형식으로 배열 생성&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="객체의-생성-초기화-성능"><a href="#객체의-생성-초기화-성능" class="headerlink" title="객체의 생성, 초기화 성능"></a>객체의 생성, 초기화 성능</h2><p>많이 사용하지만 성능을 생각하지 않고 작성하는 코드에 객체 선언과 초기화 구문이 있다. 배열(Array) 형식의 객체와 오브젝트(Object) 형식의 객체를 생성하고 초기화하는 방법의 성능을 측정해 보고 두 코드 사이에 어떤 차이점이 있는지 비교해 보고자 한다.</p><h3 id="배열의-생성-초기화-성능-비교"><a href="#배열의-생성-초기화-성능-비교" class="headerlink" title="배열의 생성, 초기화 성능 비교"></a>배열의 생성, 초기화 성능 비교</h3><p>배열을 생성자 혹인 리터럴([]) 형식을 사용해 객체를 생성할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array() 생성자 사용</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리터럴 형식으로 배열 생성</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>성능 비교 방법은 <a href="http://jindo.dev.naver.com/jsMatch/index.html">http://jindo.dev.naver.com/jsMatch/index.html</a> 사이트를 이용한다. (Chrome 79 버전 기준)</p></blockquote><p>두 방법의 성능을 비교한 결과는 생성자를 사용했을때는 0.111s, 리터럴 형식으로 사용했을 경우 0.100s 의 시간이 걸렸다.</p><p>배열을 사용하려면 배열의 각 요소에 데이터를 할당해 초기화해야한다.<br>배열의 각 요소에 데이터를 할당하는 방법에도 여러가지가 있다. 그 가운데 가장 많이 볼 수 있는 방법인 접근자 []를 사용하는 방법과 push() 메서드를 사용하는 방법의 성능을 비교한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 접근자 사용</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push() 메서드 사용</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과: 접근자 사용 0.100s / push 사용 0.123s</p><p>push 메서드를 사용하는것 보다 접근자를 사용하는 것이 빠르다는 것을 확인할 수 있다. 배열의 생성과 초기화 방법을 비교한 결과, 배열을 사용할 때는 리터럴 형식으로 객체를 생성하고 Array.push() 메서드보다 접근자 []를 사용해 데이터를 추가하는 코드를 작성하는 것이 좀 더 최적화된 배열 사용법이라는 사실을 확인할 수 있다.</p><h3 id="오브젝트-Object-객체의-생성-초기화-성능-비교"><a href="#오브젝트-Object-객체의-생성-초기화-성능-비교" class="headerlink" title="오브젝트(Object) 객체의 생성, 초기화 성능 비교"></a>오브젝트(Object) 객체의 생성, 초기화 성능 비교</h3><p>오브젝트(Object) 객체도 배열처럼 객체를 생성하고 초기화하는 다양한 방법이 있다. 가장 많이 사용하는 방법인 리터럴({})을 사용하는 방법과 생성자를 사용하는 방법의 성능을 테스트해보고 어떤 방법으로 객체를 생성하고 초기화하는 것이 효과적인지 살펴보고자 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리터럴 사용</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 사용</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>결과: 리터럴 사용 0.104s / 생성자 사용 0.100s</p><p>배열과 다르게 생성자를 사용하는 것이 시간이 적게 걸리지만 차이가 적으므로 어떤 방법이 성능이 월등히 좋다고 판가름하기 어렵다. 리터럴 형식이 코드 크기를 좀 더 줄일 수 있는 방법이기 때문에 코드를 다운로드 하는 시간 관점에서 성능에 더 좋다고 볼 수는 있다.</p><p>객체 초기화 방법에는 연산자를 이용한 데이터 삽입과 []를 이용한 데이터 삽입이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 연산자 이용</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br><span class="line">obj.b = <span class="number">2</span>;</span><br><span class="line">obj.c = <span class="number">3</span>;</span><br><span class="line">obj.d = <span class="number">4</span>;</span><br><span class="line">obj.e = <span class="number">5</span>;</span><br><span class="line">obj.f = <span class="number">6</span>;</span><br><span class="line">obj.g = <span class="number">7</span>;</span><br><span class="line">obj.h = <span class="number">8</span>;</span><br><span class="line">obj.i = <span class="number">9</span>;</span><br><span class="line">obj.j = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [] 이용</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="string">"a"</span>] = <span class="number">1</span>;</span><br><span class="line">obj[<span class="string">"b"</span>] = <span class="number">2</span>;</span><br><span class="line">obj[<span class="string">"c"</span>] = <span class="number">3</span>;</span><br><span class="line">obj[<span class="string">"d"</span>] = <span class="number">4</span>;</span><br><span class="line">obj[<span class="string">"e"</span>] = <span class="number">5</span>;</span><br><span class="line">obj[<span class="string">"f"</span>] = <span class="number">6</span>;</span><br><span class="line">obj[<span class="string">"g"</span>] = <span class="number">7</span>;</span><br><span class="line">obj[<span class="string">"h"</span>] = <span class="number">8</span>;</span><br><span class="line">obj[<span class="string">"i"</span>] = <span class="number">9</span>;</span><br><span class="line">obj[<span class="string">"j"</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>결과: 연산자 이용 0.102s / [] 이용 0.100s</p><p>Object 객체에 데이터를 삽입하는 초기화 방법에 대한 성능 테스트 결과도 Object 객체 생성에 대한 테스트 결과와 유사헀다. 객체의 초기화도 생성과 마찬가지로 한 가지 방식이 더 성능이 좋다고 판단할 수 없으며, 작성하는 코드의 크기와 주요 대상 브라우저 및 코드의 가독성과 유지 보수를 감안해 적절한 방식을 택하면 되겠다.</p><h2 id="스코프-체인-탐색과-성능"><a href="#스코프-체인-탐색과-성능" class="headerlink" title="스코프 체인 탐색과 성능"></a>스코프 체인 탐색과 성능</h2><p>자바스크립트 성능을 다루는 책에서 항상 빠지지 않는 부분이 스코프 체인이다. 개발자가 작성한 코드 자체의 성능이 런타임 성능에도 많은 영향을 준다. 런타임 환경에서 가장 많이 발생하는 브라우저의 작업 가운데 자바스크립트의 실행 성능을 저해하는 요인이 변수, 객체, 함수 등의 메모리상의 위치를 찾는 <code>탐색 작업</code>이다.</p><h3 id="스코프-체인이란"><a href="#스코프-체인이란" class="headerlink" title="스코프 체인이란?"></a>스코프 체인이란?</h3><p>자바스크립트의 함수를 실행하면서 어떤 속성(변수, 객체 등)에 접근해야 할 때 해당 속성을 효율적으로 탐색하도록 속성을 일정한 객체 단위로 분류하고 각 객체에 접근하기 위한 객체의 참조를 특정한 공간에 저장해 둔다. 이 공간이 바로 스코프 체인이다.</p><p>스코프 체인의 구성 요소에는 활성화 객체와 전역 객체가 있다. 함수에서 접근할 수 있는 모든 속성 가운데 함수 내부에서만 접근할 수 있는 함수의 지역변수나 this, arguments 객체 등의 속성은 스코프 체인의 활성화 객체에 포함돼 관리 된다. 함수 외부에서도 접근할 수 있는 window, document, 전역함수, 전역변수와 같은 속성은 스코프 체인의 전역 객체에 포함돼 관리 된다.<br>전역 객체는 자바스크립트 동작시 어디서나 항상 접근 가능한 데이터를 포함하고 있기 때문에 동작하는 모든 시간 동안 존재하지만, 활성화 객체는 실행 중인 함수 내부 데이터를 포함하기 때문에 함수가 실행되는 동안에만 존재한다.</p><p>실행 문맥(Execution Context)은 <code>함수가 동작하는 환경</code>을 나타내며, 브라우저 내부에서 사용되는 객체다. 실행 문맥은 함수가 실행될 때 새로 생성되고  함수가 종료될 때 소멸되며 함수의 스코프 체인에 대한 참조를 가지고 있게 된다. 실행 문맥은 자신과 연관된 함수의 스코프 체인을 참조하고 있으며, 함수에서 접근해야할 어떤 속성의 탐색 경로는 실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체 &gt; 스코프 체인 &gt; 전역 객체 와 같이 구성된다.</p><h3 id="지역변수를-활용한-스코프-체인-탐색-성능-개선"><a href="#지역변수를-활용한-스코프-체인-탐색-성능-개선" class="headerlink" title="지역변수를 활용한 스코프 체인 탐색 성능 개선"></a>지역변수를 활용한 스코프 체인 탐색 성능 개선</h3><p>스코프 체인의 탐색 방법을 살펴보면 여러 개의 활성화 객체와 전역 객체를 탐색하면서 접근하려는 속성이 있는지 확인하는 과정이 반복된다. 그렇다면 첫 번째로 탐색하는 활성화 객체에 찾고자 하는 속성이 있는 경우 추가로 발생할 수 있는 다른 활성화 객체, 전역 객체를 탐색하는 과정을 줄여 성능을 향상시킬 수 있을 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 내에서 전역 스코프 변수에 직접 접근하는 방법</span></span><br><span class="line"><span class="built_in">window</span>.htmlstring = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  htmlstring.push(<span class="string">"&lt;ul&gt;"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    htmlstring.push(<span class="string">`&lt;li&gt;value: <span class="subst">$&#123;i&#125;</span>&lt;/li&gt;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  htmlstring.push(<span class="string">"&lt;/ul&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 지역변수로 참조해 전역 스코프 변수에 접근하는 방법</span></span><br><span class="line"><span class="built_in">window</span>.htmlstring = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> htmlstr = htmlstring;</span><br><span class="line">  htmlstr.push(<span class="string">"&lt;ul&gt;"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    htmlstr.push(<span class="string">`&lt;li&gt;value: <span class="subst">$&#123;i&#125;</span>&lt;/li&gt;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  htmlstr.push(<span class="string">"&lt;/ul&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeList();</span><br></pre></td></tr></table></figure><p>결과: 전역 스코프 변수 접근 0.119s / 지역변수 참조 0.100s</p><p>전역 객체에 존재하는 htmlstring 속성을 makeList() 함수의 지역변수에 저장해 활성화 객체에서 바로 찾을 수 있게 한것이다. 최초 한 번은 활성화 객체와 전역 객체를 모두 탐색해야한다. 하지만 그 이후에는 활성화 객체에 저장된 htmlstr 속성으로 전역변수인 htmlstring 객체에 접근할 수 있으니 활성화 객체를 거쳐 전역 객체까지 탐색할 필요가 없어진다.</p><h2 id="반복문과-성능"><a href="#반복문과-성능" class="headerlink" title="반복문과 성능"></a>반복문과 성능</h2><p>자바스크립트의 반복문인 for, for-in, while, do-while 구문에도 성능 차이가 있다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 성능 테스트 전에 배열 초기화</span></span><br><span class="line">arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">400</span>; i++) &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">  arr[i]++;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do-while</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  arr[i] = i;</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; len);</span><br></pre></td></tr></table></figure><p>결과: for 0.113s / for-in 0.505s / while 0.108s / do-while 0.100s</p><p>for-in의 성능이 압도적으로 떨어지는 것을 확인할 수 있다. for-in 이외의 반복문은 주어진 배열 객체를 배열의 특성에 맞게 순차적으로 모든 요소를 탐색한다. 반면 for-in 구문은 인자로 주어진 배열을 배열이 아닌 일반 객체로 취급하며, 반복 시점마자 객체의 모든 속성을 무작위로 탐색한다. 이러한 탐색 방법의 차이로 다른 반복문에 비해 배열 탐색에서 현저하게 느리다.</p><h2 id="조건문과-성능"><a href="#조건문과-성능" class="headerlink" title="조건문과 성능"></a>조건문과 성능</h2><p>반복문만큼이나 조건문 또한 자바스크립트를 포함한 프로그래밍 전반에서 필수적으로 사용하는 요소다. 자바스크립트에는 if, if-else, switch, 삼항연산자 등의 조건문이 있다.</p><h3 id="조건문의-성능-비교"><a href="#조건문의-성능-비교" class="headerlink" title="조건문의 성능 비교"></a>조건문의 성능 비교</h3><p>먼저 true와 false만 판단하는 최소한의 조건 분기를 처리하는 코드로 if, switch, 삼항연산자의 성능을 측정했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-else</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toEnglish</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="string">"zero"</span>;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="number">1</span>) &#123;</span><br><span class="line">    number = <span class="string">"one"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">2</span>) &#123;</span><br><span class="line">    number = <span class="string">"two"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">3</span>) &#123;</span><br><span class="line">    number = <span class="string">"three"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">4</span>) &#123;</span><br><span class="line">    number = <span class="string">"four"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">5</span>) &#123;</span><br><span class="line">    number = <span class="string">"five"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">6</span>) &#123;</span><br><span class="line">    number = <span class="string">"six"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">7</span>) &#123;</span><br><span class="line">    number = <span class="string">"seven"</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">8</span>) &#123;</span><br><span class="line">    number = <span class="string">"eight"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">9</span>) &#123;</span><br><span class="line">    number = <span class="string">"nine"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="number">10</span>) &#123;</span><br><span class="line">    number = <span class="string">"ten"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    number = <span class="string">"null"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch-case</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toEnglish</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="string">"zero"</span>;</span><br><span class="line">  <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      number = <span class="string">"one"</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      number = <span class="string">"two"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      number = <span class="string">"three"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">      number = <span class="string">"four"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      number = <span class="string">"five"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      number = <span class="string">"six"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      number = <span class="string">"seven"</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      number = <span class="string">"eight"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">      number = <span class="string">"nine"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      number = <span class="string">"ten"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      number = <span class="string">"null"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 삼항연산자</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toEnglish</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="literal">false</span>;</span><br><span class="line">  number = (value === <span class="number">1</span>) ?</span><br><span class="line">    <span class="string">"one"</span> : (value === <span class="number">2</span>) ?</span><br><span class="line">    <span class="string">"two"</span> : (value === <span class="number">3</span>) ?</span><br><span class="line">    <span class="string">"three"</span> : (value === <span class="number">4</span>) ?</span><br><span class="line">    <span class="string">"four"</span> : (value === <span class="number">5</span>) ?</span><br><span class="line">    <span class="string">"five"</span> : (value === <span class="number">6</span>) ?</span><br><span class="line">    <span class="string">"six"</span> : (value === <span class="number">7</span>) ?</span><br><span class="line">    <span class="string">"seven"</span> : (value === <span class="number">8</span>) ?</span><br><span class="line">    <span class="string">"eight"</span> : (value === <span class="number">9</span>) ?</span><br><span class="line">    <span class="string">"nine"</span> : (value === <span class="number">10</span>) ?</span><br><span class="line">    <span class="string">"ten"</span> : <span class="string">"null"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">  toEnglish(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과: if-else 0.111s / switch 0.111s / 삼항연산자 0.100s</p><p>조건의 개수가 많지 않으므로 조건문 사이에 별다른 성능 차이가 없다. 단지, 일반적으로 조건 판단 요소가 많아질수록 switch-case 구문의 성능이 좀 더 좋다는 점은 알아두는 것이 좋다.</p><h2 id="문자열-연산과-성능"><a href="#문자열-연산과-성능" class="headerlink" title="문자열 연산과 성능"></a>문자열 연산과 성능</h2><h3 id="문자열-생성-비교"><a href="#문자열-생성-비교" class="headerlink" title="문자열 생성 비교"></a>문자열 생성 비교</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 객체 이용</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리터럴 이용</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>결과: String 객체 0.103s / 리터럴 이용 0.100s</p><p>측정한 시간이 지극히 짧지만 String 객체보다는 리터럴을 사용하는 것이 좋다.</p><h3 id="문자열-연산-성능-비교"><a href="#문자열-연산-성능-비교" class="headerlink" title="문자열 연산 성능 비교"></a>문자열 연산 성능 비교</h3><p>여러가지 데이터를 조합해 긴 문자열을 생성해야 할 때가 많다. 이때 가장 많이 사용하는 방법이 +, += 연산자를 이용하거나 Array.join() 메서드를 이용하는 방법이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// += 연신자</span></span><br><span class="line">str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  str += <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.join</span></span><br><span class="line">arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  arr[i] = <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr.join(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>결과: += 연산자 0.398s / Array.join 0.100s</p><p>Array.join() 메서드를 이용하는것이 월등한 성능을 낸다는 것을 확인할 수 있다. += 연산자는 두 문자열을 합친 새로운 문자열을 만들고 새로운 메모리 위치에 저장함과 동시에 기존 문자열에 대한 참조를 변경하는 연산을 반복적으로 실행해야 한다. 하지만 Array.join() 메서드로 연산하면 비교적 메모리에 효율적으로 접근할 수 있는 배열을 사용한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>배열은 리터럴([])방식으로 생성하고 push() 메서드가 아닌 접근자([])로 데이터를 할당하는 코드의 성능이 더 좋다.</li><li>객체는 어떤 방식이든지 비슷한 성능을 낸다. 가독성과 유지보수의 편리성을 고려해 적절한 방식으로 사용하면 된다.</li><li>반복문 가운데 for-in의 성능이 월등히 낮다.</li><li>조건문의 종류에 따른 성능 차이는 거의 없지만 조건이 많아지면 switch-case 성능이 좀 더 좋다.</li><li>문자열을 연산할 때는 += 연산자 보다는 Array.join()을 이용하는 방법이 더 좋다.</li></ul><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>기본적인 웹 사이트 최적화 방법</title>
      <link>https://kkangil.github.io/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/</link>
      <guid>https://kkangil.github.io/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/</guid>
      <pubDate>Sun, 02 Feb 2020 07:57:35 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;HTTP-요청-최소화&quot;&gt;&lt;a href=&quot;#HTTP-요청-최소화&quot; class=&quot;headerlink&quot; title=&quot;HTTP 요청 최소화&quot;&gt;&lt;/a&gt;HTTP 요청 최소화&lt;/h2&gt;&lt;p&gt;HTTP 요청 최소화는 최적화에서 가장 기본이면서도 중요한 부분이다. 웹 사이트는 주로 마크업, 이미지, 스타일시트, 자바스크립트 등으로 구성된다. 각 구성 요소는 모두 웹 서버에 있다. 이 구성 요소를 사용자의 컴퓨터로 가져오는 데는 네트워크 비용이 든다. 네트워크 비용은 곧 응답 시간으로 이어진다. 그러므로 다운로드 해야 하는 구성 요소의 개수를 줄이는 것은 가장 효과가 크고 중요한 최적화 방법이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="HTTP-요청-최소화"><a href="#HTTP-요청-최소화" class="headerlink" title="HTTP 요청 최소화"></a>HTTP 요청 최소화</h2><p>HTTP 요청 최소화는 최적화에서 가장 기본이면서도 중요한 부분이다. 웹 사이트는 주로 마크업, 이미지, 스타일시트, 자바스크립트 등으로 구성된다. 각 구성 요소는 모두 웹 서버에 있다. 이 구성 요소를 사용자의 컴퓨터로 가져오는 데는 네트워크 비용이 든다. 네트워크 비용은 곧 응답 시간으로 이어진다. 그러므로 다운로드 해야 하는 구성 요소의 개수를 줄이는 것은 가장 효과가 크고 중요한 최적화 방법이다.</p><a id="more"></a><h3 id="CSS-스프라이트"><a href="#CSS-스프라이트" class="headerlink" title="CSS 스프라이트"></a>CSS 스프라이트</h3><p>순수한 HTML 마크업만으로는 표현에 한계가 있기 때문에 어쩔 수 없이 이미지를 사용한다. 하지만 이미지를 많이 사용하면 HTTP 요청이 많아질 수 밖에 없다. 이미지를 많이 사용하면서도 HTTP 요청을 최소화하는 방법 가운데 하나가 CSS 스프라이트 기법이다.</p><p>CSS 스프라이트 기법은 이미지 여러 개를 하나로 만들고 스타일시트에서 <code>background-position</code> 속성을 설정해 필요한 부분의 이미지만 보여 주는 기술이다. 여러 이미지를 하나의 이미지로 합치기 때문에 HTTP 요청 횟수를 줄일 수 있고, 이미지의 컬러 테이블과 같은 메타데이터를 하나로 합칠 수 있어 파일 크기가 줄어든다.</p><p>CSS 스프라이트 기법은 이미지를 관리하기 어렵고 웹 접근성을 나쁘게 하는 요소가 있다는 단점이 있다. 하지만 많은 양의 이미지를 사용한다면 많은 시간을 줄일 수 있다.</p><h3 id="헤더에-만료-날짜-추가"><a href="#헤더에-만료-날짜-추가" class="headerlink" title="헤더에 만료 날짜 추가"></a>헤더에 만료 날짜 추가</h3><p>헤더에 만료 날짜를 추가하는 이유는 웹 페이지를 구성하는 여러 요소들을 사용자의 컴퓨터의 캐시에 저장해서 재사용하기 위해서다. 사용자가 처음 웹 페이지에 방문하면 만료 날짜가 설정된 요소를 사용자 컴퓨터에 저장한다. 이후 같은 웹 페이지에 다시 방문하면 유효한 요소는 서버에 요청하지 않고 사용자 컴퓨터에서 바로 읽어 온다.</p><h4 id="사용자-컴퓨터에-저장된-캐시-파일"><a href="#사용자-컴퓨터에-저장된-캐시-파일" class="headerlink" title="사용자 컴퓨터에 저장된 캐시 파일"></a>사용자 컴퓨터에 저장된 캐시 파일</h4><p>캐시에 저장된 파일에는 만료 날짜가 없는 파일도 있고 만료 날짜가 있는 파일도 있다. 모든 구성 요소에 무조건 만료 날짜를 설정하는 것이 아니라 특정 기간까지 변경되지 않아도 서비스에 문제가 없는 요소에만 적용해야 한다.<br>만약 만료 날짜 전에 수정 사항이 있어 파일을 변경해야 한다면 파일 이름을 변경하거나 파일 이름 뒤에 쿼리스트링을 추가해 새로 추가된 파일임을 알려야 바로 반영된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 파일 이름을 변경</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test_0202.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 쿼리스트링 추가</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test?0202.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>브라우저에서 캐싱된 파일을 이용할지 서버에 요청할지 판단하는 기준은 컬럼 이름을 기준으로 이름과 인터넷 주소다. 그렇기 때문에 파일 이름이나 파일의 주소를 바꾸지 않으면 계속 같은 파일로 인식하고 사용자 컴퓨터에 있는 파일을 로딩한다.</p><h4 id="자바스크립트-파일-통합"><a href="#자바스크립트-파일-통합" class="headerlink" title="자바스크립트 파일 통합"></a>자바스크립트 파일 통합</h4><p>기능이 향상됨에 따라 자바스크립트 파일은 개수도 많아지고 크기도 커지고 있다. 이럴 때 성능을 높이는 방법은 여러 개의 자바스크립트 파일을 하나의 파일로 합쳐 파일 개수를 최소화하는 것이다. 웹 사이트의 성능을 개선할 때는 파일의 용량보다 파일의 개수가 중요하다. 아주 용량이 작은 파일이라도 원격 서버에서 가져와야 한다면 네트워크 비용이 든다.</p><h3 id="파일-크기-최소화"><a href="#파일-크기-최소화" class="headerlink" title="파일 크기 최소화"></a>파일 크기 최소화</h3><h4 id="Gzip-압축을-이용한-파일-크기-최소화"><a href="#Gzip-압축을-이용한-파일-크기-최소화" class="headerlink" title="Gzip 압축을 이용한 파일 크기 최소화"></a>Gzip 압축을 이용한 파일 크기 최소화</h4><p>점점 커지는 자바스크립트 파일과 스타일시트 파일의 크기를 줄이는 가장 효과적이고 쉬운 방법은 파일을 압축하는 것이다. 아파치 웹 서버에서 파일을 압축하는 대표적인 인코딩 방식에는 Gzip과 deflate 두 가지가 있는데, deflate 방식은 지원하지 않는 브라우저가 많고 효과도 떨어지기 때문에 대부분 Gzip 방식을 사용한다.</p><h5 id="압축-전송-흐름-및-확인"><a href="#압축-전송-흐름-및-확인" class="headerlink" title="압축 전송 흐름 및 확인"></a>압축 전송 흐름 및 확인</h5><p>압축 전송은 다음과 같은 순서로 진행된다. 클라이언트에서 some.js 라는 파일을 만났을 때를 가정해보자.</p><ol><li>클라이언트에서 헤더 정보로 인코딩 여부를 물어본다.<blockquote><p>Accept-Encoding: gzip, deflate (Header)</p></blockquote></li><li>서버에서 헤더 정보로 인코딩 여부를 알려준다. 인코딩된 요소라면 다음과 같이 응답이 온다.<blockquote><p>Content-Encoding: gzip</p></blockquote></li><li>클라이언트에서 인코딩된 요소를 받음과 동시에 압축을 해제한다. 이때 추가적인 CPU 연산 비용이 들어간다. 여기서 발생하는 CPU 연산 비용도 무시할 수 없기 때문에 압축할 파일과 크기를 잘 설정해야한다. 보통 스타일시트 파일과 자바스크립트 파일을 압축한다. 그리고 파일 크기가 작으면 속도 개선 효과보다 CPU 연산 비용이 더 들기 때문에 파일 크기가 일정한 크기 이상인 경우에만 압축하는 것이 좋다. 파일 크기가 1~2KB 이상일때 압축할 것을 권장한다.</li></ol><h4 id="압축-전송의-효과"><a href="#압축-전송의-효과" class="headerlink" title="압축 전송의 효과"></a>압축 전송의 효과</h4><p>Gzip으로 압축해 전송하면 평균 70% 정도 파일 크기가 작아지는 효과를 볼 수 있다. 모바일 환경과 같이 네트워크 환경이 불안한 상황에서는 더욱 효과적인 기술일 것이다.<br>파일의 공백 및 주석을 제거하고 Gzip 으로 압축을 진행하면 파일 크기를 최소화 시킬 수 있다.</p><h3 id="쿠키-크기-최소화"><a href="#쿠키-크기-최소화" class="headerlink" title="쿠키 크기 최소화"></a>쿠키 크기 최소화</h3><p>필요한 정보를 저장하는 가장 손쉬운 방법이 최상위 도메인을 이용해 쿠키를 설정하는 방법이다. 이렇게 되면 자바스크립트 파일이나 스타일시트, 이미지등 쿠키 정보가 필요 없는 구성 요소를 요청할 때도 헤더 정보에 쿠키가 포함된다. 즉 헤더를 전송할 때 데이터 크기가 커진다.</p><p>쿠키의 크기를 줄이는 기본적인 방법</p><ul><li>지속적인 관리로 사용하지 않는 쿠키는 삭제한다.</li><li>쿠키를 설정할 때 최상위 도메인은 되도록 사용하지 않는다.</li><li>쿠키 정보가 필요없는 파일은 별도의 도메인으로 서비스한다.</li></ul><hr/><h2 id="렌더링-성능-향상"><a href="#렌더링-성능-향상" class="headerlink" title="렌더링 성능 향상"></a>렌더링 성능 향상</h2><p>전체적인 로딩 속도는 동일한데 빈 페이지가 계속 보이다 갑자기 콘텐츠가 나타나는 페이지가 있고, 처음부터 콘텐츠가 조금씩 보이며 화면이 빠르게 나타나는 페이지가 있다. 렌더링 성능 향상의 목표는 페이지를 요청했을 때 사용자가 대기하는 시간을 최대한 줄여서 이 체감 속도를 높이는 것이다.</p><h3 id="브라우저-파싱-순서"><a href="#브라우저-파싱-순서" class="headerlink" title="브라우저 파싱 순서"></a>브라우저 파싱 순서</h3><ol><li><p>HTML 파싱과 DOM 트리 구성<br>사용자가 페이지를 요청하면 네트워크를 통해 마크업을 받아 온다. 그 후 마크업 문자열을 토큰 형태로 잘라서 트리를 구축하고 파싱 작업을 시작한다. 그런 다음 DOM 트리를 생성한다.</p></li><li><p>렌더트리 구성(DOM + 스타일규칙)<br>DOM 트리를 생성한 다음 바로 화면을 그리지는 않는다. 스타일시트의 정보를 적용해야 하기 떄문이다. DOM 트리 정보와 스타일시트의 스타일 규칙을 결합해 렌더 트리를 만든다. display:none 속성처럼 DOM 트리에는 있지만 화면에 보이면 안되는 요소를 걸러낸 결과가 렌더 트리다.</p></li><li><p>렌더 트리의 배치<br>스타일 규칙에 따라 각 요소를 화면의 어디에 배치할지 좌표를 설정한다.</p></li><li><p>렌더 트리 그리기<br>요소의 좌표가 설정되면 브라우저에 순차적으로 화면에 그린다. 이때 사용자는 화면을 조금씩 보게 된다.</p></li></ol><h3 id="스타일시트와-자바스크립트-배치를-이용한-성능-향상"><a href="#스타일시트와-자바스크립트-배치를-이용한-성능-향상" class="headerlink" title="스타일시트와 자바스크립트 배치를 이용한 성능 향상"></a>스타일시트와 자바스크립트 배치를 이용한 성능 향상</h3><p>스타일시트 파일은 페이지 제일 위쪽에, 자바스크립트 파일은 페이지 맨 아래쪽에 놓아야 한다.<br>브라우저 렌더링 단계에 따르면 사용자에게 화면을 보여 주기 전에 렌더 트리를 생성해야 하는데, 이때 스타일시트 파일이 반드시 필요하다. 스타일시트 파일을 최대한 빨리 다운로드 해야 하는 이유다.</p><p>자바스크립트 파일을 페이지 아래에 놓아야 하는 가장 큰 이유는 파일을 다운로드해서 실행하기 전까지 브라우저가 DOM 파싱도 중지하고 아무것도 렌더링하지 않기 때문이다. 자바스크립트에는 document.write() 메서드가 있어 마크업을 렌더링하는 도중에도 DOM을 추가할 수 있다. 이로 인해 이미 필요한 구성 요소를 모두 브라우저에 가져왔음에도 자바스크립트를 수행하느라 렌더링이 멈추게 된다. 이때 사용자에게는 마치 화면이 멈춘 것처럼 보여 체감 속도가 느려진다.</p><h3 id="초기-렌더링시-AJAX-요청-최소화"><a href="#초기-렌더링시-AJAX-요청-최소화" class="headerlink" title="초기 렌더링시 AJAX 요청 최소화"></a>초기 렌더링시 AJAX 요청 최소화</h3><p>동적인 웹 사이트에서 화면을 그리는 단계는 일반적으로 다음과 같다.</p><ol><li>사용자가 페이지를 요청</li><li>마크업을 다운로드해 렌더링 시작 (화면을 구성하는 레이아웃만 있고 실제로 보여줄 데이터는 나중에 AJAX 요청을 통해 받은 다음 그려야함)</li><li>자바스크립트 다운로드와 렌더링이 끝난 후 onload 이벤트가 발생</li><li>onload 이벤트가 발생한 다음에 AJAX 통신을 실행하고 데이터를 화면에 그린다.</li><li>화면 완성</li></ol><p>이 과정에는 두 가지 큰 문제점이 있다. AJAX 통신을 사용하지 않는 방법으로 페이지를 개발했다면 3번 단계에서 사용자는 화면을 보게 된다. 그런데 5번 단계가지 가서야 사용자는 최종 화면을 볼 수 있다. 또 다른 문제는 렌더링이 반복된다는 것이다. 1~3번 단계까지 전체 화면을 한 번 그리고 4~5번 단계에서 화면을 한 번 더 그린다.</p><p>초기 렌더링 시에 마크업 전체를 서버에서 보내는 방식으로 개발하여 체감 속도를 높일 수 있다. 1~3 단계에서 전체 화면과 데이터가 있는 화면을 모두 그리는 것이다. 그리고 사용자의 행동이 있을 때 AJAX 요청을 실행해서 데이터를 받은 다음 화면을 그리게 한다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>도구 다루기-3</title>
      <link>https://kkangil.github.io/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/</link>
      <guid>https://kkangil.github.io/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/</guid>
      <pubDate>Sun, 02 Feb 2020 05:36:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;의존성-주입이란&quot;&gt;&lt;a href=&quot;#의존성-주입이란&quot; class=&quot;headerlink&quot; title=&quot;의존성 주입이란?&quot;&gt;&lt;/a&gt;의존성 주입이란?&lt;/h2&gt;&lt;p&gt;ConferenceWebSvc 객체에 서비스를 캡슐화하고 메시지를 화면에 표시할 자바스크립트 객체 Messenger를 작성한다.&lt;/p&gt;
&lt;p&gt;참가자는 1인당 세션을 10개까지 등록할 수 있다. 참가자가 한 세션을 등록하면 그 결과를 성공/실패 메시지로 화면에 표시하는 함수를 개발해야 한다. 아래 코드는 해당 기능을 구현하기 위한 초기 버전이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="의존성-주입이란"><a href="#의존성-주입이란" class="headerlink" title="의존성 주입이란?"></a>의존성 주입이란?</h2><p>ConferenceWebSvc 객체에 서비스를 캡슐화하고 메시지를 화면에 표시할 자바스크립트 객체 Messenger를 작성한다.</p><p>참가자는 1인당 세션을 10개까지 등록할 수 있다. 참가자가 한 세션을 등록하면 그 결과를 성공/실패 메시지로 화면에 표시하는 함수를 개발해야 한다. 아래 코드는 해당 기능을 구현하기 위한 초기 버전이다.</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Attendee = <span class="function"><span class="keyword">function</span> (<span class="params">attendeeId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'new'로 생성하도록 강제</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Attendee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Attendee(attendeeId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attendeeId = attendeeId;</span><br><span class="line">  <span class="keyword">this</span>.service = <span class="keyword">new</span> ConferenceWebSvc();</span><br><span class="line">  <span class="keyword">this</span>.messenger = <span class="keyword">new</span> Messenger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 세션에 좌석 예약을 시도하고 성공/실패 여부를 메시지로 알려줌.</span></span><br><span class="line">Attendee.prototype.reserve = <span class="function"><span class="keyword">function</span> (<span class="params">sessionId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.service.reserve(<span class="keyword">this</span>.attendeeId, sessionId)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.success(</span><br><span class="line">      <span class="string">`좌석 예약이 완료되었습니다! 고객님은 <span class="subst">$&#123;<span class="keyword">this</span>.service.getRemainingReservations()&#125;</span> 좌석을 추가로 예약하실 수 있습니다.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.failure(<span class="string">'죄송합니다. 해당 좌석은 예약하실 수 없습니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 ConferenceWebSvc, Messenger, Attendee 객체가 각자 자신만의 임무를 갖고 모듈로 조화를 이룬것 처럼 보인다. Attendee.reserve는 너무 간단해서 굳이 단위 테스트를 하지 않아도 되는데, 어차피 그럴 수도 없다. ConferenceWebSvc 내부에는 HTTP 호출이 있다. Messenger는 메시지마다 OK 버튼이 있어야 하는데, 이 또한 이 모듈에서 단위 테스트할 대상은 아니다. 단위 테스트는 자바스크립트 코드를 바르게 작성하기 위한 핵심인데, 모든 단위가 미처 준비도 되기 전에 시스템 테스트의 늪으로 빠지는 게 싫다.</p><p>요는, Attendee 객체가 아니라 이 객체가 의존하는 코드다. 의존성을 주입하는 식으로 바꾸면 해결할 수 있다. 즉, ConferenceWebSvc와 Messenger와의 의존성을 하드 코딩하지 말고 이들을 Attendee에 주입하는 것이다. 실제 운영 환경에서는 진짜 의존성을 주입하겠지만, 단위 테스트용으로는 모의체(fake)나 재스민 스파이 같은 대체제를 주입하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 운영 환경:</span></span><br><span class="line"><span class="keyword">var</span> attendee: <span class="keyword">new</span> Attendee(<span class="keyword">new</span> ConferenceWebSvc(), <span class="keyword">new</span> Messenger(), id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 개발 환경:</span></span><br><span class="line"><span class="keyword">var</span> attendee = <span class="keyword">new</span> Attendee(fakeService, fakeMessenger, id);</span><br></pre></td></tr></table></figure><p>이처럼 의존성을 주입하는 것을 두고 ‘빈자의 의존성 주입’이라 한다. 아래 코드는 빈자의 의존성 주입 방식으로 작성한 Attendee 객체다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Attendee = <span class="function"><span class="keyword">function</span> (<span class="params">service, messenger, attendeeId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'new'로 생성하도록 강제</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Attendee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Attendee(attendeeId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.attendeeId = attendeeId;</span><br><span class="line">  <span class="keyword">this</span>.service = service;</span><br><span class="line">  <span class="keyword">this</span>.messenger = messenger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="의존성을-주입하여-믿음직한-코드-만들기"><a href="#의존성을-주입하여-믿음직한-코드-만들기" class="headerlink" title="의존성을 주입하여 믿음직한 코드 만들기"></a>의존성을 주입하여 믿음직한 코드 만들기</h2><p>의존성을 주입하여 다른 방법으로는 할 수 없는 단위 테스트를 어떻게 하는지 알았다. 아무래도 테스트를 통과한, 자동화한 테스트 꾸러미로 계속 테스트할 수 있는 코드가 더 믿음직하다. 이 뿐만 아니라, 의존성 주입은 실제 객체보다 주입한 스파이나 모의 객체에 더 많은 제어권을 안겨주므로 다양한 에러 조건과 기이한 상황을 만들어내기 쉽다.</p><p>의존성 주입은 코드 재사용을 적극적으로 유도한다. 의존성을 품은, 하드 코딩한 모듈은 보통 재사용하기 어렵다. 초기 Attendee 모듈도 Messenger를 하드 코딩하여 쓴 탓에 서버 측에서 재사용할 수 없었다. 의존성 주입으로 바꾼 다음에는 성공/실패 메서드만 있으면 어떤 messenger 라도 사용할 수 있다.</p><h2 id="의존성-주입의-모든-것"><a href="#의존성-주입의-모든-것" class="headerlink" title="의존성 주입의 모든 것"></a>의존성 주입의 모든 것</h2><p>의존성 주입은 어렵지 않다. 몇 가지 개념만 기억하면 잘 활용할 수 있다.<br>어떤 객체를 코딩하든 어떤 객체를 생성하든 스스로 다음 질문을 해봤을때 한 가지라도 답변이 ‘예’ 라면 직접 인스턴스화 하지 말고 주입하는 방향으로 생각을 전환해야 한다.</p><ul><li>객체 또는 의존성 중 어느 하나라도 DB, 설정 파일, HTTP, 기타 인프라 등의 외부 자원에 의존 하는가</li><li>객체 내부에서 발생할지 모를 에러를 테스트에서 고려해야 하나</li><li>특정한 방향으로 객체를 작동시켜야 할 테스트가 있는가</li><li>서드파티 제공 객체가 아니라 온전히 내가 소유한 객체인가</li></ul><h2 id="경량급-의존성-주입-프레임워크-개발"><a href="#경량급-의존성-주입-프레임워크-개발" class="headerlink" title="경량급 의존성 주입 프레임워크 개발"></a>경량급 의존성 주입 프레임워크 개발</h2><p>지금까지는 의존성 주입을 하드 코딩했다. 전문가다운 의존성 주입 프레임워크는 이렇게 작동한다.</p><ol><li>애플리케이션이 시작되자마자 각 인젝터블(주입 가능한 모든 의존성을 집합적으로 일컫는 말) 명을 확인하고 의존성을 지칭하며 순서대로 DI 컨테이너에 등록한다.</li><li>객체가 필요하면 컨테이너에 요청한다.</li><li>컨테이너는 일단 요청받은 객체와 그 의존성을 모두 재귀적으로 인스턴스화한다. 그리고 요건에 따라 필요한 객체에 각각 주입한다.</li></ol><p>컨테이너는 인젝터블과 의존성을 등록하고 요청시 객체를 내어주는 두 가지 일을 한다. register 함수의 인자는 세 가지를 받는다.</p><ul><li>인젝터블 명</li><li>의존성 명을 담은 배열</li><li>인젝터블 객체를 반환하는 함수. 인젝터블 인스턴스를 요청하면 컨테이너는 이 함수를 호출하여 반환 값을 다시 그대로 반환한다.</li></ul><p>TDD는 단계마다 가급적 조금씩 코딩하는게 좋다. 먼저 빈 DiContainer와 register 함수를 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'DiContainer'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> container;</span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    container = <span class="keyword">new</span> DiContainer();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  describe(<span class="string">'register(name,dependencies,func)'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'인자가 하나라도 빠졌거나 타입이 잘못되면 예외를 던진다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> badArgs = [</span><br><span class="line">        <span class="comment">// 인자가 아예 없는 경우</span></span><br><span class="line">        [],</span><br><span class="line">        [<span class="string">'Name'</span>],</span><br><span class="line">        [<span class="string">'Name'</span>, [<span class="string">'Dependency1'</span>, <span class="string">'Dependency2'</span>]],</span><br><span class="line">        [<span class="string">'Name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;],</span><br><span class="line">        <span class="comment">// 타입이 잘못된 경우</span></span><br><span class="line">        [<span class="number">1</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;],</span><br><span class="line">        [<span class="string">'Name'</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;],</span><br><span class="line">        [<span class="string">'Name'</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'should be a function'</span>]</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      badArgs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        expect(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          container.register.apply(container, args);</span><br><span class="line">        &#125;).toThrowError(container.messages.registerRequiresArgs);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>container는 ‘테스트 대상’으로 beforeEach에서 생성된다. 테스트마다 인스턴스를 갓 구워내면 다른 테스트의 결과를 어지럽히지 않아도 된다.</li><li>TDD 순수주의자는 badArgs 원소마다 테스트를 따로 만들라고 하겠지만, 실제로 그렇게까지 개발자에게 부담을 주면 필요한 조건을 모두 테스트하기도 전에 질려버릴지도 모른다.</li></ul><p>위의 테스트는 당연히 실패한다. DiContainer에 수정이 필요하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> DiContainer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DiContainer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.messages = &#123;</span><br><span class="line">  registerRequiresArgs: <span class="string">'이 생성자 함수는 인자가 3개 있어야 합니다. 문자열, 문자열 배열, 함수'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span> (<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ix;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> name !== <span class="string">'string'</span> ||</span><br><span class="line">    !<span class="built_in">Array</span>.isArray(dependencies) ||</span><br><span class="line">    <span class="keyword">typeof</span> func !== <span class="string">'function'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.messages.registerRequiresArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ix = <span class="number">0</span>; ix &lt; dependencies.length; ++ix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dependencies[ix] !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.messages.registerRequiresArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>register 함수는 여전히 아무 일도 하지 않지만, 이 함수만으로는 의존성을 다시 끌어낼 방법이 없으므로 컨테이너에 의존성이 잘 들어갔는지 테스트하기 어렵다. 따라서 자연스레 나머지 반쪽 그림에 해당하는 get 함수에 관심이 쏠린다. 이 함수의 유일한 인자는 조회할 의존성 명이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DiContainer.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'get(name)'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'성명이 등록되어 있지 않으면 undefined를 반환한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      expect(container.get(<span class="string">'notDefined'</span>)).toBeUndefined();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>이제 get 함수 작성과 DiContainer 를 수정한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DiContainer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.registrations = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span> (<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.registrations[name] = &#123; <span class="attr">func</span>: func &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> registration = <span class="keyword">this</span>.registrations[name];</span><br><span class="line">  <span class="keyword">if</span> (registration === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> registration.func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'등록된 함수를 실행한 결과를 반환한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'MyName'</span>,</span><br><span class="line">    returnFromRegisteredFunction = <span class="string">"something"</span>;</span><br><span class="line"></span><br><span class="line">  container.register(name, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> returnFromRegisteredFunction;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(container.get(name)).toBe(returnFromRegisteredFunction);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이제 get은 자신이 반환하는 객체에 의존성을 제공할 수 있다. 아래 코드는 1개의 메인 객체와 2개의 의존성을 등록하는 테스트로, 메인 객체는 두 의존성의 반환값을 합한 값을 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">DiContainer.prototype.register = <span class="function"><span class="keyword">function</span> (<span class="params">name, dependencies, func</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.registrations[name] = &#123; <span class="attr">dependencies</span>: dependencies, <span class="attr">func</span>: func &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DiContainer.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>,</span><br><span class="line">    registration = <span class="keyword">this</span>.registrations[name],</span><br><span class="line">    dependencies = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (registration === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registration.dependencies.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">dependencyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dependency = self.get(dependencyName);</span><br><span class="line">    dependencies.push(dependency === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : dependency);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> registration.func.apply(<span class="literal">undefined</span>, dependencies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'등록된 함수에 의존성을 제공한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> main = <span class="string">'main'</span>,</span><br><span class="line">    mainFunc,</span><br><span class="line">    dep1 = <span class="string">'dep1'</span>,</span><br><span class="line">    dep2 = <span class="string">'dep2'</span>;</span><br><span class="line"></span><br><span class="line">  container.register(main, [dep1, dep2], <span class="function"><span class="keyword">function</span> (<span class="params">dep1Func, dep2Func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dep1Func() + dep2Func();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.register(dep1, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.register(dep2, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  mainFunc = container.get(main);</span><br><span class="line">  expect(mainFunc()).toBe(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/33211518?Acode=101">자바스크립트 패턴과 테스트</a><br><a href="https://github.com/kkangil/javascript-pattern-test">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>웹 사이트 최적화</title>
      <link>https://kkangil.github.io/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/</link>
      <guid>https://kkangil.github.io/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/</guid>
      <pubDate>Mon, 27 Jan 2020 07:06:16 GMT</pubDate>
      <description>
      
        &lt;p&gt;제이콥 닐슨의 웹 사이트인 “useit.com”은 웹 사이트의 반응 시간을 다음과 같이 평가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0.1초: 사용자의 동작에 해당 기능이 바로 반응한다고 느끼는 시간&lt;/li&gt;
&lt;li&gt;1초: 불필요하게 오래 기다리지 않았다고 느끼는 시간. 0.2~1초의 시간은 컴퓨터가 동작하는 시간으로 이해할 수 있는 시간이다. 시간이 1초 이상 걸리면 컴퓨터의 동작에 이상이 생겼다고 생각하게 된다.&lt;/li&gt;
&lt;li&gt;10초: 사용자가 집중력을 잃지 않는 최대 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 평가에 따르면 웹 페이지의 반응 시간이 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다. 웹 사이트의 기능이 점점 복잡해지고 많아지면서 느린 반응 속도 때문에 이용 중인 서비스를 떠나 다른 유사한 서비스를 이용하게 만드는 사이트가 있는 반면, 빠른 반응 속도로 웹 사이트를 탐색하는데 큰 불편함이 없는 서비스를 제공하는 사이트도 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>제이콥 닐슨의 웹 사이트인 “useit.com”은 웹 사이트의 반응 시간을 다음과 같이 평가한다.</p><ul><li>0.1초: 사용자의 동작에 해당 기능이 바로 반응한다고 느끼는 시간</li><li>1초: 불필요하게 오래 기다리지 않았다고 느끼는 시간. 0.2~1초의 시간은 컴퓨터가 동작하는 시간으로 이해할 수 있는 시간이다. 시간이 1초 이상 걸리면 컴퓨터의 동작에 이상이 생겼다고 생각하게 된다.</li><li>10초: 사용자가 집중력을 잃지 않는 최대 시간</li></ul><p>이 평가에 따르면 웹 페이지의 반응 시간이 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다. 웹 사이트의 기능이 점점 복잡해지고 많아지면서 느린 반응 속도 때문에 이용 중인 서비스를 떠나 다른 유사한 서비스를 이용하게 만드는 사이트가 있는 반면, 빠른 반응 속도로 웹 사이트를 탐색하는데 큰 불편함이 없는 서비스를 제공하는 사이트도 있다.</p><a id="more"></a><p>많은 포털과 서비스 업체에서는 이러한 사용자의 기대에 부응하기 위해 여러 가지 방법을 시도했다. 그러던 중에 웹 페이지 성능 최적화라는 개념이 생겨났다. 웹 서비스의 반응 속도를 개선할 수 있는 가장 효과적인 방법은 네트워크 속도의 개선이지만 이는 단기간에 이루기 힘든 과제이며 인터넷 서비스를 제공하는 업체에서는 불가능한 부분이다. 대신 반대로 네트워크 사용량을 줄이고 브라우저에서 웹 페이지의 실행 속도를 높여 웹 페이지의 반응 속도를 개선하고 있다.</p><h2 id="브라우저-동작-방식을-기반으로-한-최적화"><a href="#브라우저-동작-방식을-기반으로-한-최적화" class="headerlink" title="브라우저 동작 방식을 기반으로 한 최적화"></a>브라우저 동작 방식을 기반으로 한 최적화</h2><p>웹 페이지 최적화는 브라우저가 네트워크와 통신하는 과정은 물론 브라우저에서 페이지를 표시하는 과정에서의 응답 속도를 개선하는 것이다. 브라우저가 어떻게 동작하는지 이해해야 올바른 개선 방향을 잡을 수 있다.<br>사용자는 원하는 웹 사이트로 이동하기 위해 다음의 작업을 수행하고 브라우저의 동작 방식이다.</p><ol><li>브라우저의 주소창에 주소를 입력하고 Enter 키를 누르거나 링크를 클릭한다.</li><li>브라우저는 서버에 요청을 보내 페이지를 구성하는 자원을 다운로드한다.</li><li>다운로드 받은 자원을 이용해 요청 결과를 화면에 보여준다.</li></ol><p>이때 브라우저가 어떤 단계로 동작하는지, 단계별로 얼마나 시간이 걸리는지 정의한 연구 활동이 W3C의 네비게이션 타이밍(Navigation Timing) 명세다. 네비게이션 타이밍 명세의 가장 큰 목적은 정확한 단계별 소요 시간을 측정하는 것이지만 브라우저의 처리 단계를 정확하게 정의했다는 데도 큰 의미가 있다.</p><p>네비게이션 타이밍 명세에서 브라우저가 사용자의 요청을 처리하는 순서를 정리한 프로세싱 모델에서 웹 페이지 최적화와 관련 있는 단계를 정리한 것이다.</p><blockquote><p>서비스 이동 단계 -&gt; 리다이렉트 단계 -&gt; 애플리케이션 캐시 확인 단계 -&gt; 네트워크 통신 단계 -&gt; 브라우저 처리 단계</p></blockquote><ul><li>서비스 이동 단계: 사용자가 웹 서비스를 이용하다 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계. 프로세싱 모델의 Prompt for unload</li><li>리다이렉트 단계: 사용자가 요청한 URL에서 다른 URL로 다시 보내는 단계. 프로세싱 모델의 redirect</li><li>애플리케이션 캐시 확인 단계: 브라우저의 캐시에 데이터가 있는지 확인하는 단계. 프로세싱 모델의 App Cache</li><li>네트워크 통신 단계: 브라우저가 네트워크와 통신해서 웹 페이지와 구성 요소를 다운로드 하는 단계. 프로세싱 모델의 DNS, TCP, Request, Response 등</li><li>브라우저 처리 단계: 다운로드한 웹 페이지와 구성 요소로 웹 페이지를 화면에 그리는 단계. 프로세싱 모델의 Processing, onLoad</li></ul><h3 id="서비스-이동-단계"><a href="#서비스-이동-단계" class="headerlink" title="서비스 이동 단계"></a>서비스 이동 단계</h3><p>서비스 이동 단계는 웹 서비스를 이용하다가 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계다. 이 단계의 작업은 다른 주소로 이동하기 전에 보고 있던 페이지에서 실행하는데, 모두 브라우저 내부에서 처리하기 때문에 브라우저 성능과 직결된다.</p><p>웹 서비스를 이용하면 페이지가 표시될 때 우리도 모르게 이번트가 할당되고, 이때 메모리를 조금씩 사용한다. 그런데 이 메모리를 더 이상 사용하지 않을 때, 즉 페이지를 떠날 때는 메모리를 해제해야 한다. 이 <code>메모리 해제</code> 작업이 서비스 이동 단계에서 실행하는 작업 가운데 하나다.</p><p>필요 없는 메모리 해제를 담당하는 <code>가비지 컬렉션 기능</code>이 제대로 동작하지 않으면 브라우저가 응답 없음 상태가 되거나 실행 속도가 급격히 느려진다. 웹 페이지에서 동시에 많은 변수가 생성되고 처리되는 동안 브라우저에서 허용한 임계치를 넘었을 때 가비지 컬렉션이 동작하는데 가비지 컬렉션이 동작하면 스크립트 실행이 중단된다. 가비지 컬렉션이 완료되기 전까지는 스크립트가 동작하지 못해 페이지 느려지는 것이다.</p><p>서비스 이용 단계의 작업은 브라우저 내부에서 자동으로 실행한다. 만약 별도로 처리하려면 beforeunload 이벤트를 활용할 수 있다.</p><h3 id="리다이렉트-단계"><a href="#리다이렉트-단계" class="headerlink" title="리다이렉트 단계"></a>리다이렉트 단계</h3><p>쉽게 볼 수 있는 리다이렉트는 SNS에서 사용하는 단축 URL이다. SNS의 특성상 입력하는 글자 수에 제한이 있다. 쿼리가 긴 URL을 그대로 SNS에 입력하면 글자 수 제한 때문에 원하는 내용을 다 입력하지 못한다. 이때 단축 URL을 사용하면 SNS의 글자 수 제한을 피할 수 있다. 단축 URL로 접속하면 원본 URL로 리다이렉트 된다.</p><p>리다이렉트가 발생하면 상태 코드로 301이나 302를 반환하는데, 이는 HTTP 요청을 완수하기 위해서 추가로 뭔가를 해야 한다는 의미다. 이런 이유로 리다이렉트가 발생하면 어떤 자원도 다운로드 하지 않으며 브라우저에 일시적으로 빈 페이지가 보인다. 그렇기 때문에 특정한 목적으로 리다이렉트를 사용하는 것은 어쩔 수 없지만 의도치 않게 또는 실수로 리다이렉트가 발생한다면 웹 페이지의 성능 향상을 위해 바로 잡아야 한다.</p><p>리다이렉트와 관련해서 개발자가 흔히 저지르는 실수 가운데 하나는 URL 뒤에 슬래시를 넣지 않는 것이다. 주소창에 ‘naver.com’을 입력하고 Enter키를 누르면, 주소창에 입력한 주소가 <code>https://www.naver.com/&#39;</code>으로 바뀌면서 리다이렉트 된다. 이 과정을 개발자 도구로 확인해보면 302 redirect 가 발생하는 것을 확인할 수 있다. a 태그의 href 속성에 주소 뒤에 슬래시를 붙여 301, 302 로 인한 리다이렉트가 발생하지 않도록 막을 수 있다. (307 도 발생하고는 하는데 302와 의미하는바가 같다.)</p><p>두번째로 실수하는 부분은 웹 페이지를 이용한 리다이렉트다. 흔히 메타태그를 이용하는데 다음 코드는 1초 후에 페이지가 이동하는 코드다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;1; url&#x3D;https:&#x2F;&#x2F;www.naver.com&#x2F;&quot;&gt;</span><br></pre></td></tr></table></figure><br>이 코드에는 두 가지 성능 문제가 있다. 첫 번째는 이 코드를 실행시킬 별도의 페이지를 거쳐야 리다이렉트 된다는 점이다. 두 번째는 최종 페이지에 도착했을 때 캐시가 설정된 리소스임에도 불구하고 조건부 GET 요청이 이뤄진다는 점이다.</p><p>조건부 GET 요청은 브라우저에 캐싱된 리소스를 사용하기 전에 해당 리소스를 사용해도 되는지 서버에 물어 보는 것이다. 이때 헤더의 <code>If-Modified-Since</code> 정보를 이용해 서버에 요청을 보낸다. 리소스가 수정되지 않았다면 <code>304 Not Modified</code> 코드를 받아 캐시에 있는 리소스를 사용한다. 자원이 수정됐다면 서버로부터 리소스를 다운로드 한다.</p><p><code>캐시의 만료 날짜를 설정</code>했다면 서버의 확인을 거치지 않고 바로 캐싱된 리소스를 사용할 수 있는데, 메타태그로 리다이렉트하면 조건부 GET 요청으로 불필요한 서버 통신이 발생해 응답 속도가 느려진다.</p><p>웹 페이지의 주소뿐 아니라 이미자와 스타일시트, 자바스크립트와 같이 페이지를 구성하는 요소도 리다이렉트 될 수 있다. 301 이나 302 상태 코드가 발생하는 요소를 찾고 의도치 않게 리다이렉트가 발생하고 있다면 성능 향상을 위해서 바로 잡아야 한다.</p><h3 id="애플리케이션-캐시-확인-단계"><a href="#애플리케이션-캐시-확인-단계" class="headerlink" title="애플리케이션 캐시 확인 단계"></a>애플리케이션 캐시 확인 단계</h3><p>리다이렉트 작업을 마치고 HTTP 요청을 처리하기 위한 준비를 마쳤다면 브라우저는 먼저 서버로 요청을 보낸다. 서버에서 응답이 오면 개별 요소(이미지, 스타일시트, 자바스크립트 등)가 사용자 PC에 있는지 캐시 데이터를 찾는다. 캐시 데이터의 종류에는 쿠키, 이미지, 스크립트, 스타일시트 등이 있다.</p><p>캐시 데이터가 있는 이유는 무엇보다도 사용자가 동일한 페이지를 다시 방문했을 때 브라우저와 서버 사이에 통신을 하지 않고 캐시에 있는 자원을 사용하겠다는 것이다. 성능 향상을 위해 가장 효과적인 방법은 브라우저와 서버 사이의 통신을 최대한으로 줄이는 것이다. 그러므로 다시 방문한 사용자에게 좀 더 빠른 응답 속도를 제공하려면 애플리케이션 캐시를 잘 활용해야한다.</p><p>캐시를 다룰 때는 개별 요소들이 정말 유효한지, 사용해도 되는 것인지 검증하는 것이 중요하기 때문에 몇 가지 용어와 규칙이 필요하다.</p><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Last-Modified</td><td>서버에서 저장하고 있는 마지막 수정 날짜 예: Last-Modified Sun, 27 Jan 2020 17:00:00 GMT</td></tr><tr><td>If-Modified-Since</td><td>브라우저에서 저장하고 있는 마지막 수정 날짜 예: If-Modified-Since Sun, 27 Jan 2020 17:00:00 GMT</td></tr><tr><td>Expires</td><td>만료 날짜. 언제까지 유효한지 미리 지정해 놓은 시간 정보로, 특정 날짜까지는 사용할 수 있다는 정보. 예: Expires 17:00:00 Sunday, December 27, 2020 GMT</td></tr><tr><td>Cache-Control</td><td>Expires 정보의 한계를 극복하려고 HTTP/1.1 에서 소개된 캐시 설정 추가 정보</td></tr><tr><td>max-age</td><td>캐싱할 시간. Cache-Control 정보 가운데 하나로 캐싱할 시간을 초 단위까지 정할 수 있다. max-age 정보는 클라이언트 시간과 관계 없이 현재부터 며칠, 몇 년 등으로 지정할 수 있다.</td></tr></tbody></table><p>자원 요소를 다운로드할때 브라우저가 처리하는 과정이다.</p><p>Expires 정보 확인 (정보 없음)-&gt; If-Modified-Since 정보 확인(정보 있음) -&gt; If-Modified-Since 정보와 Last-Modified 정보 비교</p><ul><li>Expires 정보가 있고 기한이 남아 있으면 캐시에 저장된 요소를 사용한다.</li><li>If-Modified-Since가 없으면 서버에 요소를 요청한다.</li><li>If-Modified-Since 정보가 있으면 Last-Modifed 정보를 비교하고 날짜가 같으면 캐시에 저장된 요소를 사용하라는 응답 304 Not Modifed 을 보내주고, 날짜가 다른 경우 서버의 요소를 전송한다.</li></ul><p>사용자 PC에 캐시 파일이 있고 Expires 정보가 유효하다면 해당 파일을 서버에 요청하지 않고 캐시에 저장된 파일을 이용한다. 이러면 동적인 이미지 등을 제외한 나머지 정적인 요소는 별도로 서버에 요청하지 않기 때문에 로딩 속도를 크게 향상시킬 수 있다.</p><h3 id="네트워크-통신-단계"><a href="#네트워크-통신-단계" class="headerlink" title="네트워크 통신 단계"></a>네트워크 통신 단계</h3><p>네트워크 비용을 줄이는 첫 번째 방법은 Expires 설정이나 Cache Control 속성을 이용해 사용자 웹 페이지에 다시 왔을 때 캐시를 사용하는 방법이다. 두 번째 방법은 스타일시트나 자바스크립트와 같이 파일을 합쳐서 서비스해도 문제가 없는 리소스를 합쳐 하나의 링크로 제공해 요청 횟수를 줄이는 방법이다.</p><h5 id="DNS-DNS-Lookup"><a href="#DNS-DNS-Lookup" class="headerlink" title="DNS (DNS Lookup)"></a>DNS (DNS Lookup)</h5><p>호스트 이름으로 IP 주소를 조회한 시간이다. 보통 20~120ms 정도 소요된다. 이 작업이 완료되지 않으면 어떤 자원도 다운로드 하지 않는다. 브라우저에서 IP 주소를 조회할 때 동일한 호스트로 요청하는 요소는 다시 IP 주소를 확인하지 않아 시간이 추가로 걸리지 않는다. 그럼 하나의 호스트로 모든 리소스를 호출하면 시간을 줄일 수 있을 것 같지만, 대신 호스트별 동시 연결 기능은 포기해야 한다.</p><p>보통 이미지의 크기가 크고 개수가 많은 이미지 검색 서비스를 개발할 때 이런 부분을 많이 고려한다. 한 번에 보이는 이미지의 개수가 많을 때 호스트를 여러 개 만들어 동시에 다운로드하면 성능을 높일 수 있다고 생각하지만 실제로는 고려할 사항도 많다. DNS Lookup 단계에서 걸리는 시간도 무시할 수 없다. 때문에 여러 가지 가정을 세워서 테스트한 다음 최적의 호스트 개수를 찾아야한다.</p><h5 id="Request-Send"><a href="#Request-Send" class="headerlink" title="Request(Send)"></a>Request(Send)</h5><p>웹 서버와 TCP 연결이 이뤄지면 원하는 정보를 서버에 보내는 시간이다. 주로 요청 헤더 정보를 보내는 시간이 여기에 해당한다. Send 시간은 파일 올리기와 같이 보내야 할 정보가 많을수록 오래 걸린다.<br>일반적인 상황에서 Send 시간을 최적화하는 방법은 쿠키 정보를 포함하지 않는 별도 호스트를 사용해 서비스하는 것이다. 쿠키 정보가 필요 없는 파일(이미지, 스타일시트, 자바스크립트)에는 별도 호스트를 적용해 헤더 정보에서 쿠키 정보를 없애는 것이다.</p><h5 id="Response-Receive"><a href="#Response-Receive" class="headerlink" title="Response(Receive)"></a>Response(Receive)</h5><p>서버에서 보내는 응답 메시지를 받는 시간이다. 이 단계에서 성능을 개선하는 방법으로는 데이터 크기를 줄이기 위해 Gzip과 같은 파일 압축 기술을 사용하는 방법이 있다. 주석이나 공백을 없애 코드의 양을 줄이고, 코드의 양을 줄인 파일을 Gzip 등으로 압축해서 파일의 크기를 줄인다. Gzip으로 압축하면 원본 파일의 약 30% 정도로 크기가 줄어든다.</p><h3 id="브라우저-처리-단계"><a href="#브라우저-처리-단계" class="headerlink" title="브라우저 처리 단계"></a>브라우저 처리 단계</h3><p>프로세싱 모델의 Processing과 onLoad 에 해당하는 브라우저 처리 단계는 서버에서 받은 HTML과 이미지, 스타일시트를 조합해 사용자가 실제로 보는 화면을 만드는 단계다. 복잡한 UI를 개발할 때는 인라인 형태의 이벤트 바인딩 방법보다 이벤트 핸들러로 바인딩하는 방법을 사용한다. 이벤트 핸들러로 이벤트를 바인딩하려면 최우선 조건이 해당 DOM이 존재해야 한다. 모든 DOM이 존재하는 바로 그 시점이 DOMContentLoaded 이벤트나 onload 이벤트가 발생하는 시점이다.</p><blockquote><p>브라우저의 DOM 처리 절차에 따른 이벤트 발생 순서<br>domLoading -&gt; domInteractive -&gt; domContentLoaded -&gt; domComplete -&gt; onload</p></blockquote><p>onload 이벤트는 DOM 에서 기본으로 제공하는 이벤트로 문서에 있는 모든 이미지, 스타일시트, 자바스크립트 등이 모두 다운로드 될 때마다 발생한다. 이와 달리 DOMContentLoaded 이벤트는 기본적으로 DOM 생성에만 관련돼있다. 이미자나 다른 요소를 다운로드 하는것과 관계없이 DOM이 로딩되고 난 직후에 발생한다.</p><p>많은 양의 이벤트를 바인딩해야 하고 이미지나 스타일시트의 개수가 많은 페이지를 개발한다면 onload 이벤트보다는 DOMContentLoaded 이벤트를 이용하는게 좋다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/7516929?scode=032&amp;OzSrank=2">자바스크립트 성능 이야기</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/#disqus_thread</comments>
    </item>
    
    <item>
      <title>도구 다루기-2</title>
      <link>https://kkangil.github.io/2020/01/27/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-2/</link>
      <guid>https://kkangil.github.io/2020/01/27/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-2/</guid>
      <pubDate>Mon, 27 Jan 2020 04:45:31 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;재스민-들어가기&quot;&gt;&lt;a href=&quot;#재스민-들어가기&quot; class=&quot;headerlink&quot; title=&quot;재스민 들어가기&quot;&gt;&lt;/a&gt;재스민 들어가기&lt;/h2&gt;&lt;p&gt;재스민은 행위 주도 개발 (Behavior-Driven Development, BDD) 방식으로 자바스크립트 단위 테스트를 작성하기 위한 라이브러리다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BDD와 TDD는 상호 배타 관계가 아니다. BDD는 단위 테스트로 확인할 기능 또는 작동 로직을 일상 언어로 서술하는데, 이로써 개발자는 자신이 작성 중인 코드가 &lt;code&gt;어떻게&lt;/code&gt;가 아니라 &lt;code&gt;무엇&lt;/code&gt;을 해야하는지 테스트 코드에 표현할 수 있다. 그리고 행위 주도 스타일로 정의/구성한 테스트는 쉬운 문장으로 서술한 기능 명세서로 삼을 만하다는 이점도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="재스민-들어가기"><a href="#재스민-들어가기" class="headerlink" title="재스민 들어가기"></a>재스민 들어가기</h2><p>재스민은 행위 주도 개발 (Behavior-Driven Development, BDD) 방식으로 자바스크립트 단위 테스트를 작성하기 위한 라이브러리다.</p><blockquote><p>BDD와 TDD는 상호 배타 관계가 아니다. BDD는 단위 테스트로 확인할 기능 또는 작동 로직을 일상 언어로 서술하는데, 이로써 개발자는 자신이 작성 중인 코드가 <code>어떻게</code>가 아니라 <code>무엇</code>을 해야하는지 테스트 코드에 표현할 수 있다. 그리고 행위 주도 스타일로 정의/구성한 테스트는 쉬운 문장으로 서술한 기능 명세서로 삼을 만하다는 이점도 있다.</p></blockquote><a id="more"></a><h3 id="테스트-꾸러미와-스펙"><a href="#테스트-꾸러미와-스펙" class="headerlink" title="테스트 꾸러미와 스펙"></a>테스트 꾸러미와 스펙</h3><p>재스민 테스트 꾸러미는 전역 함수 describe로 정의되며, 이 함수는 두 인자를 받는다.</p><ul><li>문자열: 무엇을 테스트할지 서술한다.</li><li>함수: 테스트 꾸러미의 구현부다.</li></ul><p>테스트 꾸러미는 스펙, 즉 개별 테스트로 구현되며, 각 스펙은 전역 함수 it으로 정의된다. it 함수도 describe 처럼 인자를 2개 받는다.</p><ul><li>문자열: 무엇을 테스트할지 서술한다.</li><li>적어도 한 개의 기대식을 가진 함수: 코드 상태의 true/false를 확인하는 단언</li></ul><p>테스트 꾸러미 구현부에 전역 함수 beforeEach/afterEach 를 쓰면 각 꾸러미 테스트가 실행되기 이전에 beforeEach 함수를, 그 이후에는 afterEach 함수를 호출한다. 전체 테스트가 공유할 설정과 정리 코드를 두 함수에 담아두면 코드 중복을 피할 수 있어 좋다.</p><p>설정 단계가 정확히 같은 테스트가 2개 있는데, beforeEach 함수로 간단히 해결할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'createReservation(passenger, flight)'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'주어진 passenger를 passengerInfo 프로퍼티에 할당한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testPassenger = <span class="literal">null</span>,</span><br><span class="line">      testFlight = <span class="literal">null</span>,</span><br><span class="line">      testReservation = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      testPassenger = &#123;</span><br><span class="line">        firstName: <span class="string">"윤지"</span>,</span><br><span class="line">        lastName: <span class="string">"김"</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      testFlight = &#123;</span><br><span class="line">        number: <span class="string">"3443"</span>,</span><br><span class="line">        carrier: <span class="string">"대한항공"</span>,</span><br><span class="line">        destination: <span class="string">"울산"</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      testReservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">"passenger를 passenger Information 프로퍼티에 할당한다."</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      expect(testReservation.passengerInformation).toBe(testPassenger);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">"flight를 flightInformation 프로퍼티에 할당한다."</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      expect(testReservation.flightInformation).toBe(testFlight);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="기대식과-매처"><a href="#기대식과-매처" class="headerlink" title="기대식과 매처"></a>기대식과 매처</h3><p>expect 문은 테스트마다 있다. 다음은 첫 번째 단위 테스트 createReservation의 expect 문이다.</p><blockquote><p>expect(testReservation.passengerInformation).toBe(testPassenger);</p></blockquote><p>expect 함수는 테스트 대상 코드가 낸 실제값을 인자로 받아 기댓값과 견주어본다. 이 테스트가 기대하는 값은 testPassenger다.</p><p>실제값과 기댓값을 비교하는 일은 매처(matcher) 함수의 몫이다. 매처는 비교 결과 성공하면 true, 실패하면 false를 반환한다. 하나 이상의 기대식이 포함된 스펙에서 매처가 하나라고 실패하면 모조리 실패한 것으로 간주한다.</p><p>toBe 매처는 이름에서 짐작할 수 있듯이 testResevation.passengerInformation이 testPassenger 와 같은 객체여야 한다는 의미다.</p><h3 id="스파이"><a href="#스파이" class="headerlink" title="스파이"></a>스파이</h3><p>재스민 스파이(spy)는 테스트 더블(test double) 역할을 하는 자바스크립트 함수다. 테스트 더블은 어떤 함수/객체의 본래 구현부를 테스트 도중 다른 코드로 대체한 것을 말하며, 웹 서비스 같은 외부 자원과의 의존 관계를 없애고 단위 테스트의 복잡도를 낮출 목적으로 사용된다.</p><blockquote><p>다음 다섯 가지를 통칭하여 테스트 더블이라고 한다.</p><ol><li>더미(dummy): 보통 인자 리스트를 채우기 위해 사용되며, 전달은 하지만 실제로 사용되지는 않는다.</li><li>틀(stub): 더미를 조금 더 구현하여 아직 개발되지 않은 클래스나 메서드가 실제 작동하는 것 처럼 보이게 만든 객체로 보통 리턴 값은 하드 코딩한다.</li><li>스파이(spy): 틀과 비슷하지만 내부적으로 기록을 남긴다는 점이 다르다. 특정 객체가 사용되었는지, 예상되는 메서드가 특정한 인자로 호출되었는지 등의 상황을 감시하고 이러한 정보를 제공하기도 한다.</li><li>모의체(fake): 틀에서 조금 더 발전하여 실제로 간단히 구현된 코드를 갖고는 있지만, 운영 환경에서 사용할 수는 없는 객체다.</li><li>모형(mock): 더미, 틀, 스파이를 혼합한 형태와 비슷하나 행위를 검증하는 용도로 주로 사용된다.</li></ol></blockquote><p>ReservationSaver 라는 자바스크립트 객체를 만들어 이 객체의 saveReservation 함수로 웹 서비스에 예약 데이터를 전송하는 기능을 캡슐화했다. createReservation 함수를 확장하여 이 함수가 ReservationSaver 인스턴스를 인자로 받아 이 인스턴스의 saveReservation 함수를 실행하는지 확인하고자 한다.<br>saveReservation 함수는 웹 서비스와 통신하므로 지금부터 작성할 테스트는 예약 데이터 저장 후 DB를 질의하고 예약 데이터가 분명히 추가됐는지 확인하는 과정이 모두 들어가야 할 듯 싶다. 하지만 그렇지 않다. 자칫 단위 테스트가 웹 서비스, DB 같은 외부 시스템 유무와 작동 여부에 의존하게 될지도 모른다.</p><p>재스민 스파이를 사용하면 복잡한 saveReservation 구현부를 외부 시스템 의존성을 배제한, 단순한 형태로 바꿀 수 있다. 먼저 작성한 ReservationSaver 객체다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReservation</span>(<span class="params">passenger, flight, saver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reservation = &#123;</span><br><span class="line">    passengerInformation: passenger,</span><br><span class="line">    flightInformation: flight</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  saver.saveReservation(reservation);</span><br><span class="line">  <span class="keyword">return</span> reservation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReservationSaver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.saveReservation = <span class="function"><span class="keyword">function</span> (<span class="params">reservation</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 예약 정보를 저장하는 웹 서비스와 연동하는 복잡한 코드가 있을 것이다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createReservation 함수는 ReservationSaver 인스턴스를 전달받게끔 개선되었다. ReservationSaver를 인자로 받으므로 예약 데이터가 저장되었는지를 확인하는 테스트를 다음과 같이 작성할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"createReservation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> saver = <span class="keyword">new</span> ReservationSaver();</span><br><span class="line">  <span class="keyword">var</span> testPassenger = <span class="literal">null</span>,</span><br><span class="line">    testFlight = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    testPassenger = &#123;</span><br><span class="line">      firstName: <span class="string">"윤지"</span>,</span><br><span class="line">      lastName: <span class="string">"김"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testFlight = &#123;</span><br><span class="line">      number: <span class="string">"3443"</span>,</span><br><span class="line">      carrier: <span class="string">"대한항공"</span>,</span><br><span class="line">      destination: <span class="string">"울산"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  createReservation(testPassenger, testFlight, saver);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>saver.saveReservation이 정말 호출 되었는지 어떻게 알 수 있을까?<br>이 테스트는 코드에 씌어있는 대로 복잡한 ReservationSaver의 기본 구현부를 createReservation 함수에 전달하고 있다. 이렇게 하면 결국 외부 시스템에 의존하게 되고 함수를 테스트하기가 어려워지므로 별로 내키지 않는다. 이럴때 재스민 스파이가 제격이다.</p><p>createReservation을 호출하기 전에 saveReservation 함수에 스파이를 심는다. 스파이로 함수 실행 여부를 알 수 있는데, 첫 번째 테스트에 아주 잘 들어맞는다.<br>재스민에서 전역 함수 spyOn을 쓰면 특정 함수를 몰래 들여다볼 수 있다. 이 함수의 첫 번째 인자는 객체 인스턴스, 두 번째 인자는 감시할 함수명이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"createReservation"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> saver = <span class="keyword">new</span> ReservationSaver();</span><br><span class="line">  <span class="keyword">var</span> testPassenger = <span class="literal">null</span>,</span><br><span class="line">    testFlight = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  spyOn(saver, <span class="string">'saveReservation'</span>);</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    testPassenger = &#123;</span><br><span class="line">      firstName: <span class="string">"윤지"</span>,</span><br><span class="line">      lastName: <span class="string">"김"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testFlight = &#123;</span><br><span class="line">      number: <span class="string">"3443"</span>,</span><br><span class="line">      carrier: <span class="string">"대한항공"</span>,</span><br><span class="line">      destination: <span class="string">"울산"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  createReservation(testPassenger, testFlight, saver);</span><br><span class="line"></span><br><span class="line">  expect(saver.saveReservation).toHaveBeenCalled();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>스파이를 써서 saver 객체의 saveReservation 구현부를 예약 데이터 저장 기능과 무관한 함수로 대체했다. 스파이는 함수를 호출한 시점과 호출 시 전달한 인자까지 정확히 포착하고, 무엇보다 재스민은 어떤 스파이가 한 번 이상 실했됐는지 확인하는 기대식을 지닌 스파이 전용 매처(toHaveBeenCalled())를 지원한다.</p><p>createReservation 함수의 인자가 늘었으니 기존 두 테스트 역시 수정할 수 밖에 없다. 하지만 saveReservation 함수 구현부를 직접 실행할 테스트는 없을 테니 ReservationSaver 생성 코드와 스파이 관련 코드를 전체 꾸러미의 beforeEach 함수로 옮겨 리팩토링 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"createReservation"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> testPassenger = <span class="literal">null</span>,</span><br><span class="line">    testFlight = <span class="literal">null</span>,</span><br><span class="line">    testReservation = <span class="literal">null</span>,</span><br><span class="line">    testSaver = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    testPassenger = &#123;</span><br><span class="line">      firstName: <span class="string">"윤지"</span>,</span><br><span class="line">      lastName: <span class="string">"김"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testFlight = &#123;</span><br><span class="line">      number: <span class="string">"3443"</span>,</span><br><span class="line">      carrier: <span class="string">"대한항공"</span>,</span><br><span class="line">      destination: <span class="string">"울산"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    testSaver = <span class="keyword">new</span> ReservationSaver();</span><br><span class="line">    spyOn(testSaver, <span class="string">'saveReservation'</span>);</span><br><span class="line"></span><br><span class="line">    testReservation = createReservation(testPassenger, testFlight, testSaver);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"passenger를 passenger Information 프로퍼티에 할당한다."</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(testReservation.passengerInformation).toBe(testPassenger);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"flight를 flightInformation 프로퍼티에 할당한다."</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(testReservation.flightInformation).toBe(testFlight);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"예약 정보를 저장한다."</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(testSaver.saveReservation).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/33211518?Acode=101">자바스크립트 패턴과 테스트</a><br><a href="https://github.com/kkangil/javascript-pattern-test">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/01/27/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>도구 다루기</title>
      <link>https://kkangil.github.io/2020/01/19/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0/</link>
      <guid>https://kkangil.github.io/2020/01/19/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0/</guid>
      <pubDate>Sun, 19 Jan 2020 08:05:23 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;테스팅-프레임워크&quot;&gt;&lt;a href=&quot;#테스팅-프레임워크&quot; class=&quot;headerlink&quot; title=&quot;테스팅 프레임워크&quot;&gt;&lt;/a&gt;테스팅 프레임워크&lt;/h2&gt;&lt;p&gt;한 여행사의 차세대 예약 시스템 구축 프로젝트에 참여하여 항공 예약 데이터 생성 모듈을 맡게 되었는데, 그중에는 작동 명세가 다음과 같은 모듈 함수가 있었다.&lt;br&gt;‘승객(passenger) 객체, 항공편(flight) 객체를 입력받은 createReservation은 passengerInformation 프로퍼티가 승객 객체, flightInformation 프로퍼티가 항공편 객체인 새로운 객체를 반환한다.’&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="테스팅-프레임워크"><a href="#테스팅-프레임워크" class="headerlink" title="테스팅 프레임워크"></a>테스팅 프레임워크</h2><p>한 여행사의 차세대 예약 시스템 구축 프로젝트에 참여하여 항공 예약 데이터 생성 모듈을 맡게 되었는데, 그중에는 작동 명세가 다음과 같은 모듈 함수가 있었다.<br>‘승객(passenger) 객체, 항공편(flight) 객체를 입력받은 createReservation은 passengerInformation 프로퍼티가 승객 객체, flightInformation 프로퍼티가 항공편 객체인 새로운 객체를 반환한다.’</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReservation</span>(<span class="params">passenger, flight</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    passengerInfo: passenger,</span><br><span class="line">    flightInfo: flight</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>팀 규정상 단위 테스트 없이 제품 코드를 체크인할 수 없으므로 단위 테스트 작성은 반드시 필요하다.<br>참조할 함수는 이미 구현됐으니 어려운 일이 아니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'createReservation(passenger, flight'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'주어진 passenger를 passengerInfo 프로퍼티에 할당한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testPassenger = &#123;</span><br><span class="line">      firstName: <span class="string">'길동'</span>,</span><br><span class="line">      lastName: <span class="string">'홍'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> testFlight = &#123;</span><br><span class="line">      number: <span class="string">'3443'</span>,</span><br><span class="line">      carrier: <span class="string">'대한항공'</span>,</span><br><span class="line">      destination: <span class="string">'울신'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    expect(reservation.passengerInfo).toBe(testPassenger);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'주어진 filght를 flightInfo 프로퍼티에 할당한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testPassenger = &#123;</span><br><span class="line">      firstName: <span class="string">'길동'</span>,</span><br><span class="line">      lastName: <span class="string">'홍'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> testFlight = &#123;</span><br><span class="line">      number: <span class="string">'3443'</span>,</span><br><span class="line">      carrier: <span class="string">'대한항공'</span>,</span><br><span class="line">      destination: <span class="string">'울신'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    expect(reservation.flightInfo).toBe(testFlight);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위의 코드는 재스민 테스팅 프레임워크로 작성한 단위 테스트 코드다.<br>it 함수 각자는 개별 단위 테스트고(위 코드에서는 2개의 단위 테스트), 이들은 함수에서 반환된 객체의 속성이 적절한지 expect 함수로 검사한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"ko"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">data-require</span>=<span class="string">"jasmine@*"</span> <span class="attr">data-semver</span>=<span class="string">"2.0.0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">href</span>=<span class="string">"http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-require</span>=<span class="string">"jasmine@*"</span> <span class="attr">data-semver</span>=<span class="string">"2.0.0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine.js"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-require</span>=<span class="string">"jasmine@*"</span> <span class="attr">data-semver</span>=<span class="string">"2.0.0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine-html.js"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-require</span>=<span class="string">"jasmine@*"</span> <span class="attr">data-semver</span>=<span class="string">"2.0.0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"http://cdn.jsdelivr.net/jasmine/2.0.0/boot.js"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"TestFrameworks_01.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"TestFrameworks_01_test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위와 같이 html 파일을 추가하고 단위 테스트를 실행한다.<br>자세히 들여다 보니 단위테스트에 오류가 보인다. 반환된 예약 객체의 속성명은 passengerInformation과 flightInformation이라고 명세에 나와 있는데, passengerInfo와 flightInfo로 잘못 코딩한 것이다. 명세가 아니라 함수 코드의 개발에 따라 테스트를 작성한 탓에 테스트는 기대하는 함수 작동이 아닌, 구현된 함수의 잘못된 실제 작동을 확인한 꼴이다. 명세 기준으로 테스트 코드를 작성했으면 속성명을 틀릴 일이 없었을 것이다.</p><h3 id="잘못된-코드-발견하기"><a href="#잘못된-코드-발견하기" class="headerlink" title="잘못된 코드 발견하기"></a>잘못된 코드 발견하기</h3><p>TDD는 코드 결함을 최대한 빨리, 곧 코드 생성 직후 감지하며, 작은 기능 하나라도 테스트를 먼저 작성한 뒤, 취소한의 코드만으로 기능을 구현한다.<br>createReservation 함수로 다시 돌아가 테스트를 먼저 작성하면 어떻게 달라지는지 알아보고자 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'createReservation(passenger, flight)'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'주어진 passenger를 passengerInformation 프로퍼티에 할당한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testPassenger = &#123;</span><br><span class="line">      firstName: <span class="string">'길동'</span>,</span><br><span class="line">      lastName: <span class="string">'홍'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> testFlight = &#123;</span><br><span class="line">      number: <span class="string">'3443'</span>,</span><br><span class="line">      carrier: <span class="string">'대한항공'</span>,</span><br><span class="line">      destination: <span class="string">'울신'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reservation = createReservation(testPassenger, testFlight);</span><br><span class="line">    expect(reservation.passengerInformation).toBe(testPassenger);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReservation</span>(<span class="params">passenger, flight</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    passengerInfo: passenger,</span><br><span class="line">    flightInfo: flight</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드로 단위 테스트하면 실패하게 된다.<br>반환 객체의 속성명을 잘못해서 passengerInformation 대신 passengerInfo로 적었다. 속성명을 정정하고 다시 테스트하면 성공한다.</p><p>반환 객체의 속성명을 잘못 쓴 실수가 createReservation 함수를 구현한 코드에 잠복해 있지만, 이번에는 테스트를 먼저 작성한 뒤 명세에 따라 테스트를 했으므로 다른 개발자가 통합 테스트를 진행하다가 에러를 즉시 확인하여 조치할 수 있다.</p><h3 id="테스트성을-감안하여-설계하기"><a href="#테스트성을-감안하여-설계하기" class="headerlink" title="테스트성을 감안하여 설계하기"></a>테스트성을 감안하여 설계하기</h3><p>테스트를 먼저 작성하란 건 코드의 테스트성을 차후에 두고 볼 문제가 아니라 우선적인 주요 관심사로 생각하는 것이다. 어떤 코드의 테스트 용이성과 그 코드의 테스트가 얼마나 잘 이루어졌는지는 직접적인 상관 관계가 있다.</p><h3 id="꼭-필요한-코드만-작성하기"><a href="#꼭-필요한-코드만-작성하기" class="headerlink" title="꼭 필요한 코드만 작성하기"></a>꼭 필요한 코드만 작성하기</h3><p>TDD 작업 절차를 정리해보자. 작은 기능 하나를 검증하려면 실패하는 테스트를 먼저 작성한 뒤, 테스트를 성공시킬 만큼만 최소한으로 코딩한다. 그 후 내부적으로 구현 세부를 변경하는 <code>리팩토링</code> 과정을 거쳐 개발 중인 코드에서 중복 코드를 들어낸다. 이런 과정을 거치면서 결국 마지막에는 꼭 필요한 코드만 남게 된다.</p><h3 id="안전한-유지-보수와-리팩토링"><a href="#안전한-유지-보수와-리팩토링" class="headerlink" title="안전한 유지 보수와 리팩토링"></a>안전한 유지 보수와 리팩토링</h3><p>TDD를 실천하면 프로젝트 제품 코드를 대상으로 확실한 단위 테스트 꾸러미를 구축할 수 있다. 예전에 잘 돌아가던 코드가 지금은 제대로 작동하지 않은 회귀 결함은 코드 품질과 믿음성을 떨어뜨리는 요인이다.<br>여타 보험 정책이 그렇듯, 혜택은 없고 짐만 되는 재발 비용이 발생한다. 단위 테스트의 경우 테스트 꾸러미를 개발/보수하느라 재발 비용이 들어가는데, 보험과 마찬가지로 이 재발 비용을 지불하는 부담에서 벗어나는 시점이 온다.<br>종합적인 단위 테스트 꾸러미가 마련된 제품 코드를 확장 또는 보수할 때도 비슷한 안도감을 느낄 수 있다. 실수로 다른 코드를 건드리지 않았다는 확신을 하고 코드 일부를 변경할 수 있기 때문이다.</p><h3 id="실행-가능한-명세"><a href="#실행-가능한-명세" class="headerlink" title="실행 가능한 명세"></a>실행 가능한 명세</h3><p>TDD 실천 결과, 탄탄하게 구축된 단위 테스트 꾸러미는 테스트 대상 코드의 실행 가능한 명세 역할도 한다. 단위 테스팅 프레임워크인 재스민은 행위 기반(behavior-based) 으로 테스트를 구성한다. 재스민에서 스펙이라 부르는 개별 테스트는, 테스트하여 검증할 작동 로직을 일상 문장으로 표현하면서 시작한다.<br>createReservation 함수를 예로 들면, 재스민으로 단위 테스트한 결과 메시지를 보고 이 함수가 무슨 일을 하는지 큰 그림을 그려볼 수 있다. createReservation이 하는 일을 굳이 코드를 읽고 분석하지 않아도 단위 테스트가 죄다 알려주는 셈이다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/33211518?Acode=101">자바스크립트 패턴과 테스트</a><br><a href="https://github.com/kkangil/javascript-pattern-test">github</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/01/19/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>메모이제이션</title>
      <link>https://kkangil.github.io/2020/01/12/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98/</link>
      <guid>https://kkangil.github.io/2020/01/12/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98/</guid>
      <pubDate>Sun, 12 Jan 2020 04:45:18 GMT</pubDate>
      <description>
      
        &lt;p&gt;메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 메모이제이션은 함수형 프로그래밍 관련 이야기에서는 빠지지 않고 꼭 등장하는 사례이기도 하다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 메모이제이션은 함수형 프로그래밍 관련 이야기에서는 빠지지 않고 꼭 등장하는 사례이기도 하다.</p><a id="more"></a><p>함수형 자바스크립트에서 메모이제이션의 대표적인 사례로는, 한 번 들어온 인자에 대한 결과를 캐싱하여 함수 본체를 실행하지 않고 결과를 즉시 리턴하는 _.memoize 같은 고차 함수가 있다. 동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수의 콘셉트를 잘 활용한 사례이다. 함수 본체에서 하는 일이 복잡하거나 연산이 많거나 내부에서 생성하는 자원이 많거나 시간이 오래 걸리는 함수일수록 메모이제이션을 통해 얻을 수 있는 성능적 이득도 커진다.</p><h2 id="memoize-함수"><a href="#memoize-함수" class="headerlink" title="memoize 함수"></a>memoize 함수</h2><h3 id="메모이제이션-코드로-이해하기"><a href="#메모이제이션-코드로-이해하기" class="headerlink" title="메모이제이션 코드로 이해하기"></a>메모이제이션 코드로 이해하기</h3><p>메모이제이션에 대해 가장 빠르고 쉽게 이해하는 방법은 역시 코드를 통해 확인 하는 것이다. 간단 버전의 memoize 함수를 구현하여 메모이제이션의 콘셉트에 대해 파악해 보려 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[arg]) &#123; <span class="comment">// 이미 동일한 인자에 대한 결과가 있으면 리턴</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'캐시로 결과 바로 리턴'</span>, arg);</span><br><span class="line">      <span class="keyword">return</span> cache[arg];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'본체 실행'</span>, arg);</span><br><span class="line">    <span class="comment">// 받아둔 함수를 실행하면서 결과를 cache에 남겨둠</span></span><br><span class="line">    <span class="keyword">return</span> cache[arg] = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단한 memoize 함수를 구현했다. memoize 함수를 이용해 mult5 라는 함수를 만든다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mult5 = memoize(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">5</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mult5(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 본체 실행 1 -&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(mult5(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 본체 실행 2 -&gt; 10</span></span><br><span class="line"><span class="built_in">console</span>.log(mult5(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 캐시로 결과 바로 리턴 1 -&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(mult5(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 캐시로 결과 바로 리턴 2 -&gt; 10</span></span><br></pre></td></tr></table></figure><p>매우 간단한 개념이다. memoize는 고차 함수다. 해당 로직을 memoize가 대신하도록 만든 사례이다. 메모이제이션은 인자가 하나일 때 활용성이 높다. 하지만 위의 memoize는 인자를 하나만 사용할 수 있다는 점과 문자열로 식별이 가능한 인자만 사용할 수 있다는 점이 아쉽다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = memoize(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// 본체 실행 3 -&gt; 8</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="number">10</span>)); <span class="comment">// 캐시로 결과 바로 리턴 8 캐시가 동작했지만 3에만 의존하기 때문</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = memoize(<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.keys(obj);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(keys(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;));</span><br><span class="line"><span class="comment">// 본체 실행 Object &#123;a: 1, b: 2&#125; -&gt; ['a','b']</span></span><br><span class="line"><span class="built_in">console</span>.log(keys(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;));</span><br><span class="line"><span class="comment">// 캐시로 결과 바로 리턴 Object &#123;a: 1, b: 2&#125; -&gt; ['a','b']</span></span><br><span class="line"><span class="built_in">console</span>.log(keys(&#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;));</span><br><span class="line"><span class="comment">// 잘 동작하는 듯 했지만 cache가 &#123;[object Object]: ...&#125; 이런 식으로 되기 때문에 오류</span></span><br></pre></td></tr></table></figure><p>위의 코드를 보면 오류가 발생했다. JSON.stringfy(arguments); 를 활용해서 위와 같은 문제를 해결할 수 있다. 하지만 이 방법은 별도의 연산이 생겨 느리기도 하고 해결할 수 있는 범위가 적다. 이럴때는 역시 함수로 추상화를 하는 것이 좋다.</p><h3 id="Partial-js의-memoize2"><a href="#Partial-js의-memoize2" class="headerlink" title="Partial.js의 _.memoize2"></a>Partial.js의 _.memoize2</h3><p>Partial.js에도 _.memoize가 있다. partial.js의 _.memoize는 Underscore.js의 _.memoize다. partial.js 에는 또 다른 메모이제이션 함수인 _.memoize2가 있다. 이 함수는 인자를 하나만 사용하는 함수에서만 사용할 수 있으며 인자로 객체만 사용할 수 있다.</p><p>_.memoize가 캐시를 함수에 기록한다면 _.memoize2는 캐시를 인자에 기록한다. _.memoize2는 함수 생성 시 함수의 고유 아이디를 만든 후, 인자로 들어오는 객체에 해당 고유 아이디를 기준으로 arg._memoize 밑에 담아 둔다. _.memoize2는 불변 객체 콘셉트와 함께 사용하기 위해 만든 함수이고 실무에서 사용하기 위해 만든 함수다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * _.memoize2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = _.memoize2(<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'함수 본체에 들어옴'</span>);</span><br><span class="line">  <span class="keyword">return</span> obj.a + <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1(obj1));</span><br><span class="line"><span class="comment">// 함수 본체에 들어옴 11</span></span><br><span class="line"><span class="built_in">console</span>.log(f1(obj1));</span><br><span class="line"><span class="comment">// 캐시 사용</span></span><br><span class="line"><span class="built_in">console</span>.log(f1(obj2));</span><br><span class="line"><span class="comment">// 함수 본체에 들어옴 12</span></span><br><span class="line"><span class="built_in">console</span>.log(f1(obj2));</span><br><span class="line"><span class="comment">// 캐시 사용</span></span><br></pre></td></tr></table></figure><p>_.memoize2는 _.memoize와는 다른 특징과 장점을 가지고 있다. 우선 각 함수들에 대한 결과값을 인자로 사용된 객체에 담아두므로 한 번 사용하고 버리는 객체라면, 그 값은 별도의 관리 없이도 메모리에서 비워진다. 이것이 일단 가장 큰 장점이다. _.memoize는 결과 캐시가 함수에 쌓이기 때문에 함수를 없애거나 함수에 달린 캐시를 별도로 관리해야 하지만, _.memoize2는 사용한 인자에 결과 캐시가 쌓이므로 그 값을 계속 사용하느냐 아니냐에 따라 자동으로 메모리가 관리된다. 이것 외에도 값을 불변적으로 다룰 때 얻을 수 있는 실용적인 이점이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evens = _.memoize2(<span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'함수 본체에 들어와서 loop 실행'</span>);</span><br><span class="line">  <span class="keyword">return</span> _.filter(list, <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">console</span>.log(evens(list)); <span class="comment">// [2,4,6,8,10]</span></span><br><span class="line"><span class="built_in">console</span>.log(evens(list)); <span class="comment">// [2,4,6,8,10] (캐시를 사용하여 loop를 돌지 않음)</span></span><br><span class="line"></span><br><span class="line">list.push(<span class="number">11</span>);</span><br><span class="line">list.push(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(evens(list)); <span class="comment">// 캐시가 사용되어 12가 나오지 않음.</span></span><br></pre></td></tr></table></figure><p>마지막 evens 실행 시에는 원하는 결과를 얻지 못했다. 값을 가변적으로 다뤘기 때문이다. 불변적으로 값을 다루게 되면 캐시도 자동으로 갱신되고, 값이 변경되지 않은 상태에서는 계속해서 캐시를 사용하기 때문에 성능적으로 이득을 얻을 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">console</span>.log(evens(list)); <span class="comment">// [2,4,6,8,10]</span></span><br><span class="line"><span class="built_in">console</span>.log(evens(list)); <span class="comment">// [2,4,6,8,10] (캐시를 사용하여 loop를 돌지 않음)</span></span><br><span class="line"></span><br><span class="line">list2 = list2.concat(<span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list2); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(evens(list2)); <span class="comment">// [2,4,6,8,10, 12]</span></span><br><span class="line"><span class="built_in">console</span>.log(evens(list2)); <span class="comment">// [2,4,6,8,10, 12] (캐시를 사용하여 loop를 돌지 않음)</span></span><br></pre></td></tr></table></figure><p>_.memoize2로 만든 함수는 인자를 한 개만 받을 수 있다. 두 개 이상의 인자를 필요로 하는 함수는 _.memoize2를 사용할 수 없다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507">함수형 자바스크립트 프로그래밍</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2020/01/12/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>값에 대해</title>
      <link>https://kkangil.github.io/2019/12/29/%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%B4/</link>
      <guid>https://kkangil.github.io/2019/12/29/%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%B4/</guid>
      <pubDate>Sun, 29 Dec 2019 07:35:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;함수로 협업하는 가장 좋은 방법은 인자와 리턴값으로만 소통하는 것이다. 순수하게 인자와 리턴값에만 의존하면 누가 만든 함수든 어떤 라이브러리로 만든 함수든 조립할 수 있게 된다. 이때 함수에서 다루는 값으로 자바스크립트의 기본 객체를 사용하거나 아주 보편적으로 약속된 객체만 사용하면 함수들 간의 조합성이 더욱 좋아진다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>함수로 협업하는 가장 좋은 방법은 인자와 리턴값으로만 소통하는 것이다. 순수하게 인자와 리턴값에만 의존하면 누가 만든 함수든 어떤 라이브러리로 만든 함수든 조립할 수 있게 된다. 이때 함수에서 다루는 값으로 자바스크립트의 기본 객체를 사용하거나 아주 보편적으로 약속된 객체만 사용하면 함수들 간의 조합성이 더욱 좋아진다.</p><a id="more"></a><p>여기서 말하는 기본 객체란 Array, Object, String, Number, Boolean, Null, Undefined 등의 자바스크립트 기본 객체를 말하며, 브라우저의 DOM 같은 것들도 범주 안에 들어올 수 있다. 어떤 프로퍼티와 어떤 메서드를 가지고 있는지 충분히 약속되고 보장된 값들을 말한다. 약속된 스펙을 가진 값들만 사용하는 함수들은 언제나 어떤 환경에서나 사용하기 편하다.</p><h2 id="순수-함수"><a href="#순수-함수" class="headerlink" title="순수 함수"></a>순수 함수</h2><h3 id="순수-함수와-부수-효과"><a href="#순수-함수와-부수-효과" class="headerlink" title="순수 함수와 부수 효과"></a>순수 함수와 부수 효과</h3><p>순수 함수는 동일한 인자가 들어오면 항상 동일한 값을 리턴하는 함수다. 메서드가 자신이 가진 내부의 상태에 따라 다른 결과를 만든다면, 순수 함수는 들어온 인자와 상수만 사용하여 항상 동일한 결과를 리턴한다.<br>또 하나 중요한 특징이 있는데, 바로 외부의 상태를 변경하지 않는다는 점이다. 함수에게 들어온 인자를 포함하여, 외부와 공유되고 있는 값 중 함수가 참조할 수 있는 어떤 값도 변경하지 않는 것을 말한다. 함수가 외부 상태를 변경하면, 외부 상태와 연관이 있는 다른 부분에도 영향이 있고 이것을 부수 효과(Side effect)라고 한다.</p><p>부수 효과 문제는 특히 동시성이 생길 때 더욱 취약하다. 브라우저나 Node.js는 다양한 작업을 동시에 처리한다. 이렇게 동시성이 생기는 상황에서는 여러 곳에서 공유되도 있는 값이 변경되는 것은 위험하다. 부수 효과는 단지 동시성에서만의 이슈가 아니다. 예를 들면 사용자가 오랫동안 인터랙션을 해서 상태를 지속적으로 관리해야 하는 웹 페이지나 앱의 코드들에서 부수 효과 문제가 생기는 경우가 많다.</p><p>순수 함수의 정의를 아는 것보다 중요한 점은 여기에 담긴 목적과 전략이다. 순수 함수에 담긴 전략은 그 이름처럼 간단 명료하다. 상태 변화를 최소화하고, 다음 단계로 넘어갈 때마다 새로운 값으로 출발하는 식으로 코딩하는 것이다. 이렇게 하면 문제가 쉬워진다. 문제가 단순해지면 해결책 역시 쉬워지고 오류를 만들 가능성도 줄어든다. 작은 순수 함수들을 모아 만든 소프트웨어는 유지 보수와 기획 변경에 유연하게 대응한다.</p><h3 id="순수-함수와-순수-함수가-아닌-함수"><a href="#순수-함수와-순수-함수가-아닌-함수" class="headerlink" title="순수 함수와 순수 함수가 아닌 함수"></a>순수 함수와 순수 함수가 아닌 함수</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 순수 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수 함수가 아닌 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">obj, value</span>) </span>&#123;</span><br><span class="line">  obj.value = obj.value + value;</span><br><span class="line">  <span class="keyword">return</span> obj.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 작은 차이지만 순수 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add3</span>(<span class="params">obj, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.value + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 작은 차이지만 순수 함수 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add4</span>(<span class="params">obj, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: obj.value + value &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add는 인자를 받아 새로운 값을 리턴했고 add2는 obj의 상태를 변경한다. add는 인자가 같으면 항상 결과가 같고 부수 효과가 없다. add2는 obj.value의 상태에 따라 결과가 달라진다. 이런 점 자체가 문제를 만들지는 않지만 만일 obj.value를 사용하는 코드가 add2 외에 다른 곳에도 있다면 반드시 obj.value가 변경될 수 있다는 점과 변경될 시점 등을 정확히 인지하고 제어해야 할 것이다.</p><p>add3과 add4는 작은 차이가 있지만 순수 함수다. obj.value를 참조만 하고 있기 때문이다. 순수 함수를 만들기 위해 항상 모든 값을 새로 만들어야 하는 것은 아니다. 조회 자체는 부수 효과를 일으키지 않는다.</p><p>순수 함수로 프로그래밍을 한다면 add 같은 작은 기능의 함수만 만들어지는 게 아닌가 하는 생각이 들 수 있다. 클래스나 객체처럼 풍부한 기능을 가진 모듈을 만들 수 없을 것만 같을 수 있다. 하지만 인자로 함수를 사용하거나 고차 함수를 이용한 함수 조합을 통해 순수 함수의 조건을 따르면서 보다 풍부한 변화를 불러오는 함수들을 만들 수 있다.</p><h2 id="변경-최소화와-불변-객체"><a href="#변경-최소화와-불변-객체" class="headerlink" title="변경 최소화와 불변 객체"></a>변경 최소화와 불변 객체</h2><h3 id="직접-변경하는-대신-변경된-새로운-값을-만드는-전략"><a href="#직접-변경하는-대신-변경된-새로운-값을-만드는-전략" class="headerlink" title="직접 변경하는 대신, 변경된 새로운 값을 만드는 전략"></a>직접 변경하는 대신, 변경된 새로운 값을 만드는 전략</h3><p>대부분 이미 확인한 함수들이지만 이번에는 값과 값을 변경해 나가는 것에 초점을 두고 설명하고자 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users1 = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"ID"</span>, <span class="attr">age</span>: <span class="number">32</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"HA"</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"BJ"</span>, <span class="attr">age</span>: <span class="number">32</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"PJ"</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"JE"</span>, <span class="attr">age</span>: <span class="number">27</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> comparator = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.age &lt; b.age) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a.age &gt; b.age) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sortedUsers1 = users1.sort(comparator) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(users1 === sortedUsers1) <span class="comment">// 2 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.pluck(sortedUsers1, <span class="string">'age'</span>)); <span class="comment">// 3 [25, 27, 28, 32, 32]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.pluck(users1, <span class="string">'age'</span>)); <span class="comment">// 4 [25, 27, 28, 32, 32]</span></span><br></pre></td></tr></table></figure><p>users1을 나이순으로 정렬하는 예제다. Array.prototype.sort는 자기 자신을 정렬하는 함수다. 2의 결과가 true라는 것은 둘이 완전히 같은 객체라는 뜻이다. 동일한 값을 가진 객체가 아닌 완전히 같은 객체라는 것이다. 1의 .sort() 메서드는 자기 자신을 바꾸고 자기 자신을 리턴한다. 3 _.pluck 를 통해 age 값만 꺼내보면 둘다 동일하게 정렬이 된 것을 확인할 수 있는데, users1과 sortedUsers1이 완전히 같은 값이어서 동일한 결과가 출력된 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users2 = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"ID"</span>, <span class="attr">age</span>: <span class="number">32</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"HA"</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"BJ"</span>, <span class="attr">age</span>: <span class="number">32</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"PJ"</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"JE"</span>, <span class="attr">age</span>: <span class="number">27</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sortedUsers2 = _.sortBy(users2, <span class="string">'age'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(users2 === sortedUsers2) <span class="comment">// 2 false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.pluck(sortedUsers2, <span class="string">'age'</span>)) <span class="comment">// 3 [25, 27, 28, 32, 32]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.pluck(users2, <span class="string">'age'</span>)) <span class="comment">// 4 [32, 25, 32, 28, 27]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(users2[<span class="number">1</span>] === sortedUsers2[<span class="number">0</span>]); <span class="comment">// 5 true</span></span><br></pre></td></tr></table></figure><p>이번에는 _.sortBy 함수를 이용하여 정렬을 해 보았다. 2를 확인해 보면 false가 나온다. 1에서 리턴된 sortedUser2는 새로운 객체다. 3,4 를 확인해 보면 sortedUsers2는 나이순으로 정렬이 되었는데, users2 는 원본 그대로임을 알 수 있다. 다른 곳에 users2의 순서에 의존하여 동작하고 있는 코드가 있다면, sortedUsers2 처럼 새로운 객체를 만들어 정렬을 하는 방식이 부수 효과가 없고 유리하다.</p><p>sortedUser2는 새로운 값이다. 그렇다면 배열 안의 값들도 새로운 값일까? 서로 다르게 정렬이 되어 있지만, 두 배열 안에 있는 모든 값은 새로운 값이 아닌 기존의 값이다. 항상 배열 내의 모든 값을 새롭게 만든다면 메모리 사용량이 매우 높아질 것이다. _.sortBy는 내부의 값은 기존의 값을 그대로 활용하면서 배열만 새로 만들어 정렬한다.</p><p>Undescore.js의 콘셉트 중에는 이러한 중요한 전략이 있다. 이 전략을 잘 따르면 부수 효과를 줄이면서도 메모리 사용량 증가는 최소화하는 좋은 함수들을 만들 수 있다. 그것은 바로 그<code>함수가 변경할 영역에 대해서만 새 값을 만드는 전략</code>이다. 예를 들어 자신의 역할이 정렬이라면 정렬과 연관 있는 부분만 새 값으로 만들고 나머지 값들은 재활용하는 식이다. 이 전략을 대부분의 함수적 함수에 적용된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rejectedUsers2 = _.reject(users2, <span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123; <span class="keyword">return</span> user.age &lt; <span class="number">30</span>; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(rejectedUsers2);</span><br><span class="line"><span class="comment">// [&#123;name: "ID", age: 32&#125;, &#123;name: "BJ", age: 32&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rejectedUsers2 === users2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(rejectedUsers2.length, users2.length); <span class="comment">// 2 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(rejectedUsers2[<span class="number">0</span>] === users2[<span class="number">0</span>]) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>배열 내부의 값 중 특정 조건의 값들을 제외하는 _.reject 같은 함수도 배열 내부의 값들을 지우는 것이 아니라 값들이 지워진 새로운 배열을 만드는 것이다. _.reject도 결국 같은 전략을 따른 것이다. _.reject 함수의 역할은 값을 제외하는 것이고 달라지는 영역은 배열이기에 배열을 새로 만드는 것이다.</p><p>users2에서 30세 미만인 사람들을 제외했다. 더 정확히 말하면 30세 미만인 사람들이 제외된 새로운 배열을 만들어 리턴했다. rejectedUsers2는 users2가 아니며, users2.length도 그대로이고, 배열 내부의 값들도 기존의 값 그대로다. users2를 다루면서 새로 정렬하고 배열 내부의 값도 지웠지만, users2는 원래 상태 그대로이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  _.pluck(_.reject(users2, <span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123; <span class="keyword">return</span> user.age &gt;= <span class="number">30</span>; &#125;), <span class="string">'name'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// ["HA", "PJ", "JE"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  _.pluck(users2, <span class="string">'name'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// ["ID", "HA", "BJ", "PJ", "JE"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(users2)</span><br><span class="line"><span class="comment">// 원본 그대로</span></span><br></pre></td></tr></table></figure><p>1 users에서는 _.reject로 30세 이상의 user를 제외한 새 배열을 만든 후, _.pluck을 통해 이름만 추출한 새 배열을 만들어 로그를 남겼다. _.reject를 이용해 users2의 상태를 변경하지 않으면서 필터링을 했고, _.pluck 를 통해 역시 원본 소스들을 건들지 않고 name이 추출된 새로운 배열을 만들었다. 따라서 원본 데이터에는 아무런 영향을 끼치지 않았다. 그 덕분에 2에서는 어려움 없이 원본에 있는 모든 이름을 출력할 수 있다. 2가 실행된 후에도 3 users는 역시 변경되지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> b2 = _.initial(b1, <span class="number">2</span>); <span class="comment">// 뒤에서 2개 제거한 새로운 배열 리턴</span></span><br><span class="line"><span class="built_in">console</span>.log(b1 === b2, b1, b2);</span><br><span class="line"><span class="comment">// false (5) [1, 2, 3, 4, 5] (3) [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b3 = _.without(b1, <span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 1과 5를 제거한 새로운 배열 리턴</span></span><br><span class="line"><span class="keyword">var</span> b4 = _.without(b3, <span class="number">2</span>); <span class="comment">// 2를 제거한 새로운 배열 리턴</span></span><br><span class="line"><span class="built_in">console</span>.log(b1 === b3, b3 === b4, b3, b4);</span><br><span class="line"><span class="comment">// false false (3) [2, 3, 4] (2) [3, 4]</span></span><br></pre></td></tr></table></figure><p>맨 마지막에 b4를 만들 때, b3 에서 2를 제거했지만 b3에는 여전히 2가 남아있다.</p><h3 id="clone-으로-복사하기"><a href="#clone-으로-복사하기" class="headerlink" title="_.clone 으로 복사하기"></a>_.clone 으로 복사하기</h3><p>_.clone은 배열이나 객체를 받아 복사하는 함수다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> product1 = &#123;</span><br><span class="line">  name: <span class="string">"AB 반팔티"</span>,</span><br><span class="line">  price: <span class="number">10000</span>,</span><br><span class="line">  sizes: [<span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>],</span><br><span class="line">  colors: [<span class="string">"Black"</span>, <span class="string">"White"</span>, <span class="string">"Blue"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> product2 = _.clone(product1);</span><br><span class="line"><span class="built_in">console</span>.log(product2);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: "AB 반팔티",</span></span><br><span class="line"><span class="comment">//   price: 10000,</span></span><br><span class="line"><span class="comment">//   sizes: ["M", "L", "XL"],</span></span><br><span class="line"><span class="comment">//   colors: ["Black", "White", "Blue"]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(product1 === product2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">product2.name = <span class="string">"ABCD 반팔티"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(product1.name, product2.name);</span><br><span class="line"><span class="comment">// AB 반팔티 ABCD 반팔티</span></span><br></pre></td></tr></table></figure><p>product1을 _.clone 함수를 통해 복사했다. 동일한 내용이 들어 있는 새로운 객체가 리턴되어, 출력해 보면 내용은 같지만 비교하면 false가 나온다. product2.name 을 변경해도 product1에는 영향을 끼치지 않는다. product2를 마음 편히 다룰 수 있다.<br>그런데 _.clone을 정확히 다루려면 _.clone이 객체를 복하는 범위에 대해 제대로 알아야 한다. _.clone이 객체를 복사하는 것은 맞지만 객체 내부의 모든 값들까지 복사하는 것은 아니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">product2.sizes.push(<span class="string">"2XL"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(product2.sizes);</span><br><span class="line"><span class="comment">// ["M", "L", "XL", "2XL"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product1.sizes);</span><br><span class="line"><span class="comment">// ["M", "L", "XL", "2XL"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product1.sizes === product2.sizes); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>_.clone은 동일한 key들을 가진 새로운 객체를 만들면서 각 key에 기존의 key에 해당하는 value를 할당한다. 때문에 내부의 값이 객체라면 같은 객체를 바라보게 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_.clone = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cloned = _.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">  _.each(keys, <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    cloned[key] = obj[key]; <span class="comment">// Array일때는 key가 숫자</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.clone(obj1);</span><br><span class="line">obj2.b = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// &#123; a: 1, b: 22, c: &#123; d: 3 &#125; &#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">// &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c === obj2.c); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">obj2.c.d = <span class="number">33</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.c.d) <span class="comment">// 33 obj1도 같이 변경</span></span><br></pre></td></tr></table></figure><p>그렇다면 객체 안의 객체를 변경하고 싶은 경우에는 어떻게 해야 원본에 영향을 주지 않으면서 값을 변경할 수 있을까?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> product1 = &#123;</span><br><span class="line">  name: <span class="string">"AB 반팔티"</span>,</span><br><span class="line">  price: <span class="number">10000</span>,</span><br><span class="line">  sizes: [<span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>],</span><br><span class="line">  colors: [<span class="string">"Black"</span>, <span class="string">"White"</span>, <span class="string">"Blue"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> product2 = _.clone(product1);</span><br><span class="line">product2.sizes = _.clone(product2.sizes); <span class="comment">// 내부도 clone 후 push를 하거나</span></span><br><span class="line">product2.sizes.push(<span class="string">"2XL"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(product2.sizes);</span><br><span class="line"><span class="comment">// ["M", "L", "XL", "2XL"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product1.sizes);</span><br><span class="line"><span class="comment">// ["M", "L", "XL"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product1.sizes === product2.sizes); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">product2.colors = product2.colors.concat(<span class="string">"Yellow"</span>) <span class="comment">// 아니면 concat으로 한번에</span></span><br><span class="line"><span class="built_in">console</span>.log(product2.colors);</span><br><span class="line"><span class="comment">// ["Black", "White", "Blue", "Yellow"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product1.colors);</span><br><span class="line"><span class="comment">// ["Black", "White", "Blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product1.colors === product2.colors); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>위와 같이 하면 된다. 어차피 내부의 값도 복사하는 식으로 값을 다뤄야 한다면 왜 굳이 객체의 첫 번째 깊이만 복사하느냐고 생각할 수 있다. 값 복사 후 항상 내부의 모든 값을 변경할 것이 아니기에, 객체 내부의 객체는 공유하는 것이 메모리 사용에 유리하고, 복사 수행 처리 시간이라는 측면에서도 이점이 많다.</p><h3 id="extend-defaults로-복사하기"><a href="#extend-defaults로-복사하기" class="headerlink" title="_.extend, _.defaults로 복사하기"></a>_.extend, _.defaults로 복사하기</h3><p>_.extend나 _.defaults를 이용하면 값 복사와 변경을 좀 더 간결하게 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> product1 = &#123;</span><br><span class="line">  name: <span class="string">"AB 반팔티"</span>,</span><br><span class="line">  price: <span class="number">10000</span>,</span><br><span class="line">  sizes: [<span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>],</span><br><span class="line">  colors: [<span class="string">"Black"</span>, <span class="string">"White"</span>, <span class="string">"Blue"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> product2 = _.extend(&#123;&#125;, product1, &#123;</span><br><span class="line">  name: <span class="string">"AB 긴팔티"</span>,</span><br><span class="line">  price: <span class="number">15000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> product3 = _.defaults(&#123;</span><br><span class="line">  name: <span class="string">"AB 후드티"</span>,</span><br><span class="line">  price: <span class="number">15000</span></span><br><span class="line">&#125;, product1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(product2);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: "AB 긴팔티",</span></span><br><span class="line"><span class="comment">//   price: 15000,</span></span><br><span class="line"><span class="comment">//   sizes: ["M", "L", "XL"],</span></span><br><span class="line"><span class="comment">//   colors: ["Black", "White", "Blue"]</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(product3);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: "AB 후드티",</span></span><br><span class="line"><span class="comment">//   price: 15000,</span></span><br><span class="line"><span class="comment">//   sizes: ["M", "L", "XL"],</span></span><br><span class="line"><span class="comment">//   colors: ["Black", "White", "Blue"]</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> product4 = _.extend(&#123;&#125;, product3, &#123;</span><br><span class="line">  colors: product3.colors.concat(<span class="string">"Purple"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> product5 = _.defaults(&#123;</span><br><span class="line">  colors: product4.colors.concat(<span class="string">"Red"</span>)</span><br><span class="line">&#125;, product4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(product3.colors);</span><br><span class="line"><span class="comment">// ["Black", "White", "Blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product4.colors);</span><br><span class="line"><span class="comment">// ["Black", "White", "Blue", "Purple"]</span></span><br><span class="line"><span class="built_in">console</span>.log(product5.colors);</span><br><span class="line"><span class="comment">// ["Black", "White", "Blue", "Purple", "Red"]</span></span><br></pre></td></tr></table></figure><ol><li>product2는 값 복사를 위해 새로운 객체인 {} 를 _.extend의 첫 번째 인자로 넣었다.</li><li>어차피 {name: “AB 후드티”, price: 12000}도 새 객체이므로 product3처럼 _.defaults를 이용하는 것이 객체를 적게 생성해서 더 효율적이다. _.extend의 경우, 왼쪽 객체에 없는 key/value는 확장하고, 왼쪽 객체에 있던 key/value는 덮어 쓴다. _.defaults는 왼쪽에 없는 key/value만 확장한다.</li><li>1, 2를 보면 _.clone 없이 복사와 변경을 동시에 하여 간결해졌지만, colors 처럼 깊은 값을 변경해야 할 경우에는 직접 다뤄줘야 한다. _.extend와 _.defaults 역시 변경이 필요 없는 값은 이전의 값을 공유한다.</li></ol><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507">함수형 자바스크립트 프로그래밍</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2019/12/29/%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Partial.js와 함수 조립</title>
      <link>https://kkangil.github.io/2019/12/01/Partial-js%EC%99%80-%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/</link>
      <guid>https://kkangil.github.io/2019/12/01/Partial-js%EC%99%80-%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/</guid>
      <pubDate>Sun, 01 Dec 2019 06:35:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;파이프라인&quot;&gt;&lt;a href=&quot;#파이프라인&quot; class=&quot;headerlink&quot; title=&quot;파이프라인&quot;&gt;&lt;/a&gt;파이프라인&lt;/h2&gt;&lt;h3 id=&quot;즉시-실행-파이프라인-go와-mr&quot;&gt;&lt;a href=&quot;#즉시-실행-파이프라인-go와-mr&quot; class=&quot;headerlink&quot; title=&quot;즉시 실행 파이프라인, _.go와 _.mr&quot;&gt;&lt;/a&gt;즉시 실행 파이프라인, _.go와 _.mr&lt;/h3&gt;&lt;p&gt;_.go는 파이프라인의 즉시 실행 버전이다. 첫 번째 인자로 받은 값을 두 번째 인자로 받은 함수에게 넘겨주고, 두 번째 인자로 받은 함수의 결과는 세 번째 함수에게 넘겨준다. 이것을 반복하다가 마지막 함수의 결과를 리턴해 준다.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_.go(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 첫번째 인자&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; &amp;#125;, &lt;span class=&quot;comment&quot;&gt;// 100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a - &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; &amp;#125;, &lt;span class=&quot;comment&quot;&gt;// 50&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a + &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; &amp;#125; &lt;span class=&quot;comment&quot;&gt;// 60&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;_.go는 Multiple Results를 지원한다. _.mr 함수를 함께 사용하면 다음 함수에게 2개 이상의 인자들을 전달할 수 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="파이프라인"><a href="#파이프라인" class="headerlink" title="파이프라인"></a>파이프라인</h2><h3 id="즉시-실행-파이프라인-go와-mr"><a href="#즉시-실행-파이프라인-go와-mr" class="headerlink" title="즉시 실행 파이프라인, _.go와 _.mr"></a>즉시 실행 파이프라인, _.go와 _.mr</h3><p>_.go는 파이프라인의 즉시 실행 버전이다. 첫 번째 인자로 받은 값을 두 번째 인자로 받은 함수에게 넘겨주고, 두 번째 인자로 받은 함수의 결과는 세 번째 함수에게 넘겨준다. 이것을 반복하다가 마지막 함수의 결과를 리턴해 준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.go(<span class="number">10</span>, <span class="comment">// 첫번째 인자</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a * <span class="number">10</span> &#125;, <span class="comment">// 100</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a - <span class="number">50</span> &#125;, <span class="comment">// 50</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">10</span> &#125; <span class="comment">// 60</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>_.go는 Multiple Results를 지원한다. _.mr 함수를 함께 사용하면 다음 함수에게 2개 이상의 인자들을 전달할 수 있다.</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.go(<span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> _.mr(a * <span class="number">10</span>, <span class="number">50</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">10</span> &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 60</span></span><br></pre></td></tr></table></figure><p>_.go의 첫 번째 인자는 두 번째 인자인 함수가 사용할 인자이며 두 번째 부터는 파이프라인에서 사용할 함수들이다. _.go의 두 번째 인자인 함수, 즉 최초 실행될 함수에게 2개 이상의 인자를 넘끼고자 한다면 그때도 _.mr을 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.go(_.mr(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>위의 코드처럼 _.mr로 인자들을 감싸서 넘겨주면, 다음 함수는 인자를 여러개로 펼쳐서 받게 된다. _.mr(2, 3)은 하나의 값이지만 _.go 내부에서 인자를 펼쳐서 넘겨주어, 2와 3이 첫 번째 함수의 a와 b가 된다.<br>_.go는 이미 정의되어 있는 함수와 조합하거나 화살표 함수와 사용할 때 특히 표현력이 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.go(_.mr(<span class="number">2</span>, <span class="number">3</span>), add, square);</span><br><span class="line">_.go(_.mr(<span class="number">2</span>, <span class="number">3</span>), (a, b) =&gt; a + b, a =&gt; a * a)</span><br></pre></td></tr></table></figure><h3 id="함수를-만드는-파이프라인-pipe"><a href="#함수를-만드는-파이프라인-pipe" class="headerlink" title="함수를 만드는 파이프라인 _.pipe"></a>함수를 만드는 파이프라인 _.pipe</h3><p>_.go가 즉시 실행하는 파이프라인이라면 _.pipe는 실행할 준비가 된 함수를 리턴하는 파이프라인 함수다. 그 외 모든 기능은 _.go와 동일하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = _.pipe(add, square);</span><br><span class="line">f1(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = _.pipe(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, a =&gt; a * a);</span><br><span class="line">f2(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h3 id="부분-커링-함수와의-조합"><a href="#부분-커링-함수와의-조합" class="headerlink" title="부분 커링 함수와의 조합"></a>부분 커링 함수와의 조합</h3><p>파이프라인 함수를, 함수를 리턴하는 함수와 함께 사용해 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> products = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"후드 집업"</span>, <span class="attr">discounted_price</span>: <span class="number">6000</span>, <span class="attr">price</span>: <span class="number">10000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"코잼 후드티"</span>, <span class="attr">discounted_price</span>: <span class="number">8000</span>, <span class="attr">price</span>: <span class="number">8000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">"A1 반팔티"</span>, <span class="attr">discounted_price</span>: <span class="number">6000</span>, <span class="attr">price</span>: <span class="number">6000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">"코잼 반팔티"</span>, <span class="attr">discounted_price</span>: <span class="number">5000</span>, <span class="attr">price</span>: <span class="number">6000</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">_.go(products,</span><br><span class="line">  _.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.discounted_price &lt; p.price), <span class="comment">// 1</span></span><br><span class="line">  _.sortBy(<span class="string">'discounted_price'</span>), <span class="comment">// 2</span></span><br><span class="line">  _.first, <span class="comment">// 3</span></span><br><span class="line">  _.val(<span class="string">'name'</span>) <span class="comment">// 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 코잼 반팔티</span></span><br></pre></td></tr></table></figure><ol><li><code>products</code> 중에 할인 중인 상품만 남긴다.</li><li><code>discounted_price</code> 가 낮은 순으로 정렬한다.</li><li>첫 번째를 꺼낸다.</li><li>product.name 을 확인한다.</li></ol><p>Partial.js의 _.filter, _.sortBy, _.val은 모두 부분 커링이 된다. 모두 인자를 하나만 넘겨 앞으로 실행될 함수를 리턴 받았다. 그렇게 만들어진 함수들은 _.go를 통해 순서대로 실행된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 할인 상품 중 가격이 가장 높은 상품의 이름</span></span><br><span class="line">_.go(products,</span><br><span class="line">  _.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.discounted_price &lt; p.price),</span><br><span class="line">  _.sortBy(<span class="string">'discounted_price'</span>),</span><br><span class="line">  _.last,</span><br><span class="line">  _.val(<span class="string">'name'</span>),</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 후드 집업</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할인 상품 중 할인액이 가장 높은 상품의 이름</span></span><br><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.discounted_price &lt; p.price),</span><br><span class="line">  _.sortBy(<span class="function"><span class="params">p</span> =&gt;</span> p.discounted_price - p.price),</span><br><span class="line">  _.first,</span><br><span class="line">  _.val(<span class="string">'name'</span>),</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 후드 집업</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할인 상품 중 할인액이 가장 낮은 상품의 이름</span></span><br><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.discounted_price &lt; p.price),</span><br><span class="line">  _.max(<span class="function"><span class="params">p</span> =&gt;</span> p.discounted_price - p.price),</span><br><span class="line">  _.val(<span class="string">'name'</span>),</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 코잼 반팔티</span></span><br></pre></td></tr></table></figure><p>중간중간 들어간 함수들의 조합을 약간씩 수정하여, 다른 로직으로 쉽게 변경할 수 있다. 할인이 진행 중인 상품들 중 제일 비싼 상품을 꺼낸다든지, 할인이 되지 않는 상품 중 제일 싼 상품을 꺼낸다든지 하는 로직으로 변경하는 것이 위에서 알 수 있듯 매우 쉽다.</p><h3 id="보조-함수로-사용하는-파이프라인"><a href="#보조-함수로-사용하는-파이프라인" class="headerlink" title="보조 함수로 사용하는 파이프라인"></a>보조 함수로 사용하는 파이프라인</h3><p>파이프라인을 보조 함수로 만들기 위해 사용하는 것도 좋다. 파이프라인을 _.each, _.map, _.reduce 등과 같은 고차 함수들의 보조 함수로 사용해 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  products,</span><br><span class="line">  _.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.discounted_price &lt; p.price),</span><br><span class="line">  _.map(_.pipe(_.identity, _.pick([<span class="string">'id'</span>, <span class="string">'name'</span>]), _.values)),</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br><span class="line"><span class="comment">// [[1, "후드 집업"], [4, "코잼 반팔티"]]</span></span><br></pre></td></tr></table></figure><p>_.filter 에서는 할인 중인 상품만 남게 된다. _.map 에서는 iteratee를 파이프라인으로 만들었다. _.pipe는 _.identity를 통해 iteratee의 첫 번째 인자인 product만 리턴하게 되고, 부분 커링된 _.pick을 통애 id와 name만 남은 객체로 만들게 된다. 마지막으로 _.values를 통해 값만 남겼다.</p><h3 id="비동기와-go"><a href="#비동기와-go" class="headerlink" title="비동기와 _.go"></a>비동기와 _.go</h3><p>_.go는 비동기 제어를 지원한다. Promise가 체인 방식에 함수적인 아이디어를 가미하여 비동기 상황을 제어했다면, _.go는 함수적으로만 비동기를 제어한다. _.go는 내부적으로 함수들을 순차적으로 실행해 나가면서 비동기 함수의 결과를 재귀 함수로 꺼낸 후, 다음 함수에게 이어주는 식으로 비동기 상황을 제어한다.<br>_.go와 _.pipe는 일반 콜백 함수와 Promise를 모두 지원한다. _.go와 _.pipe는 기본적으로 동기로 동작하지만 파이프라인의 함수들을 실행하는 도중에 Promise 객체가 리턴되거나 jQuery의 then과 같은 Deferred Object가 리턴되거나 _.callback 함수를 이용했다면, 내부적으로 비동기를 제어하는 파이프라인으로 변한다.<br>Promise의 경우에는 함수가 실행되면 즉시 setTimeout을 일으키고, 일단 { then: … } 을 리턴하게 되므로 동기 함수들과 중첩 사용을 할 수 없다. 그러나 _.go의 경우에는 비동기 상황이 없을 경우 결과를 즉시 리턴하기 때문에, 이후 연속적으로 실행되는 함수들이 반드시 비동기성을 띌 필요가 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  <span class="number">10</span>,</span><br><span class="line">  _.callback(<span class="function"><span class="keyword">function</span> (<span class="params">a, next</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      next(a + <span class="number">10</span>)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="comment">// next를 통해 받은 결과 a</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 상황에서 _.go는 첫 번째 함수를 실행하면서 내부적으로 next를 만들어 함수에게 넘긴다. next에게 결과를 전달하면 그 결과는 다음 함수의 인자로 넘어가게 된다. 다시 바깥으로 나와 그 다음 함수들을 순차적으로 실행하므로 콜백 지옥에서 벗어날 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, next</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      next(a + b);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b, next</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      next(a - b);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b, next</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      next(a * b);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg, next</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg);</span><br><span class="line">      next(msg);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _.go(</span><br><span class="line">    _.mr(<span class="number">5</span>, <span class="number">10</span>),</span><br><span class="line">    _.callback(</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">a, b, next</span>) </span>&#123;</span><br><span class="line">        add(a, b, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">result, next</span>) </span>&#123;</span><br><span class="line">        sub(result, <span class="number">10</span>, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">result, next</span>) </span>&#123;</span><br><span class="line">        mul(result, <span class="number">10</span>, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">result, next</span>) </span>&#123;</span><br><span class="line">        log(result, next);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncCallback(); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>연속적으로 비동기 함수가 사용되어야 한다면 위와 같이 _.callback 함수에 여러개의 함수를 넘겨도 되고, 아래와 같이 미리 _.callback 패턴이라고 지정해 두면 더욱 간결하게 코딩할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = _.callback(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, next</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    next(a + b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = _.callback(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, next</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    next(a - b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mul = _.callback(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, next</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    next(a * b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = _.callback(<span class="function"><span class="keyword">function</span> (<span class="params">msg, next</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">    next(msg);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">_.go(</span><br><span class="line">  _.mr(<span class="number">5</span>, <span class="number">10</span>),</span><br><span class="line">  add,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sub(result, <span class="number">10</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mul(result, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log(result);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 코드 처럼 _.callback 함수로 미리 정의해 둔 ad, sub 등의 함수를 실행하면 그 함수는 Promise 객체를 리턴한다. 정확히는 Promise가 지원되는 환경에서는 Promise 객체를 리턴하고, Promise가 지원되지 않는 환경에서는 Partial.js 내부에 구현된 Promise 객체를 리턴한다. Promise 객체를 파이프라인이 다시 받아도 다시 비동기를 제어한다. 따라서 Promise가 지원되지 않는 환경에서도 파이프라인식의 비동기 제어가 가능하다.</p><h3 id="중간에-멈추고-나가기"><a href="#중간에-멈추고-나가기" class="headerlink" title="중간에 멈추고 나가기"></a>중간에 멈추고 나가기</h3><p>일반 함수에서는 함수 중간 어디서든 return문으로 함수를 빠져 나올 수 있다. Partial.js는 파이프라인에서도 이와 같은 일이 가능하도록 지원하는데, 바로 _.stop이라는 함수를 이용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _.stop() &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>1과 2만 찍힌 후 세번째 함수는 실행되지 않고 파이프라인 전체를 나오게 된다. _.go의 최종 결과도 함께 전달하고 싶다면 _.stop 함수에게 전달하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = _.go(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> _.stop(<span class="string">"Hi"</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>) &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure><h2 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h2><h3 id="코드-변경없이-비동기-제어가-되는-고차-함수"><a href="#코드-변경없이-비동기-제어가-되는-고차-함수" class="headerlink" title="코드 변경없이 비동기 제어가 되는 고차 함수"></a>코드 변경없이 비동기 제어가 되는 고차 함수</h3><p>Partial.js의 _.each, _.map, _.reduce 등의 주요 함수들은 _.go와 _.pipe 처럼 하나의 함수로 동기와 비동기 상황이 모두 대응되도록 되어 있다. Partial.js의 함수를 이용하면 비동기 상황에서도 동기 상황과 동일한 코드를 작성할 수 있고, 비동기 함수와 동기 함수의 조합도 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(_.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//  ["2019-12-01T08:20:00.422Z","2019-12-01T08:20:00.422Z","2019-12-01T08:20:00.422Z"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">_.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ["2019-12-01T08:20:01.424Z","2019-12-01T08:20:02.424Z","2019-12-01T08:20:03.428Z"]</span></span><br></pre></td></tr></table></figure><p>같은 _.map 함수지만 1은 즉시 완료되었고, 2는 3초 정도의 시간이 걸려 완료되었다. Partial.js의 _.each, _.map, _.reduce 등은 첫 번째 iteratee의 결과가 Promise 객체일 경우 내부적으로 for문 대신 재귀로 변경된다. 2의 경우 iteratee가 각각 모두 1초 정도의 시간이 걸렸기 때문에 배열에 1초 정도의 차이를 가진 값들이 담겼다.<br>위 코드는 둘 다 동일한 _.map 함수로 작성하기는 했지만 동기 상황의 코드와 비동기 상황의 전체적인 코드 구조가 다르다. _.go, _.pipe 등을 이용하면 두 가지 코드 모두 동일한 구조를 갖도록 만들 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">_.go(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  _.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;),</span><br><span class="line">  <span class="built_in">JSON</span>.stringify,</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">_.go(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  _.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="built_in">JSON</span>.stringify,</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>_.map의 iteratee에서 Promise 함수가 아닌 일반 비동기 함수를 사용해야 한다면 다음과 같이 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  _.map(_.callback(<span class="function"><span class="keyword">function</span> (<span class="params">val, i, list, next</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      next(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)),</span><br><span class="line">  <span class="built_in">JSON</span>.stringify,</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>마지막 인자로 next가 들어오고 next를 통해 결과를 전달하면, 그 결과가 하나씩 _.map의 결과인 새로운 배열에 쌓여간다. new Promise를 사용하는 것 보다 간결하다.</p><p>Partial.js는 iteratee의 결과나 iteratee의 속성에 따라 동기 로직과 비동기 로직을 알아서 선택하도록 되어있다. 동기 로직으로 돌아가야 할 경우에는 for문을 사용하고 비동기 로직을 사용해야 할 경우에만 재귀로 변경되기 때문에 성능적으로도 문제가 없다.</p><h3 id="비동기-결과를-기다리는-if문-if"><a href="#비동기-결과를-기다리는-if문-if" class="headerlink" title="비동기 결과를 기다리는 if문, _.if"></a>비동기 결과를 기다리는 if문, _.if</h3><p>아래 is_1, is_2 함수는 결과를 즉시 리턴하는 함수다. 아래와 같은 함수는 if문과 같은 조건절에서 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> is_1 = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a === <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> is_2 = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a === <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_1(a)) <span class="keyword">return</span> <span class="string">'1입니다.'</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (is_2(a)) <span class="keyword">return</span> <span class="string">'2입니다.'</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'1도 아니고 2도 아닙니다.'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test1(<span class="number">2</span>)); <span class="comment">// 2입니다.</span></span><br></pre></td></tr></table></figure><p>그런데 만약 is_1과 같은 함수가 즉시 값을 리턴할 수 없고, 데이터베이스에 다녀와야 하거나 HTTP 통신이 있어야 하면 상황은 달라진다. 자바스크립트에서는 아래와 같은 상황을 if문으로 제어할 수 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> is_1_async = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(a === <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> is_2_async = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(a === <span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_1_async(a)) <span class="keyword">return</span> <span class="string">'1입니다.'</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (is_2_async(a)) <span class="keyword">return</span> <span class="string">'2입니다.'</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'1도 아니고 2도 아닙니다.'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test2(<span class="number">2</span>)); <span class="comment">// 1입니다. (정상적으로 동작하지 않음)</span></span><br></pre></td></tr></table></figure><p>is_1_async 함수의 진짜 결과는 false이겠지만  is_1_async가 즉시 Promise 객체를 리턴하기 때문에 if의 조건문 입장에서는 true가 된다. is_1_async가 콜백 패턴으로 이루어진 일반 함수 였다고 하더라고, undefined가 즉시 리턴될 것이므로 역시 정상적인 결과를 만들수 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test4 =</span><br><span class="line">  _.if(is_1_async, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'1입니다.'</span> &#125;)</span><br><span class="line">    .else_if(is_2_async, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'2입니다.'</span> &#125;)</span><br><span class="line">    .else(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'1도 아니고 2도 아닙니다. '</span> &#125;);</span><br><span class="line"></span><br><span class="line">test4(<span class="number">2</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 2입니다.</span></span><br></pre></td></tr></table></figure><p>위 함수는 동기 함수를 사용했던 test1과 유사한 구조를 가지고 있다. _.constant나 화살표 함수를 사용하면 더욱 간결해진다. _.go와 함께 사용한 버전도 확인해 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test5 =</span><br><span class="line">  _.if(is_1_async, _.constant(<span class="string">'1입니다.'</span>))</span><br><span class="line">    .else_if(is_2_async, _.constant(<span class="string">'2입니다.'</span>))</span><br><span class="line">    .else(_.constant(<span class="string">'1도 아니고 2도 아닙니다. '</span>));</span><br><span class="line"></span><br><span class="line">test5(<span class="number">2</span>).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 화살표함수</span></span><br><span class="line"><span class="keyword">var</span> test6 =</span><br><span class="line">  _.if(is_1_async, () =&gt; <span class="string">'1입니다.'</span>)</span><br><span class="line">    .else_if(is_2_async, () =&gt; <span class="string">'2입니다.'</span>)</span><br><span class="line">    .else(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'1도 아니고 2도 아닙니다. '</span>);</span><br><span class="line">test6(<span class="number">1</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br><span class="line"><span class="comment">// _.go</span></span><br><span class="line">_.go(</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  _.if(is_1_async, _.constant(<span class="string">'1입니다.'</span>))</span><br><span class="line">    .else_if(is_2_async, _.constant(<span class="string">'2입니다.'</span>))</span><br><span class="line">    .else(_.constant(<span class="string">'1도 아니고 2도 아닙니다. '</span>)),</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>동기와 비동기 상황을 동시에 대응하는 함수를 쉽게 만드는 팁이 있다. 해당 함수의 로직을 _.go나 _.pipe로 구현해 두는 것이다. 그렇게 하면 자동으로 동기 상황과 비동기 상황에 맞춰 로직을 알아서 변경시키기 때문에 추가적인 다른 작업을 하지 않아도 된다.</p><h2 id="고차-함수"><a href="#고차-함수" class="headerlink" title="고차 함수"></a>고차 함수</h2><h3 id="all-spread"><a href="#all-spread" class="headerlink" title="_.all, _.spread"></a>_.all, _.spread</h3><p>이 두 함수는 파이프라인과 함께 사용할 때 유용한 함수다. _.all과 _.spread 모두 받은 인자를 받은 함수들에게 전달하는 함수들인데, _.all은 받은 모든 인자를 모든 함수들에게 동일하게 전달하고, _.spread는 받은 인자들을 하나씩 나눠 준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.all(<span class="number">10</span>, <span class="number">5</span>, [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a * b &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">_.spread(<span class="number">10</span>, <span class="number">5</span>, [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a * a &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123; <span class="keyword">return</span> b * b &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>_.all은 받아 둔 모든 인자를 마지막 인자로 들어온 배열 안에 있는 모든 함수들에게 동일하게 전달한다. _.spread는 받은 인자를 하나씩 나눠서, 받은 함수들에게 하나씩 전달하는 함수다.<br>_.all과 _.spread에게 인자 전달 없이 함수들만 전달하면 함수를 리턴하는 함수로 동작하여 파이프라인 등에서 사용하기 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_.go(</span><br><span class="line">  <span class="number">10</span>,</span><br><span class="line">  _.all(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">5</span> &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a - <span class="number">5</span> &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a * <span class="number">5</span> &#125;</span><br><span class="line">  ),</span><br><span class="line">  _.spread(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span> &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123; <span class="keyword">return</span> b + <span class="number">2</span> &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123; <span class="keyword">return</span> c + <span class="number">3</span> &#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="built_in">console</span>.log</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16 7 53</span></span><br></pre></td></tr></table></figure><h2 id="파이프라인2"><a href="#파이프라인2" class="headerlink" title="파이프라인2"></a>파이프라인2</h2><h3 id="go에서-this-사용"><a href="#go에서-this-사용" class="headerlink" title="_.go에서 this 사용"></a>_.go에서 this 사용</h3><p>Partial.js의 _.pipe가 this를 지원하는 것을 확인했었다. _.go에서도 this 지원이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123; <span class="attr">name</span>: <span class="string">"Cojamm"</span> &#125;;</span><br><span class="line">_.go.call(user, <span class="number">32</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.job = <span class="string">"Rapper"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123;name: "Cojamm", age: 32, job: "Rapper"&#125;</span></span><br></pre></td></tr></table></figure><p>_.go.call의 call은 Fucntion.prototype.call 이다. _.go는 일반 함수이므로 call을 사용하는게 자연스럽다. _.go 는 call을 통해 전달받은 this를 파이프라인 내 함수들에게 전달한다. apply 역시 사용할 수 있다.</p><h3 id="또-다른-파이프라인-indent"><a href="#또-다른-파이프라인-indent" class="headerlink" title="또 다른 파이프라인, _.indent"></a>또 다른 파이프라인, _.indent</h3><p>자바스크립트에서는 부모 스코프와 자식 스코프라는 개념이 있다. 자식 스코프는 부모 스코프의 지역 변수를 참조할 수 있다. 이러한 중첩 구조의 접근 방식이 파이프라인 내에서도 필요했는데, 이를 위한 함수가 바로 _.indent다. _.indent는 이름처럼 _.indent가 중첩될 때마다 this와 arguments를 한 단계씩 안으로 들여쓰는 콘셉트를 가지고 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = _.indent(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>_.indent는 _.pipe처럼 함수를 리턴하는 파이프라인이다. 함수들의 연속 실행이 준비된 함수를 리턴하여 f1에 담았고 실행했다.<br>1과 2의 결과에는 차이가 있다. console.log 에게 두 번째 인자로 넘긴 arguments에 담긴 값이 다르다. 1은 파이프라인의 첫 번째 함수이기에 f1을 통해 넘겨진 인자 [1,2]가 arguments에 들어온다. 2는 두 번째 함수이고, 이전 함수에서 ‘hi’를 리턴했기에 [‘hi’]가 arguments에 담겨 있다.<br>파이프라인으로 코딩하다 보면 파이프라인의 최초 함수가 아닌 중간에 있는 함수에서 파이프라인이 최초로 받은 인자를 알고 싶을 때가 있다. 이것은 클로저를 사용하는 것으로도 자연스럽게 해결된다.<br>_.indent의 해결법은 파이프라인 내부의 함수들은 중간 어디서든 this.arguments로 파이프라인의 최초 인자들에 접근할 수 있다.</p><p>_.indent의 this는 한 번의 파이프라인 사용 후 휘발되는 this다. 파이프라인 전체에서 공유하고자 하는 값이 있을 때 값을 이어주는 식으로 사용할 수도 있다. 또한 인스턴스를 만들어 두고 계속 사용하는 this가 아닌, 함수를 실행할 때마다 새로 생겼다 사라지는 this이므로 부수효과가 최소화되고 메모리 사용에도 문제가 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = _.indent(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">this</span>.b = a + <span class="number">10</span>; &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.b) &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f2(<span class="number">5</span>); <span class="comment">// 15</span></span><br><span class="line">f2(<span class="number">7</span>); <span class="comment">// 17</span></span><br></pre></td></tr></table></figure><p>_.indent에서 this는 이번에 실행할 때 열린 부모 스코프를 대신하는 역할이므로, 그 this의 key/value를 확장한다는 것은 새로운 변수를 할당하는 것 이라고 볼 수 있다. this에 값을 단 후 값을 변경하지 않는다면 부수 효과로부터 자유로워진다. 하나의 큰 함수 안에서 변수에 담고 그 변수에 담긴 값을 변경하지 않는 것과 동일하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = _.indent(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = a + <span class="number">10</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  _.indent(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.b = <span class="number">20</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.b); <span class="comment">// 20</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.parent.b) <span class="comment">// 15</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.parent.arguments); <span class="comment">// [5]</span></span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f3(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>parent를 통해 부모를 찾아갈 수 있고, this.parent.arguments로 파이프라인의 최초 인자도 찾아갈 수 있다. 자바스크립트에서 값에 접근할 수 있다는 것은 값을 변경할 수도 있다는 의미이므로 위험하다. 이것은 모든 값 혹은 변수에 해당하는 이야기다. 그러나 값을 참조하는 식으로 접근한다면, 여기저기에서 값에 접근할 수 있다는 것 자체는 문제가 되지는 않는다.</p><h3 id="무조건-비동기로-동작하는-async"><a href="#무조건-비동기로-동작하는-async" class="headerlink" title="무조건 비동기로 동작하는 _.async"></a>무조건 비동기로 동작하는 _.async</h3><p>_.go, _.pipe, _.indent는 파이프라인 내부의 함수에서 비동기 결과가 나올 경우 비동기 제어를 시작하도록 구현되어 있다. 그러므로 비동기 상황이 생기지 않는다면 즉시 일반 값이 리턴되고, 비동기 상황이 생겼을 때만 Promise 객체가 리턴된다. 때로는 내부 함수의 결과와 상관없이 무조건 비동기를 일으키고 싶을 때가 있다. _.async는 이럴 때 사용하기 적합한, 무조건 비동기로 동작하는 파이프라인이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.go.async(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507">함수형 자바스크립트 프로그래밍</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2019/12/01/Partial-js%EC%99%80-%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수 조립하기</title>
      <link>https://kkangil.github.io/2019/11/17/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD%ED%95%98%EA%B8%B0/</link>
      <guid>https://kkangil.github.io/2019/11/17/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Sun, 17 Nov 2019 05:49:58 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;함수-조립하기&quot;&gt;&lt;a href=&quot;#함수-조립하기&quot; class=&quot;headerlink&quot; title=&quot;함수 조립하기&quot;&gt;&lt;/a&gt;함수 조립하기&lt;/h1&gt;&lt;p&gt;함수형 자바스크립트 기법을 잘 활용하면 소프트웨어의 기능을 변경하거나 추가하기가 쉽다. 작은 단위로 쪼갠 함수들을 조합하여 큰 기능을 만들면 조합된 함수 사이사이에 새로운 함수를 추가하는 식으로 쉽게 확장해 나갈 수 있다.&lt;/p&gt;
&lt;p&gt;함수형 자바스크립트 10가지 기법&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;함수를 되도록 작게 만들기&lt;/li&gt;
&lt;li&gt;다형성 높은 함수를 만들기&lt;/li&gt;
&lt;li&gt;상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화하기&lt;/li&gt;
&lt;li&gt;동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기&lt;/li&gt;
&lt;li&gt;복잡한 객체 하나를 인자로 사용하기보다는 되도록 일반적인 값 여러개를 인자로 사용하기&lt;/li&gt;
&lt;li&gt;큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="함수-조립하기"><a href="#함수-조립하기" class="headerlink" title="함수 조립하기"></a>함수 조립하기</h1><p>함수형 자바스크립트 기법을 잘 활용하면 소프트웨어의 기능을 변경하거나 추가하기가 쉽다. 작은 단위로 쪼갠 함수들을 조합하여 큰 기능을 만들면 조합된 함수 사이사이에 새로운 함수를 추가하는 식으로 쉽게 확장해 나갈 수 있다.</p><p>함수형 자바스크립트 10가지 기법</p><ol><li>함수를 되도록 작게 만들기</li><li>다형성 높은 함수를 만들기</li><li>상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화하기</li><li>동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기</li><li>복잡한 객체 하나를 인자로 사용하기보다는 되도록 일반적인 값 여러개를 인자로 사용하기</li><li>큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기</li></ol><a id="more"></a><ol start="7"><li>어느 곳에서든 바로 실행하거나 혹은 미뤄서 실행할 수 있도록 일반 함수이자 순수 함수로 선언하기</li><li>모델이나 컬렉션 등의 커스텀 객체보다는 기본 객체를 이용하기</li><li>로직의 흐름을 최대한 단방향으로 흐르게 하기</li><li>작은 함수를 모아 큰 함수를 만들기</li></ol><p>이번 장에서는 작은 함수로 큰 함수를 만드는 방법들을 다룬다. 객체지향에 빗대어 표현하면 클래스와 인스턴스에 대해서 처음 다루는 장이라고 할 수도 있겠다.</p><h2 id="고차-함수와-보조-함수"><a href="#고차-함수와-보조-함수" class="headerlink" title="고차 함수와 보조 함수"></a>고차 함수와 보조 함수</h2><p>이번 장에서는 고차 함수의 다양한 사례를 통해 함수 조립에 대한 생각들을 확장하고자 한다. 함수를 주재료로 다루는 함수들을 다룰 것이다.</p><h3 id="한-번만-실행하는-함수"><a href="#한-번만-실행하는-함수" class="headerlink" title="한 번만 실행하는 함수"></a>한 번만 실행하는 함수</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_.once = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag, result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> result;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> result = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hi = _.once(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hi();</span><br><span class="line"><span class="comment">// hi</span></span><br><span class="line">hi();</span><br><span class="line"><span class="comment">// 아무일도 일어나지 않음</span></span><br></pre></td></tr></table></figure><p>_.once는 받아 둔 익명 함수가 한 번만 실행되도록 설정된 함수를 리턴한다. 이런 기능을 구현하기 위해서는 flag 값이 필요하며 flag 값에 따라 실행할 것인지 말 것인지 대해 판단하는 로직이 어딘가에 있어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = _.once(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a());</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="built_in">console</span>.log(a());</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure><h3 id="다시-물어-보지-않는-함수"><a href="#다시-물어-보지-않는-함수" class="headerlink" title="다시 물어 보지 않는 함수"></a>다시 물어 보지 않는 함수</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skip</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> yes;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yes || (yes = body.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최초 한번만 실행을 하고 그 이후로는 실행이 되지 않는다. skip은 고차 함수이고 body는 skip이 남겨 놓은 로직을 완성하는 함수다. 함수형 자바스크립트는 함수로 함수를 다루거나 함수로 함수를 만드는 것의 반복이고, 고차 함수 응용의 반복이다.<br>skip은 고차 함수이자 함수를 만드는 함수다. 함수로 함수를 만들 때는 재료로 함수가 사용되기도 하고 일반 값이 사용되기도 한다. 함수로 만들어진 함수는 대부분 클로저다.</p><h3 id="앞서-받은-인자-혹은-상황을-변경해-나가는-경우"><a href="#앞서-받은-인자-혹은-상황을-변경해-나가는-경우" class="headerlink" title="앞서 받은 인자 혹은 상황을 변경해 나가는 경우"></a>앞서 받은 인자 혹은 상황을 변경해 나가는 경우</h3><p>skip같은 함수는 앞서 만든 상황을 변경해 나가는 사례다. 처음에는 false로 시작했지만 true로 변경하여 이후 동작을 다르게 만들기 위해 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idMaker</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> messageCid = idMaker(<span class="number">0</span>);</span><br><span class="line">messageCid();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">messageCid();</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postCid = idMaker(<span class="number">11</span>);</span><br><span class="line">postCid()</span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line">postCid()</span><br><span class="line"><span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>idMaker는 원하는 시작점부터 시작해 실행할 때마다 증가한 고유한 아이디 값을 만드는 함수를 만드는 함수다. idMaker는 메신저 등을 만들 때 사용할 수 있다. 사용자가 메시지를 입력하고 엔터 키를 쳤을 때, 임시로 클라이언트 측 고유 아이디를 만들어 메시지에 해당하는 HTML 요소를 즉시 그려 둔 다음, 서버에게 정보를 보내어 DB에 저장하고 응답으로 온 데이터를, 만들어 두었던 클라이언트 측 고유 아이디를 기준으로 매핑한다.</p><h3 id="앞서-받은-인자를-잘-유지해야-하는-경우"><a href="#앞서-받은-인자를-잘-유지해야-하는-경우" class="headerlink" title="앞서 받은 인자를 잘 유지해야 하는 경우"></a>앞서 받은 인자를 잘 유지해야 하는 경우</h3><p>클로저가 기억하고 있는 외부 변수도 일반 변수처럼 언제든지 값이 변경될 수 있다. 앞선 _.once, skip, idMaker 사례는 값이 변경되는 점을 이용한 기법이다. 이번에는 반대로 값을 잘 유지해야 하는 상황을 살펴 볼 텐데, 이런 상황에서 실수가 많이 생긴다.</p><p>특히 앞서 받은 인자와 나중에 받은 인자를 조합하여 결과를 만들려고 할 때는 실수하기가 쉽다. 이럴 때는 계속 사용할 객체는 원래 상태를 잘 유지하도록, 한 번만 쓰이고 사라져야 할 값은 사라지도록 잘 관리해 주어야 한다.</p><p>앞서 받은 인자의 상태가 변경되지 않도록 concat이나 slice를 이용해 항상 새로운 객체를 만든다거나, _.rest 같은 함수를 이용해 인자의 일부분을 잘 제외시켜야 하는데, 이 것을 어떤 타이밍에 하는지가 중요하다.</p><h2 id="부분-적용"><a href="#부분-적용" class="headerlink" title="부분 적용"></a>부분 적용</h2><h3 id="partial로-함수-만들기"><a href="#partial로-함수-만들기" class="headerlink" title="_.partial로 함수 만들기"></a>_.partial로 함수 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pc = _.partial(<span class="built_in">console</span>.log, <span class="number">1</span>);</span><br><span class="line">pc(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2가 오른쪽으로 들어감</span></span><br><span class="line">pc(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 2, 3이 오른쪽으로 들어감</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pc = _.partial(<span class="built_in">console</span>.log, _, <span class="number">2</span>);</span><br><span class="line">pc(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1, 2 1이 왼쪽의 _ 자리에 들어감</span></span><br><span class="line">pc(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1 2 3  1이 왼쪽의 _자리에 들어가고 3이 오른쪽으로 들어감</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pc = _.partial(<span class="built_in">console</span>.log, _, _, <span class="number">3</span>);</span><br><span class="line">pc(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1 undefined 3 1이 왼쪽 _ 자리에 들어가고 두 번째 _는 들어오지 않아 undefined 가 됨</span></span><br><span class="line">pc(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1 2 3 1과 2가 순서대로 _, _ 를 채움</span></span><br><span class="line">pc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1 2 3 4 1과 2가 순서대로 _, _를 채우고 3의 오른쪽으로 4가 들어감</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pc = _.partial(<span class="built_in">console</span>.log, _, <span class="number">2</span>, _, _, <span class="number">5</span>);</span><br><span class="line">pc(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure><p>_.partial 함수를 이용하면 원하는 위치에 인자를 부분적으로 적용할 수 있다. _.partial을 활용한 다양한 함수 조립 사례를 확인해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add_all = _.partial(_.reduce, _, <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(add_all([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(add_all([<span class="number">5</span>, <span class="number">2</span>]));</span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>_.partial은 함수를 다루는 고차 함수다. _.reduce도 고차 함수다. 위 코드 처럼 _.partial을 이용해 _.reduce와 같은 고차 함수에 미리 보조 함수를 적용해 두는식으로 add_all 같은 함수를 구현할 수 있다.</p><p>_.partial은 정말 강력하다. _.partial을 이용하면, 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> method = <span class="function"><span class="keyword">function</span> (<span class="params">obj, method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[method].apply(obj, _.rest(<span class="built_in">arguments</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> push = _.partial(method, _, <span class="string">'push'</span>);</span><br><span class="line"><span class="keyword">var</span> shift = _.partial(method, _, <span class="string">'shift'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">push(a, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">shift(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = method([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'concat'</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>이번 method 함수로 함수를 만드는 함수가 아닌 혼자서도 실행할 수 있는 일반 함수가 되었다. 이러한 방식의 이점은 method 같은 함수가 혼자서도 활용 가능한 함수가 된다는 점이다.</p><h3 id="partial과-compose로-함수-만들기"><a href="#partial과-compose로-함수-만들기" class="headerlink" title="_.partial과 _.compose로 함수 만들기"></a>_.partial과 _.compose로 함수 만들기</h3><p>_.partial은 함수를 연속으로 실행해 주는 _.compose 등의 함수와 함께 더 재미있게 사용할 수 있다. _.compose는 오른쪽의 함수를 실행한 결과를 왼쪽의 함수에게 전달하는 것을 반복하는 고차 함수이다. _.compose는 인자로 함수만 받는 함수다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_.compose(<span class="built_in">console</span>.log, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a - <span class="number">2</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">5</span> &#125;)(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// console.log &lt;- 5 - 2 &lt;- 0 + 5 &lt;- 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falsy_values = _.compose(</span><br><span class="line">  _.partial(_.isEqual, <span class="number">-1</span>), <span class="comment">// 1</span></span><br><span class="line">  _.partial(_.findIndex, _, _.identity) <span class="comment">// 2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(falsy_values([<span class="number">1</span>, <span class="literal">true</span>, &#123;&#125;]));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(falsy_values([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>]));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(falsy_values([<span class="number">0</span>, <span class="string">""</span>, <span class="literal">false</span>]));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> some = _.negate(falsy_values); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(some([<span class="number">1</span>, <span class="literal">true</span>, &#123;&#125;]));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(some([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>]));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(some(<span class="number">0</span>, <span class="string">""</span>, <span class="literal">false</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> every = _.compose(</span><br><span class="line">  _.partial(_.isEqual, <span class="number">-1</span>),</span><br><span class="line">  _.partial(_.findIndex, _, _.negate(_.identity)) <span class="comment">// 4</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(every([<span class="number">1</span>, <span class="literal">true</span>, &#123;&#125;]));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(every([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>]));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(every([<span class="number">0</span>, <span class="string">""</span>, <span class="literal">false</span>]));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol><li>_.isEqual 함수에 -1을 부분 적용하여, 앞에서 나온 결과가 -1과 같은지를 검사하는 함수 만들기</li><li>-1 과 비교하는 함수가 실행되기 전에는 _.findIndex에 _.identity 를 부분 적용해 둔 함수가 실행된다. _.findIndex는 긍정적인 값을 처음 만났을 때의 index를 리턴한다. _.compose 를 통해 두 함수를 역순으로 나열했고, falsy_values 는 배열에 들어있는 모든 값이 부정적인 값인지를 판단하는 함수가 된다.</li><li>받은 함수를 실행한 후, 결과를 반대로 만드는 함수를 리턴하는 함수인 _.negate 와 앞서 조합한 falsy_values를 조합하여 하나라도 긍정적인 값이 있는지를 체크하는 some 함수를 만들었다.</li><li>falay_values를 조합던 코듸의 _.identity 부분만 _.negate로 감싸서 모두 긍정적인 값이 맞는지를 체크하는 every 함수</li></ol><h3 id="더-나은-partial-함수"><a href="#더-나은-partial-함수" class="headerlink" title="더 나은 _.partial 함수"></a>더 나은 _.partial 함수</h3><p>_.partial은 인자를 왼쪽에서부터 하나씩 적용하면서 _로 구분하여 인자가 적용될 위치를 지정해 둘 수 있도록 한다. 이런 _.partial에도 한 가지 아쉬움이 있다. 자바스크립트 함수는 인자 개수가 유동적일 수 있고 함수의 마지막 인자를 중요하게 사용할 수도 있는데, 이 같은 함수화 _.partial은 합이 잘 맞지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iter = <span class="built_in">arguments</span>[<span class="built_in">arguments</span>.length - <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">arguments</span>.length--;</span><br><span class="line">  <span class="keyword">return</span> _.reduce(<span class="built_in">arguments</span>, iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m(<span class="number">100</span>, <span class="number">50</span>, add);</span><br><span class="line"><span class="comment">// 150</span></span><br><span class="line">m(<span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, add);</span><br><span class="line"><span class="comment">// 160</span></span><br><span class="line">m(<span class="number">100</span>, <span class="number">50</span>, sub);</span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line">m(<span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, sub);</span><br><span class="line"><span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = _.partial(m, _, _, _, add);</span><br><span class="line"><span class="comment">// f1 은 3개의 인자만 더할 수 있다.</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// _.reduce에 1이 넘어가면서 에러</span></span><br></pre></td></tr></table></figure><p>f1의 상황처럼 인자를 유동적으로 다루는 함수는 _.partial로 다루기 좋지 않다. 맨 왼쪽 인자나 맨 왼쪽에서 두 번째 인자를 적용해 두는 것은 가능하지만 맨 오른쪽 인자나 맨 오른쪽에서 두 번째에만 인자를 적용해 두는것은 불가능 하기 때문이다. Lodash 는 이를 위해 _.partialRight를 구현했지만 양쪽 끝 모두를 부분 적용하고, 가운데 부분을 가변적으로 가져가고 싶을 때도 있기에 아직 아쉽다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ___ = &#123;&#125;;</span><br><span class="line">_.partial = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args1 = [], args3, len = <span class="built_in">arguments</span>.length, ___idx = len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">if</span> (arg == ___ &amp;&amp; (___idx = i) &amp;&amp; (args3 = [])) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; ___idx) args1.push(arg);</span><br><span class="line">    <span class="keyword">else</span> args3.push(arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, mergeArgs(args1, <span class="built_in">arguments</span>, args3)) &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_toUndef</span>(<span class="params">args1, args2, args3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args2) args1 = args1.concat(args2);</span><br><span class="line">  <span class="keyword">if</span> (args3) args1 = args1.concat(args3);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = args1.length; i &lt; len; i++)</span><br><span class="line">    <span class="keyword">if</span> (args1[i] == _) args1[i] = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> args1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArgs</span>(<span class="params">args1, args2, args3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!args2.length) <span class="keyword">return</span> args3 ? _toUndef(args1, args3) : _toUndef(args1.slice());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> n_args1 = args1.slice(), args2 = _.toArray(args2), i = <span class="number">-1</span>, len = n_args1.length;</span><br><span class="line">  <span class="keyword">while</span> (++i &lt; len) <span class="keyword">if</span> (n_args1[i] == _) n_args1[i] = args2.shift();</span><br><span class="line">  <span class="keyword">if</span> (!args3) <span class="keyword">return</span> _toUndef(n_args1, args2.length ? args2 : <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> n_arg3 = args3.slice(), i = n_arg3.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) <span class="keyword">if</span> (n_arg3[i] == _) n_arg3[i] = args2.pop();</span><br><span class="line">  <span class="keyword">return</span> args2.length ? _toUndef(n_args1, args2, n_arg3) : _toUndef(n_args1, n_arg3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>복잡해 보이지만 생각보다 단순하다. 우선 새로운 구분자인 <strong>_ 가 추가 되었다. _.partial을 실행하면 _</strong>를 기준으로 왼편의 인자들을 왼쪽부터 적용하고 오른편의 인자들을 오른쪽부터 적용할 준비를 해 둔 함수를 리턴한다. 부분 적용된 함수를 나중에 실행하면 그때 받은 인자들로 왼쪽과 오른쪽을 먼저 채운 후, 남은 인자들로 가운데 ___자리를 채운다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pc = _.partial(<span class="built_in">console</span>.log, ___, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">pc(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line">pc(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 1 4 5 6 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pc = _.partial(<span class="built_in">console</span>.log, _, <span class="number">2</span>, ___, <span class="number">5</span>, _, <span class="number">7</span>);</span><br><span class="line">pc(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1 2 5 undefined 7</span></span><br><span class="line">pc(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1 2 3 5 4 7</span></span><br><span class="line">pc(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 1 2 3 4 6 5 8 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add_all = _.partial(m, ___, add);</span><br><span class="line">add_all(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub10 = _.partial(m, ___, <span class="number">10</span>, sub);</span><br><span class="line">sub10(<span class="number">50</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>_.partial을 이용하면 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있고, 코드에 함수 표현식이 나오는것도 많이 줄일 수 있다. 이렇게 하면 _.chain, _.compose, _.pipeline 등의 함수 합성 패턴과도 잘 어울리고 함수를 조립하는 것도 즐거워 진다. 함수에 인자를 미리 적용해 두는 기법은 비동기 상황에서도 효과적으로 쓰인다.</p><h2 id="연속적인-함수-실행"><a href="#연속적인-함수-실행" class="headerlink" title="연속적인 함수 실행"></a>연속적인 함수 실행</h2><h3 id="체인의-아쉬운점"><a href="#체인의-아쉬운점" class="headerlink" title="체인의 아쉬운점"></a>체인의 아쉬운점</h3><p>체인은 메서드를 연속적으로 실행하면서 객체의 상태를 변경해 나가는 기법이다. 체인은 표현력이 좋고 실행 순서를 눈으로 따라가기에도 좋다. 체인 방식은 많은 장점을 가지고 있지만 체인 방식으로만 모든 로직을 구현하기에는 다소 불편한 점이 있다.</p><p>체인 방식은 체인 객체가 가지고 있는 메서드만 이용할 수 있기 때문에 체인 객체와 연관 없는 로직이나 다른 재료를 중간에 섞어 사용하기 어렵다. 정해진 메서드나 규격에 맞춰서 사용해야 하기 때문에 인자를 자유롭게 사용하기 어렵고 다양한 로직을 만들기도 어렵다. 따라서 결과를 완성해 나가는 과정에서 체인을 끊어야 하는 경우가 많다.</p><p>체인 방식은 사용하기는 쉽지만 잘 만들어 두기는 어렵다. this만 리턴하면 되는데 뭐가 어렵냐고 할 수 있지만, 가만히 생각해 보면 잘 쓰이는 체인 API는 그렇게 많지 않다. 잘 쓰이는 체인 API가 되려면 우선 체인 패턴과 잘 어울리는 주제여야 한다.</p><p>체인 방식은 객체가 생성되어야만 메서드를 사용할 수 있기 때문에 반드시 생성 단계를 거쳐야 한다. 그리고 this 등의 상태와 흐름과 깊이에 의존하기 때문에 언제 어디서나 아무 때나 사용이 가능한 순수 함수보다는 접근성면에서 좀 불편하다.</p><h3 id="compose의-아쉬운-점"><a href="#compose의-아쉬운-점" class="headerlink" title="_.compose의 아쉬운 점"></a>_.compose의 아쉬운 점</h3><p>_.compose 함수는 디자인 패턴과 같은 특별한 개념이나 지식 없어도, 바로 코딩 및 설계가 가능하다는 장점이 있다. 인자와 결과만을 생각하면서 작은 함수들을 조합하면 된다. 몇 가지 아쉬운 점이 있는데 그중 가장 큰 아쉬움은, 함수 실행의 순서가 오른쪽에서부터 왼쪽이기 때문에 읽기가 어렵다는 점이다. 함수 실행을 중첩해서 하는 것과 코드의 표현력이 크게 다를 바가 없고, 기능적으로도 특별히 나을 점이 없다.</p><h3 id="파이프라인"><a href="#파이프라인" class="headerlink" title="파이프라인"></a>파이프라인</h3><p>파이프라인은 _.compose의 장점을 그대로 가지고 있다. _.compose와 기본적인 사용법은 동일하다. 다만, 함수 실행 방향은 왼쪽에서부터 오른쪽이다. 왼쪽에서부터 오른쪽, 위에서부터 아래로 표현되어 코드를 읽기 쉽다. 또한 체인과 달리 아무 함수나 사용할 수 있어 자유도가 높다. 여기서는 이런 파이프라인의 장점들을 살펴볼 것이다.</p><p>Michael Fogus의 _.pipeline </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_.pipeline = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funs = <span class="built_in">arguments</span>; <span class="comment">// 1. 함수들</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">seed</span>) </span>&#123; <span class="comment">// 2. 첫 인자</span></span><br><span class="line">    <span class="keyword">return</span> _.reduce(funs,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">l, r</span>) </span>&#123; <span class="keyword">return</span> r(l); &#125;, <span class="comment">// 4. 모든 함수를 연속적으로 실행</span></span><br><span class="line">      seed) <span class="comment">// 3. 첫 인자 전달</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div_square = _.pipeline(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(div_square(<span class="number">6</span>));</span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>_.pipeline은 _.reduce를 이용해서 만들어졌다. _.reduce는 정말 강력한 함수다. 위 상황에서 가지고 있는 데이터는 함수들이고 만들고자 하는 데이터는 최초 인자로부터 시작해 모든 함수를 통과한 마지막 결과이다.</p><ol><li>arguments를 지역 변수 funs에 담았다.</li><li>funs를 기억하는 함수를 리턴한다.</li><li>리턴된 함수가 나중에 실행되면 받은 인자인 seed를 _.reduce 의 마지막 인자로 넘겨주어 seed는 최초의 l이 된다.</li><li>예측해 보건대 l 은 left고 r은 right인 듯 하다. 오른쪽 함수를 r을 실행하며 왼쪽 함수의 결과 l을 넘겨주고 있다. funs의 개수만큼 반복되며 마지막 함수의 결과가 곧 _.pipeline으로 만든 함수의 결과가 된다.</li></ol><h3 id="클래스를-대신하는-파이프라인"><a href="#클래스를-대신하는-파이프라인" class="headerlink" title="클래스를 대신하는 파이프라인"></a>클래스를 대신하는 파이프라인</h3><p>_.pipeline은 작은 함수들을 모아 큰 함수를 만드는 함수다. 파이프라인은 클래스와 기능적인 면과 개념적인 면이 다르지만 비슷한 역할을 대신할 수 있다. 작은 함수들을 조합하여 큰 함수들을 만들고 함수 조합을 조금씩 변경하거나 추가하면서 새로운 로직을 만들어 갈 수 있다.</p><p>회원가입을 예로 들어 보자. 개인 회원과 기업 회원이 있다고 가정하면, 회원 가입과 관련된 작은 로직들을 작은 함수 단위로 쪼개어 나눈 후 약간 변경하여 조합하거나 더할 수 있고, 뺄 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = [];</span><br><span class="line"><span class="keyword">var</span> companies = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joined_at</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.extend(attrs, &#123; <span class="attr">joined_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">member</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> member.name + <span class="string">" 회원님은 "</span> + member.id + <span class="string">" 번째 회원이십니다. 환영합니다."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> join_user = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">member</span>) </span>&#123;</span><br><span class="line">    users.push(member);</span><br><span class="line">    member.id = users.length;</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> join_company = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">member</span>) </span>&#123;</span><br><span class="line">    companies.push(member);</span><br><span class="line">    member.id = companies.length;</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(join_user(&#123; <span class="attr">name</span>: <span class="string">"ID"</span> &#125;));</span><br><span class="line"><span class="comment">// ID 회원님은 1 번째 회원이십니다. 환영합니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(join_user(&#123; <span class="attr">name</span>: <span class="string">"JI"</span> &#125;));</span><br><span class="line"><span class="comment">// JI 회원님은 2 번째 회원이십니다. 환영합니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(join_company(&#123; <span class="attr">name</span>: <span class="string">"MARPPLE"</span> &#125;));</span><br><span class="line"><span class="comment">// MARPPLE 회원님은 1 번째 회원이십니다. 환영합니다.</span></span><br></pre></td></tr></table></figure><p>join_user와 join_company는 두 번째 함수만 다르고 첫 번째와 세 번째 함수는 동일하게 조합되었다. 위에서 부터 내려오면서 가입 날짜를 만들고 서로 다른 배열에 담은 후 인사말을 남기고 있다.<br>_.partial을 함께 이용하면 아래와 같은 표현이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joined_at</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.extend(attrs, &#123; <span class="attr">joined_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">table, member</span>) </span>&#123;</span><br><span class="line">  table.push(member);</span><br><span class="line">  member.id = table.length;</span><br><span class="line">  <span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">member</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> member.name + <span class="string">" 회원님은 "</span> + member.id + <span class="string">" 번째 회원이십니다. 환영합니다."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> join_user = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  _.partial(join, users),</span><br><span class="line">  greeting</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> join_company = _.pipeline(</span><br><span class="line">  joined_at,</span><br><span class="line">  _.partial(join, companies),</span><br><span class="line">  greeting</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이번에는 _.partial을 이용해 users에 담을지 companies에 담을지를 선택했다. 이런 방식은 로직을 단순하게 한다. 서로 다른 기능을 하지만 조건문이 없다. 각자 자신이 해야 할 일만 순서대로 수행할 뿐이다. 작은 함수는 작성이 쉽고 테스트도 쉬우면 오류도 적기 마련이다. 앞뒤로 받을 인자와 결과만을 생각하면서 문제를 작게 만들면 문제 해결도 쉬워진다.</p><h3 id="더-나은-파이프라인-그리고-Multiple-Results"><a href="#더-나은-파이프라인-그리고-Multiple-Results" class="headerlink" title="더 나은 파이프라인, 그리고 Multiple Results"></a>더 나은 파이프라인, 그리고 Multiple Results</h3><p>Underscore.js의 _.pipeline이나 Lodash의 _.flow에는 아쉬운 점이 있다. 인자를 하나만 받을 수 있다는 점이다. 파이프라인에 사용된 내부 함수들 역시 마찬가지다. 파이프라인 내부에서 function (a, b) { return a + b; } 와 같은 함수는 사용할 수 없다는 얘기다. 물론 객체나 배열에 담아 다음 함수에게 전달할 수도 있겠지만 function(args) { return args[0] + args[1]; } 과 같은 함수는 파이프라인만을 위한 함수라고 봐야 한다. 클로저나 _.partial을 이용해서 인자나 재료를 늘릴 수 있지만 자칫 외부 상황에 의존하는 함수가 될 수 있다.</p><p>함수형 자바스크립트는 순수 함수를 많이 사용할수록, 인자들을 적극 활용할수록 강력해진다. 인자는 특히 2~3개 사용할 때도 많고 개수가 가변적인 경우도 많다. 인자를 2개 이상 필요로 하는 함수들을 파이프라인 사이에 끼워 넣지 못한다는 것은, 곧 파이프라인 사이에 정의된 함수들의 재사용성도 낮아진다는 얘기다.</p><p>만일 언어가 Go였다면 함수의 결과로 Multiple Results를 리턴할 수 있고 파이프라인 중간중간에 여러 개의 인자를 받는 함수들을 얼마든지 끼워 넣을 수 있을 것이다.</p><p>Multiple Results는 함수의 결과값을 여러 개로 리턴하는 개념이다. 자바스크립트에는 이러한 기능이 없지만 이것을 대체하는 기능을 구현할 수 있다. 여러 개의 값을 모아 Multiple Results를 뜻하는 객체로 만든 후 파이프라인 안에서 Multiple Results에 담긴 인자를 다시 여러개로 펼쳐서 실행하도록 구현하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_.mr = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>._mr = <span class="literal">true</span>; <span class="comment">// 인자들이 담긴 arguments 객체에 _mr로 구분자를 만듬</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.pipeline = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funs = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">seed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.reduce(funs,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">l, r</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Multiple Results라면 apply로 인자를 펼침.</span></span><br><span class="line">        <span class="keyword">return</span> l &amp;&amp; l._mr ? r.apply(<span class="literal">null</span>, l) : r(l);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 인자가 여러개면 첫 번째 함수에게도 Multiple Results로 만들어서 넘기기</span></span><br><span class="line">      <span class="built_in">arguments</span>.length &lt; <span class="number">2</span> ? seed : _.mr.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>apply는 배열이나 arguments 객체를 받아 함수의 인자들로 펼쳐준다. 함수를 실행하기 전 l이 Multiple Results라면 r.apply()를 이용해 r 함수에게 인자를 여러개로 전달할 수 있도록 기능을 추가했다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = _.pipeline(</span><br><span class="line">  add,</span><br><span class="line">  square,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.mr(a, a / <span class="number">5</span>); <span class="comment">// Multiple Results</span></span><br><span class="line">  &#125;,</span><br><span class="line">  sub</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(f1(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>이제 add와 sub 같이 인자를 2개 이상 사용하는 일반 함수들도 파이프라인 사이에 넣을 수 있게 되었다. _.pipeline으로 함수를 정의하면 Multiple Results 를 지원하는 함수가 되어, 함수를 중첩하기만 해도 마치 Go 언어 처럼 동작한다.</p><h2 id="더-나은-함수-조립"><a href="#더-나은-함수-조립" class="headerlink" title="더 나은 함수 조립"></a>더 나은 함수 조립</h2><p>함수를 조립하는 데에도 함수가 사용된다. 함수를 재료로 사용하고, 재료를 함수로 실행하면서 로직을 완성한다. 함수로 함수를 만드는 방법들을 더 정교하게 잘 다루면 훨씬 다양하고 재밌게 조합할 수 있다. _.partial이나 _.pipeline의 기능을 높인다거나 그동안 살펴보았던 함수형 스타일의 함수들에게 부분 커링을 내장하도록 한다거나 하면 함수 조립의 효과를 더욱 높일 수 있다.</p><h3 id="Partial-js의-pipe"><a href="#Partial-js의-pipe" class="headerlink" title="Partial.js의 _.pipe"></a>Partial.js의 _.pipe</h3><p>마이클 포거스의 _.pipeline은 Multiple Results를 지원하지 않는 아쉬움이 있었다. 한 가지 아쉬운 점이 더 있는데, 파이프라인의 내부 함수에서 this를 사용할 수 없다는 점이다. 자바스크립트에서의 함수는 메서드든 아니든 this를 사용할 수 있도록 되어있다. 새로운 기능을 만들 때, 기존의 기본 기능을 유지하는 것은 언제나 중요한 일이다.</p><p>Partial.js의 파이프라인 함수인 _.pipe는 Multiple Results와 this를 모두 지원한다. 그리고 Multiple Results를 사용할 수 있기 때문에 인자를 2개 이상 필요로 하는 함수도 함께 사용할 수 있고, this를 사용할 수 있기 때문에 메서드를 만들거나 this를 사용하는 라이브러리들과 협업이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_.pipe(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">console</span>.log, <span class="comment">// 1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">console</span>.log, <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line">).call(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  method1: _.pipe(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">console</span>.log, <span class="comment">// 10</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">console</span>.log <span class="comment">// &#123;a: 10, b: 2, method1: ƒ&#125;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.method1();</span><br></pre></td></tr></table></figure><h3 id="즉시-실행-파이프라인-go"><a href="#즉시-실행-파이프라인-go" class="headerlink" title="즉시 실행 파이프라인 _.go"></a>즉시 실행 파이프라인 _.go</h3><p>_.go는 _.pipe의 즉시 실행 버전이다. 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 편하기 때문에 첫 번째 인자를 파이프라인에서 사용할 인자로 정했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.go(<span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a / <span class="number">2</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">2</span> &#125;,</span><br><span class="line">  <span class="built_in">console</span>.log <span class="comment">// 7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507">함수형 자바스크립트 프로그래밍</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2019/11/17/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수형 자바스크립트를 위한 문법 다시 보기-2</title>
      <link>https://kkangil.github.io/2019/10/27/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0-2/</link>
      <guid>https://kkangil.github.io/2019/10/27/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0-2/</guid>
      <pubDate>Sun, 27 Oct 2019 05:33:33 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;if-else-amp-amp-삼항-연산자-다시-보기&quot;&gt;&lt;a href=&quot;#if-else-amp-amp-삼항-연산자-다시-보기&quot; class=&quot;headerlink&quot; title=&quot;if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기&quot;&gt;&lt;/a&gt;if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기&lt;/h2&gt;&lt;h3 id=&quot;if의-괄호&quot;&gt;&lt;a href=&quot;#if의-괄호&quot; class=&quot;headerlink&quot; title=&quot;if의 괄호&quot;&gt;&lt;/a&gt;if의 괄호&lt;/h3&gt;&lt;p&gt;if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.&lt;/p&gt;
&lt;p&gt;괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="if-else-amp-amp-삼항-연산자-다시-보기"><a href="#if-else-amp-amp-삼항-연산자-다시-보기" class="headerlink" title="if else || &amp;&amp; 삼항 연산자 다시 보기"></a>if else || &amp;&amp; 삼항 연산자 다시 보기</h2><h3 id="if의-괄호"><a href="#if의-괄호" class="headerlink" title="if의 괄호"></a>if의 괄호</h3><p>if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.</p><p>괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.<br><a id="more"></a><br>if (expression) { statements } 중 statements 부분에는 비동기 코드를 활용할 여지가 있고 몇 가지 아이디어를 통해 어느정도 제어가 가능하지만 if의 괄호 부분은 비동기 코드와 거리가 좀 있다. 하지만 괄호 안에서 할 수 있는 일들은 많다. 새로운 객체를 생성할 수도 있고 객체의 key에 값을 할당할 수도 있으며 함수를 실행할 수도 있다. 먼저 에러가 발생하는 코드를 확인해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">var</span> a = <span class="number">0</span>) <span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>위 코드는 문법 에러가 난다. 괄호에서는 표현식만 사용할 수 있기 때문이다. 아래 코드는 에러는 나지 않지만 쓸모없는 코드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;) <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>f1을 정의하는 곳에서는 에러가 나지 않았고 hi도 출력했지만 f1은 실행할 수 없다. f1이 값으로 다뤄져서 유명 함수로 선언되었기 때문이다. f1은 어디에서도 참조할 수 없어 위 코드는 사실상 에러가 나지 않지만 아무런 의미가 없는 코드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">5</span>) <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">0</span>) <span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(a = <span class="literal">false</span>)) <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">5</span> - <span class="number">5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>미리 선언된 변수에 값을 할당하는 것은 가능하다. 동시에 if의 괄호에는 a가 사용된다. 1에서는 if (5)인 셈이므로 5가 출력된다. 2에서는 if (0) 인 셈이므로 else로 넘어가게 된다. 3에서는 false를 담았고 !으로 반전하여 false가 결과로 나오도록 했다. 4에서는 a에 0이 담기고 else로 넘어간다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj.a = <span class="number">5</span>) <span class="built_in">console</span>.log(obj.a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj.b = <span class="literal">false</span>) <span class="built_in">console</span>.log(obj.b); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="keyword">if</span> (c = obj.c = <span class="literal">true</span>) <span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>이번에는 if의 괄호 안에서 객체의 key에 값을 할당했다. obj에 값을 할당했고, if의 괄호에서는 obj가 아닌 할당한 값이 쓰인다. 2와 3을 통해 알 수 있다. c에는 obj가 아닌 true가 담긴다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (add(<span class="number">1</span>, <span class="number">2</span>)) <span class="built_in">console</span>.log(<span class="string">'hi1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">if</span> (a = add(<span class="number">1</span>, <span class="number">2</span>)) <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;()) <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br></pre></td></tr></table></figure><p>함수를 실행할 수도 있고 실행한 결과를 변수에 담으면서 참과 거짓을 판단할 수도 있다. 익명 함수나 유명 함수를 정의하면서 즉시 실행할 수도 있다.</p><p>위에서 확인한 모든 코드들은 자바스크립트의 대부분의 괄호에서 동일하게 동작한다. 이를테면 while문의 괄호에서도 동일하게 동작한다. 괄호 안에서 어떤 코드들을 돌릴 수 있는지 잘 알고 있다면 코드를 더 깔끔하게 정리하거나 코드 구조를 크게 변경하지 않고도 기능을 발전시킬 수 있다.</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="|| &amp;&amp;"></a>|| &amp;&amp;</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> &amp;&amp; <span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &amp;&amp; <span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log([] || &#123;&#125;); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log([] &amp;&amp; &#123;&#125;); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log([] &amp;&amp; &#123;&#125; || <span class="number">0</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> || <span class="number">0</span> || <span class="number">0</span> || <span class="number">1</span> || <span class="literal">null</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">-10</span>) || add(<span class="number">10</span>, <span class="number">-10</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">-10</span>) || add(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"><span class="keyword">var</span> v;</span><br><span class="line"><span class="built_in">console</span>.log((v = add(<span class="number">10</span>, <span class="number">-10</span>)) || v++ &amp;&amp; <span class="number">20</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log((v = add(<span class="number">10</span>, <span class="number">10</span>)) || ++v &amp;&amp; <span class="number">20</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>||과 &amp;&amp;의 활용법은 생각보다 다양하다. 오른쪽으로 더 갈 것인가 말 것인가를 한 줄로 만들어 if else를 대체할 수도 있다. 상황에 따라 if else가 가독성이나 효율이 좋을 수 있고 ||, &amp;&amp; 가 좋을 수도 있다. 다양한 도구를 상황에 맞게 잘 사용하면 된다.</p><h3 id="삼항-연산자"><a href="#삼항-연산자" class="headerlink" title="삼항 연산자"></a>삼항 연산자</h3><p>삼항 연산자는 조건이 간단하고 실행 코드도 간단할 때 많이 사용된다. 보통 값을 담을 때 사용된다. 삼항 연산자를 이용해도 여러 줄을 코딩할 수 있다. 익명 함수, 유명 함수, 화살표 함수 등으로 즉시 실행 패턴을 사용하는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a ? <span class="number">10</span> : <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">arr, v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.length ? f(arr, v + arr.shift()) : v;</span><br><span class="line">&#125;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure><p>위 코드에서는 a 가 false이므로 삼항 연산자에서 10을 건너뛰고 함수 부분이 실행된다. 함수 정의 끝부분을 보면 알 수 있듯이 즉시 실행했다. 그리고 [1,2,3]과 0을 인자로 받는다. 위와 같이 즉시 실행 함수를 이용하면 어디에서든 한 줄만 작성할 수 있던 곳을 확장할 수 있다. 또한 다른 함수를 실행할 수도 있고 재귀를 돌면서 얼마든지 복잡한 로직도 넣을 수 있다.</p><h2 id="함수-실행의-괄호"><a href="#함수-실행의-괄호" class="headerlink" title="함수 실행의 괄호"></a>함수 실행의 괄호</h2><h3 id="함수-실행을-통해-생기는-새로운-공간"><a href="#함수-실행을-통해-생기는-새로운-공간" class="headerlink" title="함수 실행을 통해 생기는 새로운 공간"></a>함수 실행을 통해 생기는 새로운 공간</h3><p>이전에 가장 특별한 괄호는 함수를 실행하는 괄호라고 했었다. 함수를 실행하는 괄호와 그렇지 않은 다른 괄호의 차이는 무엇일까?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">5</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;);</span><br></pre></td></tr></table></figure><p>위 코드의 괄호 두 가지는 모두 일반적인 괄호다. 함수를 실행하는 괄호가 아닌 일반 괄호에서는 코드가 실행되면 해당 지점에 즉시 값을 만들고 끝난다. 해당 지점에서 만들어진 값을 참조할 수는 있지만 여기서 할 일은 바로 모두 끝난다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add5 = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="comment">// 새로운 공간</span></span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> call = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123; <span class="comment">// 새로운 공간</span></span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수를 실행하는 괄호</span></span><br><span class="line">add(<span class="number">5</span>);</span><br><span class="line">call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;);</span><br></pre></td></tr></table></figure><p>함수를 실행하는 괄호는 일반 괄호와 특성이 모두 같지만 한 가지 특성을 더 가지고 있다. 이 괄호를 통해 새로운 <code>실행 컨텍스트</code>가 열린다는 점이다. 이 점은 매우 중요하다. 함수를 실행하는 괄호에서는 코드가 실행되었을 때 해당 지점에 값을 만든 후 끝나지 않고, 이 값이 실행된 함수의 공간으로 넘어간다. 새롭게 열린 공간이 끝나기 전까지는 이전 공간의 상황들도 끝나지 않는다. 이 공간들을 실행 컨텍스트라고 한다.</p><p>새로운 공간이 생긴다는것, 콜 스택에 쌓인다는 것, 태스크 큐와 이벤트 루프에 의해 제어된다는 것, 이것들을 통해 개발자가 시작과 끝을 제어할 수 있다는 점들이 함수를 실행하는 괄호가 가진 가장 특별한 차이다.</p><p>함수가 정의되거나 실행되는 지점에서는 클로저도 만들어질 수 있고, 비동기 상황이 생길 수도 있으며 서로 다른 컨택스트가 연결되는 등의 특별한 일들이 생긴다. 이것들은 함수에 대한 매우 실제적이고 중요한 개념이다.<br>for문을 사용할 때 어떤 지점들을 확인하면서 코드 블록을 반복시키는지, 언제 어떻게 끝나는지 정확히 이해하지 않고는 코딩할 수 없듯이 함수도 마찬가지다.</p><h3 id="기본적인-비동기-상황"><a href="#기본적인-비동기-상황" class="headerlink" title="기본적인 비동기 상황"></a>기본적인 비동기 상황</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 (1초 뒤)</span></span><br></pre></td></tr></table></figure><p>코드 라인 순서와 달리 1, 2, 3 으로 실행 되었다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>비동기 상황이 생기는 함수의 결과는 return 문으로 반환할 수 없다. 비동기 상황이 생기는 함수의 결과를 받는 방법 중 하나는 콜백 함수를 넘겨서 돌려받는 방법이다. add의 마지막 인자로 넘겨진 익명 함수 callback은 add 안에서 모든 상황이 끝날 때 실행된다. 이를 통해 add를 실행한 스코프 내부에서 다시 add의 결과를 받을 수 있게 된다.<br>일반 괄호였다면 10, 5, function등이 그 자리에 정의되고 끝났겠지만 함수를 실행하는 괄호에서는 그 값들이 다른 공간으로 넘어간다. 새롭게 열린 공간에서는 넘겨받은 재료들로 새로우 일을 할 수 있다.</p><h3 id="함수-실행-괄호의-마법과-비동기"><a href="#함수-실행-괄호의-마법과-비동기" class="headerlink" title="함수 실행 괄호의 마법과 비동기"></a>함수 실행 괄호의 마법과 비동기</h3><p>비동기 상황을 제어하는 방법은 함수 실행을 일렬로 나열하는 것이다.</p><p>add 함수 실행 -&gt; setTimeout 함수 실행 -&gt; setTimeout이 1초 뒤 익명 함수를 실행 -&gt; 받아 둔 callback 실행</p><p>위와 같이 함수들의 실행을 일렬로 나열하여 한 가지 일이 순서대로 일어나도록 하는 것이다.<br>이 함수 나열을 숨겨서 비동기 코드가 동기식으로 실행되는 것처럼 보이도록 해볼 것이다. Promise하고 비슷할 것이다. 이 작업을 통해 함수 실행의 괄호에서 다른 공간으로 이동되는 사이에 할 수 있는 일을 확인할 것이다. 이런 기법들을 통해 프로미스의 내부 코드를 예상해 볼 수도 있을 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">15</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  sub(a, <span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    div(a, <span class="number">10</span>, <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(r); <span class="comment">// 약 3초 후에 2가 찍힘</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>원래 비동기가 일어나는 함수들은 아래처럼 중첩 실행을 할 수 없다. 함수의 몇 가지 특성을 활용해 비동기 함수도 아래처럼 중첩 실행이 가능하도록 해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(div(sub(add(<span class="number">10</span>, <span class="number">15</span>), <span class="number">5</span>), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// undefined가 찍히고 callback이 없다는 에러가 남.</span></span><br></pre></td></tr></table></figure><p>우선 함수가 실행되는 사이에 무언가를 할 수 있도록 함수로 한 번 감싸서 공간을 만들 것이다. wrap에게 함수를 전달하여 함수를 리턴 받으면 원래 기능을 유지하면서 코드 사이에 공간이 생긴다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">func</span>) </span>&#123; <span class="comment">// 1. 함수 받기</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 2. 함수 리턴하기, 이것이 실행됨.</span></span><br><span class="line">    <span class="comment">// 여기에 새로운 공간이 생김, 나중에 함수를 실행했을 때 이 부분을 거쳐감</span></span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="built_in">arguments</span>); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = wrap(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">10</span>, <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1에서 받은 함수를 기억하는 2 클로저를 만들어 리턴했고, add는 2가 된다. 나중에 2가 실행되면 1에서 받아 둔 3 함수를 실행하면서 2가 받은 모든 인자를 넘겨준다. 이전 add와 완전히 동일하게 동작하면서도 사이사이에 코드를 끼워 넣을 수 있는 공간들이 더 생겼다. wrap을 조금만 더 고치고 _async 라고 이름을 바꿔보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_async</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="built_in">arguments</span>.length++] = <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">// 1</span></span><br><span class="line">      _callback(result) <span class="comment">// 6</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _callback; <span class="comment">// 3</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_async_cb_receiver</span>(<span class="params">callback</span>) </span>&#123; <span class="comment">// 4</span></span><br><span class="line">      _callback = callback; <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = _async(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(<span class="number">20</span>, <span class="number">30</span>)(<span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123; <span class="comment">// 7</span></span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>우선 마지막 부분 7을 보면 add를 실행하는 방법이 바뀌었다. 한 번에 인자 3개를 넘기지 않고 마치 커링처럼 add에 필요한 재료를 넘긴 후 한 번 더 실행하면서 callback 함수를 넘기고 있다.</p><ol><li>add가 실행되면 인자로 20과 30이 넘어온다. 원래는 callback 함수를 받아야 하므로 arguments에 마지막 값으로 함수를 추가한다. 그리고 그 함수는 나중에 개발자가 넘겨준 callback 함수를 실행할 수 있게 준비해 두었다.</li><li>add를 정의할 때 받아 둔 func를 실행하면서 인자 3개를 넘긴다.</li><li>_callback 이라는 지역 변수를 만들어서 1과 4가 기억해 두도록 했다. 클로저를 활용하여 서로 다른 컨텍스트가 협업할 수 있도록 이어주었다.</li><li>_async_cb_receiver라는 이름을 가진 유명 함수이자 클로저를 만들어 리턴한다.</li><li>_async_cb_receiver가 실행될 때 받은 함수 callback을 _callback에 할당한다.</li><li>1초가 지나면 1이 실행될 것이고 add가 callback을 통해 넘긴 결과인 result를 받아 두었던 _callback을 실행하면서 다시 넘겨주고 있다.</li><li>이 익명 함수가 _callback 이므로 6에서 넘겨진 r을 받게 되고 로그를 남겼다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = _async(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = _async(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = _async(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">15</span>)(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  sub(a, <span class="number">5</span>)(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    div(a, <span class="number">10</span>)(<span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(r);</span><br><span class="line">      <span class="comment">// 약 3초 후 2가 찍힘</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="비동기와-재귀"><a href="#비동기와-재귀" class="headerlink" title="비동기와 재귀"></a>비동기와 재귀</h3><p>일반 콜백 패턴의 함수를 실행하는 것과 아직 큰 차이는 없지만 연산에 필요한 실행과 결과를 받기 위한 실행이 분리되었다. 함수를 실행하는 괄호에서는 값을 다른 공간으로 넘겨 새로운 일들을 더 할 수 있다. add, sub, div는 async를 통해 본체에 가기 전 새로운 공간을 가지고 있고, 그 공간에서는 시작과 끝을 제어하고 있다. 이 내부 공간을 손보면 좀 더 재밌는 일을 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_async</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="built_in">arguments</span>.length++] = <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">      _callback(result)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 변경된 부분</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 새로운 공간 추가</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i] &amp;&amp; args[i].name === <span class="string">'_async_cb_receiver'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> args[i](<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      func.apply(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;)(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _callback;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_async_cb_receiver</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      _callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = _async(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'add'</span>, a, b);</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = _async(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sub'</span>, a, b);</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = _async(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'div'</span>, a, b);</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = _async(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log(div(sub(add(<span class="number">10</span>, <span class="number">15</span>), <span class="number">5</span>), <span class="number">10</span>));</span><br><span class="line"><span class="comment">// 약 4초 뒤 2</span></span><br><span class="line">log(add(add(<span class="number">10</span>, <span class="number">10</span>), sub(<span class="number">10</span>, <span class="number">5</span>)));</span><br><span class="line"><span class="comment">// 약 3초 뒤 25</span></span><br></pre></td></tr></table></figure><p>모두 비동기 함수들 인데도 마치 즉시 완료되는 동기 함수들을 중첩하여 실행한 것처럼 동작하고 있다. 추가된 부분만 다시 자세히 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변경 전</span></span><br><span class="line">func.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변경 후</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args[i] &amp;&amp; args[i].name === <span class="string">'_async_cb_receiver'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> args[i](<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  func.apply(<span class="literal">null</span>, args);</span><br><span class="line">&#125;)(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>크게 보면 wait라는 유명 함수를 만들었고 내부에서 재귀를 돌다 func를 실행하도록 변경되었다. 재귀는 인자 중에 <code>_async_cb_receiver</code> 가 있다면 모두 결과값으로 치환될 때까지 돌게 된다.<br>add의 실행 결과는 숫자가 아닌 _async_cb_receiver라는 이름을 가진 함수다. 이 함수에 함수를 넣으면 결과를 받을 수 있다. 이를 이용하여 add의 실행 결과를 받은 sub는 자신의 본체(func) 로 가기 전에 wait로 _async_cb_receiver가 있는지 확인하고, 있다면 실행하여 결과값을 받고 재귀를 돌며 해당 번째 args[i]를 결과값으로 변경한다.</p><p>앞의 예제는 특정 지점에 함수를 정의하거나 함수로 감싸고, 함수를 즉시 실행하거나 재귀를 하는 식으로 기존 로직 사이에 선행 로직이나 후행 로직을 만들면서 프로그램의 순서를 제어할 수 있음을 보여준다. 위 예제에서는 이런 기법을 통해 비동기 상황을 제어하고, 다른 라이브러리들과의 연결 고리를 만드는 중요한 단위가 된다.</p><p>일반 괄호에서는 할 수 없는 일이지만 함수를 실행하는 괄호에서는 새로운 공간들을 레이어처럼 얼마든지 만들 수 있다. 앞의 예제 처럼 본체까지 가기 전 레이어들을 통과하면서 비동기 함수의 결과를 기다렸다가 결과값으로 변형해 넘겨줄 수도 있다. 함수를 실행하는 괄호에서 함수를 실행할 수 있고, 실행한 결과가 함수여서 그 함수를 다시 함수에게 인자로 넘길 수 있고, 그렇게 받은 함수를 실행할 수 있다.</p><p>자바스크립트에서 재귀는 충분히 실용적이라는 이야기를 했었다. 앞의 상황에서는 재귀를 통해 비동기 상황을 제어했다. 재귀는 로직들을 함수라는 단위로 일자로 나열하는 것이다. 비동기 제어의 핵심 역시 함수 실행의 나열이다. 비동기가 발생되면 스택이 초기화되므로 재귀에 대한 부담도 없다. 아무리 많은 재귀가 일어나도 ‘Maximum call stack size exceeded’ 에러는 절대로 발생하지 않는다.</p><p>참조: <a href="http://www.yes24.com/Product/Goods/56885507">함수형 자바스크립트 프로그래밍</a></p>]]></content:encoded>
      
      <comments>https://kkangil.github.io/2019/10/27/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0-2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
