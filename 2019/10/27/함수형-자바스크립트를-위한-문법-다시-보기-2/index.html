
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="kkangil&#39;s Blog">
    <title>함수형 자바스크립트를 위한 문법 다시 보기-2 - kkangil&#39;s Blog</title>
    <meta name="author" content="kkangil">
    <link rel="canonical" href="https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/"/>
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/rss2.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"kkangil","sameAs":["https://github.com/kkangil","http://stackoverflow.com/users/10870848/kkangil","https://www.linkedin.com/in/kangil-kim-31093a169/","fe.kkangil@gmail.com"],"image":"profile.jpeg"},"articleBody":"if else || &amp;&amp; 삼항 연산자 다시 보기if의 괄호if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.\n괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.if (expression) { statements } 중 statements 부분에는 비동기 코드를 활용할 여지가 있고 몇 가지 아이디어를 통해 어느정도 제어가 가능하지만 if의 괄호 부분은 비동기 코드와 거리가 좀 있다. 하지만 괄호 안에서 할 수 있는 일들은 많다. 새로운 객체를 생성할 수도 있고 객체의 key에 값을 할당할 수도 있으며 함수를 실행할 수도 있다. 먼저 에러가 발생하는 코드를 확인해보자.\n1if (var a = 0) console.log(a);\n위 코드는 문법 에러가 난다. 괄호에서는 표현식만 사용할 수 있기 때문이다. 아래 코드는 에러는 나지 않지만 쓸모없는 코드다.\n12if (function f1() &#123;&#125;) console.log(&apos;hi&apos;);f1();\nf1을 정의하는 곳에서는 에러가 나지 않았고 hi도 출력했지만 f1은 실행할 수 없다. f1이 값으로 다뤄져서 유명 함수로 선언되었기 때문이다. f1은 어디에서도 참조할 수 없어 위 코드는 사실상 에러가 나지 않지만 아무런 의미가 없는 코드다.\n12345678910var a;if (a = 5) console.log(a); // 1if (a = 0) console.log(1); // 2else console.log(a);if (!(a = false)) console.log(a); // 3if (a = 5 - 5); // 4else console.log(a)\n미리 선언된 변수에 값을 할당하는 것은 가능하다. 동시에 if의 괄호에는 a가 사용된다. 1에서는 if (5)인 셈이므로 5가 출력된다. 2에서는 if (0) 인 셈이므로 else로 넘어가게 된다. 3에서는 false를 담았고 !으로 반전하여 false가 결과로 나오도록 했다. 4에서는 a에 0이 담기고 else로 넘어간다.\n123456789var obj = &#123;&#125;;if (obj.a = 5) console.log(obj.a); // 1if (obj.b = false) console.log(obj.b); // 2else console.log(&apos;hi&apos;);var c;if (c = obj.c = true) console.log(c); // 3\n이번에는 if의 괄호 안에서 객체의 key에 값을 할당했다. obj에 값을 할당했고, if의 괄호에서는 obj가 아닌 할당한 값이 쓰인다. 2와 3을 통해 알 수 있다. c에는 obj가 아닌 true가 담긴다.\n12345678910function add(a, b) &#123;  return a + b;&#125;if (add(1, 2)) console.log(&apos;hi1&apos;);var a;if (a = add(1, 2)) console.log(a);if (function () &#123; return true; &#125;()) console.log(&apos;hi&apos;)\n함수를 실행할 수도 있고 실행한 결과를 변수에 담으면서 참과 거짓을 판단할 수도 있다. 익명 함수나 유명 함수를 정의하면서 즉시 실행할 수도 있다.\n위에서 확인한 모든 코드들은 자바스크립트의 대부분의 괄호에서 동일하게 동작한다. 이를테면 while문의 괄호에서도 동일하게 동작한다. 괄호 안에서 어떤 코드들을 돌릴 수 있는지 잘 알고 있다면 코드를 더 깔끔하게 정리하거나 코드 구조를 크게 변경하지 않고도 기능을 발전시킬 수 있다.\n|| &amp;&amp;1234567891011console.log(0 &amp;&amp; 1) // 0console.log(1 &amp;&amp; 0) // 0console.log([] || &#123;&#125;); // []console.log([] &amp;&amp; &#123;&#125;); // &#123;&#125;console.log([] &amp;&amp; &#123;&#125; || 0); // &#123;&#125;console.log(0 || 0 || 0 || 1 || null); // 1console.log(add(10, -10) || add(10, -10)); // 0console.log(add(10, -10) || add(10, 10)); //20var v;console.log((v = add(10, -10)) || v++ &amp;&amp; 20); // 0console.log((v = add(10, 10)) || ++v &amp;&amp; 20); // 20\n||과 &amp;&amp;의 활용법은 생각보다 다양하다. 오른쪽으로 더 갈 것인가 말 것인가를 한 줄로 만들어 if else를 대체할 수도 있다. 상황에 따라 if else가 가독성이나 효율이 좋을 수 있고 ||, &amp;&amp; 가 좋을 수도 있다. 다양한 도구를 상황에 맞게 잘 사용하면 된다.\n삼항 연산자삼항 연산자는 조건이 간단하고 실행 코드도 간단할 때 많이 사용된다. 보통 값을 담을 때 사용된다. 삼항 연산자를 이용해도 여러 줄을 코딩할 수 있다. 익명 함수, 유명 함수, 화살표 함수 등으로 즉시 실행 패턴을 사용하는 것이다.\n1234567var a = false;var c = a ? 10 : function f(arr, v) &#123;  return arr.length ? f(arr, v + arr.shift()) : v;&#125;([1, 2, 3], 0);console.log(c)\n위 코드에서는 a 가 false이므로 삼항 연산자에서 10을 건너뛰고 함수 부분이 실행된다. 함수 정의 끝부분을 보면 알 수 있듯이 즉시 실행했다. 그리고 [1,2,3]과 0을 인자로 받는다. 위와 같이 즉시 실행 함수를 이용하면 어디에서든 한 줄만 작성할 수 있던 곳을 확장할 수 있다. 또한 다른 함수를 실행할 수도 있고 재귀를 돌면서 얼마든지 복잡한 로직도 넣을 수 있다.\n함수 실행의 괄호함수 실행을 통해 생기는 새로운 공간이전에 가장 특별한 괄호는 함수를 실행하는 괄호라고 했었다. 함수를 실행하는 괄호와 그렇지 않은 다른 괄호의 차이는 무엇일까?\n12(5);(function () &#123; return 10; &#125;);\n위 코드의 괄호 두 가지는 모두 일반적인 괄호다. 함수를 실행하는 괄호가 아닌 일반 괄호에서는 코드가 실행되면 해당 지점에 즉시 값을 만들고 끝난다. 해당 지점에서 만들어진 값을 참조할 수는 있지만 여기서 할 일은 바로 모두 끝난다.\n1234567891011var add5 = function (a) &#123; // 새로운 공간  return a + 5;&#125;var call = function (f) &#123; // 새로운 공간  return f();&#125;// 함수를 실행하는 괄호add(5);call(function () &#123; return 10; &#125;);\n함수를 실행하는 괄호는 일반 괄호와 특성이 모두 같지만 한 가지 특성을 더 가지고 있다. 이 괄호를 통해 새로운 실행 컨텍스트가 열린다는 점이다. 이 점은 매우 중요하다. 함수를 실행하는 괄호에서는 코드가 실행되었을 때 해당 지점에 값을 만든 후 끝나지 않고, 이 값이 실행된 함수의 공간으로 넘어간다. 새롭게 열린 공간이 끝나기 전까지는 이전 공간의 상황들도 끝나지 않는다. 이 공간들을 실행 컨텍스트라고 한다.\n새로운 공간이 생긴다는것, 콜 스택에 쌓인다는 것, 태스크 큐와 이벤트 루프에 의해 제어된다는 것, 이것들을 통해 개발자가 시작과 끝을 제어할 수 있다는 점들이 함수를 실행하는 괄호가 가진 가장 특별한 차이다.\n함수가 정의되거나 실행되는 지점에서는 클로저도 만들어질 수 있고, 비동기 상황이 생길 수도 있으며 서로 다른 컨택스트가 연결되는 등의 특별한 일들이 생긴다. 이것들은 함수에 대한 매우 실제적이고 중요한 개념이다.for문을 사용할 때 어떤 지점들을 확인하면서 코드 블록을 반복시키는지, 언제 어떻게 끝나는지 정확히 이해하지 않고는 코딩할 수 없듯이 함수도 마찬가지다.\n기본적인 비동기 상황123456789console.log(1);setTimeout(function () &#123;  console.log(3)&#125;, 1000);console.log(2);// 1// 2// 3 (1초 뒤)\n코드 라인 순서와 달리 1, 2, 3 으로 실행 되었다. \n123456789var add = function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a + b);  &#125;, 1000);&#125;add(10, 5, function (r) &#123;  console.log(r);&#125;)\n비동기 상황이 생기는 함수의 결과는 return 문으로 반환할 수 없다. 비동기 상황이 생기는 함수의 결과를 받는 방법 중 하나는 콜백 함수를 넘겨서 돌려받는 방법이다. add의 마지막 인자로 넘겨진 익명 함수 callback은 add 안에서 모든 상황이 끝날 때 실행된다. 이를 통해 add를 실행한 스코프 내부에서 다시 add의 결과를 받을 수 있게 된다.일반 괄호였다면 10, 5, function등이 그 자리에 정의되고 끝났겠지만 함수를 실행하는 괄호에서는 그 값들이 다른 공간으로 넘어간다. 새롭게 열린 공간에서는 넘겨받은 재료들로 새로우 일을 할 수 있다.\n함수 실행 괄호의 마법과 비동기비동기 상황을 제어하는 방법은 함수 실행을 일렬로 나열하는 것이다.\nadd 함수 실행 -&gt; setTimeout 함수 실행 -&gt; setTimeout이 1초 뒤 익명 함수를 실행 -&gt; 받아 둔 callback 실행\n위와 같이 함수들의 실행을 일렬로 나열하여 한 가지 일이 순서대로 일어나도록 하는 것이다.이 함수 나열을 숨겨서 비동기 코드가 동기식으로 실행되는 것처럼 보이도록 해볼 것이다. Promise하고 비슷할 것이다. 이 작업을 통해 함수 실행의 괄호에서 다른 공간으로 이동되는 사이에 할 수 있는 일을 확인할 것이다. 이런 기법들을 통해 프로미스의 내부 코드를 예상해 볼 수도 있을 것이다.\n12345678910111213141516171819202122232425var add = function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a + b);  &#125;, 1000);&#125;var sub = function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a - b);  &#125;, 1000);&#125;var div = function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a / b);  &#125;, 1000);&#125;add(10, 15, function (a) &#123;  sub(a, 5, function (a) &#123;    div(a, 10, function (r) &#123;      console.log(r); // 약 3초 후에 2가 찍힘    &#125;)  &#125;)&#125;)\n원래 비동기가 일어나는 함수들은 아래처럼 중첩 실행을 할 수 없다. 함수의 몇 가지 특성을 활용해 비동기 함수도 아래처럼 중첩 실행이 가능하도록 해보자.\n12console.log(div(sub(add(10, 15), 5), 10));// undefined가 찍히고 callback이 없다는 에러가 남.\n우선 함수가 실행되는 사이에 무언가를 할 수 있도록 함수로 한 번 감싸서 공간을 만들 것이다. wrap에게 함수를 전달하여 함수를 리턴 받으면 원래 기능을 유지하면서 코드 사이에 공간이 생긴다.\n12345678910111213141516function wrap(func) &#123; // 1. 함수 받기  return function () &#123; // 2. 함수 리턴하기, 이것이 실행됨.    // 여기에 새로운 공간이 생김, 나중에 함수를 실행했을 때 이 부분을 거쳐감    return func.apply(arguments); // 3  &#125;&#125;var add = wrap(function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a + b);  &#125;, 1000);&#125;);add(5, 10, function (r) &#123;  console.log(r);&#125;)\n1에서 받은 함수를 기억하는 2 클로저를 만들어 리턴했고, add는 2가 된다. 나중에 2가 실행되면 1에서 받아 둔 3 함수를 실행하면서 2가 받은 모든 인자를 넘겨준다. 이전 add와 완전히 동일하게 동작하면서도 사이사이에 코드를 끼워 넣을 수 있는 공간들이 더 생겼다. wrap을 조금만 더 고치고 _async 라고 이름을 바꿔보자.\n1234567891011121314151617181920212223242526function _async(func) &#123;  return function () &#123;    arguments[arguments.length++] = function (result) &#123; // 1      _callback(result) // 6    &#125;;    func.apply(null, arguments); // 2    var _callback; // 3    function _async_cb_receiver(callback) &#123; // 4      _callback = callback; // 5    &#125;    return _async_cb_receiver;  &#125;&#125;var add = _async(function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a + b);  &#125;, 1000);&#125;);add(20, 30)(function (r) &#123; // 7  console.log(r);&#125;)\n우선 마지막 부분 7을 보면 add를 실행하는 방법이 바뀌었다. 한 번에 인자 3개를 넘기지 않고 마치 커링처럼 add에 필요한 재료를 넘긴 후 한 번 더 실행하면서 callback 함수를 넘기고 있다.\n\nadd가 실행되면 인자로 20과 30이 넘어온다. 원래는 callback 함수를 받아야 하므로 arguments에 마지막 값으로 함수를 추가한다. 그리고 그 함수는 나중에 개발자가 넘겨준 callback 함수를 실행할 수 있게 준비해 두었다.\nadd를 정의할 때 받아 둔 func를 실행하면서 인자 3개를 넘긴다.\n_callback 이라는 지역 변수를 만들어서 1과 4가 기억해 두도록 했다. 클로저를 활용하여 서로 다른 컨텍스트가 협업할 수 있도록 이어주었다.\n_async_cb_receiver라는 이름을 가진 유명 함수이자 클로저를 만들어 리턴한다.\n_async_cb_receiver가 실행될 때 받은 함수 callback을 _callback에 할당한다.\n1초가 지나면 1이 실행될 것이고 add가 callback을 통해 넘긴 결과인 result를 받아 두었던 _callback을 실행하면서 다시 넘겨주고 있다.\n이 익명 함수가 _callback 이므로 6에서 넘겨진 r을 받게 되고 로그를 남겼다.\n\n1234567891011121314151617181920212223242526var add = _async(function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a + b);  &#125;, 1000);&#125;);var sub = _async(function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a - b);  &#125;, 1000);&#125;);var div = _async(function (a, b, callback) &#123;  setTimeout(function () &#123;    callback(a / b);  &#125;, 1000);&#125;);add(10, 15)(function (a) &#123;  sub(a, 5)(function (a) &#123;    div(a, 10)(function (r) &#123;      console.log(r);      // 약 3초 후 2가 찍힘    &#125;)  &#125;)&#125;)\n비동기와 재귀일반 콜백 패턴의 함수를 실행하는 것과 아직 큰 차이는 없지만 연산에 필요한 실행과 결과를 받기 위한 실행이 분리되었다. 함수를 실행하는 괄호에서는 값을 다른 공간으로 넘겨 새로운 일들을 더 할 수 있다. add, sub, div는 async를 통해 본체에 가기 전 새로운 공간을 가지고 있고, 그 공간에서는 시작과 끝을 제어하고 있다. 이 내부 공간을 손보면 좀 더 재밌는 일을 할 수 있다.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function _async(func) &#123;  return function () &#123;    arguments[arguments.length++] = function (result) &#123;      _callback(result)    &#125;;    // 변경된 부분    (function wait(args) &#123;      // 새로운 공간 추가      for (var i = 0; i &lt; args.length; i++) &#123;        if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;          return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);        &#125;      &#125;      func.apply(null, args);    &#125;)(arguments);    var _callback;    function _async_cb_receiver(callback) &#123;      _callback = callback;    &#125;    return _async_cb_receiver;  &#125;&#125;var add = _async(function (a, b, callback) &#123;  setTimeout(function () &#123;    console.log(&apos;add&apos;, a, b);    callback(a + b);  &#125;, 1000);&#125;);var sub = _async(function (a, b, callback) &#123;  setTimeout(function () &#123;    console.log(&apos;sub&apos;, a, b);    callback(a - b);  &#125;, 1000);&#125;);var div = _async(function (a, b, callback) &#123;  setTimeout(function () &#123;    console.log(&apos;div&apos;, a, b);    callback(a / b);  &#125;, 1000);&#125;);var log = _async(function (val) &#123;  setTimeout(function () &#123;    console.log(val);  &#125;, 1000)&#125;)log(div(sub(add(10, 15), 5), 10));// 약 4초 뒤 2log(add(add(10, 10), sub(10, 5)));// 약 3초 뒤 25\n모두 비동기 함수들 인데도 마치 즉시 완료되는 동기 함수들을 중첩하여 실행한 것처럼 동작하고 있다. 추가된 부분만 다시 자세히 살펴보자.\n123456789101112// 변경 전func.apply(null, args);// 변경 후(function wait(args) &#123;  for (var i = 0; i &lt; args.length; i++) &#123;    if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;      return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);    &#125;  &#125;  func.apply(null, args);&#125;)(arguments);\n크게 보면 wait라는 유명 함수를 만들었고 내부에서 재귀를 돌다 func를 실행하도록 변경되었다. 재귀는 인자 중에 _async_cb_receiver 가 있다면 모두 결과값으로 치환될 때까지 돌게 된다.add의 실행 결과는 숫자가 아닌 _async_cb_receiver라는 이름을 가진 함수다. 이 함수에 함수를 넣으면 결과를 받을 수 있다. 이를 이용하여 add의 실행 결과를 받은 sub는 자신의 본체(func) 로 가기 전에 wait로 _async_cb_receiver가 있는지 확인하고, 있다면 실행하여 결과값을 받고 재귀를 돌며 해당 번째 args[i]를 결과값으로 변경한다.\n앞의 예제는 특정 지점에 함수를 정의하거나 함수로 감싸고, 함수를 즉시 실행하거나 재귀를 하는 식으로 기존 로직 사이에 선행 로직이나 후행 로직을 만들면서 프로그램의 순서를 제어할 수 있음을 보여준다. 위 예제에서는 이런 기법을 통해 비동기 상황을 제어하고, 다른 라이브러리들과의 연결 고리를 만드는 중요한 단위가 된다.\n일반 괄호에서는 할 수 없는 일이지만 함수를 실행하는 괄호에서는 새로운 공간들을 레이어처럼 얼마든지 만들 수 있다. 앞의 예제 처럼 본체까지 가기 전 레이어들을 통과하면서 비동기 함수의 결과를 기다렸다가 결과값으로 변형해 넘겨줄 수도 있다. 함수를 실행하는 괄호에서 함수를 실행할 수 있고, 실행한 결과가 함수여서 그 함수를 다시 함수에게 인자로 넘길 수 있고, 그렇게 받은 함수를 실행할 수 있다.\n자바스크립트에서 재귀는 충분히 실용적이라는 이야기를 했었다. 앞의 상황에서는 재귀를 통해 비동기 상황을 제어했다. 재귀는 로직들을 함수라는 단위로 일자로 나열하는 것이다. 비동기 제어의 핵심 역시 함수 실행의 나열이다. 비동기가 발생되면 스택이 초기화되므로 재귀에 대한 부담도 없다. 아무리 많은 재귀가 일어나도 ‘Maximum call stack size exceeded’ 에러는 절대로 발생하지 않는다.\n참조: 함수형 자바스크립트 프로그래밍\n","dateCreated":"2019-10-27T14:33:33+09:00","dateModified":"2019-12-01T18:41:28+09:00","datePublished":"2019-10-27T14:33:33+09:00","description":"if else || &amp;&amp; 삼항 연산자 다시 보기if의 괄호if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.\n괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.","headline":"함수형 자바스크립트를 위한 문법 다시 보기-2","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/"},"publisher":{"@type":"Organization","name":"kkangil","sameAs":["https://github.com/kkangil","http://stackoverflow.com/users/10870848/kkangil","https://www.linkedin.com/in/kangil-kim-31093a169/","fe.kkangil@gmail.com"],"image":"profile.jpeg","logo":{"@type":"ImageObject","url":"profile.jpeg"}},"url":"https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/","keywords":"javascript, 함수형 프로그래밍"}</script>
    <meta name="description" content="if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기if의 괄호if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데">
<meta name="keywords" content="javascript,함수형 프로그래밍">
<meta property="og:type" content="blog">
<meta property="og:title" content="함수형 자바스크립트를 위한 문법 다시 보기-2">
<meta property="og:url" content="https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/index.html">
<meta property="og:site_name" content="kkangil&#39;s Blog">
<meta property="og:description" content="if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기if의 괄호if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2019-12-01T09:41:28.905Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="함수형 자바스크립트를 위한 문법 다시 보기-2">
<meta name="twitter:description" content="if else || &amp;amp;&amp;amp; 삼항 연산자 다시 보기if의 괄호if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데">
    
    
        
    
    
        <meta property="og:image" content="https://kkangil.github.io/assets/images/profile.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">kkangil&#39;s Blog</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/profile.jpeg" alt="Author&#39;s picture">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpeg" alt="Author&#39;s picture">
                </a>
                <h4 class="sidebar-profile-name">kkangil</h4>
                
                    <h5 class="sidebar-profile-bio"><p>React와 Node를 사용하는 풀스택 개발자가 되는것이 목표입니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="Home">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="카테고리">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="태그">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="기록">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">기록</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="#search" title="검색">
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="About">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/kkangil" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="http://stackoverflow.com/users/10870848/kkangil" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://www.linkedin.com/in/kangil-kim-31093a169/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/fe.kkangil@gmail.com" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            함수형 자바스크립트를 위한 문법 다시 보기-2
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-10-27T14:33:33+09:00">
	
		    10월 27, 2019
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/함수형-프로그래밍/">함수형 프로그래밍</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="if-else-amp-amp-삼항-연산자-다시-보기"><a href="#if-else-amp-amp-삼항-연산자-다시-보기" class="headerlink" title="if else || &amp;&amp; 삼항 연산자 다시 보기"></a>if else || &amp;&amp; 삼항 연산자 다시 보기</h2><h3 id="if의-괄호"><a href="#if의-괄호" class="headerlink" title="if의 괄호"></a>if의 괄호</h3><p>if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다.</p>
<p>괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.<br><a id="more"></a><br>if (expression) { statements } 중 statements 부분에는 비동기 코드를 활용할 여지가 있고 몇 가지 아이디어를 통해 어느정도 제어가 가능하지만 if의 괄호 부분은 비동기 코드와 거리가 좀 있다. 하지만 괄호 안에서 할 수 있는 일들은 많다. 새로운 객체를 생성할 수도 있고 객체의 key에 값을 할당할 수도 있으며 함수를 실행할 수도 있다. 먼저 에러가 발생하는 코드를 확인해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (var a = 0) console.log(a);</span><br></pre></td></tr></table></figure>
<p>위 코드는 문법 에러가 난다. 괄호에서는 표현식만 사용할 수 있기 때문이다. 아래 코드는 에러는 나지 않지만 쓸모없는 코드다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (function f1() &#123;&#125;) console.log(&apos;hi&apos;);</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure>
<p>f1을 정의하는 곳에서는 에러가 나지 않았고 hi도 출력했지만 f1은 실행할 수 없다. f1이 값으로 다뤄져서 유명 함수로 선언되었기 때문이다. f1은 어디에서도 참조할 수 없어 위 코드는 사실상 에러가 나지 않지만 아무런 의미가 없는 코드다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">if (a = 5) console.log(a); // 1</span><br><span class="line"></span><br><span class="line">if (a = 0) console.log(1); // 2</span><br><span class="line">else console.log(a);</span><br><span class="line"></span><br><span class="line">if (!(a = false)) console.log(a); // 3</span><br><span class="line"></span><br><span class="line">if (a = 5 - 5); // 4</span><br><span class="line">else console.log(a)</span><br></pre></td></tr></table></figure>
<p>미리 선언된 변수에 값을 할당하는 것은 가능하다. 동시에 if의 괄호에는 a가 사용된다. 1에서는 if (5)인 셈이므로 5가 출력된다. 2에서는 if (0) 인 셈이므로 else로 넘어가게 된다. 3에서는 false를 담았고 !으로 반전하여 false가 결과로 나오도록 했다. 4에서는 a에 0이 담기고 else로 넘어간다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">if (obj.a = 5) console.log(obj.a); // 1</span><br><span class="line"></span><br><span class="line">if (obj.b = false) console.log(obj.b); // 2</span><br><span class="line">else console.log(&apos;hi&apos;);</span><br><span class="line"></span><br><span class="line">var c;</span><br><span class="line">if (c = obj.c = true) console.log(c); // 3</span><br></pre></td></tr></table></figure>
<p>이번에는 if의 괄호 안에서 객체의 key에 값을 할당했다. obj에 값을 할당했고, if의 괄호에서는 obj가 아닌 할당한 값이 쓰인다. 2와 3을 통해 알 수 있다. c에는 obj가 아닌 true가 담긴다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (add(1, 2)) console.log(&apos;hi1&apos;);</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line">if (a = add(1, 2)) console.log(a);</span><br><span class="line"></span><br><span class="line">if (function () &#123; return true; &#125;()) console.log(&apos;hi&apos;)</span><br></pre></td></tr></table></figure>
<p>함수를 실행할 수도 있고 실행한 결과를 변수에 담으면서 참과 거짓을 판단할 수도 있다. 익명 함수나 유명 함수를 정의하면서 즉시 실행할 수도 있다.</p>
<p>위에서 확인한 모든 코드들은 자바스크립트의 대부분의 괄호에서 동일하게 동작한다. 이를테면 while문의 괄호에서도 동일하게 동작한다. 괄호 안에서 어떤 코드들을 돌릴 수 있는지 잘 알고 있다면 코드를 더 깔끔하게 정리하거나 코드 구조를 크게 변경하지 않고도 기능을 발전시킬 수 있다.</p>
<h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="|| &amp;&amp;"></a>|| &amp;&amp;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(0 &amp;&amp; 1) // 0</span><br><span class="line">console.log(1 &amp;&amp; 0) // 0</span><br><span class="line">console.log([] || &#123;&#125;); // []</span><br><span class="line">console.log([] &amp;&amp; &#123;&#125;); // &#123;&#125;</span><br><span class="line">console.log([] &amp;&amp; &#123;&#125; || 0); // &#123;&#125;</span><br><span class="line">console.log(0 || 0 || 0 || 1 || null); // 1</span><br><span class="line">console.log(add(10, -10) || add(10, -10)); // 0</span><br><span class="line">console.log(add(10, -10) || add(10, 10)); //20</span><br><span class="line">var v;</span><br><span class="line">console.log((v = add(10, -10)) || v++ &amp;&amp; 20); // 0</span><br><span class="line">console.log((v = add(10, 10)) || ++v &amp;&amp; 20); // 20</span><br></pre></td></tr></table></figure>
<p>||과 &amp;&amp;의 활용법은 생각보다 다양하다. 오른쪽으로 더 갈 것인가 말 것인가를 한 줄로 만들어 if else를 대체할 수도 있다. 상황에 따라 if else가 가독성이나 효율이 좋을 수 있고 ||, &amp;&amp; 가 좋을 수도 있다. 다양한 도구를 상황에 맞게 잘 사용하면 된다.</p>
<h3 id="삼항-연산자"><a href="#삼항-연산자" class="headerlink" title="삼항 연산자"></a>삼항 연산자</h3><p>삼항 연산자는 조건이 간단하고 실행 코드도 간단할 때 많이 사용된다. 보통 값을 담을 때 사용된다. 삼항 연산자를 이용해도 여러 줄을 코딩할 수 있다. 익명 함수, 유명 함수, 화살표 함수 등으로 즉시 실행 패턴을 사용하는 것이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = false;</span><br><span class="line"></span><br><span class="line">var c = a ? 10 : function f(arr, v) &#123;</span><br><span class="line">  return arr.length ? f(arr, v + arr.shift()) : v;</span><br><span class="line">&#125;([1, 2, 3], 0);</span><br><span class="line"></span><br><span class="line">console.log(c)</span><br></pre></td></tr></table></figure>
<p>위 코드에서는 a 가 false이므로 삼항 연산자에서 10을 건너뛰고 함수 부분이 실행된다. 함수 정의 끝부분을 보면 알 수 있듯이 즉시 실행했다. 그리고 [1,2,3]과 0을 인자로 받는다. 위와 같이 즉시 실행 함수를 이용하면 어디에서든 한 줄만 작성할 수 있던 곳을 확장할 수 있다. 또한 다른 함수를 실행할 수도 있고 재귀를 돌면서 얼마든지 복잡한 로직도 넣을 수 있다.</p>
<h2 id="함수-실행의-괄호"><a href="#함수-실행의-괄호" class="headerlink" title="함수 실행의 괄호"></a>함수 실행의 괄호</h2><h3 id="함수-실행을-통해-생기는-새로운-공간"><a href="#함수-실행을-통해-생기는-새로운-공간" class="headerlink" title="함수 실행을 통해 생기는 새로운 공간"></a>함수 실행을 통해 생기는 새로운 공간</h3><p>이전에 가장 특별한 괄호는 함수를 실행하는 괄호라고 했었다. 함수를 실행하는 괄호와 그렇지 않은 다른 괄호의 차이는 무엇일까?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5);</span><br><span class="line">(function () &#123; return 10; &#125;);</span><br></pre></td></tr></table></figure>
<p>위 코드의 괄호 두 가지는 모두 일반적인 괄호다. 함수를 실행하는 괄호가 아닌 일반 괄호에서는 코드가 실행되면 해당 지점에 즉시 값을 만들고 끝난다. 해당 지점에서 만들어진 값을 참조할 수는 있지만 여기서 할 일은 바로 모두 끝난다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var add5 = function (a) &#123; // 새로운 공간</span><br><span class="line">  return a + 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var call = function (f) &#123; // 새로운 공간</span><br><span class="line">  return f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 함수를 실행하는 괄호</span><br><span class="line">add(5);</span><br><span class="line">call(function () &#123; return 10; &#125;);</span><br></pre></td></tr></table></figure>
<p>함수를 실행하는 괄호는 일반 괄호와 특성이 모두 같지만 한 가지 특성을 더 가지고 있다. 이 괄호를 통해 새로운 <code>실행 컨텍스트</code>가 열린다는 점이다. 이 점은 매우 중요하다. 함수를 실행하는 괄호에서는 코드가 실행되었을 때 해당 지점에 값을 만든 후 끝나지 않고, 이 값이 실행된 함수의 공간으로 넘어간다. 새롭게 열린 공간이 끝나기 전까지는 이전 공간의 상황들도 끝나지 않는다. 이 공간들을 실행 컨텍스트라고 한다.</p>
<p>새로운 공간이 생긴다는것, 콜 스택에 쌓인다는 것, 태스크 큐와 이벤트 루프에 의해 제어된다는 것, 이것들을 통해 개발자가 시작과 끝을 제어할 수 있다는 점들이 함수를 실행하는 괄호가 가진 가장 특별한 차이다.</p>
<p>함수가 정의되거나 실행되는 지점에서는 클로저도 만들어질 수 있고, 비동기 상황이 생길 수도 있으며 서로 다른 컨택스트가 연결되는 등의 특별한 일들이 생긴다. 이것들은 함수에 대한 매우 실제적이고 중요한 개념이다.<br>for문을 사용할 때 어떤 지점들을 확인하면서 코드 블록을 반복시키는지, 언제 어떻게 끝나는지 정확히 이해하지 않고는 코딩할 수 없듯이 함수도 마찬가지다.</p>
<h3 id="기본적인-비동기-상황"><a href="#기본적인-비동기-상황" class="headerlink" title="기본적인 비동기 상황"></a>기본적인 비동기 상황</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3 (1초 뒤)</span><br></pre></td></tr></table></figure>
<p>코드 라인 순서와 달리 1, 2, 3 으로 실행 되었다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var add = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(10, 5, function (r) &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>비동기 상황이 생기는 함수의 결과는 return 문으로 반환할 수 없다. 비동기 상황이 생기는 함수의 결과를 받는 방법 중 하나는 콜백 함수를 넘겨서 돌려받는 방법이다. add의 마지막 인자로 넘겨진 익명 함수 callback은 add 안에서 모든 상황이 끝날 때 실행된다. 이를 통해 add를 실행한 스코프 내부에서 다시 add의 결과를 받을 수 있게 된다.<br>일반 괄호였다면 10, 5, function등이 그 자리에 정의되고 끝났겠지만 함수를 실행하는 괄호에서는 그 값들이 다른 공간으로 넘어간다. 새롭게 열린 공간에서는 넘겨받은 재료들로 새로우 일을 할 수 있다.</p>
<h3 id="함수-실행-괄호의-마법과-비동기"><a href="#함수-실행-괄호의-마법과-비동기" class="headerlink" title="함수 실행 괄호의 마법과 비동기"></a>함수 실행 괄호의 마법과 비동기</h3><p>비동기 상황을 제어하는 방법은 함수 실행을 일렬로 나열하는 것이다.</p>
<p>add 함수 실행 -&gt; setTimeout 함수 실행 -&gt; setTimeout이 1초 뒤 익명 함수를 실행 -&gt; 받아 둔 callback 실행</p>
<p>위와 같이 함수들의 실행을 일렬로 나열하여 한 가지 일이 순서대로 일어나도록 하는 것이다.<br>이 함수 나열을 숨겨서 비동기 코드가 동기식으로 실행되는 것처럼 보이도록 해볼 것이다. Promise하고 비슷할 것이다. 이 작업을 통해 함수 실행의 괄호에서 다른 공간으로 이동되는 사이에 할 수 있는 일을 확인할 것이다. 이런 기법들을 통해 프로미스의 내부 코드를 예상해 볼 수도 있을 것이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var add = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sub = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div = function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(10, 15, function (a) &#123;</span><br><span class="line">  sub(a, 5, function (a) &#123;</span><br><span class="line">    div(a, 10, function (r) &#123;</span><br><span class="line">      console.log(r); // 약 3초 후에 2가 찍힘</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>원래 비동기가 일어나는 함수들은 아래처럼 중첩 실행을 할 수 없다. 함수의 몇 가지 특성을 활용해 비동기 함수도 아래처럼 중첩 실행이 가능하도록 해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(div(sub(add(10, 15), 5), 10));</span><br><span class="line">// undefined가 찍히고 callback이 없다는 에러가 남.</span><br></pre></td></tr></table></figure>
<p>우선 함수가 실행되는 사이에 무언가를 할 수 있도록 함수로 한 번 감싸서 공간을 만들 것이다. wrap에게 함수를 전달하여 함수를 리턴 받으면 원래 기능을 유지하면서 코드 사이에 공간이 생긴다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function wrap(func) &#123; // 1. 함수 받기</span><br><span class="line">  return function () &#123; // 2. 함수 리턴하기, 이것이 실행됨.</span><br><span class="line">    // 여기에 새로운 공간이 생김, 나중에 함수를 실행했을 때 이 부분을 거쳐감</span><br><span class="line">    return func.apply(arguments); // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = wrap(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(5, 10, function (r) &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>1에서 받은 함수를 기억하는 2 클로저를 만들어 리턴했고, add는 2가 된다. 나중에 2가 실행되면 1에서 받아 둔 3 함수를 실행하면서 2가 받은 모든 인자를 넘겨준다. 이전 add와 완전히 동일하게 동작하면서도 사이사이에 코드를 끼워 넣을 수 있는 공간들이 더 생겼다. wrap을 조금만 더 고치고 _async 라고 이름을 바꿔보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function _async(func) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    arguments[arguments.length++] = function (result) &#123; // 1</span><br><span class="line">      _callback(result) // 6</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    func.apply(null, arguments); // 2</span><br><span class="line"></span><br><span class="line">    var _callback; // 3</span><br><span class="line">    function _async_cb_receiver(callback) &#123; // 4</span><br><span class="line">      _callback = callback; // 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(20, 30)(function (r) &#123; // 7</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>우선 마지막 부분 7을 보면 add를 실행하는 방법이 바뀌었다. 한 번에 인자 3개를 넘기지 않고 마치 커링처럼 add에 필요한 재료를 넘긴 후 한 번 더 실행하면서 callback 함수를 넘기고 있다.</p>
<ol>
<li>add가 실행되면 인자로 20과 30이 넘어온다. 원래는 callback 함수를 받아야 하므로 arguments에 마지막 값으로 함수를 추가한다. 그리고 그 함수는 나중에 개발자가 넘겨준 callback 함수를 실행할 수 있게 준비해 두었다.</li>
<li>add를 정의할 때 받아 둔 func를 실행하면서 인자 3개를 넘긴다.</li>
<li>_callback 이라는 지역 변수를 만들어서 1과 4가 기억해 두도록 했다. 클로저를 활용하여 서로 다른 컨텍스트가 협업할 수 있도록 이어주었다.</li>
<li>_async_cb_receiver라는 이름을 가진 유명 함수이자 클로저를 만들어 리턴한다.</li>
<li>_async_cb_receiver가 실행될 때 받은 함수 callback을 _callback에 할당한다.</li>
<li>1초가 지나면 1이 실행될 것이고 add가 callback을 통해 넘긴 결과인 result를 받아 두었던 _callback을 실행하면서 다시 넘겨주고 있다.</li>
<li>이 익명 함수가 _callback 이므로 6에서 넘겨진 r을 받게 되고 로그를 남겼다.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var div = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(10, 15)(function (a) &#123;</span><br><span class="line">  sub(a, 5)(function (a) &#123;</span><br><span class="line">    div(a, 10)(function (r) &#123;</span><br><span class="line">      console.log(r);</span><br><span class="line">      // 약 3초 후 2가 찍힘</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="비동기와-재귀"><a href="#비동기와-재귀" class="headerlink" title="비동기와 재귀"></a>비동기와 재귀</h3><p>일반 콜백 패턴의 함수를 실행하는 것과 아직 큰 차이는 없지만 연산에 필요한 실행과 결과를 받기 위한 실행이 분리되었다. 함수를 실행하는 괄호에서는 값을 다른 공간으로 넘겨 새로운 일들을 더 할 수 있다. add, sub, div는 async를 통해 본체에 가기 전 새로운 공간을 가지고 있고, 그 공간에서는 시작과 끝을 제어하고 있다. 이 내부 공간을 손보면 좀 더 재밌는 일을 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function _async(func) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    arguments[arguments.length++] = function (result) &#123;</span><br><span class="line">      _callback(result)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 변경된 부분</span><br><span class="line">    (function wait(args) &#123;</span><br><span class="line">      // 새로운 공간 추가</span><br><span class="line">      for (var i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;</span><br><span class="line">          return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      func.apply(null, args);</span><br><span class="line">    &#125;)(arguments);</span><br><span class="line"></span><br><span class="line">    var _callback;</span><br><span class="line">    function _async_cb_receiver(callback) &#123;</span><br><span class="line">      _callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _async_cb_receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;add&apos;, a, b);</span><br><span class="line">    callback(a + b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sub = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;sub&apos;, a, b);</span><br><span class="line">    callback(a - b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var div = _async(function (a, b, callback) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;div&apos;, a, b);</span><br><span class="line">    callback(a / b);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var log = _async(function (val) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log(div(sub(add(10, 15), 5), 10));</span><br><span class="line">// 약 4초 뒤 2</span><br><span class="line">log(add(add(10, 10), sub(10, 5)));</span><br><span class="line">// 약 3초 뒤 25</span><br></pre></td></tr></table></figure>
<p>모두 비동기 함수들 인데도 마치 즉시 완료되는 동기 함수들을 중첩하여 실행한 것처럼 동작하고 있다. 추가된 부분만 다시 자세히 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 변경 전</span><br><span class="line">func.apply(null, args);</span><br><span class="line"></span><br><span class="line">// 변경 후</span><br><span class="line">(function wait(args) &#123;</span><br><span class="line">  for (var i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">    if (args[i] &amp;&amp; args[i].name === &apos;_async_cb_receiver&apos;) &#123;</span><br><span class="line">      return args[i](function (arg) &#123; args[i] = arg; wait(args) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  func.apply(null, args);</span><br><span class="line">&#125;)(arguments);</span><br></pre></td></tr></table></figure>
<p>크게 보면 wait라는 유명 함수를 만들었고 내부에서 재귀를 돌다 func를 실행하도록 변경되었다. 재귀는 인자 중에 <code>_async_cb_receiver</code> 가 있다면 모두 결과값으로 치환될 때까지 돌게 된다.<br>add의 실행 결과는 숫자가 아닌 _async_cb_receiver라는 이름을 가진 함수다. 이 함수에 함수를 넣으면 결과를 받을 수 있다. 이를 이용하여 add의 실행 결과를 받은 sub는 자신의 본체(func) 로 가기 전에 wait로 _async_cb_receiver가 있는지 확인하고, 있다면 실행하여 결과값을 받고 재귀를 돌며 해당 번째 args[i]를 결과값으로 변경한다.</p>
<p>앞의 예제는 특정 지점에 함수를 정의하거나 함수로 감싸고, 함수를 즉시 실행하거나 재귀를 하는 식으로 기존 로직 사이에 선행 로직이나 후행 로직을 만들면서 프로그램의 순서를 제어할 수 있음을 보여준다. 위 예제에서는 이런 기법을 통해 비동기 상황을 제어하고, 다른 라이브러리들과의 연결 고리를 만드는 중요한 단위가 된다.</p>
<p>일반 괄호에서는 할 수 없는 일이지만 함수를 실행하는 괄호에서는 새로운 공간들을 레이어처럼 얼마든지 만들 수 있다. 앞의 예제 처럼 본체까지 가기 전 레이어들을 통과하면서 비동기 함수의 결과를 기다렸다가 결과값으로 변형해 넘겨줄 수도 있다. 함수를 실행하는 괄호에서 함수를 실행할 수 있고, 실행한 결과가 함수여서 그 함수를 다시 함수에게 인자로 넘길 수 있고, 그렇게 받은 함수를 실행할 수 있다.</p>
<p>자바스크립트에서 재귀는 충분히 실용적이라는 이야기를 했었다. 앞의 상황에서는 재귀를 통해 비동기 상황을 제어했다. 재귀는 로직들을 함수라는 단위로 일자로 나열하는 것이다. 비동기 제어의 핵심 역시 함수 실행의 나열이다. 비동기가 발생되면 스택이 초기화되므로 재귀에 대한 부담도 없다. 아무리 많은 재귀가 일어나도 ‘Maximum call stack size exceeded’ 에러는 절대로 발생하지 않는다.</p>
<p>참조: <a href="http://www.yes24.com/Product/Goods/56885507" target="_blank" rel="noopener">함수형 자바스크립트 프로그래밍</a></p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/javascript/">javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/함수형-프로그래밍/">함수형 프로그래밍</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/11/17/함수-조립하기/" data-tooltip="함수 조립하기" aria-label="이전: 함수 조립하기">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/10/20/함수형-자바스크립트를-위한-문법-다시-보기/" data-tooltip="함수형 자바스크립트를 위한 문법 다시 보기" aria-label="다음: 함수형 자바스크립트를 위한 문법 다시 보기">
                
                    <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="글 공유">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/" title="Facebook 공유">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/" title="Twitter 공유">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/" title="Google+ 공유">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="상단 이동">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 kkangil. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/11/17/함수-조립하기/" data-tooltip="함수 조립하기" aria-label="이전: 함수 조립하기">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/10/20/함수형-자바스크립트를-위한-문법-다시-보기/" data-tooltip="함수형 자바스크립트를 위한 문법 다시 보기" aria-label="다음: 함수형 자바스크립트를 위한 문법 다시 보기">
                
                    <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="글 공유">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/" title="Facebook 공유">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/" title="Twitter 공유">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/" title="Google+ 공유">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="상단 이동">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook 공유</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter 공유</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https://kkangil.github.io/2019/10/27/함수형-자바스크립트를-위한-문법-다시-보기-2/">
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+ 공유</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpeg" alt="Author&#39;s picture">
        
            <h4 id="about-card-name">kkangil</h4>
        
            <div id="about-card-bio"><p>React와 Node를 사용하는 풀스택 개발자가 되는것이 목표입니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>web developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                Asia/Seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
