{"pages":[{"title":"all-archives","text":"","link":"/all-archives/index.html"},{"title":"all-tags","text":"","link":"/all-tags/index.html"},{"title":"all-categories","text":"","link":"/all-categories/index.html"}],"posts":[{"title":"Deep clone","text":"이슈 react에서 setState를 하지 않았음에도 state가 변경되는 현상 api 구축중 객체를 변경하지 않았음에도 객체 값이 변경되는 현상 react 프로젝트 개발중 위의 이슈가 자주 발생하고 있었다.해당 이슈가 왜 발생하는지, 어떻게 해결할 수 있는지 기록해두려고 한다.해당 글은 react 뿐만 아니라 javascript 언어를 사용한다면 꼭 알아둬야 된다고 생각한다. 123456state = { a: 1, b: 2 }handleChange = e =&gt; { const state = {...this.state}; state[e.target.name] = e.target.value; this.setState(state);} 위 코드는 본인이 input 의 onChange 이벤트 함수로 거의 복붙하면서 변형없이 사용하는 이벤트 함수이다.최근 state 변수 선언 즉, state 객체를 복사하고 사용하는 과정에 있어 동일한 이슈가 많이 발생하고 있어, 해당 함수를 단순히 복사하는것이 아닌 이해가 필요하고 상황에 따라 변형해서 사용해야할 필요있다. Object copy1const state = {...this.state} state 변수는 react state 객체를 복사한것이다. 해당 문법은 es9 문법으로 특정 값만 바꿀때 유용하다.해당 문법의 es5 버전은 .assign() 메소드이다. 1234567891011121314151617181920const object1 = { a: 1, b: 2,};const object2 = Object.assign({}, object1, {a: 100});const object3 = Object.assign({ c: 3 }, object1, {a: 100});const object4 = Object.assign({}, object1);object4.a = 100const object5 = {...object1}object5.a = 100console.log(object2.a); //100console.log(object2.b); //2console.log(object3.a); //100console.log(object3.b); //2console.log(object3.c); //3console.log(object4.a); //100console.log(object5.a); //100 object2 : 빈 객체에 object1을 복사한 후 a 의 값을 변경 object3: c: 3 값이 담겨있는 객체에 object1을 복사한 후 a 의 값을 변경 object4: 현재 우리 회사에서 사용하는 handleChange를 es5로 바꾼 방법 object5: Spread syntax(…) es8 문법사용하지만 state 내부에 객체를 변경하려고 할때 문제가 발생한다. 123456789101112131415state = { a: 1, b: { c: 2 }, d: { c: 2 }}handleChange = e =&gt; { const state {...this.state} state.b.c = 3 this.setState(state)} 2단계 이상 깊이의 object는 복사가 원활하지 않는것을 확인할 수 있다. 복사본의 값을 변경했는데 원본의 값도 변경되는 알수 없는 현상이 발생한다.MDN: 깊은 클로닝에 대해서, Object.assign() 은 속성의 값을 복사하기때문에 다른 대안을 사용해야합니다. 출처 값이 객체에 대한 참조인 경우, 참조 값만을 복사합니다. 123456789const org = { a : {b : 2}};const obj = Object.assign({}, org);obj.a.b = 100; console.log(obj.a.b); //expected: 2 but actual: 100const obj2 = {...org};obj2.a.b = 100; console.log(org.a.b); //expected: 2 but actual: 100 해당 현상은 깊은 클로닝(deep cloning) 방식을 사용해야한다.객체 복사 방식 변경 : 객체를 string 으로 변경하고 다시 파싱해주는 방법 1234567const org = { a : {b : 2}};const obj = JSON.parse(JSON.stringify(org)); obj.a.b = 100;console.log(org.a.b); // 2lodash 메소드 사용import _ from 'lodash'; const org = { a : {b : 2}};const obj = _.cloneDeep(org); obj.a.b = 100;console.log(org.a.b); // 2 Array copy2단계 이상 깊이의 배열을 복사할때는 맵을 사용해서 객체 하나하나 복사해준 후 return 해주는 방식을 사용해서 에러발생을 막아야합니다.1234567891011121314151617const org = { obj: { a: [{ b: 1 },{ b: 2 }] }}const obj1 = {...org}const arr = org.obj.a // xconst arr2 = org.obj.a.map(row =&gt; { return {...row}}) 참고https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign","link":"/2019/04/18/Deep-clone/"},{"title":"Next.js with pm2 ecosystem","text":"Next.js는 Client-Side-Rendering 을 사용하는 react가 아닌 SSR(Server-Side-Rendering) 방식을 사용하는 react framework 이다.해당 글은 Next.js에서 배포시 참고하면 좋을 내용으로 Next.js가 뿐만 아니라 react, Node 에서도 사용 가능하다. pm2 ecosystempm2 ecosystem이란, 실행할 인스턴스의 설정을 JSON 형식으로 관리할 수 있고, pm2 에서 제공해 주는 option 을 보다 쉽게 관리 할수 있도록 도와준다. pm2 명령어로 직접 실행시킬 수 있지만, ecosystem을 사용함으로써 어떤 서버나 환경에서도 같은 설정을 사용해서 서버를 실행할 수 있다는 점이 장점이다. ecosystem.config.js 를 최상위 폴더에 생성한다. 작성방법 123456789101112131415161718module.exports = { apps: [ { name: \"chungeoram\", script: \"./server.js\", watch: true, interpreter: '/home/ubuntu/.nvm/versions/node/v8.11.3/bin/node', \"env_public-develop\": { NODE_ENV: \"public-develop\", PORT: 1111, API_END_POINT: 'http://endpoint/api' }, env_production: { NODE_ENV: \"production\" } } ]}; name: pm2 에서 관리하는 이름 script: 앱을 구동할 경로 watch: 파일이 변경되면 자동으로 재시작 유무 ignore_watch: 배열안에 있는 리스트는 watch 대상에서 무시한다. exec_mode: 클러스터 모드로 구동instances: 클러스터로 구동될시 몇개까지 구동할것인지 선택(0 : cpu갯수) merge_logs: 클러스터로 구동할시 로그를 한파일에 기록 interpreter: 해석기 절대 경로(default: node) log_date_format: 로그에 출력될 날짜와 시간값의 형식 error_file: 에러 파일 위치 out_file: 기본 출력 로그 위치 env_{value} value는 process.env.NODE_ENV 값과 매칭된다. 예를 들어 현재 process.env.NODE_ENV가 public-develop 일때, env_public-develop 내부의 값이 사용된다. 내부의 값들은 process.env 객체 내로 값이 할당되며, process.env.PORT , process.env.API_END_POINT 로 값을 배포 환경의 따라 다르게 사용가능하다. pm2 구동방법package.json script에 명령어를 추가해준다.1234567\"scripts\": { \"precommit\": \"lint-staged\", \"build\": \"next build\", \"start\": \"pm2 start ecosystem.config.js --env production\", \"start-public\": \"pm2 start ecosystem.config.js --env public-develop\", \"dev\": \"nodemon server.js\" } $ yarn build → $ yarn start app 빌드 후 명령어를 사용해서, pm2를 구동시켜 준다. pm2 start {파일이름} –env {value} 와 같은 형식으로 명령어를 추가한다. 여기서 환경변수는 ecosystem.config.js 의 env_{value}와 매칭 된다. Next.js 에서 process.env 변수 사용 주의사항Next.config.js 에서 sass, webpack 등의 처리 후 export 하는 과정에서, process.env 객체가 비어있는 문제를 발견했다. 하지만, api.js config.js 등 환경 변수에 따라 값을 변경해줘야 하기 때문에 process.env 객체가 비어있으면 안된다. 해당 문제를 처리하기 위해 Next.js 에서 publicRuntimeConfig 라는 옵션을 제공해준다. 1234567891011121314151617181920const withSass = require('@zeit/next-sass')const withCSS = require('@zeit/next-css')const publicRuntimeConfig = { API_END_POINT: process.env.API_END_POINT, NODE_ENV: process.env.NODE_ENV,}module.exports = withCSS(withSass({ publicRuntimeConfig, webpack: config =&gt; { // Fixes npm packages that depend on `fs` module config.node = { fs: 'empty', module: 'empty' } return config }})) 필요한 process.env 의 값을 publicRuntimeConfig 객체에 담아주고 Next.js 의 옵션 값에 할당해준다.할당해 주게되면, Next.js 의 config 값으로 저장되게 된다.이후 Next.js의 config 값을 불러오는 함수를 추가해준다. 12345678910import getConfig from 'next/config';export const getNodeEnv = () =&gt; { const { publicRuntimeConfig } = getConfig(); const realNodeEnv = publicRuntimeConfig.NODE_ENV || process.env.NODE_ENV; const apiEndPoint = publicRuntimeConfig.API_END_POINT; return { realNodeEnv, apiEndPoint }}; 해당 함수는 Next.js의 config에서 publicRuntimeConfig 를 가져와 return 해준다.이제 process.env 환경변수를 사용하고 싶다면, process.env.API_END_POINT 와 같이 직접적으로 사용하는것이 아닌, 해당 함수를 사용해준다. 123456789101112import config from './config'import { getNodeEnv } from '@/utils/env'const env = getNodeEnv()const endPoint = env.apiEndPoint || config.apiEndPointexport default { AUTH_TOKEN: { method: 'POST', path: () =&gt; `${endPoint}/auth/authenticate-token` }}","link":"/2019/04/18/Next-js-with-pm2-ecosystem/"},{"title":"Partial.js와 함수 조립","text":"파이프라인즉시 실행 파이프라인, _.go와 _.mr_.go는 파이프라인의 즉시 실행 버전이다. 첫 번째 인자로 받은 값을 두 번째 인자로 받은 함수에게 넘겨주고, 두 번째 인자로 받은 함수의 결과는 세 번째 함수에게 넘겨준다. 이것을 반복하다가 마지막 함수의 결과를 리턴해 준다. 12345_.go(10, // 첫번째 인자 function (a) { return a * 10 }, // 100 function (a) { return a - 50 }, // 50 function (a) { return a + 10 } // 60) _.go는 Multiple Results를 지원한다. _.mr 함수를 함께 사용하면 다음 함수에게 2개 이상의 인자들을 전달할 수 있다. 123456_.go(10, function (a) { return _.mr(a * 10, 50) }, function (a, b) { return a - b }, function (a) { return a + 10 })// 60 _.go의 첫 번째 인자는 두 번째 인자인 함수가 사용할 인자이며 두 번째 부터는 파이프라인에서 사용할 함수들이다. _.go의 두 번째 인자인 함수, 즉 최초 실행될 함수에게 2개 이상의 인자를 넘끼고자 한다면 그때도 _.mr을 사용하면 된다. 12345678910_.go(_.mr(2, 3), function (a, b) { return a + b; }, function (a) { return a * a })// 25 위의 코드처럼 _.mr로 인자들을 감싸서 넘겨주면, 다음 함수는 인자를 여러개로 펼쳐서 받게 된다. _.mr(2, 3)은 하나의 값이지만 _.go 내부에서 인자를 펼쳐서 넘겨주어, 2와 3이 첫 번째 함수의 a와 b가 된다._.go는 이미 정의되어 있는 함수와 조합하거나 화살표 함수와 사용할 때 특히 표현력이 좋다. 123456789function add(a, b) { return a + b;}function square(a) { return a * a;}_.go(_.mr(2, 3), add, square);_.go(_.mr(2, 3), (a, b) =&gt; a + b, a =&gt; a * a) 함수를 만드는 파이프라인 _.pipe_.go가 즉시 실행하는 파이프라인이라면 _.pipe는 실행할 준비가 된 함수를 리턴하는 파이프라인 함수다. 그 외 모든 기능은 _.go와 동일하다. 12345var f1 = _.pipe(add, square);f1(2, 3); // 25var f2 = _.pipe((a, b) =&gt; a + b, a =&gt; a * a);f2(2, 3) // 25 부분 커링 함수와의 조합파이프라인 함수를, 함수를 리턴하는 함수와 함께 사용해 보자. 123456789101112131415var products = [ { id: 1, name: \"후드 집업\", discounted_price: 6000, price: 10000 }, { id: 2, name: \"코잼 후드티\", discounted_price: 8000, price: 8000 }, { id: 3, name: \"A1 반팔티\", discounted_price: 6000, price: 6000 }, { id: 4, name: \"코잼 반팔티\", discounted_price: 5000, price: 6000 },]_.go(products, _.filter(p =&gt; p.discounted_price &lt; p.price), // 1 _.sortBy('discounted_price'), // 2 _.first, // 3 _.val('name') // 4)// 코잼 반팔티 products 중에 할인 중인 상품만 남긴다. discounted_price 가 낮은 순으로 정렬한다. 첫 번째를 꺼낸다. product.name 을 확인한다. Partial.js의 _.filter, _.sortBy, _.val은 모두 부분 커링이 된다. 모두 인자를 하나만 넘겨 앞으로 실행될 함수를 리턴 받았다. 그렇게 만들어진 함수들은 _.go를 통해 순서대로 실행된다. 123456789101112131415161718192021222324252627282930// 할인 상품 중 가격이 가장 높은 상품의 이름_.go(products, _.filter(p =&gt; p.discounted_price &lt; p.price), _.sortBy('discounted_price'), _.last, _.val('name'), console.log)// 후드 집업// 할인 상품 중 할인액이 가장 높은 상품의 이름_.go( products, _.filter(p =&gt; p.discounted_price &lt; p.price), _.sortBy(p =&gt; p.discounted_price - p.price), _.first, _.val('name'), console.log)// 후드 집업// 할인 상품 중 할인액이 가장 낮은 상품의 이름_.go( products, _.filter(p =&gt; p.discounted_price &lt; p.price), _.max(p =&gt; p.discounted_price - p.price), _.val('name'), console.log)// 코잼 반팔티 중간중간 들어간 함수들의 조합을 약간씩 수정하여, 다른 로직으로 쉽게 변경할 수 있다. 할인이 진행 중인 상품들 중 제일 비싼 상품을 꺼낸다든지, 할인이 되지 않는 상품 중 제일 싼 상품을 꺼낸다든지 하는 로직으로 변경하는 것이 위에서 알 수 있듯 매우 쉽다. 보조 함수로 사용하는 파이프라인파이프라인을 보조 함수로 만들기 위해 사용하는 것도 좋다. 파이프라인을 _.each, _.map, _.reduce 등과 같은 고차 함수들의 보조 함수로 사용해 보자. 1234567_.go( products, _.filter(p =&gt; p.discounted_price &lt; p.price), _.map(_.pipe(_.identity, _.pick(['id', 'name']), _.values)), console.log)// [[1, \"후드 집업\"], [4, \"코잼 반팔티\"]] _.filter 에서는 할인 중인 상품만 남게 된다. _.map 에서는 iteratee를 파이프라인으로 만들었다. _.pipe는 _.identity를 통해 iteratee의 첫 번째 인자인 product만 리턴하게 되고, 부분 커링된 _.pick을 통애 id와 name만 남은 객체로 만들게 된다. 마지막으로 _.values를 통해 값만 남겼다. 비동기와 _.go_.go는 비동기 제어를 지원한다. Promise가 체인 방식에 함수적인 아이디어를 가미하여 비동기 상황을 제어했다면, _.go는 함수적으로만 비동기를 제어한다. _.go는 내부적으로 함수들을 순차적으로 실행해 나가면서 비동기 함수의 결과를 재귀 함수로 꺼낸 후, 다음 함수에게 이어주는 식으로 비동기 상황을 제어한다._.go와 _.pipe는 일반 콜백 함수와 Promise를 모두 지원한다. _.go와 _.pipe는 기본적으로 동기로 동작하지만 파이프라인의 함수들을 실행하는 도중에 Promise 객체가 리턴되거나 jQuery의 then과 같은 Deferred Object가 리턴되거나 _.callback 함수를 이용했다면, 내부적으로 비동기를 제어하는 파이프라인으로 변한다.Promise의 경우에는 함수가 실행되면 즉시 setTimeout을 일으키고, 일단 { then: … } 을 리턴하게 되므로 동기 함수들과 중첩 사용을 할 수 없다. 그러나 _.go의 경우에는 비동기 상황이 없을 경우 결과를 즉시 리턴하기 때문에, 이후 연속적으로 실행되는 함수들이 반드시 비동기성을 띌 필요가 없다. 1234567891011_.go( 10, _.callback(function (a, next) { setTimeout(function () { next(a + 10) }, 100) }), function (a) { // next를 통해 받은 결과 a console.log(a); }) 위 상황에서 _.go는 첫 번째 함수를 실행하면서 내부적으로 next를 만들어 함수에게 넘긴다. next에게 결과를 전달하면 그 결과는 다음 함수의 인자로 넘어가게 된다. 다시 바깥으로 나와 그 다음 함수들을 순차적으로 실행하므로 콜백 지옥에서 벗어날 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function asyncCallback() { function add(a, b, next) { setTimeout(function () { next(a + b); }, 1000); } function sub(a, b, next) { setTimeout(function () { next(a - b); }, 1000); } function mul(a, b, next) { setTimeout(function () { next(a * b); }, 1000); } function log(msg, next) { setTimeout(function () { console.log(msg); next(msg); }, 1000); } _.go( _.mr(5, 10), _.callback( function (a, b, next) { add(a, b, next); }, function (result, next) { sub(result, 10, next); }, function (result, next) { mul(result, 10, next); }, function (result, next) { log(result, next); } ) )}asyncCallback(); // 50 연속적으로 비동기 함수가 사용되어야 한다면 위와 같이 _.callback 함수에 여러개의 함수를 넘겨도 되고, 아래와 같이 미리 _.callback 패턴이라고 지정해 두면 더욱 간결하게 코딩할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738var add = _.callback(function (a, b, next) { setTimeout(function () { next(a + b); }, 1000);});var sub = _.callback(function (a, b, next) { setTimeout(function () { next(a - b); }, 1000);});var mul = _.callback(function (a, b, next) { setTimeout(function () { next(a * b); }, 1000);});var log = _.callback(function (msg, next) { setTimeout(function () { console.log(msg); next(msg); }, 1000);});_.go( _.mr(5, 10), add, function (result) { return sub(result, 10); }, function (result) { return mul(result, 100); }, function (result) { return log(result); }) 위 코드 처럼 _.callback 함수로 미리 정의해 둔 ad, sub 등의 함수를 실행하면 그 함수는 Promise 객체를 리턴한다. 정확히는 Promise가 지원되는 환경에서는 Promise 객체를 리턴하고, Promise가 지원되지 않는 환경에서는 Partial.js 내부에 구현된 Promise 객체를 리턴한다. Promise 객체를 파이프라인이 다시 받아도 다시 비동기를 제어한다. 따라서 Promise가 지원되지 않는 환경에서도 파이프라인식의 비동기 제어가 가능하다. 중간에 멈추고 나가기일반 함수에서는 함수 중간 어디서든 return문으로 함수를 빠져 나올 수 있다. Partial.js는 파이프라인에서도 이와 같은 일이 가능하도록 지원하는데, 바로 _.stop이라는 함수를 이용하면 된다. 1234567_.go( null, function () { console.log(1) }, function () { console.log(2) }, function () { return _.stop() }, function () { console.log(3) }) 1과 2만 찍힌 후 세번째 함수는 실행되지 않고 파이프라인 전체를 나오게 된다. _.go의 최종 결과도 함께 전달하고 싶다면 _.stop 함수에게 전달하면 된다. 123456789var result = _.go( null, function () { console.log(1) }, function () { console.log(2) }, function () { return _.stop(\"Hi\") }, function () { console.log(3) });console.log(result); // Hi 비동기코드 변경없이 비동기 제어가 되는 고차 함수Partial.js의 _.each, _.map, _.reduce 등의 주요 함수들은 _.go와 _.pipe 처럼 하나의 함수로 동기와 비동기 상황이 모두 대응되도록 되어 있다. Partial.js의 함수를 이용하면 비동기 상황에서도 동기 상황과 동일한 코드를 작성할 수 있고, 비동기 함수와 동기 함수의 조합도 가능하다. 123456789101112131415161718// 1console.log(JSON.stringify(_.map([1, 2, 3], function (v) { return new Date();})))// [\"2019-12-01T08:20:00.422Z\",\"2019-12-01T08:20:00.422Z\",\"2019-12-01T08:20:00.422Z\"]// 2_.map([1, 2, 3], function () { return new Promise(function (resolve) { setTimeout(function () { resolve(new Date()) }, 1000); });}).then(function (result) { console.log(JSON.stringify(result))})// [\"2019-12-01T08:20:01.424Z\",\"2019-12-01T08:20:02.424Z\",\"2019-12-01T08:20:03.428Z\"] 같은 _.map 함수지만 1은 즉시 완료되었고, 2는 3초 정도의 시간이 걸려 완료되었다. Partial.js의 _.each, _.map, _.reduce 등은 첫 번째 iteratee의 결과가 Promise 객체일 경우 내부적으로 for문 대신 재귀로 변경된다. 2의 경우 iteratee가 각각 모두 1초 정도의 시간이 걸렸기 때문에 배열에 1초 정도의 차이를 가진 값들이 담겼다.위 코드는 둘 다 동일한 _.map 함수로 작성하기는 했지만 동기 상황의 코드와 비동기 상황의 전체적인 코드 구조가 다르다. _.go, _.pipe 등을 이용하면 두 가지 코드 모두 동일한 구조를 갖도록 만들 수 있다. 123456789101112131415161718192021// 1_.go( [1, 2, 3], _.map(function () { return new Date() }), JSON.stringify, console.log);// 2_.go( [1, 2, 3], _.map(function () { return new Promise(function (resolve) { setTimeout(function () { resolve(new Date()) }, 1000); }); }), JSON.stringify, console.log) _.map의 iteratee에서 Promise 함수가 아닌 일반 비동기 함수를 사용해야 한다면 다음과 같이 사용하면 된다. 12345678910_.go( [1, 2, 3], _.map(_.callback(function (val, i, list, next) { setTimeout(function () { next(new Date()); }, 1000) })), JSON.stringify, console.log) 마지막 인자로 next가 들어오고 next를 통해 결과를 전달하면, 그 결과가 하나씩 _.map의 결과인 새로운 배열에 쌓여간다. new Promise를 사용하는 것 보다 간결하다. Partial.js는 iteratee의 결과나 iteratee의 속성에 따라 동기 로직과 비동기 로직을 알아서 선택하도록 되어있다. 동기 로직으로 돌아가야 할 경우에는 for문을 사용하고 비동기 로직을 사용해야 할 경우에만 재귀로 변경되기 때문에 성능적으로도 문제가 없다. 비동기 결과를 기다리는 if문, _.if아래 is_1, is_2 함수는 결과를 즉시 리턴하는 함수다. 아래와 같은 함수는 if문과 같은 조건절에서 사용할 수 있다. 1234567891011121314var is_1 = function (a) { return a === 1;};var is_2 = function (a) { return a === 2;};function test1(a) { if (is_1(a)) return '1입니다.' else if (is_2(a)) return '2입니다.' else return '1도 아니고 2도 아닙니다.'}console.log(test1(2)); // 2입니다. 그런데 만약 is_1과 같은 함수가 즉시 값을 리턴할 수 없고, 데이터베이스에 다녀와야 하거나 HTTP 통신이 있어야 하면 상황은 달라진다. 자바스크립트에서는 아래와 같은 상황을 if문으로 제어할 수 없다. 1234567891011121314151617181920212223var is_1_async = function (a) { return new Promise(function (resolve) { setTimeout(function () { resolve(a === 1); }, 1000); })};var is_2_async = function (a) { return new Promise(function (resolve) { setTimeout(function () { resolve(a === 2); }, 1000); })};function test2(a) { if (is_1_async(a)) return '1입니다.' else if (is_2_async(a)) return '2입니다.' else return '1도 아니고 2도 아닙니다.'};console.log(test2(2)); // 1입니다. (정상적으로 동작하지 않음) is_1_async 함수의 진짜 결과는 false이겠지만 is_1_async가 즉시 Promise 객체를 리턴하기 때문에 if의 조건문 입장에서는 true가 된다. is_1_async가 콜백 패턴으로 이루어진 일반 함수 였다고 하더라고, undefined가 즉시 리턴될 것이므로 역시 정상적인 결과를 만들수 없다. 123456var test4 = _.if(is_1_async, function () { return '1입니다.' }) .else_if(is_2_async, function () { return '2입니다.' }) .else(function () { return '1도 아니고 2도 아닙니다. ' });test4(2).then(console.log); // 2입니다. 위 함수는 동기 함수를 사용했던 test1과 유사한 구조를 가지고 있다. _.constant나 화살표 함수를 사용하면 더욱 간결해진다. _.go와 함께 사용한 버전도 확인해 보자. 12345678910111213141516171819202122var test5 = _.if(is_1_async, _.constant('1입니다.')) .else_if(is_2_async, _.constant('2입니다.')) .else(_.constant('1도 아니고 2도 아닙니다. '));test5(2).then(console.log);// 화살표함수var test6 = _.if(is_1_async, () =&gt; '1입니다.') .else_if(is_2_async, () =&gt; '2입니다.') .else(() =&gt; '1도 아니고 2도 아닙니다. ');test6(1).then(console.log)// _.go_.go( 3, _.if(is_1_async, _.constant('1입니다.')) .else_if(is_2_async, _.constant('2입니다.')) .else(_.constant('1도 아니고 2도 아닙니다. ')), console.log) 동기와 비동기 상황을 동시에 대응하는 함수를 쉽게 만드는 팁이 있다. 해당 함수의 로직을 _.go나 _.pipe로 구현해 두는 것이다. 그렇게 하면 자동으로 동기 상황과 비동기 상황에 맞춰 로직을 알아서 변경시키기 때문에 추가적인 다른 작업을 하지 않아도 된다. 고차 함수_.all, _.spread이 두 함수는 파이프라인과 함께 사용할 때 유용한 함수다. _.all과 _.spread 모두 받은 인자를 받은 함수들에게 전달하는 함수들인데, _.all은 받은 모든 인자를 모든 함수들에게 동일하게 전달하고, _.spread는 받은 인자들을 하나씩 나눠 준다. 12345678910_.all(10, 5, [ function (a, b) { return a + b }, function (a, b) { return a - b }, function (a, b) { return a * b }])_.spread(10, 5, [ function (a) { return a * a }, function (b) { return b * b }]) _.all은 받아 둔 모든 인자를 마지막 인자로 들어온 배열 안에 있는 모든 함수들에게 동일하게 전달한다. _.spread는 받은 인자를 하나씩 나눠서, 받은 함수들에게 하나씩 전달하는 함수다._.all과 _.spread에게 인자 전달 없이 함수들만 전달하면 함수를 리턴하는 함수로 동작하여 파이프라인 등에서 사용하기 좋다. 12345678910111213141516_.go( 10, _.all( function (a) { return a + 5 }, function (a) { return a - 5 }, function (a) { return a * 5 } ), _.spread( function (a) { return a + 1 }, function (b) { return b + 2 }, function (c) { return c + 3 } ), console.log)// 16 7 53 파이프라인2_.go에서 this 사용Partial.js의 _.pipe가 this를 지원하는 것을 확인했었다. _.go에서도 this 지원이 가능하다. 1234567891011121314var user = { name: \"Cojamm\" };_.go.call(user, 32, function (age) { this.age = age; }, function () { console.log(this.name); }, function () { this.job = \"Rapper\"; })console.log(user); // {name: \"Cojamm\", age: 32, job: \"Rapper\"} _.go.call의 call은 Fucntion.prototype.call 이다. _.go는 일반 함수이므로 call을 사용하는게 자연스럽다. _.go 는 call을 통해 전달받은 this를 파이프라인 내 함수들에게 전달한다. apply 역시 사용할 수 있다. 또 다른 파이프라인, _.indent자바스크립트에서는 부모 스코프와 자식 스코프라는 개념이 있다. 자식 스코프는 부모 스코프의 지역 변수를 참조할 수 있다. 이러한 중첩 구조의 접근 방식이 파이프라인 내에서도 필요했는데, 이를 위한 함수가 바로 _.indent다. _.indent는 이름처럼 _.indent가 중첩될 때마다 this와 arguments를 한 단계씩 안으로 들여쓰는 콘셉트를 가지고 있다. 1234567891011var f1 = _.indent( function () { console.log(this, arguments); // 1 return 'hi'; }, function () { console.log(this, arguments) // 2 })f1(1, 2); _.indent는 _.pipe처럼 함수를 리턴하는 파이프라인이다. 함수들의 연속 실행이 준비된 함수를 리턴하여 f1에 담았고 실행했다.1과 2의 결과에는 차이가 있다. console.log 에게 두 번째 인자로 넘긴 arguments에 담긴 값이 다르다. 1은 파이프라인의 첫 번째 함수이기에 f1을 통해 넘겨진 인자 [1,2]가 arguments에 들어온다. 2는 두 번째 함수이고, 이전 함수에서 ‘hi’를 리턴했기에 [‘hi’]가 arguments에 담겨 있다.파이프라인으로 코딩하다 보면 파이프라인의 최초 함수가 아닌 중간에 있는 함수에서 파이프라인이 최초로 받은 인자를 알고 싶을 때가 있다. 이것은 클로저를 사용하는 것으로도 자연스럽게 해결된다._.indent의 해결법은 파이프라인 내부의 함수들은 중간 어디서든 this.arguments로 파이프라인의 최초 인자들에 접근할 수 있다. _.indent의 this는 한 번의 파이프라인 사용 후 휘발되는 this다. 파이프라인 전체에서 공유하고자 하는 값이 있을 때 값을 이어주는 식으로 사용할 수도 있다. 또한 인스턴스를 만들어 두고 계속 사용하는 this가 아닌, 함수를 실행할 때마다 새로 생겼다 사라지는 this이므로 부수효과가 최소화되고 메모리 사용에도 문제가 없다. 123456789var f2 = _.indent( function (a) { this.b = a + 10; }, function () { }, function () { }, function () { console.log(this.b) },)f2(5); // 15f2(7); // 17 _.indent에서 this는 이번에 실행할 때 열린 부모 스코프를 대신하는 역할이므로, 그 this의 key/value를 확장한다는 것은 새로운 변수를 할당하는 것 이라고 볼 수 있다. this에 값을 단 후 값을 변경하지 않는다면 부수 효과로부터 자유로워진다. 하나의 큰 함수 안에서 변수에 담고 그 변수에 담긴 값을 변경하지 않는 것과 동일하다. 1234567891011121314151617181920var f3 = _.indent( function (a) { this.b = a + 10; }, _.indent( function () { this.b = 20; console.log(this.b); // 20 console.log(this.parent.b) // 15 }, function () { console.log(this.parent.arguments); // [5] } ), function () { console.log(this.b); })f3(5); parent를 통해 부모를 찾아갈 수 있고, this.parent.arguments로 파이프라인의 최초 인자도 찾아갈 수 있다. 자바스크립트에서 값에 접근할 수 있다는 것은 값을 변경할 수도 있다는 의미이므로 위험하다. 이것은 모든 값 혹은 변수에 해당하는 이야기다. 그러나 값을 참조하는 식으로 접근한다면, 여기저기에서 값에 접근할 수 있다는 것 자체는 문제가 되지는 않는다. 무조건 비동기로 동작하는 _.async_.go, _.pipe, _.indent는 파이프라인 내부의 함수에서 비동기 결과가 나올 경우 비동기 제어를 시작하도록 구현되어 있다. 그러므로 비동기 상황이 생기지 않는다면 즉시 일반 값이 리턴되고, 비동기 상황이 생겼을 때만 Promise 객체가 리턴된다. 때로는 내부 함수의 결과와 상관없이 무조건 비동기를 일으키고 싶을 때가 있다. _.async는 이럴 때 사용하기 적합한, 무조건 비동기로 동작하는 파이프라인이다. 1234567_.go.async(1, function (a) { return a;}).then(console.log);console.log(2);// 2// 1 참조: 함수형 자바스크립트 프로그래밍","link":"/2019/12/01/Partial-js%EC%99%80-%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/"},{"title":"Sequelize model 정의","text":"sequelize model 정의 sesquelize model 을 정의하는 방법은 여러가지 있지만, sequelize 의 define 메소드를 이용해 정의하고자 한다. model이란 데이터베이스의 테이블에 해당되며, 객체내의 key 값은 컬럼으로 생성된다.1234567891011return sequelize.define( \"User\", { username: { type: DataTypes.STRING(128) }, job: { type: DataTypes.STRING } }) define 함수의 첫번째 파라미터는 테이블의 이름에 해당된다. 또한 express 프로젝트에서도 해당 이름으로 데이터베이스에 접근할 수 있다. 두번째 파라미터는 컬럼을 정의하는 것이다. 위의 예시는 가장 기본적인 컬럼을 생성한 것이고 나머지 옵션들은 밑에서 확인해 보도록 한다. column option sequelize model 생성시 sequelize 는 고유 키값을 정의해 주지 않아도, 다른 설정이 없다면 id 로 생성해주며 row 생성시 자동으로 1씩 증가한다. id 이외에 createdAt(생성일), updatedAt(수정일) 도 같이 생성해준다. defaultValue: row가 생성될때 기본값을 설정해줄 수 있다. (etc. Sequelize.NOW) allowNull: false로 설정해주면 빈값으로 생성시 에러가 난다.(default true) unique: 테이블내의 고유한 값(boolean) primaryKey: 고유 키값 설정 여부 autoIncrement: 자동으로 값을 증가시켜준다. (Integer 에서만 사용 가능) field: 객체 키값과 다르게 custom으로 컬럼명을 사용할 수 있게해준다. comment: 해당 컬럼에 대한 설명을 달 수 있다. 컬럼 생성에 영향을 미치지는 않는다. 주석같은 개념 Getters &amp; setters 컬럼 option에 getter와 setter를 추가해 줄 수 있다.1234567891011121314151617181920212223242526return sequelize.define( \"User\", { username: { type: DataTypes.STRING(128), allowNull: false, get() { const job = this.getDataValue('job') return `${this.getDataValue('username')} (${this.getDataValue('job')})` } }, job: { type: DataTypes.STRING, allowNull: false, set(job) { this.setDataValue('job', job.toUpperCase()) } } })const userSample = async () =&gt; { const user = await User.create({ username: 'kkangil', job: 'developer' }) console.log(user.get('username')) // kkangil (DEVELOPER) console.log(user.get('job')) // DEVELOPER} getDataValue 를 사용하여 자신의 컬럼 뿐만 아니라 테이블의 컬럼 데이터도 가져올 수 있다. setDataValue 를 사용하여 생성이나 수정 시 데이터 값을 수정, 변경할 수 있다. 컬럼 객체 내부에 설정해 주지 않고, define 함수의 세번째 파라미터로도 사용이 가능하다.12345678910111213141516171819return sequelize.define( \"User\", { username: { type: DataTypes.STRING(128), allowNull: false }, job: { type: DataTypes.STRING, allowNull: false } }, { getterMethods: { getUser() { return `${this.username} (${this.job})` } } }) validate column 데이터 타입 이외에도 validate 를 사용해서 유효성 확인 후 에러를 반환해 줄 수 있다. 1234567891011121314151617181920212223242526return sequelize.define( \"Foo\", { bar: { type: DataTypes.STRING, validate: { is: /^[a-z]+$/i, // 정규식 사용해서 유효성 확인 not: /^[a-z]+$/i, isEmail: true, // 이메일 유효성 확인 isInt: true, notNull: true, isNull: true, notEmpty: true, // string 빈값 확인 equals: 'specific value', // 특정 값으로만 생성 가능 contains: 'foo', // 해당 값을 포함하고 있는지 확인 notContains: 'bar', notIn: [['foo', 'bar']], isIn: [['foo', 'bar']], len: [2,10], // 2자리 ~ 10자리 max: 23, min: 10, isCreditCard: true // 신용카드 유효성 확인 } } }) 제공되는 validate 가 아닌 직접 만들어서 사용하는 기능도 제공한다. 12345678910bar: { type: DataTypes.INTEGER, validate: { isEven(value) { if (parseInt(value) % 2 !== 0) { throw new Error('Only even values are allowed!'); } } }} throw new Error의 메시지가 에러로 리턴된다. 직접 만들어서 사용하지 않아도 메시지를 설정해 줄 수 있다.123456789101112bar: { type: DataTypes.INTEGER, validate: { notNull: { msg: \"Must\" }, isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } }} allowNull 을 사용한다면 notNull 의 msg를 설정해주면 에러메시지로 사용가능하다. 123456789101112131415161718192021return sequelize.define( \"User\", { username: { type: DataTypes.STRING(128), allowNull: false }, job: { type: DataTypes.STRING, allowNull: false } }, { validate: { checkUsernameAndJob() { if (!(this.username &amp;&amp; this.job)) { throw new Error('이름과 직업을 입력해주세요.') } } } }) define 함수의 세번째 파라미터 객체에 validate 를 설정해주면 하나의 컬럼이 아닌 테이블의 모든 컬럼의 유효성은 같이 확인 할 수 있다. model configuration define 함수의 세번째 파라미터 객체의 설정값123456789101112return sequelize.define( ..., { modelName: 'bar', // 모델 이름 설정 timestamps: false, // createdAt, updatedAt 생성하지 않음 paranoid: true, // 데이터를 삭제하지 않고 현재 시간으로 deletedAt 데이터가 추가된다. underscored: true, // 자동으로 컬럼명을 snake 네임으로 변경한다. tableName: 'my_bar', // 테이블 이름 설정 createdAt: false, // createdAt 사용하지 않음 updatedAt: 'updateTimestamp', // updatedAt 컬럼명 정의 deletedAt: 'destroyTime', // deletedAt 컬럼명 정의 (paranoid가 true로 설정되어 있어야함.) }) 참고 sequelize docs","link":"/2019/04/28/Sequelize-model-%EC%A0%95%EC%9D%98/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy Front-matter 설정 설명 기본 값 layout 레이아웃 title 타이틀 date 발행일 파일이 생성된 날짜 updated 갱신일 파일이 업로드된 날짜 tags 태그 (page에서는 사용 불가능) categories 카테고리 (page에서는 사용 불가능) permalink 포스트의 기본 permalink를 override합니다. comments 포스트에서 comment 기능을 사용할지 여부 true More info: Deployment","link":"/2019/04/17/hello-world/"},{"title":"jest 메서드-toBe","text":".toBe(value).toBe(value) 메서드는 expect 의 값과 비교할때 사용한다. 이것은 Object.is() 를 사용하여 비교하는데 === 연산자를 사용하는 것보다 테스트하기에 더 좋다. 1234567891011121314const can = { name: 'pamplemousse', ounces: 12,};describe('the can', () =&gt; { test('has 12 ounces', () =&gt; { expect(can.ounces).toBe(12); }); test('has a sophisticated name', () =&gt; { expect(can.name).toBe('pamplemousse'); });}); .toBe(value) 메서드에는 소수를 쓰지 않는것이 좋다. 예를 들면 1expect(0.1 + 0.2).toBe(0.3) 위와 같은 경우이다. 자바스크립트에서는 0.1 + 0.2 가 0.3이 아니기 때문이다. .toHaveBeenCalled()mock 함수가 실행됐는지를 테스트하는 메서드이다.mock 함수가 실행됐으면 테스트에 성공하는데 반대로 해당 함수를 실행하지 않는 것이 원하는 결과라면 .not 을 사용해서 테스트 코드를 구성하면 된다. 12345678910111213141516171819function drinkAll(callback, flavour) { if (flavour !== 'octopus') { callback(flavour); }}describe('drinkAll', () =&gt; { test('drinks something lemon-flavoured', () =&gt; { const drink = jest.fn(); drinkAll(drink, 'lemon'); expect(drink).toHaveBeenCalled(); }); test('does not drink something octopus-flavoured', () =&gt; { const drink = jest.fn(); drinkAll(drink, 'octopus'); expect(drink).not.toHaveBeenCalled(); });}); .toHaveBeenCalledTimes(number)mock 함수가 몇번 실행됐는지를 확인할때 사용하는 메서드이다. 인자의 number 만큼 실행됐으면 테스트는 성공한다. 12345test('drinkEach drinks each drink', () =&gt; { const drink = jest.fn(); drinkEach(drink, ['lemon', 'octopus']); expect(drink).toHaveBeenCalledTimes(2);}); toHaveBeenCalledWith(arg1, arg2, …)mock 함수가 실행됐을때 인자값을 테스트할때 사용한다. 1234567test('registration applies correctly to orange La Croix', () =&gt; { const beverage = new LaCroix('orange'); register(beverage); const f = jest.fn(); applyToAll(f); expect(f).toHaveBeenCalledWith(beverage);}); toHaveBeenLastCalledWith(arg1, arg2, …)mock 함수가 여러번 실행되었을때 마지막 실행의 인자값을 비교할때 사용한다. 12345test('applying to all flavors does mango last', () =&gt; { const drink = jest.fn(); applyToAllFlavors(drink); expect(drink).toHaveBeenLastCalledWith('mango');}); .toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)mock 함수가 여러번 실행되었을때 순서를 지정하여 인자값을 비교한다. 123456test('drinkEach drinks each drink', () =&gt; { const drink = jest.fn(); drinkEach(drink, ['lemon', 'octopus']); expect(drink).toHaveBeenNthCalledWith(1, 'lemon'); expect(drink).toHaveBeenNthCalledWith(2, 'octopus');}); .toHaveReturned()mock 함수가 실행되었고 return 이 되었는지를 테스트하는 메서드이다. 1234567test('drinks returns', () =&gt; { const drink = jest.fn(() =&gt; true); drink(); expect(drink).toHaveReturned();}); .toHaveReturnedTimes(number)mock 함수가 실행되었고 몇번 return 이 되었는지를 테스트하는 메서드이다. 12345678test('drink returns twice', () =&gt; { const drink = jest.fn(() =&gt; true); drink(); drink(); expect(drink).toHaveReturnedTimes(2);}); .toHaveReturnedWith(value)mock 함수가 실행되었고 어떤 값이 리턴되었는지 테스트하는 메서드이다. 12345678test('drink returns La Croix', () =&gt; { const beverage = {name: 'La Croix'}; const drink = jest.fn(beverage =&gt; beverage.name); drink(beverage); expect(drink).toHaveReturnedWith('La Croix');}); .toHaveLastReturnedWith(value)마지막으로 실행된 mock 함수의 return 값을 테스트하는 메서드이다. 12345678910test('drink returns La Croix (Orange) last', () =&gt; { const beverage1 = {name: 'La Croix (Lemon)'}; const beverage2 = {name: 'La Croix (Orange)'}; const drink = jest.fn(beverage =&gt; beverage.name); drink(beverage1); drink(beverage2); expect(drink).toHaveLastReturnedWith('La Croix (Orange)');}); .toHaveNthReturnedWith(nthCall, value)mock 함수가 여러번 실행되었을때 순서를 지정하여 return 값을 비교한다. 1234567891011test('drink returns expected nth calls', () =&gt; { const beverage1 = {name: 'La Croix (Lemon)'}; const beverage2 = {name: 'La Croix (Orange)'}; const drink = jest.fn(beverage =&gt; beverage.name); drink(beverage1); drink(beverage2); expect(drink).toHaveNthReturnedWith(1, 'La Croix (Lemon)'); expect(drink).toHaveNthReturnedWith(2, 'La Croix (Orange)');}); .toHaveLength(number)length 속성을 가진 객체에서 길이를 비교할때 사용한다. array 와 string 의 길이를 비교할 때 유용하다. 123expect([1, 2, 3]).toHaveLength(3);expect('abc').toHaveLength(3);expect('').not.toHaveLength(5); .toHaveProperty(keyPath, value?)객체에 keyPath 의 속성이 있는지 테스트할때 사용한다. 두번째 인자 value 는 인자값으로 keyPath 만 사용했을 경우에는 해당 속성이 있는지만 확인하지만 value 까지 사용하면 keyPath 속성의 값도 같이 비교한다. 123456789101112131415161718192021222324252627282930313233343536373839404142const houseForSale = { bath: true, bedrooms: 4, kitchen: { amenities: ['oven', 'stove', 'washer'], area: 20, wallColor: 'white', 'nice.oven': true, }, 'ceiling.height': 2,};test('this house has my desired features', () =&gt; { // Example Referencing expect(houseForSale).toHaveProperty('bath'); expect(houseForSale).toHaveProperty('bedrooms', 4); expect(houseForSale).not.toHaveProperty('pool'); // Deep referencing using dot notation expect(houseForSale).toHaveProperty('kitchen.area', 20); expect(houseForSale).toHaveProperty('kitchen.amenities', [ 'oven', 'stove', 'washer', ]); expect(houseForSale).not.toHaveProperty('kitchen.open'); // Deep referencing using an array containing the keyPath expect(houseForSale).toHaveProperty(['kitchen', 'area'], 20); expect(houseForSale).toHaveProperty( ['kitchen', 'amenities'], ['oven', 'stove', 'washer'], ); expect(houseForSale).toHaveProperty(['kitchen', 'amenities', 0], 'oven'); expect(houseForSale).toHaveProperty(['kitchen', 'nice.oven']); expect(houseForSale).not.toHaveProperty(['kitchen', 'open']); // Referencing keys with dot in the key itself expect(houseForSale).toHaveProperty(['ceiling.height'], 'tall');}); .toBeCloseTo(number, numDigits?)소수를 비교할때 근사치로 비교한다. numDigits 를 사용하면 소수 몇번째 자리까지만 비교할 수 있다.자바스크립트에서 0.1 + 0.2 는 0.3 이 아닌 0.30000000000000004 이므로 이 메서드를 사용하면 테스트가 가능하다. 123test('adding works sanely with decimals', () =&gt; { expect(0.2 + 0.1).toBeCloseTo(0.3, 5);}); toBeDefined()expect 의 값이 정의 되어있는지를 확인한다. 즉, undefined 이 아닌지 확인한다. (null 도 true).not 을 붙이면 undefined 인지 확인할 수 있다. 1234test('toBeDefined', () =&gt; { expect(null).toBeDefined(); expect(undefined).not.toBeDefined();}); .toBeFalsy()자바스크립트에서 다음 6개의 부정값에 대해서 테스트하는 메서드이다.false, 0, '', null, undefined, NaN 12345678test(\".toBeFalsy()\", () =&gt; { expect(0).toBeFalsy(); expect(false).toBeFalsy(); expect(null).toBeFalsy(); expect(undefined).toBeFalsy(); expect('').toBeFalsy(); expect(NaN).toBeFalsy();}) .toBeTruthy().toBeFalsy 에서 사용되는 6개의 부정값 이외의 값은 truthy 하다. .toBeGreaterThan(number | bigint)expect 의 값이 number | bigint 보다 큰지 확인하는 메서드다. 123test(\"toBeGreaterThan\", () =&gt; { expect(11).toBeGreaterThan(10);}) .toBeGreaterThanOrEqual(number | bigint)expect 의 값이 number | bigint 보다 크거나 같은지 확인하는 메서드다. 123test(\"toBeGreaterThanOrEqual\", () =&gt; { expect(11).toBeGreaterThanOrEqual(11);}) .toBeLessThan(number | bigint)expect 의 값이 number | bigint 보다 작은지 확인하는 메서드다. 123test(\"toBeLessThan\", () =&gt; { expect(9).toBeLessThan(10);}) .toBeLessThanOrEqual(number | bigint)expect 의 값이 number | bigint 보다 작거나 같은지 확인하는 메서드다. 123test(\"toBeLessThanOrEqual\", () =&gt; { expect(11).toBeLessThanOrEqual(11);}) .toBeInstanceOf(Class)instance 객체를 비교할때 사용한다. 12345class A {}expect(new A()).toBeInstanceOf(A);expect(() =&gt; {}).toBeInstanceOf(Function);expect(new A()).toBeInstanceOf(Function); // Error .toBeNull()expect 값이 null 인지 확인하는 메서드이다..toBe(null) 을 사용하는 것과 동일하지만 테스트가 실패했을때 에러 메시지가 조금 더 보기 좋다. 1234567function bloop() { return null;}test('bloop returns null', () =&gt; { expect(bloop()).toBeNull();}); .toBeUndefined()expect 값이 undefined 인지 확인하는 메서드이다.toBeNull 과 마찬가지로 toBe(undefined)를 사용할 수도 있지만 에러 메시지가 조금 더 좋다고 한다. .toBeNaN()expect 값이 NaN 확인하는 메서드이다. .toContain(item)배열 또는 문자에서 item 을 포함하고 있는지 확인하는 메서드이다. 12345678test(\"toContain\", () =&gt; { const a = [\"foo\", \"bar\"]; const b = \"foo_bar\" expect(a).toContain(\"bar\"); expect(a).not.toContain(\"baz\"); expect(b).toContain(\"bar\")}); toContainEqual(item)배열에서 일반 특별한 구조를 가진 value (ex. JSON) 를 포함하고 있는지 확인할때 사용한다. 12345test(\"toContain\", () =&gt; { const a = [\"foo\", \"bar\", { delicious: true, sour: false }]; expect(a).toContain({ delicious: true, sour: false })}); toContain 메서드를 사용하면 위의 테스트는 실패되지만 이 경우 toContainEqual 메서드를 사용하면 성공한다. 12345test(\"toContainEqual\", () =&gt; { const a = [\"foo\", \"bar\", { delicious: true, sour: false }]; expect(a).toContainEqual({ delicious: true, sour: false })}); toEqual(value)toBe 는 정확하게 테스트하기 위해 Object.is 를 사용한다. 만약 오브젝트의 값을 체크하기를 원한다면 대신 toEqual 를 사용해야한다. toEqual 는 오브젝트 또는 배열의 모든 필드 값을 재귀적으로 체크한다. 1234567891011121314151617const can1 = { flavor: 'grapefruit', ounces: 12,};const can2 = { flavor: 'grapefruit', ounces: 12,};describe('the La Croix cans on my desk', () =&gt; { test('have all the same properties', () =&gt; { expect(can1).toEqual(can2); }); test('are not the exact same can', () =&gt; { expect(can1).not.toBe(can2); });}); toBe 를 사용한 expect(can1).not.toBe(can2); 의 경우 can1 의 객체와 can2 의 객체가 동일한 객체가 아니기 때문에 테스트에 성공한다. .toMatch(regexpOrString)정규식에 대해 문자열을 테스트 할 수 있다. 123456describe('an essay on the best flavor', () =&gt; { test('mentions grapefruit', () =&gt; { expect(essayOnTheBestFlavor()).toMatch(/grapefruit/); expect(essayOnTheBestFlavor()).toMatch(new RegExp('grapefruit')); });}); .toMatchObject(object)객체 부분 속성에 대해 일치하는지 테스트한다.1234567891011121314151617181920const houseForSale = { bath: true, bedrooms: 4, kitchen: { amenities: ['oven', 'stove', 'washer'], area: 20, wallColor: 'white', },};const desiredHouse = { bath: true, kitchen: { amenities: ['oven', 'stove', 'washer'], wallColor: expect.stringMatching(/white|yellow/), },};test('the house has my desired features', () =&gt; { expect(houseForSale).toMatchObject(desiredHouse);}); .toThrow(error?)특정 함수가 호출될 때 에러를 던진다는 것을 테스트하려면 toThrow를 사용하면 된다. 12345test('throws on octopus', () =&gt; { expect(() =&gt; { drinkFlavor('octopus'); }).toThrow();}); 참조: Jest 공식 문서","link":"/2020/02/23/jest-%EB%A9%94%EC%84%9C%EB%93%9C-toBe/"},{"title":"jest 메서드 - globals","text":"Jest 제공 메서드들 중 Globals 메서드에 대해서 정리해보려 한다. Jest 공식 문서에 나와 있는 Globals 메서드 정의는 다음과 같다. Globals 메서드를 사용해서 전역 환경을 설정한다. 이것은 필수로 설정해 줄 필요는 없다. afterAll(fn, timeout)이름에서 유추할 수 있듯이 테스트가 진행되는 동안 매번 실행되는 것이 아니라 모든 테스트가 완료 되었을 때 실행된다. 만약 인자의 함수가 Promise 이거나 generator 일 경우, Jest 는 완료를 기다린다. 다른 테스트와 공유되는 전역 환경 상태를 초기화 할때 주로 사용한다. 123456789const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) { db.cleanUp();}afterAll(() =&gt; { cleanUpDatabase(globalDatabase);}); descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트가 모두 완료될 때 실행된다. afterEach(fn, timeout)afterAll 메서드와 달리 afterEach는 하나의 테스트가 완료될 때마다 실행된다. 각 테스트에 의해 생성된 임시 상태 또는 변수를 초기화 하는 경우 주로 사용한다. 123456789const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) { db.cleanUp();}afterEach(() =&gt; { cleanUpDatabase(globalDatabase);}); descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 완료될 때 실행된다. beforeAll(fn, timeout)afterAll과 정반대라고 생각하면 된다. 이 메서드는 테스트가 실행되기전 최초에 한번 실행된다. 각 테스트를 진행하기 위해 데이터를 설정해 줄때 주로 사용된다. 123456789const globalDatabase = makeGlobalDatabase();beforeAll(() =&gt; { // Clears the database and adds some testing data. // Jest will wait for this promise to resolve before running tests. return globalDatabase.clear().then(() =&gt; { return globalDatabase.insert({testData: 'foo'}); });}); descirbe 함수 내부에서 사용될 경우 describe 내부의 테스트를 하기전에 실행된다. beforeEach(fn, timeout)하나의 테스트가 시작되기 전에 실행된다. descirbe 함수 내부에서 사용될 경우 describe 내부의 각각 테스트가 시작되기 전 실행된다. 123456789const globalDatabase = makeGlobalDatabase();beforeEach(() =&gt; { // Clears the database and adds some testing data. // Jest will wait for this promise to resolve before running tests. return globalDatabase.clear().then(() =&gt; { return globalDatabase.insert({testData: 'foo'}); });}); 중복된 코드를 제거할때 유용하게 사용할 수 있다. describe(name, fn)describe 메서드는 몇몇의 관계가 있는 테스트들을 그룹으로 묶어 생성할 때 사용한다. test 메서드를 최상위에서 바로 실행시킬 수 있지만, describe 메서드로 관련있는 테스트 끼리 묶어서 작성하게 되면 가독성이 높아진다. 1234567891011121314const myBeverage = { delicious: true, sour: false,};describe('my beverage', () =&gt; { test('is delicious', () =&gt; { expect(myBeverage.delicious).toBeTruthy(); }); test('is not sour', () =&gt; { expect(myBeverage.sour).toBeFalsy(); });}); describe 메서드 함수 내부에서 다시 describe로 그룹화를 할 수 있다. describe.each(table)(name, fn, timeout)여러가지 다른 데이터로 중복되는 테스트를 수행할때 describe.each를 활용할 수 있다. 하나의 테스트 케이스로 값이 다른 데이터들로 테스를 수행하는 것이다. table: 인자로 배열을 넘기면 fn 함수의 인자로 사용 가능하다. name: 테스트의 이름 printf formatting 기법을 사용할 수 있다. 1234567891011121314151617describe.each([ [1, 1, 2], [1, 2, 3], [2, 1, 3],])('.add(%i, %i)', (a, b, expected) =&gt; { test(`returns ${expected}`, () =&gt; { expect(a + b).toBe(expected); }); test(`returned value not be greater than ${expected}`, () =&gt; { expect(a + b).not.toBeGreaterThan(expected); }); test(`returned value not be less than ${expected}`, () =&gt; { expect(a + b).not.toBeLessThan(expected); });}); describe.eachtable 형식으로도 사용 가능하다. 123456describe.each` a | b | expected ${1} | ${1} | ${2} ${1} | ${2} | ${3} ${2} | ${1} | ${3}` describe.only(name, fn)오직 하나의 describe 그룹의 테스트만 수행하고 싶을 때 사용한다. 다른 describe 테스트들은 skip 된다.describe.only.each 메서드도 사용할 수 있다. 12345678910111213describe.only('my beverage', () =&gt; { test('is delicious', () =&gt; { expect(myBeverage.delicious).toBeTruthy(); }); test('is not sour', () =&gt; { expect(myBeverage.sour).toBeFalsy(); });});describe('my other beverage', () =&gt; { // ... will be skipped}); describe.skip(name, fn)특정한 describe 그룹을 테스트 하고 싶지 않을때 사용한다.12345678910111213describe('my beverage', () =&gt; { test('is delicious', () =&gt; { expect(myBeverage.delicious).toBeTruthy(); }); test('is not sour', () =&gt; { expect(myBeverage.sour).toBeFalsy(); });});describe.skip('my other beverage', () =&gt; { // ... will be skipped}); describe.skip.each(table)(name, fn) 메서드도 사용가능하다. test(name, fn, timeout)test 메서드를 사용하여 테스트를 수행할 수 있다. Promise나 비동기 방법을 지원한다. 123456789test('did not rain', () =&gt; { expect(inchesOfRain()).toBe(0);});test('has lemon in it', () =&gt; { return fetchBeverageList().then(list =&gt; { expect(list).toContain('lemon'); });}); test.each(table)(name, fn, timeout)describe.each(table)(name, fn, timeout)와 개념은 동일하다. 하지만 describe는 그룹화이기 때문에 여러가지 테스트를 동시에 수행할 수 있지만 test.each는 단일 테스트에 대한 each 이다. test.only(name, fn, timeout)describe.only 와 개념은 동일하다.1234567test.only('it is raining', () =&gt; { expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () =&gt; { expect(inchesOfSnow()).toBe(0);}); 오직 한가지의 test만 수행되며 describe 내부의 test들도 수행되지 않는다. test.only.each(table)(name, fn) 메서드도 사용할 수 있다. test.skip(name, fn)수행하고 싶지 않은 테스트를 건너뛰게 할 수 있다. 1234567test('it is raining', () =&gt; { expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () =&gt; { expect(inchesOfSnow()).toBe(0);}); test.skip.each(table)(name, fn) 도 사용가능하다. test.todo(name)추가되어야할 테스트 TODO를 남겨놓을 수 있다. 해당 메서드를 사용하면 다른 테스트들과 달리 강조되어 표시된다. 인자로 callback을 넘기면 에러가 발생한다. 123const add = (a, b) =&gt; a + b;test.todo('add should be associative'); 참조: Jest 공식 문서","link":"/2020/02/09/jest-%EB%A9%94%EC%84%9C%EB%93%9C-globals/"},{"title":"jest 메서드 - expect","text":"expect(value)expect 함수는 값을 테스트 하고 싶을 때 사용한다. 드물게 expect 함수만 사용해서 테스트를 할 수 있지만 값을 테스트하기 위해 matcher 함수를 함께 사용한다. expect.extend(matchers)expect.extend 함수를 사용하여 Jest 에서 제공하는 matcher 가 아닌 직접 만들어서 사용할 수 있다. 123456789101112131415161718192021222324252627expect.extend({ toBeWithinRange(received, floor, ceiling) { const pass = received &gt;= floor &amp;&amp; received &lt;= ceiling; if (pass) { return { message: () =&gt; `expected ${received} not to be within range ${floor} - ${ceiling}`, pass: true, }; } else { return { message: () =&gt; `expected ${received} to be within range ${floor} - ${ceiling}`, pass: false, }; } },});test('numeric ranges', () =&gt; { expect(100).toBeWithinRange(90, 110); expect(101).not.toBeWithinRange(0, 100); expect({ apples: 6, bananas: 3 }).toEqual({ apples: expect.toBeWithinRange(1, 10), bananas: expect.not.toBeWithinRange(11, 20), });}); toBeWithinRange 라는 matcher 를 만드는 방법이다. expect 의 값이 첫번째 인자로 넘어간다. 성공 했을경우 성공 사유 message 와 pass를 true로 return 해준다. 살패 했을경우는 반대로 실패 사유 message 와 pass 를 false 로 return 해준다. expect.extend 는 비동기 함수 호출도 지원한다. 123456789101112131415161718192021222324expect.extend({ async toBeDivisibleByExternalValue(received) { const externalValue = await getExternalValueFromRemoteSource(); const pass = received % externalValue == 0; if (pass) { return { message: () =&gt; `expected ${received} not to be divisible by ${externalValue}`, pass: true, }; } else { return { message: () =&gt; `expected ${received} to be divisible by ${externalValue}`, pass: false, }; } },});test('is divisible by external value', async () =&gt; { await expect(100).toBeDivisibleByExternalValue(); await expect(101).not.toBeDivisibleByExternalValue();}); Custom Matchers APIMacher 들은 항상 두개의 key 를 포함하고 있는 객체를 리턴해야한다. pass 는 성공/실패 여부이고 message 는 테스트가 실패 했을 경우 보여진다. .not() 메서드를 사용하면 실패 했을때 pass: true 의 message 가 보여진다. expect.anythingnull 과 undefined 을 제외한 모든 값들과 일치한다. 즉, null 과 undefined 외의 모든 값들은 동일하다. 12345test('map calls its argument with a non-null argument', () =&gt; { const mock = jest.fn(); [1].map(x =&gt; mock(x)); expect(mock).toBeCalledWith(1);}); 위의 테스트 코드는 성공할 것이다. 하지만 expect(mock).toBeCalledWith(2); 로 바꾸게 된다면 배열의 length 가 1 이므로 실패할 것이다. 만약 mock() 함수가 몇번 실행이 되는지 상관없이 테스트 케이스를 성공 처리 하고 싶을때 anything 을 사용하는 것이다. 1expect(mock).toBeCalledWith(expect.anything()); expect.any(constructor)expect.any(constructor) matches anything that was created with the given constructor expect.any 는 주어진 생성자와 값이 해당 생성자에 일치하는 지를 테스트 한다. toEqual 과 toBeCalledWith 함수에 값대신 해당 메서드를 사용할 수 있다. randocall 함수의 return 값이 Number 인지 테스트하는 코드다. 123456789function randocall(fn) { return fn(Math.floor(Math.random() * 6 + 1));}test('randocall calls its callback with a number', () =&gt; { const mock = jest.fn(); randocall(mock); expect(mock).toBeCalledWith(expect.any(Number));}); expect.arrayContaining(array)기대값이 expect.arrayContaining(array) 메서드에 주어지는 배열의 요소를 모두 포함하고 있는지 확인할 때 사용하는 메서드이다. toEqual 과 toBeCalledWith 함수에 사용할 수 있다. 12345678910describe('arrayContaining', () =&gt; { const expected = ['Alice', 'Bob']; it('matches even if received contains additional elements', () =&gt; { expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected)); }); it('does not match if received does not contain expected elements', () =&gt; { expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected)); }); expect(['Alice', 'Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));}); 첫번째 테스트의 경우 기대값 요소에 ‘Alice’, ‘Bob’ 이 포함되어 있기 때문에 성공한다. 두번째의 경우는 ‘Alice’ 를 포함하고 있지 않기 때문에 실패한다. 세번째 테스트 경우처럼 배열 요소에 중복이 있어도 상관없이 테스트는 성공한다. expect.not.arrayContaining(array) 메서드도 사용 가능하다. 12345678describe('not.arrayContaining', () =&gt; { const expected = ['Samantha']; it('matches if the actual array does not contain the expected elements', () =&gt; { expect(['Alice', 'Bob', 'Eve']).toEqual( expect.not.arrayContaining(expected), ); });}); expect.objectContaining(object)객체의 key 와 value 를 포함하고 있는지 테스트할때 사용한다. 1234567describe('objectContaining', () =&gt; { const expected = { foo: 'bar' }; it('matches if the actual object does contain expected key: value pairs', () =&gt; { expect({ bar: 'baz' }).toEqual(expect.objectContaining(expected)); });}); foo 라는 key 가 없어서 위 테스트는 실패한다. 만약 { bar: ‘baz’ } 를 { foo: ‘baz’ } 객체로 변경해서 테스트 해보면 실패하는것을 확인할 수 있다. objectContaining 는 key/value 쌍으로 동일해야 성공한다. 12345678910test('onPress gets called with the right thing', () =&gt; { const onPress = jest.fn(); simulatePresses(onPress); expect(onPress).toBeCalledWith( expect.objectContaining({ x: expect.any(Number), y: expect.any(Number), }), );}); objectContaining 객체의 value 에 특정한 값이 아니라 any, anything 도 사용할 수 있다. expect.not.objectContaining(object) 메서드도 사용 가능하다. expect.stringContaining(string)expect.stringContaining(string) 은 주어지는 문자를 포함하고 있는지 테스트한다. 1234567describe('stringContaining', () =&gt; { const expected = 'Hello world!'; it('matches if the received value does contain the expected substring', () =&gt; { expect('Hello world!').toEqual(expect.stringContaining(expected)); });}); expect.not.stringContaining(string) 도 사용 가능하다. expect.stringMatching(string | regexp)주어진 string 이나 정규식에 일치하는지 테스트할 때 사용한다. string 이 주어지는 경우 완전하게 일치 해야하며 정규식을 사용하는 경우는 해당 정규식에 일치하면 된다. 12345678910111213141516describe('stringMatching in arrayContaining', () =&gt; { const expected = [ expect.stringMatching(/^Alic/), expect.stringMatching(/^[BR]ob/), ]; it('matches even if received contains additional elements', () =&gt; { expect(['Alicia', 'Roberto', 'Evelina']).toEqual( expect.arrayContaining(expected), ); }); it('does not match if received does not contain expected elements', () =&gt; { expect(['Roberto', 'Evelina']).not.toEqual( expect.arrayContaining(expected), ); });}); expect.assertions(number)test 함수의 callback 함수 내부에서 테스트가 몇번이 일어나는지 확인하는 메서드이다. 12345test('assertions count', () =&gt; { expect.assertions(2); expect(true).toBeTruthy(); expect(null).toBeFalsy();}); 위 테스트코드에서 expect.assertions 을 제외하고 두개의 테스트를 하고있다. expect.hasAssertions()expect.hasAssertions() 함수는 test 함수의 callback 함수 내부에서 테스트가 최소 한번 실행되고 있는지 테스트하는 함수다. 1234test('has assertions', () =&gt; { expect.hasAssertions(); expect(null).toBeFalsy();}); resolves성공된 Promise 의 value 를 가져올때 사용한다. resolves 를 사용하지 않으면 received value 는 {} 가 된다. 123test('resolves to lemon', () =&gt; { expect(Promise.resolve('lemon')).resolves.toBe('lemon');}); async/await 과도 사용할 수 있다. 1234test('async/await resolves to lemon', async () =&gt; { await expect(Promise.resolve('lemon')).resolves.toBe('lemon'); await expect(Promise.resolve('lemon')).resolves.not.toBe('octopus');}); rejectsrejects 는 resolves 와는 반대로 실패된 Promise 의 reason 을 가져올 때 사용한다. 12345678910test('rejects to octopus', () =&gt; { // make sure to add a return statement return expect(Promise.reject(new Error('octopus'))).rejects.toThrow( 'octopus', );});test('rejects to octopus', async () =&gt; { await expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus');}); 참조: Jest 공식 문서","link":"/2020/02/16/jest-%EB%A9%94%EC%84%9C%EB%93%9C-expect/"},{"title":"도구 다루기-2","text":"재스민 들어가기재스민은 행위 주도 개발 (Behavior-Driven Development, BDD) 방식으로 자바스크립트 단위 테스트를 작성하기 위한 라이브러리다. BDD와 TDD는 상호 배타 관계가 아니다. BDD는 단위 테스트로 확인할 기능 또는 작동 로직을 일상 언어로 서술하는데, 이로써 개발자는 자신이 작성 중인 코드가 어떻게가 아니라 무엇을 해야하는지 테스트 코드에 표현할 수 있다. 그리고 행위 주도 스타일로 정의/구성한 테스트는 쉬운 문장으로 서술한 기능 명세서로 삼을 만하다는 이점도 있다. 테스트 꾸러미와 스펙재스민 테스트 꾸러미는 전역 함수 describe로 정의되며, 이 함수는 두 인자를 받는다. 문자열: 무엇을 테스트할지 서술한다. 함수: 테스트 꾸러미의 구현부다. 테스트 꾸러미는 스펙, 즉 개별 테스트로 구현되며, 각 스펙은 전역 함수 it으로 정의된다. it 함수도 describe 처럼 인자를 2개 받는다. 문자열: 무엇을 테스트할지 서술한다. 적어도 한 개의 기대식을 가진 함수: 코드 상태의 true/false를 확인하는 단언 테스트 꾸러미 구현부에 전역 함수 beforeEach/afterEach 를 쓰면 각 꾸러미 테스트가 실행되기 이전에 beforeEach 함수를, 그 이후에는 afterEach 함수를 호출한다. 전체 테스트가 공유할 설정과 정리 코드를 두 함수에 담아두면 코드 중복을 피할 수 있어 좋다. 설정 단계가 정확히 같은 테스트가 2개 있는데, beforeEach 함수로 간단히 해결할 수 있다. 123456789101112131415161718192021222324252627282930describe('createReservation(passenger, flight)', function () { it('주어진 passenger를 passengerInfo 프로퍼티에 할당한다.', function () { var testPassenger = null, testFlight = null, testReservation = null; beforeEach(function () { testPassenger = { firstName: \"윤지\", lastName: \"김\" }; testFlight = { number: \"3443\", carrier: \"대한항공\", destination: \"울산\" }; testReservation = createReservation(testPassenger, testFlight); }); it(\"passenger를 passenger Information 프로퍼티에 할당한다.\", function () { expect(testReservation.passengerInformation).toBe(testPassenger); }); it(\"flight를 flightInformation 프로퍼티에 할당한다.\", function () { expect(testReservation.flightInformation).toBe(testFlight); }) })}); 기대식과 매처expect 문은 테스트마다 있다. 다음은 첫 번째 단위 테스트 createReservation의 expect 문이다. expect(testReservation.passengerInformation).toBe(testPassenger); expect 함수는 테스트 대상 코드가 낸 실제값을 인자로 받아 기댓값과 견주어본다. 이 테스트가 기대하는 값은 testPassenger다. 실제값과 기댓값을 비교하는 일은 매처(matcher) 함수의 몫이다. 매처는 비교 결과 성공하면 true, 실패하면 false를 반환한다. 하나 이상의 기대식이 포함된 스펙에서 매처가 하나라고 실패하면 모조리 실패한 것으로 간주한다. toBe 매처는 이름에서 짐작할 수 있듯이 testResevation.passengerInformation이 testPassenger 와 같은 객체여야 한다는 의미다. 스파이재스민 스파이(spy)는 테스트 더블(test double) 역할을 하는 자바스크립트 함수다. 테스트 더블은 어떤 함수/객체의 본래 구현부를 테스트 도중 다른 코드로 대체한 것을 말하며, 웹 서비스 같은 외부 자원과의 의존 관계를 없애고 단위 테스트의 복잡도를 낮출 목적으로 사용된다. 다음 다섯 가지를 통칭하여 테스트 더블이라고 한다. 더미(dummy): 보통 인자 리스트를 채우기 위해 사용되며, 전달은 하지만 실제로 사용되지는 않는다. 틀(stub): 더미를 조금 더 구현하여 아직 개발되지 않은 클래스나 메서드가 실제 작동하는 것 처럼 보이게 만든 객체로 보통 리턴 값은 하드 코딩한다. 스파이(spy): 틀과 비슷하지만 내부적으로 기록을 남긴다는 점이 다르다. 특정 객체가 사용되었는지, 예상되는 메서드가 특정한 인자로 호출되었는지 등의 상황을 감시하고 이러한 정보를 제공하기도 한다. 모의체(fake): 틀에서 조금 더 발전하여 실제로 간단히 구현된 코드를 갖고는 있지만, 운영 환경에서 사용할 수는 없는 객체다. 모형(mock): 더미, 틀, 스파이를 혼합한 형태와 비슷하나 행위를 검증하는 용도로 주로 사용된다. ReservationSaver 라는 자바스크립트 객체를 만들어 이 객체의 saveReservation 함수로 웹 서비스에 예약 데이터를 전송하는 기능을 캡슐화했다. createReservation 함수를 확장하여 이 함수가 ReservationSaver 인스턴스를 인자로 받아 이 인스턴스의 saveReservation 함수를 실행하는지 확인하고자 한다.saveReservation 함수는 웹 서비스와 통신하므로 지금부터 작성할 테스트는 예약 데이터 저장 후 DB를 질의하고 예약 데이터가 분명히 추가됐는지 확인하는 과정이 모두 들어가야 할 듯 싶다. 하지만 그렇지 않다. 자칫 단위 테스트가 웹 서비스, DB 같은 외부 시스템 유무와 작동 여부에 의존하게 될지도 모른다. 재스민 스파이를 사용하면 복잡한 saveReservation 구현부를 외부 시스템 의존성을 배제한, 단순한 형태로 바꿀 수 있다. 먼저 작성한 ReservationSaver 객체다. 123456789101112131415function createReservation(passenger, flight, saver) { var reservation = { passengerInformation: passenger, flightInformation: flight }; saver.saveReservation(reservation); return reservation;}function ReservationSaver() { this.saveReservation = function (reservation) { // 예약 정보를 저장하는 웹 서비스와 연동하는 복잡한 코드가 있을 것이다. }} createReservation 함수는 ReservationSaver 인스턴스를 전달받게끔 개선되었다. ReservationSaver를 인자로 받으므로 예약 데이터가 저장되었는지를 확인하는 테스트를 다음과 같이 작성할 수 있다. 1234567891011121314151617181920describe(\"createReservation\", function() { var saver = new ReservationSaver(); var testPassenger = null, testFlight = null; beforeEach(function () { testPassenger = { firstName: \"윤지\", lastName: \"김\" }; testFlight = { number: \"3443\", carrier: \"대한항공\", destination: \"울산\" }; }); createReservation(testPassenger, testFlight, saver);}) saver.saveReservation이 정말 호출 되었는지 어떻게 알 수 있을까?이 테스트는 코드에 씌어있는 대로 복잡한 ReservationSaver의 기본 구현부를 createReservation 함수에 전달하고 있다. 이렇게 하면 결국 외부 시스템에 의존하게 되고 함수를 테스트하기가 어려워지므로 별로 내키지 않는다. 이럴때 재스민 스파이가 제격이다. createReservation을 호출하기 전에 saveReservation 함수에 스파이를 심는다. 스파이로 함수 실행 여부를 알 수 있는데, 첫 번째 테스트에 아주 잘 들어맞는다.재스민에서 전역 함수 spyOn을 쓰면 특정 함수를 몰래 들여다볼 수 있다. 이 함수의 첫 번째 인자는 객체 인스턴스, 두 번째 인자는 감시할 함수명이다. 123456789101112131415161718192021222324describe(\"createReservation\", function () { var saver = new ReservationSaver(); var testPassenger = null, testFlight = null; spyOn(saver, 'saveReservation'); beforeEach(function () { testPassenger = { firstName: \"윤지\", lastName: \"김\" }; testFlight = { number: \"3443\", carrier: \"대한항공\", destination: \"울산\" }; }); createReservation(testPassenger, testFlight, saver); expect(saver.saveReservation).toHaveBeenCalled();}) 스파이를 써서 saver 객체의 saveReservation 구현부를 예약 데이터 저장 기능과 무관한 함수로 대체했다. 스파이는 함수를 호출한 시점과 호출 시 전달한 인자까지 정확히 포착하고, 무엇보다 재스민은 어떤 스파이가 한 번 이상 실했됐는지 확인하는 기대식을 지닌 스파이 전용 매처(toHaveBeenCalled())를 지원한다. createReservation 함수의 인자가 늘었으니 기존 두 테스트 역시 수정할 수 밖에 없다. 하지만 saveReservation 함수 구현부를 직접 실행할 테스트는 없을 테니 ReservationSaver 생성 코드와 스파이 관련 코드를 전체 꾸러미의 beforeEach 함수로 옮겨 리팩토링 한다. 123456789101112131415161718192021222324252627282930313233343536describe(\"createReservation\", function () { var testPassenger = null, testFlight = null, testReservation = null, testSaver = null; beforeEach(function () { testPassenger = { firstName: \"윤지\", lastName: \"김\" }; testFlight = { number: \"3443\", carrier: \"대한항공\", destination: \"울산\" }; testSaver = new ReservationSaver(); spyOn(testSaver, 'saveReservation'); testReservation = createReservation(testPassenger, testFlight, testSaver); }); it(\"passenger를 passenger Information 프로퍼티에 할당한다.\", function () { expect(testReservation.passengerInformation).toBe(testPassenger); }); it(\"flight를 flightInformation 프로퍼티에 할당한다.\", function () { expect(testReservation.flightInformation).toBe(testFlight); }); it(\"예약 정보를 저장한다.\", function () { expect(testSaver.saveReservation).toHaveBeenCalled(); });}) 참조: 자바스크립트 패턴과 테스트github","link":"/2020/01/27/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-2/"},{"title":"기본적인 웹 사이트 최적화 방법","text":"HTTP 요청 최소화HTTP 요청 최소화는 최적화에서 가장 기본이면서도 중요한 부분이다. 웹 사이트는 주로 마크업, 이미지, 스타일시트, 자바스크립트 등으로 구성된다. 각 구성 요소는 모두 웹 서버에 있다. 이 구성 요소를 사용자의 컴퓨터로 가져오는 데는 네트워크 비용이 든다. 네트워크 비용은 곧 응답 시간으로 이어진다. 그러므로 다운로드 해야 하는 구성 요소의 개수를 줄이는 것은 가장 효과가 크고 중요한 최적화 방법이다. CSS 스프라이트순수한 HTML 마크업만으로는 표현에 한계가 있기 때문에 어쩔 수 없이 이미지를 사용한다. 하지만 이미지를 많이 사용하면 HTTP 요청이 많아질 수 밖에 없다. 이미지를 많이 사용하면서도 HTTP 요청을 최소화하는 방법 가운데 하나가 CSS 스프라이트 기법이다. CSS 스프라이트 기법은 이미지 여러 개를 하나로 만들고 스타일시트에서 background-position 속성을 설정해 필요한 부분의 이미지만 보여 주는 기술이다. 여러 이미지를 하나의 이미지로 합치기 때문에 HTTP 요청 횟수를 줄일 수 있고, 이미지의 컬러 테이블과 같은 메타데이터를 하나로 합칠 수 있어 파일 크기가 줄어든다. CSS 스프라이트 기법은 이미지를 관리하기 어렵고 웹 접근성을 나쁘게 하는 요소가 있다는 단점이 있다. 하지만 많은 양의 이미지를 사용한다면 많은 시간을 줄일 수 있다. 헤더에 만료 날짜 추가헤더에 만료 날짜를 추가하는 이유는 웹 페이지를 구성하는 여러 요소들을 사용자의 컴퓨터의 캐시에 저장해서 재사용하기 위해서다. 사용자가 처음 웹 페이지에 방문하면 만료 날짜가 설정된 요소를 사용자 컴퓨터에 저장한다. 이후 같은 웹 페이지에 다시 방문하면 유효한 요소는 서버에 요청하지 않고 사용자 컴퓨터에서 바로 읽어 온다. 사용자 컴퓨터에 저장된 캐시 파일캐시에 저장된 파일에는 만료 날짜가 없는 파일도 있고 만료 날짜가 있는 파일도 있다. 모든 구성 요소에 무조건 만료 날짜를 설정하는 것이 아니라 특정 기간까지 변경되지 않아도 서비스에 문제가 없는 요소에만 적용해야 한다.만약 만료 날짜 전에 수정 사항이 있어 파일을 변경해야 한다면 파일 이름을 변경하거나 파일 이름 뒤에 쿼리스트링을 추가해 새로 추가된 파일임을 알려야 바로 반영된다. 1234567&lt;script type=\"text/javascript\" src=\"test.js\"&gt;&lt;/script&gt;// 파일 이름을 변경&lt;script type=\"text/javascript\" src=\"test_0202.js\"&gt;&lt;/script&gt;// 쿼리스트링 추가&lt;script type=\"text/javascript\" src=\"test?0202.js\"&gt;&lt;/script&gt; 브라우저에서 캐싱된 파일을 이용할지 서버에 요청할지 판단하는 기준은 컬럼 이름을 기준으로 이름과 인터넷 주소다. 그렇기 때문에 파일 이름이나 파일의 주소를 바꾸지 않으면 계속 같은 파일로 인식하고 사용자 컴퓨터에 있는 파일을 로딩한다. 자바스크립트 파일 통합기능이 향상됨에 따라 자바스크립트 파일은 개수도 많아지고 크기도 커지고 있다. 이럴 때 성능을 높이는 방법은 여러 개의 자바스크립트 파일을 하나의 파일로 합쳐 파일 개수를 최소화하는 것이다. 웹 사이트의 성능을 개선할 때는 파일의 용량보다 파일의 개수가 중요하다. 아주 용량이 작은 파일이라도 원격 서버에서 가져와야 한다면 네트워크 비용이 든다. 파일 크기 최소화Gzip 압축을 이용한 파일 크기 최소화점점 커지는 자바스크립트 파일과 스타일시트 파일의 크기를 줄이는 가장 효과적이고 쉬운 방법은 파일을 압축하는 것이다. 아파치 웹 서버에서 파일을 압축하는 대표적인 인코딩 방식에는 Gzip과 deflate 두 가지가 있는데, deflate 방식은 지원하지 않는 브라우저가 많고 효과도 떨어지기 때문에 대부분 Gzip 방식을 사용한다. 압축 전송 흐름 및 확인압축 전송은 다음과 같은 순서로 진행된다. 클라이언트에서 some.js 라는 파일을 만났을 때를 가정해보자. 클라이언트에서 헤더 정보로 인코딩 여부를 물어본다. Accept-Encoding: gzip, deflate (Header) 서버에서 헤더 정보로 인코딩 여부를 알려준다. 인코딩된 요소라면 다음과 같이 응답이 온다. Content-Encoding: gzip 클라이언트에서 인코딩된 요소를 받음과 동시에 압축을 해제한다. 이때 추가적인 CPU 연산 비용이 들어간다. 여기서 발생하는 CPU 연산 비용도 무시할 수 없기 때문에 압축할 파일과 크기를 잘 설정해야한다. 보통 스타일시트 파일과 자바스크립트 파일을 압축한다. 그리고 파일 크기가 작으면 속도 개선 효과보다 CPU 연산 비용이 더 들기 때문에 파일 크기가 일정한 크기 이상인 경우에만 압축하는 것이 좋다. 파일 크기가 1~2KB 이상일때 압축할 것을 권장한다. 압축 전송의 효과Gzip으로 압축해 전송하면 평균 70% 정도 파일 크기가 작아지는 효과를 볼 수 있다. 모바일 환경과 같이 네트워크 환경이 불안한 상황에서는 더욱 효과적인 기술일 것이다.파일의 공백 및 주석을 제거하고 Gzip 으로 압축을 진행하면 파일 크기를 최소화 시킬 수 있다. 쿠키 크기 최소화필요한 정보를 저장하는 가장 손쉬운 방법이 최상위 도메인을 이용해 쿠키를 설정하는 방법이다. 이렇게 되면 자바스크립트 파일이나 스타일시트, 이미지등 쿠키 정보가 필요 없는 구성 요소를 요청할 때도 헤더 정보에 쿠키가 포함된다. 즉 헤더를 전송할 때 데이터 크기가 커진다. 쿠키의 크기를 줄이는 기본적인 방법 지속적인 관리로 사용하지 않는 쿠키는 삭제한다. 쿠키를 설정할 때 최상위 도메인은 되도록 사용하지 않는다. 쿠키 정보가 필요없는 파일은 별도의 도메인으로 서비스한다. 렌더링 성능 향상전체적인 로딩 속도는 동일한데 빈 페이지가 계속 보이다 갑자기 콘텐츠가 나타나는 페이지가 있고, 처음부터 콘텐츠가 조금씩 보이며 화면이 빠르게 나타나는 페이지가 있다. 렌더링 성능 향상의 목표는 페이지를 요청했을 때 사용자가 대기하는 시간을 최대한 줄여서 이 체감 속도를 높이는 것이다. 브라우저 파싱 순서 HTML 파싱과 DOM 트리 구성사용자가 페이지를 요청하면 네트워크를 통해 마크업을 받아 온다. 그 후 마크업 문자열을 토큰 형태로 잘라서 트리를 구축하고 파싱 작업을 시작한다. 그런 다음 DOM 트리를 생성한다. 렌더트리 구성(DOM + 스타일규칙)DOM 트리를 생성한 다음 바로 화면을 그리지는 않는다. 스타일시트의 정보를 적용해야 하기 떄문이다. DOM 트리 정보와 스타일시트의 스타일 규칙을 결합해 렌더 트리를 만든다. display:none 속성처럼 DOM 트리에는 있지만 화면에 보이면 안되는 요소를 걸러낸 결과가 렌더 트리다. 렌더 트리의 배치스타일 규칙에 따라 각 요소를 화면의 어디에 배치할지 좌표를 설정한다. 렌더 트리 그리기요소의 좌표가 설정되면 브라우저에 순차적으로 화면에 그린다. 이때 사용자는 화면을 조금씩 보게 된다. 스타일시트와 자바스크립트 배치를 이용한 성능 향상스타일시트 파일은 페이지 제일 위쪽에, 자바스크립트 파일은 페이지 맨 아래쪽에 놓아야 한다.브라우저 렌더링 단계에 따르면 사용자에게 화면을 보여 주기 전에 렌더 트리를 생성해야 하는데, 이때 스타일시트 파일이 반드시 필요하다. 스타일시트 파일을 최대한 빨리 다운로드 해야 하는 이유다. 자바스크립트 파일을 페이지 아래에 놓아야 하는 가장 큰 이유는 파일을 다운로드해서 실행하기 전까지 브라우저가 DOM 파싱도 중지하고 아무것도 렌더링하지 않기 때문이다. 자바스크립트에는 document.write() 메서드가 있어 마크업을 렌더링하는 도중에도 DOM을 추가할 수 있다. 이로 인해 이미 필요한 구성 요소를 모두 브라우저에 가져왔음에도 자바스크립트를 수행하느라 렌더링이 멈추게 된다. 이때 사용자에게는 마치 화면이 멈춘 것처럼 보여 체감 속도가 느려진다. 초기 렌더링시 AJAX 요청 최소화동적인 웹 사이트에서 화면을 그리는 단계는 일반적으로 다음과 같다. 사용자가 페이지를 요청 마크업을 다운로드해 렌더링 시작 (화면을 구성하는 레이아웃만 있고 실제로 보여줄 데이터는 나중에 AJAX 요청을 통해 받은 다음 그려야함) 자바스크립트 다운로드와 렌더링이 끝난 후 onload 이벤트가 발생 onload 이벤트가 발생한 다음에 AJAX 통신을 실행하고 데이터를 화면에 그린다. 화면 완성 이 과정에는 두 가지 큰 문제점이 있다. AJAX 통신을 사용하지 않는 방법으로 페이지를 개발했다면 3번 단계에서 사용자는 화면을 보게 된다. 그런데 5번 단계가지 가서야 사용자는 최종 화면을 볼 수 있다. 또 다른 문제는 렌더링이 반복된다는 것이다. 1~3번 단계까지 전체 화면을 한 번 그리고 4~5번 단계에서 화면을 한 번 더 그린다. 초기 렌더링 시에 마크업 전체를 서버에서 보내는 방식으로 개발하여 체감 속도를 높일 수 있다. 1~3 단계에서 전체 화면과 데이터가 있는 화면을 모두 그리는 것이다. 그리고 사용자의 행동이 있을 때 AJAX 요청을 실행해서 데이터를 받은 다음 화면을 그리게 한다. 참조: 자바스크립트 성능 이야기","link":"/2020/02/02/%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95/"},{"title":"값에 대해","text":"함수로 협업하는 가장 좋은 방법은 인자와 리턴값으로만 소통하는 것이다. 순수하게 인자와 리턴값에만 의존하면 누가 만든 함수든 어떤 라이브러리로 만든 함수든 조립할 수 있게 된다. 이때 함수에서 다루는 값으로 자바스크립트의 기본 객체를 사용하거나 아주 보편적으로 약속된 객체만 사용하면 함수들 간의 조합성이 더욱 좋아진다. 여기서 말하는 기본 객체란 Array, Object, String, Number, Boolean, Null, Undefined 등의 자바스크립트 기본 객체를 말하며, 브라우저의 DOM 같은 것들도 범주 안에 들어올 수 있다. 어떤 프로퍼티와 어떤 메서드를 가지고 있는지 충분히 약속되고 보장된 값들을 말한다. 약속된 스펙을 가진 값들만 사용하는 함수들은 언제나 어떤 환경에서나 사용하기 편하다. 순수 함수순수 함수와 부수 효과순수 함수는 동일한 인자가 들어오면 항상 동일한 값을 리턴하는 함수다. 메서드가 자신이 가진 내부의 상태에 따라 다른 결과를 만든다면, 순수 함수는 들어온 인자와 상수만 사용하여 항상 동일한 결과를 리턴한다.또 하나 중요한 특징이 있는데, 바로 외부의 상태를 변경하지 않는다는 점이다. 함수에게 들어온 인자를 포함하여, 외부와 공유되고 있는 값 중 함수가 참조할 수 있는 어떤 값도 변경하지 않는 것을 말한다. 함수가 외부 상태를 변경하면, 외부 상태와 연관이 있는 다른 부분에도 영향이 있고 이것을 부수 효과(Side effect)라고 한다. 부수 효과 문제는 특히 동시성이 생길 때 더욱 취약하다. 브라우저나 Node.js는 다양한 작업을 동시에 처리한다. 이렇게 동시성이 생기는 상황에서는 여러 곳에서 공유되도 있는 값이 변경되는 것은 위험하다. 부수 효과는 단지 동시성에서만의 이슈가 아니다. 예를 들면 사용자가 오랫동안 인터랙션을 해서 상태를 지속적으로 관리해야 하는 웹 페이지나 앱의 코드들에서 부수 효과 문제가 생기는 경우가 많다. 순수 함수의 정의를 아는 것보다 중요한 점은 여기에 담긴 목적과 전략이다. 순수 함수에 담긴 전략은 그 이름처럼 간단 명료하다. 상태 변화를 최소화하고, 다음 단계로 넘어갈 때마다 새로운 값으로 출발하는 식으로 코딩하는 것이다. 이렇게 하면 문제가 쉬워진다. 문제가 단순해지면 해결책 역시 쉬워지고 오류를 만들 가능성도 줄어든다. 작은 순수 함수들을 모아 만든 소프트웨어는 유지 보수와 기획 변경에 유연하게 대응한다. 순수 함수와 순수 함수가 아닌 함수1234567891011121314151617181920// 순수 함수function add(a, b) { return a + b;}// 순수 함수가 아닌 함수function add2(obj, value) { obj.value = obj.value + value; return obj.value;}// 작은 차이지만 순수 함수function add3(obj, value) { return obj.value + value;}// 작은 차이지만 순수 함수 2function add4(obj, value) { return { value: obj.value + value };} add는 인자를 받아 새로운 값을 리턴했고 add2는 obj의 상태를 변경한다. add는 인자가 같으면 항상 결과가 같고 부수 효과가 없다. add2는 obj.value의 상태에 따라 결과가 달라진다. 이런 점 자체가 문제를 만들지는 않지만 만일 obj.value를 사용하는 코드가 add2 외에 다른 곳에도 있다면 반드시 obj.value가 변경될 수 있다는 점과 변경될 시점 등을 정확히 인지하고 제어해야 할 것이다. add3과 add4는 작은 차이가 있지만 순수 함수다. obj.value를 참조만 하고 있기 때문이다. 순수 함수를 만들기 위해 항상 모든 값을 새로 만들어야 하는 것은 아니다. 조회 자체는 부수 효과를 일으키지 않는다. 순수 함수로 프로그래밍을 한다면 add 같은 작은 기능의 함수만 만들어지는 게 아닌가 하는 생각이 들 수 있다. 클래스나 객체처럼 풍부한 기능을 가진 모듈을 만들 수 없을 것만 같을 수 있다. 하지만 인자로 함수를 사용하거나 고차 함수를 이용한 함수 조합을 통해 순수 함수의 조건을 따르면서 보다 풍부한 변화를 불러오는 함수들을 만들 수 있다. 변경 최소화와 불변 객체직접 변경하는 대신, 변경된 새로운 값을 만드는 전략대부분 이미 확인한 함수들이지만 이번에는 값과 값을 변경해 나가는 것에 초점을 두고 설명하고자 한다. 123456789101112131415161718192021var users1 = [ { name: \"ID\", age: 32 }, { name: \"HA\", age: 25 }, { name: \"BJ\", age: 32 }, { name: \"PJ\", age: 28 }, { name: \"JE\", age: 27 },];var comparator = function (a, b) { if (a.age &lt; b.age) return -1; if (a.age &gt; b.age) return 1; return 0;};var sortedUsers1 = users1.sort(comparator) // 1console.log(users1 === sortedUsers1) // 2 trueconsole.log(_.pluck(sortedUsers1, 'age')); // 3 [25, 27, 28, 32, 32]console.log(_.pluck(users1, 'age')); // 4 [25, 27, 28, 32, 32] users1을 나이순으로 정렬하는 예제다. Array.prototype.sort는 자기 자신을 정렬하는 함수다. 2의 결과가 true라는 것은 둘이 완전히 같은 객체라는 뜻이다. 동일한 값을 가진 객체가 아닌 완전히 같은 객체라는 것이다. 1의 .sort() 메서드는 자기 자신을 바꾸고 자기 자신을 리턴한다. 3 _.pluck 를 통해 age 값만 꺼내보면 둘다 동일하게 정렬이 된 것을 확인할 수 있는데, users1과 sortedUsers1이 완전히 같은 값이어서 동일한 결과가 출력된 것이다. 1234567891011121314151617var users2 = [ { name: \"ID\", age: 32 }, { name: \"HA\", age: 25 }, { name: \"BJ\", age: 32 }, { name: \"PJ\", age: 28 }, { name: \"JE\", age: 27 },];var sortedUsers2 = _.sortBy(users2, 'age') // 1console.log(users2 === sortedUsers2) // 2 falseconsole.log(_.pluck(sortedUsers2, 'age')) // 3 [25, 27, 28, 32, 32]console.log(_.pluck(users2, 'age')) // 4 [32, 25, 32, 28, 27]console.log(users2[1] === sortedUsers2[0]); // 5 true 이번에는 _.sortBy 함수를 이용하여 정렬을 해 보았다. 2를 확인해 보면 false가 나온다. 1에서 리턴된 sortedUser2는 새로운 객체다. 3,4 를 확인해 보면 sortedUsers2는 나이순으로 정렬이 되었는데, users2 는 원본 그대로임을 알 수 있다. 다른 곳에 users2의 순서에 의존하여 동작하고 있는 코드가 있다면, sortedUsers2 처럼 새로운 객체를 만들어 정렬을 하는 방식이 부수 효과가 없고 유리하다. sortedUser2는 새로운 값이다. 그렇다면 배열 안의 값들도 새로운 값일까? 서로 다르게 정렬이 되어 있지만, 두 배열 안에 있는 모든 값은 새로운 값이 아닌 기존의 값이다. 항상 배열 내의 모든 값을 새롭게 만든다면 메모리 사용량이 매우 높아질 것이다. _.sortBy는 내부의 값은 기존의 값을 그대로 활용하면서 배열만 새로 만들어 정렬한다. Undescore.js의 콘셉트 중에는 이러한 중요한 전략이 있다. 이 전략을 잘 따르면 부수 효과를 줄이면서도 메모리 사용량 증가는 최소화하는 좋은 함수들을 만들 수 있다. 그것은 바로 그함수가 변경할 영역에 대해서만 새 값을 만드는 전략이다. 예를 들어 자신의 역할이 정렬이라면 정렬과 연관 있는 부분만 새 값으로 만들고 나머지 값들은 재활용하는 식이다. 이 전략을 대부분의 함수적 함수에 적용된다. 1234567var rejectedUsers2 = _.reject(users2, function (user) { return user.age &lt; 30; });console.log(rejectedUsers2);// [{name: \"ID\", age: 32}, {name: \"BJ\", age: 32}]console.log(rejectedUsers2 === users2) // falseconsole.log(rejectedUsers2.length, users2.length); // 2 5 console.log(rejectedUsers2[0] === users2[0]) // true 배열 내부의 값 중 특정 조건의 값들을 제외하는 _.reject 같은 함수도 배열 내부의 값들을 지우는 것이 아니라 값들이 지워진 새로운 배열을 만드는 것이다. _.reject도 결국 같은 전략을 따른 것이다. _.reject 함수의 역할은 값을 제외하는 것이고 달라지는 영역은 배열이기에 배열을 새로 만드는 것이다. users2에서 30세 미만인 사람들을 제외했다. 더 정확히 말하면 30세 미만인 사람들이 제외된 새로운 배열을 만들어 리턴했다. rejectedUsers2는 users2가 아니며, users2.length도 그대로이고, 배열 내부의 값들도 기존의 값 그대로다. users2를 다루면서 새로 정렬하고 배열 내부의 값도 지웠지만, users2는 원래 상태 그대로이다. 123456789101112131415// 1console.log( _.pluck(_.reject(users2, function (user) { return user.age &gt;= 30; }), 'name'))// [\"HA\", \"PJ\", \"JE\"]// 2console.log( _.pluck(users2, 'name'))// [\"ID\", \"HA\", \"BJ\", \"PJ\", \"JE\"]// 3console.log(users2)// 원본 그대로 1 users에서는 _.reject로 30세 이상의 user를 제외한 새 배열을 만든 후, _.pluck을 통해 이름만 추출한 새 배열을 만들어 로그를 남겼다. _.reject를 이용해 users2의 상태를 변경하지 않으면서 필터링을 했고, _.pluck 를 통해 역시 원본 소스들을 건들지 않고 name이 추출된 새로운 배열을 만들었다. 따라서 원본 데이터에는 아무런 영향을 끼치지 않았다. 그 덕분에 2에서는 어려움 없이 원본에 있는 모든 이름을 출력할 수 있다. 2가 실행된 후에도 3 users는 역시 변경되지 않는다. 123456789var b1 = [1, 2, 3, 4, 5];var b2 = _.initial(b1, 2); // 뒤에서 2개 제거한 새로운 배열 리턴console.log(b1 === b2, b1, b2);// false (5) [1, 2, 3, 4, 5] (3) [1, 2, 3]var b3 = _.without(b1, 1, 5); // 1과 5를 제거한 새로운 배열 리턴var b4 = _.without(b3, 2); // 2를 제거한 새로운 배열 리턴console.log(b1 === b3, b3 === b4, b3, b4);// false false (3) [2, 3, 4] (2) [3, 4] 맨 마지막에 b4를 만들 때, b3 에서 2를 제거했지만 b3에는 여전히 2가 남아있다. _.clone 으로 복사하기_.clone은 배열이나 객체를 받아 복사하는 함수다. 123456789101112131415161718192021var product1 = { name: \"AB 반팔티\", price: 10000, sizes: [\"M\", \"L\", \"XL\"], colors: [\"Black\", \"White\", \"Blue\"]};var product2 = _.clone(product1);console.log(product2);// {// name: \"AB 반팔티\",// price: 10000,// sizes: [\"M\", \"L\", \"XL\"],// colors: [\"Black\", \"White\", \"Blue\"]// }console.log(product1 === product2); // falseproduct2.name = \"ABCD 반팔티\";console.log(product1.name, product2.name);// AB 반팔티 ABCD 반팔티 product1을 _.clone 함수를 통해 복사했다. 동일한 내용이 들어 있는 새로운 객체가 리턴되어, 출력해 보면 내용은 같지만 비교하면 false가 나온다. product2.name 을 변경해도 product1에는 영향을 끼치지 않는다. product2를 마음 편히 다룰 수 있다.그런데 _.clone을 정확히 다루려면 _.clone이 객체를 복하는 범위에 대해 제대로 알아야 한다. _.clone이 객체를 복사하는 것은 맞지만 객체 내부의 모든 값들까지 복사하는 것은 아니다. 123456product2.sizes.push(\"2XL\");console.log(product2.sizes);// [\"M\", \"L\", \"XL\", \"2XL\"]console.log(product1.sizes);// [\"M\", \"L\", \"XL\", \"2XL\"]console.log(product1.sizes === product2.sizes); // true _.clone은 동일한 key들을 가진 새로운 객체를 만들면서 각 key에 기존의 key에 해당하는 value를 할당한다. 때문에 내부의 값이 객체라면 같은 객체를 바라보게 된다. 1234567891011121314151617181920212223_.clone = function (obj) { var cloned = _.isArray(obj) ? [] : {}; var keys = _.keys(obj); _.each(keys, function (key) { cloned[key] = obj[key]; // Array일때는 key가 숫자 }); return cloned;}var obj1 = { a: 1, b: 2, c: { d: 3 } };var obj2 = _.clone(obj1);obj2.b = 22;console.log(obj2);// { a: 1, b: 22, c: { d: 3 } };console.log(obj1);// { a: 1, b: 2, c: { d: 3 } };console.log(obj1 === obj2); // falseconsole.log(obj1.c === obj2.c); // trueobj2.c.d = 33;console.log(obj1.c.d) // 33 obj1도 같이 변경 그렇다면 객체 안의 객체를 변경하고 싶은 경우에는 어떻게 해야 원본에 영향을 주지 않으면서 값을 변경할 수 있을까? 12345678910111213141516171819202122var product1 = { name: \"AB 반팔티\", price: 10000, sizes: [\"M\", \"L\", \"XL\"], colors: [\"Black\", \"White\", \"Blue\"]};var product2 = _.clone(product1);product2.sizes = _.clone(product2.sizes); // 내부도 clone 후 push를 하거나product2.sizes.push(\"2XL\")console.log(product2.sizes);// [\"M\", \"L\", \"XL\", \"2XL\"]console.log(product1.sizes);// [\"M\", \"L\", \"XL\"]console.log(product1.sizes === product2.sizes); // falseproduct2.colors = product2.colors.concat(\"Yellow\") // 아니면 concat으로 한번에console.log(product2.colors);// [\"Black\", \"White\", \"Blue\", \"Yellow\"]console.log(product1.colors);// [\"Black\", \"White\", \"Blue\"]console.log(product1.colors === product2.colors); // false 위와 같이 하면 된다. 어차피 내부의 값도 복사하는 식으로 값을 다뤄야 한다면 왜 굳이 객체의 첫 번째 깊이만 복사하느냐고 생각할 수 있다. 값 복사 후 항상 내부의 모든 값을 변경할 것이 아니기에, 객체 내부의 객체는 공유하는 것이 메모리 사용에 유리하고, 복사 수행 처리 시간이라는 측면에서도 이점이 많다. _.extend, _.defaults로 복사하기_.extend나 _.defaults를 이용하면 값 복사와 변경을 좀 더 간결하게 할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var product1 = { name: \"AB 반팔티\", price: 10000, sizes: [\"M\", \"L\", \"XL\"], colors: [\"Black\", \"White\", \"Blue\"]};// 1var product2 = _.extend({}, product1, { name: \"AB 긴팔티\", price: 15000});// 2var product3 = _.defaults({ name: \"AB 후드티\", price: 15000}, product1);console.log(product2);// {// name: \"AB 긴팔티\",// price: 15000,// sizes: [\"M\", \"L\", \"XL\"],// colors: [\"Black\", \"White\", \"Blue\"]// };console.log(product3);// {// name: \"AB 후드티\",// price: 15000,// sizes: [\"M\", \"L\", \"XL\"],// colors: [\"Black\", \"White\", \"Blue\"]// };// 3var product4 = _.extend({}, product3, { colors: product3.colors.concat(\"Purple\")});var product5 = _.defaults({ colors: product4.colors.concat(\"Red\")}, product4);console.log(product3.colors);// [\"Black\", \"White\", \"Blue\"]console.log(product4.colors);// [\"Black\", \"White\", \"Blue\", \"Purple\"]console.log(product5.colors);// [\"Black\", \"White\", \"Blue\", \"Purple\", \"Red\"] product2는 값 복사를 위해 새로운 객체인 {} 를 _.extend의 첫 번째 인자로 넣었다. 어차피 {name: “AB 후드티”, price: 12000}도 새 객체이므로 product3처럼 _.defaults를 이용하는 것이 객체를 적게 생성해서 더 효율적이다. _.extend의 경우, 왼쪽 객체에 없는 key/value는 확장하고, 왼쪽 객체에 있던 key/value는 덮어 쓴다. _.defaults는 왼쪽에 없는 key/value만 확장한다. 1, 2를 보면 _.clone 없이 복사와 변경을 동시에 하여 간결해졌지만, colors 처럼 깊은 값을 변경해야 할 경우에는 직접 다뤄줘야 한다. _.extend와 _.defaults 역시 변경이 필요 없는 값은 이전의 값을 공유한다. 참조: 함수형 자바스크립트 프로그래밍","link":"/2019/12/29/%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%B4/"},{"title":"도구 다루기-3","text":"의존성 주입이란?ConferenceWebSvc 객체에 서비스를 캡슐화하고 메시지를 화면에 표시할 자바스크립트 객체 Messenger를 작성한다. 참가자는 1인당 세션을 10개까지 등록할 수 있다. 참가자가 한 세션을 등록하면 그 결과를 성공/실패 메시지로 화면에 표시하는 함수를 개발해야 한다. 아래 코드는 해당 기능을 구현하기 위한 초기 버전이다. 123456789101112131415161718192021Attendee = function (attendeeId) { // 'new'로 생성하도록 강제 if (!(this instanceof Attendee)) { return new Attendee(attendeeId); } this.attendeeId = attendeeId; this.service = new ConferenceWebSvc(); this.messenger = new Messenger();}// 주어진 세션에 좌석 예약을 시도하고 성공/실패 여부를 메시지로 알려줌.Attendee.prototype.reserve = function (sessionId) { if (this.service.reserve(this.attendeeId, sessionId)) { this.messenger.success( `좌석 예약이 완료되었습니다! 고객님은 ${this.service.getRemainingReservations()} 좌석을 추가로 예약하실 수 있습니다.` ); } else { this.messenger.failure('죄송합니다. 해당 좌석은 예약하실 수 없습니다.'); }} 이 코드는 ConferenceWebSvc, Messenger, Attendee 객체가 각자 자신만의 임무를 갖고 모듈로 조화를 이룬것 처럼 보인다. Attendee.reserve는 너무 간단해서 굳이 단위 테스트를 하지 않아도 되는데, 어차피 그럴 수도 없다. ConferenceWebSvc 내부에는 HTTP 호출이 있다. Messenger는 메시지마다 OK 버튼이 있어야 하는데, 이 또한 이 모듈에서 단위 테스트할 대상은 아니다. 단위 테스트는 자바스크립트 코드를 바르게 작성하기 위한 핵심인데, 모든 단위가 미처 준비도 되기 전에 시스템 테스트의 늪으로 빠지는 게 싫다. 요는, Attendee 객체가 아니라 이 객체가 의존하는 코드다. 의존성을 주입하는 식으로 바꾸면 해결할 수 있다. 즉, ConferenceWebSvc와 Messenger와의 의존성을 하드 코딩하지 말고 이들을 Attendee에 주입하는 것이다. 실제 운영 환경에서는 진짜 의존성을 주입하겠지만, 단위 테스트용으로는 모의체(fake)나 재스민 스파이 같은 대체제를 주입하면 된다. 12345// 운영 환경:var attendee: new Attendee(new ConferenceWebSvc(), new Messenger(), id);// 개발 환경:var attendee = new Attendee(fakeService, fakeMessenger, id); 이처럼 의존성을 주입하는 것을 두고 ‘빈자의 의존성 주입’이라 한다. 아래 코드는 빈자의 의존성 주입 방식으로 작성한 Attendee 객체다. 12345678910Attendee = function (service, messenger, attendeeId) { // 'new'로 생성하도록 강제 if (!(this instanceof Attendee)) { return new Attendee(attendeeId); } this.attendeeId = attendeeId; this.service = service; this.messenger = messenger;} 의존성을 주입하여 믿음직한 코드 만들기의존성을 주입하여 다른 방법으로는 할 수 없는 단위 테스트를 어떻게 하는지 알았다. 아무래도 테스트를 통과한, 자동화한 테스트 꾸러미로 계속 테스트할 수 있는 코드가 더 믿음직하다. 이 뿐만 아니라, 의존성 주입은 실제 객체보다 주입한 스파이나 모의 객체에 더 많은 제어권을 안겨주므로 다양한 에러 조건과 기이한 상황을 만들어내기 쉽다. 의존성 주입은 코드 재사용을 적극적으로 유도한다. 의존성을 품은, 하드 코딩한 모듈은 보통 재사용하기 어렵다. 초기 Attendee 모듈도 Messenger를 하드 코딩하여 쓴 탓에 서버 측에서 재사용할 수 없었다. 의존성 주입으로 바꾼 다음에는 성공/실패 메서드만 있으면 어떤 messenger 라도 사용할 수 있다. 의존성 주입의 모든 것의존성 주입은 어렵지 않다. 몇 가지 개념만 기억하면 잘 활용할 수 있다.어떤 객체를 코딩하든 어떤 객체를 생성하든 스스로 다음 질문을 해봤을때 한 가지라도 답변이 ‘예’ 라면 직접 인스턴스화 하지 말고 주입하는 방향으로 생각을 전환해야 한다. 객체 또는 의존성 중 어느 하나라도 DB, 설정 파일, HTTP, 기타 인프라 등의 외부 자원에 의존 하는가 객체 내부에서 발생할지 모를 에러를 테스트에서 고려해야 하나 특정한 방향으로 객체를 작동시켜야 할 테스트가 있는가 서드파티 제공 객체가 아니라 온전히 내가 소유한 객체인가 경량급 의존성 주입 프레임워크 개발지금까지는 의존성 주입을 하드 코딩했다. 전문가다운 의존성 주입 프레임워크는 이렇게 작동한다. 애플리케이션이 시작되자마자 각 인젝터블(주입 가능한 모든 의존성을 집합적으로 일컫는 말) 명을 확인하고 의존성을 지칭하며 순서대로 DI 컨테이너에 등록한다. 객체가 필요하면 컨테이너에 요청한다. 컨테이너는 일단 요청받은 객체와 그 의존성을 모두 재귀적으로 인스턴스화한다. 그리고 요건에 따라 필요한 객체에 각각 주입한다. 컨테이너는 인젝터블과 의존성을 등록하고 요청시 객체를 내어주는 두 가지 일을 한다. register 함수의 인자는 세 가지를 받는다. 인젝터블 명 의존성 명을 담은 배열 인젝터블 객체를 반환하는 함수. 인젝터블 인스턴스를 요청하면 컨테이너는 이 함수를 호출하여 반환 값을 다시 그대로 반환한다. TDD는 단계마다 가급적 조금씩 코딩하는게 좋다. 먼저 빈 DiContainer와 register 함수를 생성한다. 1234567DiContainer = function() {};DiContainer.prototype.register = function(name, dependencies, func) {}; 12345678910111213141516171819202122232425262728describe('DiContainer', function () { var container; beforeEach(function () { container = new DiContainer(); }); describe('register(name,dependencies,func)', function () { it('인자가 하나라도 빠졌거나 타입이 잘못되면 예외를 던진다.', function () { var badArgs = [ // 인자가 아예 없는 경우 [], ['Name'], ['Name', ['Dependency1', 'Dependency2']], ['Name', function () { }], // 타입이 잘못된 경우 [1, ['a', 'b'], function () { }], ['Name', [1, 2], function () { }], ['Name', ['a', 'b'], 'should be a function'] ]; badArgs.forEach(function (args) { expect(function () { container.register.apply(container, args); }).toThrowError(container.messages.registerRequiresArgs); }); }) });}) container는 ‘테스트 대상’으로 beforeEach에서 생성된다. 테스트마다 인스턴스를 갓 구워내면 다른 테스트의 결과를 어지럽히지 않아도 된다. TDD 순수주의자는 badArgs 원소마다 테스트를 따로 만들라고 하겠지만, 실제로 그렇게까지 개발자에게 부담을 주면 필요한 조건을 모두 테스트하기도 전에 질려버릴지도 모른다. 위의 테스트는 당연히 실패한다. DiContainer에 수정이 필요하다. 123456789101112131415161718192021222324252627DiContainer = function () { if (!(this instanceof DiContainer)) { return new DiContainer(); }};DiContainer.prototype.messages = { registerRequiresArgs: '이 생성자 함수는 인자가 3개 있어야 합니다. 문자열, 문자열 배열, 함수'}DiContainer.prototype.register = function (name, dependencies, func) { var ix; if ( typeof name !== 'string' || !Array.isArray(dependencies) || typeof func !== 'function' ) { throw new Error(this.messages.registerRequiresArgs); } for (ix = 0; ix &lt; dependencies.length; ++ix) { if (typeof dependencies[ix] !== 'string') { throw new Error(this.messages.registerRequiresArgs); } }}; register 함수는 여전히 아무 일도 하지 않지만, 이 함수만으로는 의존성을 다시 끌어낼 방법이 없으므로 컨테이너에 의존성이 잘 들어갔는지 테스트하기 어렵다. 따라서 자연스레 나머지 반쪽 그림에 해당하는 get 함수에 관심이 쏠린다. 이 함수의 유일한 인자는 조회할 의존성 명이다. 123456789DiContainer.prototype.get = function (name) {}describe('get(name)', function () { it('성명이 등록되어 있지 않으면 undefined를 반환한다.', function () { expect(container.get('notDefined')).toBeUndefined(); }) }) 이제 get 함수 작성과 DiContainer 를 수정한다. 12345678910111213141516171819202122232425262728DiContainer = function () { ... this.registrations = [];};DiContainer.prototype.register = function (name, dependencies, func) { ... this.registrations[name] = { func: func };};DiContainer.prototype.get = function (name) { var registration = this.registrations[name]; if (registration === undefined) { return undefined; } return registration.func();}it('등록된 함수를 실행한 결과를 반환한다.', function () { var name = 'MyName', returnFromRegisteredFunction = \"something\"; container.register(name, [], function () { return returnFromRegisteredFunction; }); expect(container.get(name)).toBe(returnFromRegisteredFunction);}) 이제 get은 자신이 반환하는 객체에 의존성을 제공할 수 있다. 아래 코드는 1개의 메인 객체와 2개의 의존성을 등록하는 테스트로, 메인 객체는 두 의존성의 반환값을 합한 값을 반환한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849DiContainer.prototype.register = function (name, dependencies, func) { ... this.registrations[name] = { dependencies: dependencies, func: func };};DiContainer.prototype.get = function (name) { var self = this, registration = this.registrations[name], dependencies = []; if (registration === undefined) { return undefined; } registration.dependencies.forEach(function (dependencyName) { var dependency = self.get(dependencyName); dependencies.push(dependency === undefined ? undefined : dependency); }); return registration.func.apply(undefined, dependencies);}it('등록된 함수에 의존성을 제공한다.', function () { var main = 'main', mainFunc, dep1 = 'dep1', dep2 = 'dep2'; container.register(main, [dep1, dep2], function (dep1Func, dep2Func) { return function () { return dep1Func() + dep2Func(); }; }); container.register(dep1, [], function () { return function () { return 1; } }); container.register(dep2, [], function () { return function () { return 2; } }); mainFunc = container.get(main); expect(mainFunc()).toBe(3);}); 참조: 자바스크립트 패턴과 테스트github","link":"/2020/02/02/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3/"},{"title":"도구 다루기","text":"테스팅 프레임워크한 여행사의 차세대 예약 시스템 구축 프로젝트에 참여하여 항공 예약 데이터 생성 모듈을 맡게 되었는데, 그중에는 작동 명세가 다음과 같은 모듈 함수가 있었다.‘승객(passenger) 객체, 항공편(flight) 객체를 입력받은 createReservation은 passengerInformation 프로퍼티가 승객 객체, flightInformation 프로퍼티가 항공편 객체인 새로운 객체를 반환한다.’ 123456function createReservation(passenger, flight) { return { passengerInfo: passenger, flightInfo: flight }} 팀 규정상 단위 테스트 없이 제품 코드를 체크인할 수 없으므로 단위 테스트 작성은 반드시 필요하다.참조할 함수는 이미 구현됐으니 어려운 일이 아니다. 123456789101112131415161718192021222324252627282930313233describe('createReservation(passenger, flight', function () { it('주어진 passenger를 passengerInfo 프로퍼티에 할당한다.', function () { var testPassenger = { firstName: '길동', lastName: '홍' }; var testFlight = { number: '3443', carrier: '대한항공', destination: '울신' }; var reservation = createReservation(testPassenger, testFlight); expect(reservation.passengerInfo).toBe(testPassenger); }); it('주어진 filght를 flightInfo 프로퍼티에 할당한다.', function () { var testPassenger = { firstName: '길동', lastName: '홍' }; var testFlight = { number: '3443', carrier: '대한항공', destination: '울신' }; var reservation = createReservation(testPassenger, testFlight); expect(reservation.flightInfo).toBe(testFlight); });}); 위의 코드는 재스민 테스팅 프레임워크로 작성한 단위 테스트 코드다.it 함수 각자는 개별 단위 테스트고(위 코드에서는 2개의 단위 테스트), 이들은 함수에서 반환된 객체의 속성이 적절한지 expect 함수로 검사한다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link data-require=\"jasmine@*\" data-semver=\"2.0.0\" rel=\"stylesheet\" href=\"http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine.css\" /&gt; &lt;script data-require=\"jasmine@*\" data-semver=\"2.0.0\" src=\"http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine.js\"&gt; &lt;/script&gt; &lt;script data-require=\"jasmine@*\" data-semver=\"2.0.0\" src=\"http://cdn.jsdelivr.net/jasmine/2.0.0/jasmine-html.js\"&gt; &lt;/script&gt; &lt;script data-require=\"jasmine@*\" data-semver=\"2.0.0\" src=\"http://cdn.jsdelivr.net/jasmine/2.0.0/boot.js\"&gt; &lt;/script&gt; &lt;script src=\"TestFrameworks_01.js\"&gt;&lt;/script&gt; &lt;script src=\"TestFrameworks_01_test.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 위와 같이 html 파일을 추가하고 단위 테스트를 실행한다.자세히 들여다 보니 단위테스트에 오류가 보인다. 반환된 예약 객체의 속성명은 passengerInformation과 flightInformation이라고 명세에 나와 있는데, passengerInfo와 flightInfo로 잘못 코딩한 것이다. 명세가 아니라 함수 코드의 개발에 따라 테스트를 작성한 탓에 테스트는 기대하는 함수 작동이 아닌, 구현된 함수의 잘못된 실제 작동을 확인한 꼴이다. 명세 기준으로 테스트 코드를 작성했으면 속성명을 틀릴 일이 없었을 것이다. 잘못된 코드 발견하기TDD는 코드 결함을 최대한 빨리, 곧 코드 생성 직후 감지하며, 작은 기능 하나라도 테스트를 먼저 작성한 뒤, 취소한의 코드만으로 기능을 구현한다.createReservation 함수로 다시 돌아가 테스트를 먼저 작성하면 어떻게 달라지는지 알아보고자 한다. 1234567891011121314151617describe('createReservation(passenger, flight)', function () { it('주어진 passenger를 passengerInformation 프로퍼티에 할당한다.', function () { var testPassenger = { firstName: '길동', lastName: '홍' }; var testFlight = { number: '3443', carrier: '대한항공', destination: '울신' }; var reservation = createReservation(testPassenger, testFlight); expect(reservation.passengerInformation).toBe(testPassenger); })}); 123456function createReservation(passenger, flight) { return { passengerInfo: passenger, flightInfo: flight }} 위의 코드로 단위 테스트하면 실패하게 된다.반환 객체의 속성명을 잘못해서 passengerInformation 대신 passengerInfo로 적었다. 속성명을 정정하고 다시 테스트하면 성공한다. 반환 객체의 속성명을 잘못 쓴 실수가 createReservation 함수를 구현한 코드에 잠복해 있지만, 이번에는 테스트를 먼저 작성한 뒤 명세에 따라 테스트를 했으므로 다른 개발자가 통합 테스트를 진행하다가 에러를 즉시 확인하여 조치할 수 있다. 테스트성을 감안하여 설계하기테스트를 먼저 작성하란 건 코드의 테스트성을 차후에 두고 볼 문제가 아니라 우선적인 주요 관심사로 생각하는 것이다. 어떤 코드의 테스트 용이성과 그 코드의 테스트가 얼마나 잘 이루어졌는지는 직접적인 상관 관계가 있다. 꼭 필요한 코드만 작성하기TDD 작업 절차를 정리해보자. 작은 기능 하나를 검증하려면 실패하는 테스트를 먼저 작성한 뒤, 테스트를 성공시킬 만큼만 최소한으로 코딩한다. 그 후 내부적으로 구현 세부를 변경하는 리팩토링 과정을 거쳐 개발 중인 코드에서 중복 코드를 들어낸다. 이런 과정을 거치면서 결국 마지막에는 꼭 필요한 코드만 남게 된다. 안전한 유지 보수와 리팩토링TDD를 실천하면 프로젝트 제품 코드를 대상으로 확실한 단위 테스트 꾸러미를 구축할 수 있다. 예전에 잘 돌아가던 코드가 지금은 제대로 작동하지 않은 회귀 결함은 코드 품질과 믿음성을 떨어뜨리는 요인이다.여타 보험 정책이 그렇듯, 혜택은 없고 짐만 되는 재발 비용이 발생한다. 단위 테스트의 경우 테스트 꾸러미를 개발/보수하느라 재발 비용이 들어가는데, 보험과 마찬가지로 이 재발 비용을 지불하는 부담에서 벗어나는 시점이 온다.종합적인 단위 테스트 꾸러미가 마련된 제품 코드를 확장 또는 보수할 때도 비슷한 안도감을 느낄 수 있다. 실수로 다른 코드를 건드리지 않았다는 확신을 하고 코드 일부를 변경할 수 있기 때문이다. 실행 가능한 명세TDD 실천 결과, 탄탄하게 구축된 단위 테스트 꾸러미는 테스트 대상 코드의 실행 가능한 명세 역할도 한다. 단위 테스팅 프레임워크인 재스민은 행위 기반(behavior-based) 으로 테스트를 구성한다. 재스민에서 스펙이라 부르는 개별 테스트는, 테스트하여 검증할 작동 로직을 일상 문장으로 표현하면서 시작한다.createReservation 함수를 예로 들면, 재스민으로 단위 테스트한 결과 메시지를 보고 이 함수가 무슨 일을 하는지 큰 그림을 그려볼 수 있다. createReservation이 하는 일을 굳이 코드를 읽고 분석하지 않아도 단위 테스트가 죄다 알려주는 셈이다. 참조: 자바스크립트 패턴과 테스트github","link":"/2020/01/19/%EB%8F%84%EA%B5%AC-%EB%8B%A4%EB%A3%A8%EA%B8%B0/"},{"title":"렌더링","text":"렌더링 과정렌더링이란 논리적인 문서(DOM)의 표현식을 그래픽 표현식으로 변형시키는 과정이다. 이 과정은 다음과 같이 크게 2단계를 거쳐 이뤄진다. DOM 요소와 스타일에 기반을 둔 레이아웃 계산 계산된 요소의 화면 표현 일반적인 전체 흐름은 브라우저에 문서가 로딩됨에 따라 DOM 트리의 구성이 진행되면 레이아웃을 계산한 후 문서에 요소를 그린다. 렌더링이 진행되는 과정DOM 트리 생성브라우저는 HTML 태그를 파싱해 DOM 트리를 구성한다. DOM은 데이터의 표현식으로 모든 HTML 태그에는 그에 상응하는 노드가 있으며, 태그 사이에는 텍스트 데이터가 포함될 수 있는데 이 또한 텍스트 노드의 표현식이다. 각 태그는 태그 데이터의 표현식인 DOM 요소로 1:1로 대응해 표현되며, DOM 요소 노드는 트리 형태로 구성된다. 이를 DOM 트리라 한다. 스타일 구조체 생성스타일 정보를 통해 스타일 구조체를 생성한다. 스타일 정보는 단계적으로 처리되며, 가장 마지막 단계의 스타일 정보가 이전 스타일보다 우선으로 적용된다. 스타일 정보는 다음과 같이 3단계로 나누어 처리된다. 브라우저 자체에 포함된 기본 스타일 정보 사용자 정의 스타일 HTML 인라인 스타일 렌더 트리 생성DOM 트리와 스타일 구조를 통해 렌더 트리를 생성한다.렌더 트리는 DOM 트리와는 다르게 각 노드에 스타일 정보가 설정되어 있고 화면에 표현되는 노드로 구성된다. 어떤 노드의 스타일이 ‘display: none’ 으로 설정되어 있으면 해당 노드는 렌더 트리에 포함되지 않는다. 그렇기 때문에 DOM 트리와 렌더 트리의 노드는 서로 1:1로 대응되지 않는다. head, title, script 등과 같이 화면에 표현되는 노드가 아니므로 DOM 트리에는 포함되어 있지만 렌더 트리에는 포함되어 있지 않다. 레이아웃 처리렌더 트리의 각 노드의 크기가 계산되고 문서에서 정확한 위치에 배치되도록 위치를 계산한다. 루트에서 하위 노드로 반복되며 진행한다. 페인트렌더 트리를 순회하면서 페인트 함수를 호출해 노드를 화면에 표현한다. 리플로우(reflow) 와 리페인트(repaint)렌더링이 모두 완료된 상태에서 사용자의 인터랙션 또는 기능에 따라 화면의 일부 영역에 변경 요인이 발생한다. 이러한 작업이 발생하면 구성돼 있는 렌더 트리가 변경되어야 하며 리플로우 또는 리페인트가 발생한다. 리플로우변경이 필요한 렌더 트리에 대한 유효성 확인 작업과 함께 노드의 크기와 위치를 다시 계산한다. 노드의 ‘크기’ 또는 ‘위치’가 바뀌어 현재 레이아웃에 영향을 미쳐 배치를 다시 해야 할 때 리플로우가 발생한다. 특정 요소에 리플로우가 발생하면 요소의 DOM 구조에 따라 자식 요소와 부모 요소 역시 다시 계산될 수 있으며, 경우에 따라서는 문서 전체에 리플로우가 발생할 수도 있다. 리페인트변경 영역의 결과를 표현하기 위해 화면이 업데이트 되는것을 의미한다. 리플로우각 발생하거나 배경색 변경 등의 단순한 스타일 변경과 같은 작업이 발생하는 경우다. 리플로우와 리페인트 모두 처리 비용이 발생하지만 리페인트보다 리플로우의 비용이 훨씬 높다. 리플로우는 변경 범위에 따라 전체 페이지의 레이아웃을 변경해야 할 수도 있기 때문이다. 어느 경우든 리플로우와 리페인트는 코드를 작성할 때 최소화해야 한다. 발생 요인 DOM 노드의 변경 DOM 노드의 노출 속성을 통한 변경: display: none 은 리플로우와 리페인트를 발생시키지만 비슷한 속성인 visibility: hidden 은 요소가 차지한 영역을 유지해 레이아웃에 영향을 주지 않으므로 리페인트만 발생한다. 스크립트 애니메이션: 애니메이션은 DOM 노드의 이동과 스타일 변경이 짧은 시간 내에 수차례 반복해 발생되는 작업이다. 스타일 사용자의 액션 리플로우 최소화 방법작업 그룹핑DOM 요소의 정보를 요청하고 변경하는 코드는 같은 형태의 작업끼리 그룹으로 묶어 실행시키는 것이 좋다. 123456function change() { var width = document.getElementById(\"layer1\").style.width; document.getElementById(\"layer2\").style.width = width; var height = document.getElementById(\"layer3\").style.height; document.getElementById(\"layer4\").style.height = height;} 위의 코드는 요소의 스타일 정보를 요청하고, 반환된 값을 다른 요소의 스타일 변경하는 데 사용한다. 그 후 다시 다른 요소에 동일한 형태의 작업이 반복된다. 이 코드를 실행하면 리플로우가 여러 번 발생할 수 있다.스타일 조회 -&gt; 변경 -&gt; 리플로우 -&gt; 스타일 조회 -&gt; 변경 -&gt; 리플로우 123456function change() { var width = document.getElementById(\"layer1\").style.width; var height = document.getElementById(\"layer3\").style.height; document.getElementById(\"layer2\").style.width = width; document.getElementById(\"layer4\").style.height = height;} 위와 같이 비슷한 형태의 작업 끼리 그룹으로 묶어 실행되도록 순서를 변경하면 렌더링 처리를 향상시킬 수 있다. 스타일 조회 -&gt; 스타일 조회 -&gt; 변경 -&gt; 변경 -&gt; 리플로우 실행 사이클브라우저에서 자바스크립트 실행은 이벤트 루프 모델을 따른다. 기본적으로 브라우저는 이벤트가 발생하면 바로 처리가 가능하도록 유휴(idle) 상태에 머무른다. 그러다 어떤 요청에 의해 유휴 상태가 해제되면 작업이 실행된다. 작업이 실행되면 브라우저는 작업의 실행 결과에 따른 리페인트가 완료될 때까지 기다린다. 이러한 실행 사이클로 인해 타이머를 사용하면 수차례의 리플로우와 리페인트가 발생될 수 있다. 123456function reflow() { document.getElementById(\"box1\").style.height = \"50px\"; setTimeout(function() { document.getElementById(\"box2\").style.height = \"70px\"; }, 0)} 타이머의 설정 시간을 0으로 설정해도 브라우저가 유휴 상태(stack 이 비워져 있는 상태)가 아니면 그 상태가 되기까지 실행되지 않는다. 첫 번째 요소에 대한 작업이 한 사이클 내에서 실행되고, 타이머의 실행은 먼저 실행된 사이클이 끝난 다음에 진행된다. 이로 인해 결과적으로는 리플로우와 리페인트가 두 번 발생하게 된다. 이와 같이 리플로우와 리페인트가 일어날 수 있는 작업은 가능하면 한 실행 사이클 안에서 실행하도록 처리하는 편이 효과적이다. 노출 제어를 통한 리플로우 최소화 방법요소의 스타일을 변경하면 리페인트는 반드시 일어나며, 변경 형태에 따라 리플로우도 일어난다. display기본적으로 리플로우와 리페인트는 모두 화면에 변경된 사항이 반영되는 시점에 발생한다. 여러 속성의 스타일을 변경하는 중간 단계에서는 화면에 표시하지 않고, 작업이 완료되고 최종 결과가 반영되는 마지막 시점에 요소를 다시 표시한다면 리플로우와 리페인트의 발생 횟수를 크게 줄일 수 있다. 이 코드는 값을 여러번 변경하며 값이 변경될 때마다 리플로우와 리페인트가 발생한다. 123456789var element = document.getElementById(\"box1\");for (var i=50; i &lt; 100; i++) { element.style.width = i + \"px\"}for (var i=1; i &lt; 50; i++) { element.style.borderWidth = i + \"px\"} 하지만 다음과 같이 요소를 보이지 않게 하고 모든 변경이 반영된 이후에 표시하면 처음과 마지막 시점 두 번으로 리플로우 발생 횟수가 줄어든다. 12345678910111213var element = document.getElementById(\"box1\");element.style.display = \"none\";for (var i=50; i &lt; 100; i++) { element.style.width = i + \"px\"}for (var i=1; i &lt; 50; i++) { element.style.borderWidth = i + \"px\"}element.style.display = \"block\"; display 의 none, block 을 이용한 최소화 방법이다. 노드 복제변경하려는 요소의 노드를 복제한 후 복제된 노드에 필요한 작업을 실행하는 방법이다. 복제된 노드는 DOM 트리에 추가된 상태가 아니므로 렌더링 성능에 영향을 줄 수 있는 작업을 실행하더라도 리플로우나 리페인트가 발생하지 않는다. 12345678var element = document.getElementById(\"box1\");var clone = element.cloneNode(true);for (var i=0; i&lt; 100; i++) { clone.style.width = i + \"px\";}parentNode.replaceChild(clone, element); 작업이 모두 완료된 이후 복제된 노드를 원래 노드와 치환해 DOM 트리에 변경된 사항이 적용되게 한다. 그러면 치환 시점에만 리플로우와 리페인트가 발생하는 것이므로 display 속성을 사용하는것 보다 적게 발생한다. 캐싱여기서의 캐싱은 별도의 변수에 자주 사용하는 값을 저장하는 것이다. 특정 속성과 메서드를 사용하기만 해도 리플로우 발생하는 경우가 있다. 자주 사용하는 속성의 값이나 메서드의 반환값을 변수에 저장하면 직접 속성이나 메서드를 호출하는 횟수를 줄여 성능을 향상 시킬 수 있다. 1234for (condition) { el.style.width = el.scrollWidth + \"px\"; el.style.height = el.scrollHeight + \"px\";} scrollWidth 와 scrollHeight 메서드는 호출하기만 해도 리플로우가 발생한다. 이 경우 값을 최대한 별도의 변수에 캐싱해 자주 호출되지 않게 하면 리플로우의 발생 빈도를 낮출 수 있다. 1234567var scrollWidth = el.scrollWidth;var scrollHeight = el.scrollHeight;for (condition) { el.style.width = scrollWidth + \"px\"; el.style.height = scrollHeight + \"px\";} 하드웨어 가속 렌더링브라우저는 웹 페이지 컨텐츠 렌더링 작업의 대부분을 CPU 에 의존해 왔다. 하지만 모바일 기기에도 GPU 가 기본으로 포함되고, 비디오, 3D 그래픽 등과 같이 화려하고 용량이 큰 컨텐트의 소비가 늘어 이를 활용하는 방법에 대한 고민도 커졌다. GPU를 렌더링에 활용하면 성능에 이점이 있다. 일반적인 렌더링은 CPU 에서 렌더링 요소에 대한 연산 작업을 처리하면 그 결과값을 사용해 GPU 가 출력하는 과정을 거친다. 그러나 CPU 에서 처리되던 작업이 GPU 에 위임되면 처리 결과값을 GPU 로 전달하는 과정이 생략될 수 있고 CPU 도 다른 작업에 더 집중할 수 있다. GPU 의 기본적인 하드웨어 디자인은 대용량의 픽셀 데이터를 조합하고 그리는 작업을 하게 되어 있으므로 CPU 보다 GPU 가 렌더링 작업을 최적으로 실행할 수 있다. 참조: 자바스크립트 성능 이야기","link":"/2020/02/16/%EB%A0%8C%EB%8D%94%EB%A7%81/"},{"title":"리액트 Hooks: 3. 사용방법2","text":"useReducerredux와 같이 action을 사용하여 useState보다 다양하게 state 를 조작할수 있게 해준다. harmony1234567891011121314151617181920212223242526272829303132333435363738394041import React, { useReducer } from \"react\";const reducer = (state, action) =&gt; { switch (action.type) { case \"INCREMENT\": return { ...state, count: state.count + 1 }; case \"DECREMENT\": return { ...state, count: state.count - 1 }; case \"HANDLE_CHANGE\": return { ...state, [action.target.name]: action.target.value }; default: return state; }};const CountReducer = () =&gt; { const [state, dispatch] = useReducer(reducer, { count: 0, name: \"\", nickname: \"\" }); const handleChange = e =&gt; { dispatch({ type: \"HANDLE_CHANGE\", target: e.target }); }; return ( &lt;div&gt; &lt;p&gt;current count: {state.count}&lt;/p&gt; &lt;button onClick={() =&gt; dispatch({ type: \"INCREMENT\" })}&gt;increase&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: \"DECREMENT\" })}&gt;decrease&lt;/button&gt; &lt;div&gt; &lt;input name=\"name\" value={state.name} onChange={handleChange} /&gt; &lt;input name=\"name\" value={state.nickname} onChange={handleChange} /&gt; &lt;/div&gt; &lt;/div&gt; );};export default CountReducer; 이전에 useState로 구현했었던 count와 input 컴포넌트를 위의 코드와 같이 reducer를 사용해서 구현할 수 있다. useState 또는 useReducer 어떤것이 더 좋다 안좋다는 없지만, 상황에 따라 유연하게 사용할 줄 알아야 할것같다. useMemo두번째 파라미터 배열 값을 전달받아 해당 값이 변경 될때만 첫번째 파라미터 함수를 실행한다. 해당 기능을 사용하면 불필요한 함수 호출을 줄일 수 있다. harmony1234567891011121314151617181920212223242526272829303132333435import React, { useState, useMemo } from \"react\";const Sum = () =&gt; { const [num, setNum] = useState(\"\"); const [numList, setNumList] = useState([]); const handleClickAdd = () =&gt; { if (+num) { const newNumList = [...numList]; newNumList.push(+num); setNumList(newNumList); setNum(\"\"); } }; const sumValue = useMemo(() =&gt; { if (!numList.length) return 0; const sum = numList.reduce((a, b) =&gt; a + b); return sum; }, [numList]); return ( &lt;div&gt; Sum &lt;div&gt; &lt;input value={num} onChange={e =&gt; setNum(e.target.value)} /&gt; &lt;button onClick={handleClickAdd}&gt;add&lt;/button&gt; &lt;/div&gt; &lt;div&gt;number list: {numList.join(\", \")}&lt;/div&gt; &lt;div&gt;number total: {sumValue}&lt;/div&gt; &lt;/div&gt; );};export default Sum; sumValue 함수에 useMemo를 사용하지 않으면, input 값이 변경될때도 해당 로직이 불필요하게 실행된다. useMemo를 사용해 줌으로써 불필요하게 실행되지 않도록 하고, numList의 값이 변경될때마다 해당 로직이 실행된다. useCallbackuseMemo와 거의 비슷한 기능으로 렌더링 성능을 최적화 하기위해 주로 사용된다. 쓰지 않아도 문제되지는 않지만 렌더링 해야할 컴포넌트 개수나 로직이 많아진다면 고려해 봐야한다. 해당 기능은 이벤트 함수를 필요할때만 생성해 주는 기능이다. harmony123456789101112const handleChange = useCallback(e =&gt; { setNum(e.target.value); }, []); const handleClickAdd = useCallback(() =&gt; { if (+num) { const newNumList = [...numList]; newNumList.push(+num); setNumList(newNumList); setNum(\"\"); } }, [numList, num]); 위의 onChange 함수와 handleClickAdd 함수를 useCallback을 사용하는 함수로 변경했다. 두번째 파라미터 배열은 해당 값이 변경될때만 함수를 생성해 주는것이다. 빈 배열이라면 최초에만 생성해주고 이후 다시 생성되지 않는다. handleChange 는 빈배열, handleClickAdd 은 두개의 값을 판단하고 있는데, 이는 handleChange는 단순히 num 의 값만 변경해 주고 있어 초기에만 생성해 줘도 되는것이다. handleClickAdd 함수는 이벤트가 실행 될때마다 값을 가져와서 사용해 주고 있기때문에 배열에 해당 값들을 명시해줘야한다. useRefuseRef는 함수형 컴포넌트에서도 ref 기능을 사용할 수 있게 해준다. harmony1234567891011const inputElement = useRef(null);const handleClickAdd = useCallback(() =&gt; { if (+num) { const newNumList = [...numList]; newNumList.push(+num); setNumList(newNumList); setNum(\"\"); inputElement.current.focus(); } }, [numList, num]);&lt;input value={num} onChange={handleChange} ref={inputElement} /&gt; useRef는 다른 Hook과 다르게 최초 선언을 배열 형태로 선언해 주지 않는다. ref 값이 변경되어도 리렌더링 되지 않는다.","link":"/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-3-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%952/"},{"title":"리액트 Hooks: 2. 사용방법1","text":"useState사용방법useState 는 이름에서 유추하는것과 같이 함수형 컴포넌트에서도 state를 사용할 수 있게 해준다. 사용방법은 해당 기능을 import 한 후 [state 이름, state이름을 변경시켜줄 setState와 같은 이름] = useState(초기값) 이다. harmony1234567891011121314import React, { useState } from \"react\";const Counter = props =&gt; { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;current count: {count}&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;increase&lt;/button&gt; &lt;button onClick={() =&gt; setCount(count - 1)}&gt;decrease&lt;/button&gt; &lt;/div&gt; );};export default Counter; useState를 사용하여 count state를 생성해 주었으며 초기값은 0으로 맞춰 주었다. state 사용은 기존의 class에서 사용하던 this.state.count가 아닌 count로만 사용해야 한다. setCount 파라미터로 값을 넘겨주면 해당 값으로 state가 변경된다. 여러개의 state 사용여러개의 state를 사용해야 한다면, 기존 class 방식에서는 state 객체 안에 키와 값을 설정해 주면 됐지만, 함수형 컴포넌트에서는 useState를 여러번 써줘야 한다. harmony1234567891011121314const Counter = props =&gt; { const [count, setCount] = useState(0); const [name, setName] = useState(\"\"); return ( &lt;div&gt; &lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt; &lt;p&gt; {name ? `${name}'s` : \"\"} current count: {count} &lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;increase&lt;/button&gt; &lt;button onClick={() =&gt; setCount(count - 1)}&gt;decrease&lt;/button&gt; &lt;/div&gt; );}; 재사용 가능한 useState 함수 컴포넌트동일한 stateful 로직을 사용한다면 컴포넌트를 분리해서 사용하는것이 좋다. harmony1234567891011121314151617181920212223242526272829const useInputOption = props =&gt; { const [value, setValue] = useState(props || \"\"); const onChange = e =&gt; { setValue(e.target.value); }; return { value, onChange };};const Counter = props =&gt; { const [count, setCount] = useState(0); const nameInputOption = useInputOption(\"\"); const nickInputOption = useInputOption(\"\"); return ( &lt;div&gt; &lt;input {...nameInputOption} /&gt; &lt;input {...nickInputOption} /&gt; &lt;p&gt; {nameInputOption.value ? `${nameInputOption.value}'s` : \"\"} current count: {count} &lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;increase&lt;/button&gt; &lt;button onClick={() =&gt; setCount(count - 1)}&gt;decrease&lt;/button&gt; &lt;/div&gt; );}; input의 value와 onChange 이벤트 함수를 return 해주는 useInputOption 컴포넌트를 만들었다. 코드가 간결해지고 재사용성이 높아진다. useEffectuseEffect는 함수형 컴포넌트에서도 라이프사이클과 같은 기능을 사용할 수 있게 해준다.componentDidMount 와 componentDidUpdate, componentWillUnmount 를 합쳐놓은 것이다.useEffect 함수는 state 변수를 하나만 관리하는것이 좋다. 즉 여러개의 useEffect 함수를 사용하는것을 추천해주고 있다. 사용방법harmony12345678910111213import React, { useState, useEffect } from \"react\";const User = () =&gt; { const [name, setName] = useState(\"\"); useEffect(() =&gt; { console.log(\"completed render\", name); }); return &lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt;;};export default User; 해당 코드를 확인해보면 render 가 될때마다 console.log 가 찍히는것을 확인할 수 있다. 이것은 componentDidMount 와 componentDidUpdate 라이프사이클과 일치한다. componentDidMountharmony123useEffect(() =&gt; { console.log(\"completed render\", name); }, []); useEffect 함수에 두번째 파라미터로 빈배열을 넣으면 최초 렌더링이 될때만 실행되고 name이 변경되더라도 실행되지 않는다. componentDidUpdateharmony123useEffect(() =&gt; { console.log(\"completed render\", name); }, [name]); 배열에 원하는 값을 넣어주면 해당 값이 변할때만 실행된다. componentWillUnmountharmony123456useEffect(() =&gt; { console.log(\"completed render\", name); return () =&gt; { console.log(\"unmount\", name); }; }, [name]); return 함수는 렌더링이 될때마다 실행되는 함수이다. name을 확인해보면 변경되기 이전의 값이 찍히는것을 확인할 수 있다. 두번째 파라미터에 빈 배열을 담아서 실행하면 unmount 될때만 return 함수가 실행된다. Promise 처리useEffect와 useState를 사용하여 promise 컴포넌트 또한 재사용이 가능하도록 할 수 있다.harmony123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { useState, useEffect } from \"react\";const usePromise = ({ promise, initialData, arr }) =&gt; { const [data, setData] = useState(initialData); const [loading, setLoading] = useState(false); const [error, setError] = useState(false); const fetchData = async () =&gt; { setLoading(true); try { const result = await promise(); setData(result); } catch (err) { setError(true); } setLoading(false); }; useEffect(() =&gt; { fetchData(); }, arr || []); return { data, loading, error };};const getNames = async () =&gt; { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve([{ name: \"kkangil\" }, { name: \"kkangil2\" }]), 1000) );};const Names = () =&gt; { const { data: names, loading, error } = usePromise({ promise: getNames, initialData: [] }); if (loading) return &lt;div&gt;로딩중...&lt;/div&gt;; if (error) return &lt;div&gt;에러&lt;/div&gt;; return ( &lt;&gt; {names.map((row, index) =&gt; ( &lt;div key={index}&gt;{row.name}&lt;/div&gt; ))} &lt;/&gt; );}; usePromise 파라미터로 호출해야하는 promise 함수, 최초 초기화 데이터 initialData, useEffect 함수 2번째 파라미터 배열 arr을 객체로 받는다. useEffect 함수에서 async/await을 사용하면 warning이 발생한다. 그렇기 때문에 async/await 함수를 따로 만들어 해당 함수를 useEffect에서 실행 시켜준다. Names initialData에 빈배열을 넣어주지 않으면 return의 names.map 에서 에러가 발생한다. 해당 에러를 막기 위해 빈 배열로 초기화해줬다. names 값이 존재할때만 map 을 사용하는 방법도 있지만, 추후 재사용을 위해 데이터 초기값을 설정해줄 수 있도록 했다. useContextuseContext는 함수형 컴포넌트에서 Context를 쉽게 사용할 수 있게 해준다.harmony12345678910111213141516import React, { createContext, useContext } from \"react\";const backgroundColorContext = createContext(\"black\");const Context = () =&gt; { const backgroundColor = useContext(backgroundColorContext); const style = { width: \"50px\", height: \"50px\", borderRadius: \"50%\", background: backgroundColor }; return &lt;div style={style} /&gt;;};export default Context;","link":"/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-2-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%951/"},{"title":"웹 사이트 최적화","text":"제이콥 닐슨의 웹 사이트인 “useit.com”은 웹 사이트의 반응 시간을 다음과 같이 평가한다. 0.1초: 사용자의 동작에 해당 기능이 바로 반응한다고 느끼는 시간 1초: 불필요하게 오래 기다리지 않았다고 느끼는 시간. 0.2~1초의 시간은 컴퓨터가 동작하는 시간으로 이해할 수 있는 시간이다. 시간이 1초 이상 걸리면 컴퓨터의 동작에 이상이 생겼다고 생각하게 된다. 10초: 사용자가 집중력을 잃지 않는 최대 시간 이 평가에 따르면 웹 페이지의 반응 시간이 1초 이내여야 사용자 경험에 긍정적인 영향을 미친다. 웹 사이트의 기능이 점점 복잡해지고 많아지면서 느린 반응 속도 때문에 이용 중인 서비스를 떠나 다른 유사한 서비스를 이용하게 만드는 사이트가 있는 반면, 빠른 반응 속도로 웹 사이트를 탐색하는데 큰 불편함이 없는 서비스를 제공하는 사이트도 있다. 많은 포털과 서비스 업체에서는 이러한 사용자의 기대에 부응하기 위해 여러 가지 방법을 시도했다. 그러던 중에 웹 페이지 성능 최적화라는 개념이 생겨났다. 웹 서비스의 반응 속도를 개선할 수 있는 가장 효과적인 방법은 네트워크 속도의 개선이지만 이는 단기간에 이루기 힘든 과제이며 인터넷 서비스를 제공하는 업체에서는 불가능한 부분이다. 대신 반대로 네트워크 사용량을 줄이고 브라우저에서 웹 페이지의 실행 속도를 높여 웹 페이지의 반응 속도를 개선하고 있다. 브라우저 동작 방식을 기반으로 한 최적화웹 페이지 최적화는 브라우저가 네트워크와 통신하는 과정은 물론 브라우저에서 페이지를 표시하는 과정에서의 응답 속도를 개선하는 것이다. 브라우저가 어떻게 동작하는지 이해해야 올바른 개선 방향을 잡을 수 있다.사용자는 원하는 웹 사이트로 이동하기 위해 다음의 작업을 수행하고 브라우저의 동작 방식이다. 브라우저의 주소창에 주소를 입력하고 Enter 키를 누르거나 링크를 클릭한다. 브라우저는 서버에 요청을 보내 페이지를 구성하는 자원을 다운로드한다. 다운로드 받은 자원을 이용해 요청 결과를 화면에 보여준다. 이때 브라우저가 어떤 단계로 동작하는지, 단계별로 얼마나 시간이 걸리는지 정의한 연구 활동이 W3C의 네비게이션 타이밍(Navigation Timing) 명세다. 네비게이션 타이밍 명세의 가장 큰 목적은 정확한 단계별 소요 시간을 측정하는 것이지만 브라우저의 처리 단계를 정확하게 정의했다는 데도 큰 의미가 있다. 네비게이션 타이밍 명세에서 브라우저가 사용자의 요청을 처리하는 순서를 정리한 프로세싱 모델에서 웹 페이지 최적화와 관련 있는 단계를 정리한 것이다. 서비스 이동 단계 -&gt; 리다이렉트 단계 -&gt; 애플리케이션 캐시 확인 단계 -&gt; 네트워크 통신 단계 -&gt; 브라우저 처리 단계 서비스 이동 단계: 사용자가 웹 서비스를 이용하다 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계. 프로세싱 모델의 Prompt for unload 리다이렉트 단계: 사용자가 요청한 URL에서 다른 URL로 다시 보내는 단계. 프로세싱 모델의 redirect 애플리케이션 캐시 확인 단계: 브라우저의 캐시에 데이터가 있는지 확인하는 단계. 프로세싱 모델의 App Cache 네트워크 통신 단계: 브라우저가 네트워크와 통신해서 웹 페이지와 구성 요소를 다운로드 하는 단계. 프로세싱 모델의 DNS, TCP, Request, Response 등 브라우저 처리 단계: 다운로드한 웹 페이지와 구성 요소로 웹 페이지를 화면에 그리는 단계. 프로세싱 모델의 Processing, onLoad 서비스 이동 단계서비스 이동 단계는 웹 서비스를 이용하다가 다른 주소로 이동할 때 브라우저가 제일 먼저 실행하는 단계다. 이 단계의 작업은 다른 주소로 이동하기 전에 보고 있던 페이지에서 실행하는데, 모두 브라우저 내부에서 처리하기 때문에 브라우저 성능과 직결된다. 웹 서비스를 이용하면 페이지가 표시될 때 우리도 모르게 이번트가 할당되고, 이때 메모리를 조금씩 사용한다. 그런데 이 메모리를 더 이상 사용하지 않을 때, 즉 페이지를 떠날 때는 메모리를 해제해야 한다. 이 메모리 해제 작업이 서비스 이동 단계에서 실행하는 작업 가운데 하나다. 필요 없는 메모리 해제를 담당하는 가비지 컬렉션 기능이 제대로 동작하지 않으면 브라우저가 응답 없음 상태가 되거나 실행 속도가 급격히 느려진다. 웹 페이지에서 동시에 많은 변수가 생성되고 처리되는 동안 브라우저에서 허용한 임계치를 넘었을 때 가비지 컬렉션이 동작하는데 가비지 컬렉션이 동작하면 스크립트 실행이 중단된다. 가비지 컬렉션이 완료되기 전까지는 스크립트가 동작하지 못해 페이지 느려지는 것이다. 서비스 이용 단계의 작업은 브라우저 내부에서 자동으로 실행한다. 만약 별도로 처리하려면 beforeunload 이벤트를 활용할 수 있다. 리다이렉트 단계쉽게 볼 수 있는 리다이렉트는 SNS에서 사용하는 단축 URL이다. SNS의 특성상 입력하는 글자 수에 제한이 있다. 쿼리가 긴 URL을 그대로 SNS에 입력하면 글자 수 제한 때문에 원하는 내용을 다 입력하지 못한다. 이때 단축 URL을 사용하면 SNS의 글자 수 제한을 피할 수 있다. 단축 URL로 접속하면 원본 URL로 리다이렉트 된다. 리다이렉트가 발생하면 상태 코드로 301이나 302를 반환하는데, 이는 HTTP 요청을 완수하기 위해서 추가로 뭔가를 해야 한다는 의미다. 이런 이유로 리다이렉트가 발생하면 어떤 자원도 다운로드 하지 않으며 브라우저에 일시적으로 빈 페이지가 보인다. 그렇기 때문에 특정한 목적으로 리다이렉트를 사용하는 것은 어쩔 수 없지만 의도치 않게 또는 실수로 리다이렉트가 발생한다면 웹 페이지의 성능 향상을 위해 바로 잡아야 한다. 리다이렉트와 관련해서 개발자가 흔히 저지르는 실수 가운데 하나는 URL 뒤에 슬래시를 넣지 않는 것이다. 주소창에 ‘naver.com’을 입력하고 Enter키를 누르면, 주소창에 입력한 주소가 https://www.naver.com/'으로 바뀌면서 리다이렉트 된다. 이 과정을 개발자 도구로 확인해보면 302 redirect 가 발생하는 것을 확인할 수 있다. a 태그의 href 속성에 주소 뒤에 슬래시를 붙여 301, 302 로 인한 리다이렉트가 발생하지 않도록 막을 수 있다. (307 도 발생하고는 하는데 302와 의미하는바가 같다.) 두번째로 실수하는 부분은 웹 페이지를 이용한 리다이렉트다. 흔히 메타태그를 이용하는데 다음 코드는 1초 후에 페이지가 이동하는 코드다.1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1; url=https://www.naver.com/&quot;&gt;이 코드에는 두 가지 성능 문제가 있다. 첫 번째는 이 코드를 실행시킬 별도의 페이지를 거쳐야 리다이렉트 된다는 점이다. 두 번째는 최종 페이지에 도착했을 때 캐시가 설정된 리소스임에도 불구하고 조건부 GET 요청이 이뤄진다는 점이다. 조건부 GET 요청은 브라우저에 캐싱된 리소스를 사용하기 전에 해당 리소스를 사용해도 되는지 서버에 물어 보는 것이다. 이때 헤더의 If-Modified-Since 정보를 이용해 서버에 요청을 보낸다. 리소스가 수정되지 않았다면 304 Not Modified 코드를 받아 캐시에 있는 리소스를 사용한다. 자원이 수정됐다면 서버로부터 리소스를 다운로드 한다. 캐시의 만료 날짜를 설정했다면 서버의 확인을 거치지 않고 바로 캐싱된 리소스를 사용할 수 있는데, 메타태그로 리다이렉트하면 조건부 GET 요청으로 불필요한 서버 통신이 발생해 응답 속도가 느려진다. 웹 페이지의 주소뿐 아니라 이미자와 스타일시트, 자바스크립트와 같이 페이지를 구성하는 요소도 리다이렉트 될 수 있다. 301 이나 302 상태 코드가 발생하는 요소를 찾고 의도치 않게 리다이렉트가 발생하고 있다면 성능 향상을 위해서 바로 잡아야 한다. 애플리케이션 캐시 확인 단계리다이렉트 작업을 마치고 HTTP 요청을 처리하기 위한 준비를 마쳤다면 브라우저는 먼저 서버로 요청을 보낸다. 서버에서 응답이 오면 개별 요소(이미지, 스타일시트, 자바스크립트 등)가 사용자 PC에 있는지 캐시 데이터를 찾는다. 캐시 데이터의 종류에는 쿠키, 이미지, 스크립트, 스타일시트 등이 있다. 캐시 데이터가 있는 이유는 무엇보다도 사용자가 동일한 페이지를 다시 방문했을 때 브라우저와 서버 사이에 통신을 하지 않고 캐시에 있는 자원을 사용하겠다는 것이다. 성능 향상을 위해 가장 효과적인 방법은 브라우저와 서버 사이의 통신을 최대한으로 줄이는 것이다. 그러므로 다시 방문한 사용자에게 좀 더 빠른 응답 속도를 제공하려면 애플리케이션 캐시를 잘 활용해야한다. 캐시를 다룰 때는 개별 요소들이 정말 유효한지, 사용해도 되는 것인지 검증하는 것이 중요하기 때문에 몇 가지 용어와 규칙이 필요하다. 용어 설명 Last-Modified 서버에서 저장하고 있는 마지막 수정 날짜 예: Last-Modified Sun, 27 Jan 2020 17:00:00 GMT If-Modified-Since 브라우저에서 저장하고 있는 마지막 수정 날짜 예: If-Modified-Since Sun, 27 Jan 2020 17:00:00 GMT Expires 만료 날짜. 언제까지 유효한지 미리 지정해 놓은 시간 정보로, 특정 날짜까지는 사용할 수 있다는 정보. 예: Expires 17:00:00 Sunday, December 27, 2020 GMT Cache-Control Expires 정보의 한계를 극복하려고 HTTP/1.1 에서 소개된 캐시 설정 추가 정보 max-age 캐싱할 시간. Cache-Control 정보 가운데 하나로 캐싱할 시간을 초 단위까지 정할 수 있다. max-age 정보는 클라이언트 시간과 관계 없이 현재부터 며칠, 몇 년 등으로 지정할 수 있다. 자원 요소를 다운로드할때 브라우저가 처리하는 과정이다. Expires 정보 확인 (정보 없음)-&gt; If-Modified-Since 정보 확인(정보 있음) -&gt; If-Modified-Since 정보와 Last-Modified 정보 비교 Expires 정보가 있고 기한이 남아 있으면 캐시에 저장된 요소를 사용한다. If-Modified-Since가 없으면 서버에 요소를 요청한다. If-Modified-Since 정보가 있으면 Last-Modifed 정보를 비교하고 날짜가 같으면 캐시에 저장된 요소를 사용하라는 응답 304 Not Modifed 을 보내주고, 날짜가 다른 경우 서버의 요소를 전송한다. 사용자 PC에 캐시 파일이 있고 Expires 정보가 유효하다면 해당 파일을 서버에 요청하지 않고 캐시에 저장된 파일을 이용한다. 이러면 동적인 이미지 등을 제외한 나머지 정적인 요소는 별도로 서버에 요청하지 않기 때문에 로딩 속도를 크게 향상시킬 수 있다. 네트워크 통신 단계네트워크 비용을 줄이는 첫 번째 방법은 Expires 설정이나 Cache Control 속성을 이용해 사용자 웹 페이지에 다시 왔을 때 캐시를 사용하는 방법이다. 두 번째 방법은 스타일시트나 자바스크립트와 같이 파일을 합쳐서 서비스해도 문제가 없는 리소스를 합쳐 하나의 링크로 제공해 요청 횟수를 줄이는 방법이다. DNS (DNS Lookup)호스트 이름으로 IP 주소를 조회한 시간이다. 보통 20~120ms 정도 소요된다. 이 작업이 완료되지 않으면 어떤 자원도 다운로드 하지 않는다. 브라우저에서 IP 주소를 조회할 때 동일한 호스트로 요청하는 요소는 다시 IP 주소를 확인하지 않아 시간이 추가로 걸리지 않는다. 그럼 하나의 호스트로 모든 리소스를 호출하면 시간을 줄일 수 있을 것 같지만, 대신 호스트별 동시 연결 기능은 포기해야 한다. 보통 이미지의 크기가 크고 개수가 많은 이미지 검색 서비스를 개발할 때 이런 부분을 많이 고려한다. 한 번에 보이는 이미지의 개수가 많을 때 호스트를 여러 개 만들어 동시에 다운로드하면 성능을 높일 수 있다고 생각하지만 실제로는 고려할 사항도 많다. DNS Lookup 단계에서 걸리는 시간도 무시할 수 없다. 때문에 여러 가지 가정을 세워서 테스트한 다음 최적의 호스트 개수를 찾아야한다. Request(Send)웹 서버와 TCP 연결이 이뤄지면 원하는 정보를 서버에 보내는 시간이다. 주로 요청 헤더 정보를 보내는 시간이 여기에 해당한다. Send 시간은 파일 올리기와 같이 보내야 할 정보가 많을수록 오래 걸린다.일반적인 상황에서 Send 시간을 최적화하는 방법은 쿠키 정보를 포함하지 않는 별도 호스트를 사용해 서비스하는 것이다. 쿠키 정보가 필요 없는 파일(이미지, 스타일시트, 자바스크립트)에는 별도 호스트를 적용해 헤더 정보에서 쿠키 정보를 없애는 것이다. Response(Receive)서버에서 보내는 응답 메시지를 받는 시간이다. 이 단계에서 성능을 개선하는 방법으로는 데이터 크기를 줄이기 위해 Gzip과 같은 파일 압축 기술을 사용하는 방법이 있다. 주석이나 공백을 없애 코드의 양을 줄이고, 코드의 양을 줄인 파일을 Gzip 등으로 압축해서 파일의 크기를 줄인다. Gzip으로 압축하면 원본 파일의 약 30% 정도로 크기가 줄어든다. 브라우저 처리 단계프로세싱 모델의 Processing과 onLoad 에 해당하는 브라우저 처리 단계는 서버에서 받은 HTML과 이미지, 스타일시트를 조합해 사용자가 실제로 보는 화면을 만드는 단계다. 복잡한 UI를 개발할 때는 인라인 형태의 이벤트 바인딩 방법보다 이벤트 핸들러로 바인딩하는 방법을 사용한다. 이벤트 핸들러로 이벤트를 바인딩하려면 최우선 조건이 해당 DOM이 존재해야 한다. 모든 DOM이 존재하는 바로 그 시점이 DOMContentLoaded 이벤트나 onload 이벤트가 발생하는 시점이다. 브라우저의 DOM 처리 절차에 따른 이벤트 발생 순서domLoading -&gt; domInteractive -&gt; domContentLoaded -&gt; domComplete -&gt; onload onload 이벤트는 DOM 에서 기본으로 제공하는 이벤트로 문서에 있는 모든 이미지, 스타일시트, 자바스크립트 등이 모두 다운로드 될 때마다 발생한다. 이와 달리 DOMContentLoaded 이벤트는 기본적으로 DOM 생성에만 관련돼있다. 이미자나 다른 요소를 다운로드 하는것과 관계없이 DOM이 로딩되고 난 직후에 발생한다. 많은 양의 이벤트를 바인딩해야 하고 이미지나 스타일시트의 개수가 많은 페이지를 개발한다면 onload 이벤트보다는 DOMContentLoaded 이벤트를 이용하는게 좋다. 참조: 자바스크립트 성능 이야기","link":"/2020/01/27/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/"},{"title":"리액트 Hooks: 1. hooks 란?","text":"리액트 16.8 버전에서 Hooks 라는 새로운 기능이 추가 되었다.해당 기능은 간단히 설명하자면 기존 리액트 component 에서 state 와 라이프 사이클을 사용하려면 class 로 component 를 생성해야 했다.이말은 즉, 함수형 component 에서는 props 를 받아 사용할 수 있지만, state와 라이프 사이클을 사용할 수 없었다. https://reactjs.org/docs/hooks-intro.html Hooks 특징 현재 진행중인 프로젝트가 있다면 코드를 다시 짜지 않아도, 바로 사용할 수 있다. 어떠한 변화 없이 기능이 추가 되었기 때문에 이전 버전과의 호환성이 100%이다. 16.8.0 이후 버전에서 사용가능하다. Hooks로 class를 대신할 수 있게됐지만, 리액트는 class를 제거할 계획이 없다고 밝혔다. 리액트에 대한 여러가지 컨셉(props, state, context, refs, and lifecycle)을 대체할 수 없는 대신, 더욱 직관적으로 제공한다고 한다. Hooks가 나오게된 배경Component 사이에서 stateful 한 로직의 재사용이 어렵다. 리액트는 컴포넌트에 재활용하는 방법인 “attach” 방법을 제공하지 않는다. 이런 문제들을 해결하기 위해 다양한 패턴이 사용되었다. (render propr, HOC …) 이런 패턴을 사용했을 때, 재구조화를 해야하고 이는 번거롭고 어려워질 수 있다. 또한 이런 패턴을 DevTools 에서 확인해 보면 wrapper 지옥에 빠져있는 수많은 컴포넌트를 볼 수 있다. Hooks 는 컴포넌트로 부터 stateful 한 로직을 추출해 낼 수 있으며 이것은 의존성과 재사용성을 테스트할 수 있다. 이해하기 어려운 복잡한 컴포넌트 처음은 가벼운 컴포넌트였지만, 개발을 진행하다보면 수많은 side effects와 stateful 로직이 걷잡을 수 없이 많아진다. 각각의 라이프 사이클은 자주 연관성이 없는 로직을 섞어 사용하곤 한다. 예를 들어 컴포넌트는 componentDidMount와 componentDidUpdate 라이프사이클에서 데이터를 fetch 할 수 있다. 하지만 몇몇 componentDidMount 메소드는 이벤트를 설정하는 데 연관 없는 로직 들을 포함할 수 있으며 componentWillUnmount는 cleanup을 수행할 수도 있다. 함께 변경되는 관련 코드는 분리되지만 연관 없는 코드들은 단일 메소드로 결합한다. 이것은 버그와 무결성을 쉽게 발생시킨다. 많은 경우 컴포넌트들을 작게 만드는 것은 불가능하다. stateful 로직은 모든곳에 있기 때문이다. 또한 이것은 테스트하는 것도 어렵다. 이것이 사람들이 state 를 관리하는 라이브러리를 함께 사용하는것을 선호하는 이유중 하나이다. 그러나 너무 추상적이라고 소개하고 다른 파일 사이를 건너뛰는것을 요구하며 컴포넌트 재사용을 더욱 어렵게 만든다. 이러한 이슈들을 해결하기 위해 Hooks는 라이프사이클 메소드를 기초로한 분리에 초점을 맞추는 것보다는 컴포넌트들을 연관성을 기초로 더 작은 함수로 분리할 수 있게 한다. 사람과 기계를 혼란시키는 Classes 코드를 재사용성과 구조적으로 만드는 것은 어려울뿐만 아니라 리액트를 배울때 classes는 큰 진입장벽이다. 다른 대부분의 언어들과는 다른 Javascript가 어떻게 동작하는지 이해하고 있어야한다. 이벤트 핸들러는 항상 바인딩이 되어야 하는것을 기억해야 한다. 안정적인 문법의 제안이 없다면, 코드는 매우 장황해진다. 사람들은 props, state, 단방향 데이터 흐름에 대해 이해하고 있지만 여전히 classes는 어려워한다. 이러한 문제를 해결하기 위해서 Hooks는 classes 없이 리액트의 특징들을 사용할 수 있게 해준다.","link":"/2019/04/19/%EB%A6%AC%EC%95%A1%ED%8A%B8-Hooks-1-hooks-%EB%9E%80/"},{"title":"성능을 높이는 코드 스타일","text":"객체의 생성, 초기화 성능많이 사용하지만 성능을 생각하지 않고 작성하는 코드에 객체 선언과 초기화 구문이 있다. 배열(Array) 형식의 객체와 오브젝트(Object) 형식의 객체를 생성하고 초기화하는 방법의 성능을 측정해 보고 두 코드 사이에 어떤 차이점이 있는지 비교해 보고자 한다. 배열의 생성, 초기화 성능 비교배열을 생성자 혹인 리터럴([]) 형식을 사용해 객체를 생성할 수 있다. 12345// Array() 생성자 사용var arr = new Array();// 리터럴 형식으로 배열 생성var arr = []; 성능 비교 방법은 http://jindo.dev.naver.com/jsMatch/index.html 사이트를 이용한다. (Chrome 79 버전 기준) 두 방법의 성능을 비교한 결과는 생성자를 사용했을때는 0.111s, 리터럴 형식으로 사용했을 경우 0.100s 의 시간이 걸렸다. 배열을 사용하려면 배열의 각 요소에 데이터를 할당해 초기화해야한다.배열의 각 요소에 데이터를 할당하는 방법에도 여러가지가 있다. 그 가운데 가장 많이 볼 수 있는 방법인 접근자 []를 사용하는 방법과 push() 메서드를 사용하는 방법의 성능을 비교한다. 1234567891011// 접근자 사용var arr = [];for (var i = 0; i &lt; 1000; i++) { arr[i] = i;}// push() 메서드 사용var arr = [];for (var i = 0; i &lt; 1000; i++) { arr.push(i);} 결과: 접근자 사용 0.100s / push 사용 0.123s push 메서드를 사용하는것 보다 접근자를 사용하는 것이 빠르다는 것을 확인할 수 있다. 배열의 생성과 초기화 방법을 비교한 결과, 배열을 사용할 때는 리터럴 형식으로 객체를 생성하고 Array.push() 메서드보다 접근자 []를 사용해 데이터를 추가하는 코드를 작성하는 것이 좀 더 최적화된 배열 사용법이라는 사실을 확인할 수 있다. 오브젝트(Object) 객체의 생성, 초기화 성능 비교오브젝트(Object) 객체도 배열처럼 객체를 생성하고 초기화하는 다양한 방법이 있다. 가장 많이 사용하는 방법인 리터럴({})을 사용하는 방법과 생성자를 사용하는 방법의 성능을 테스트해보고 어떤 방법으로 객체를 생성하고 초기화하는 것이 효과적인지 살펴보고자 한다. 12345// 리터럴 사용var obj = {};// 생성자 사용var obj = new Object(); 결과: 리터럴 사용 0.104s / 생성자 사용 0.100s 배열과 다르게 생성자를 사용하는 것이 시간이 적게 걸리지만 차이가 적으므로 어떤 방법이 성능이 월등히 좋다고 판가름하기 어렵다. 리터럴 형식이 코드 크기를 좀 더 줄일 수 있는 방법이기 때문에 코드를 다운로드 하는 시간 관점에서 성능에 더 좋다고 볼 수는 있다. 객체 초기화 방법에는 연산자를 이용한 데이터 삽입과 []를 이용한 데이터 삽입이 있다. 12345678910111213141516171819202122232425// 연산자 이용var obj = {};obj.a = 1;obj.b = 2;obj.c = 3;obj.d = 4;obj.e = 5;obj.f = 6;obj.g = 7;obj.h = 8;obj.i = 9;obj.j = 10;// [] 이용var obj = {};obj[\"a\"] = 1;obj[\"b\"] = 2;obj[\"c\"] = 3;obj[\"d\"] = 4;obj[\"e\"] = 5;obj[\"f\"] = 6;obj[\"g\"] = 7;obj[\"h\"] = 8;obj[\"i\"] = 9;obj[\"j\"] = 10; 결과: 연산자 이용 0.102s / [] 이용 0.100s Object 객체에 데이터를 삽입하는 초기화 방법에 대한 성능 테스트 결과도 Object 객체 생성에 대한 테스트 결과와 유사헀다. 객체의 초기화도 생성과 마찬가지로 한 가지 방식이 더 성능이 좋다고 판단할 수 없으며, 작성하는 코드의 크기와 주요 대상 브라우저 및 코드의 가독성과 유지 보수를 감안해 적절한 방식을 택하면 되겠다. 스코프 체인 탐색과 성능자바스크립트 성능을 다루는 책에서 항상 빠지지 않는 부분이 스코프 체인이다. 개발자가 작성한 코드 자체의 성능이 런타임 성능에도 많은 영향을 준다. 런타임 환경에서 가장 많이 발생하는 브라우저의 작업 가운데 자바스크립트의 실행 성능을 저해하는 요인이 변수, 객체, 함수 등의 메모리상의 위치를 찾는 탐색 작업이다. 스코프 체인이란?자바스크립트의 함수를 실행하면서 어떤 속성(변수, 객체 등)에 접근해야 할 때 해당 속성을 효율적으로 탐색하도록 속성을 일정한 객체 단위로 분류하고 각 객체에 접근하기 위한 객체의 참조를 특정한 공간에 저장해 둔다. 이 공간이 바로 스코프 체인이다. 스코프 체인의 구성 요소에는 활성화 객체와 전역 객체가 있다. 함수에서 접근할 수 있는 모든 속성 가운데 함수 내부에서만 접근할 수 있는 함수의 지역변수나 this, arguments 객체 등의 속성은 스코프 체인의 활성화 객체에 포함돼 관리 된다. 함수 외부에서도 접근할 수 있는 window, document, 전역함수, 전역변수와 같은 속성은 스코프 체인의 전역 객체에 포함돼 관리 된다.전역 객체는 자바스크립트 동작시 어디서나 항상 접근 가능한 데이터를 포함하고 있기 때문에 동작하는 모든 시간 동안 존재하지만, 활성화 객체는 실행 중인 함수 내부 데이터를 포함하기 때문에 함수가 실행되는 동안에만 존재한다. 실행 문맥(Execution Context)은 함수가 동작하는 환경을 나타내며, 브라우저 내부에서 사용되는 객체다. 실행 문맥은 함수가 실행될 때 새로 생성되고 함수가 종료될 때 소멸되며 함수의 스코프 체인에 대한 참조를 가지고 있게 된다. 실행 문맥은 자신과 연관된 함수의 스코프 체인을 참조하고 있으며, 함수에서 접근해야할 어떤 속성의 탐색 경로는 실행 문맥 &gt; 스코프 체인 &gt; 활성화 객체 &gt; 스코프 체인 &gt; 전역 객체 와 같이 구성된다. 지역변수를 활용한 스코프 체인 탐색 성능 개선스코프 체인의 탐색 방법을 살펴보면 여러 개의 활성화 객체와 전역 객체를 탐색하면서 접근하려는 속성이 있는지 확인하는 과정이 반복된다. 그렇다면 첫 번째로 탐색하는 활성화 객체에 찾고자 하는 속성이 있는 경우 추가로 발생할 수 있는 다른 활성화 객체, 전역 객체를 탐색하는 과정을 줄여 성능을 향상시킬 수 있을 것이다. 123456789101112131415161718192021222324// 함수 내에서 전역 스코프 변수에 직접 접근하는 방법window.htmlstring = [];function makeList () { htmlstring.push(\"&lt;ul&gt;\"); for (var i =0; i &lt; 100; i++) { htmlstring.push(`&lt;li&gt;value: ${i}&lt;/li&gt;`); } htmlstring.push(\"&lt;/ul&gt;\");}makeList();// 지역변수로 참조해 전역 스코프 변수에 접근하는 방법window.htmlstring = [];function makeList () { var htmlstr = htmlstring; htmlstr.push(\"&lt;ul&gt;\"); for (var i =0; i &lt; 100; i++) { htmlstr.push(`&lt;li&gt;value: ${i}&lt;/li&gt;`); } htmlstr.push(\"&lt;/ul&gt;\");}makeList(); 결과: 전역 스코프 변수 접근 0.119s / 지역변수 참조 0.100s 전역 객체에 존재하는 htmlstring 속성을 makeList() 함수의 지역변수에 저장해 활성화 객체에서 바로 찾을 수 있게 한것이다. 최초 한 번은 활성화 객체와 전역 객체를 모두 탐색해야한다. 하지만 그 이후에는 활성화 객체에 저장된 htmlstr 속성으로 전역변수인 htmlstring 객체에 접근할 수 있으니 활성화 객체를 거쳐 전역 객체까지 탐색할 필요가 없어진다. 반복문과 성능자바스크립트의 반복문인 for, for-in, while, do-while 구문에도 성능 차이가 있다. 1234567891011121314151617181920212223242526272829// 성능 테스트 전에 배열 초기화arr = [];for (var i=0; i &lt; 400; i++) { arr[i] = i;}// forfor (var i = 0, len = arr.length; i &lt; len; i++) { arr[i]++;}// for-infor (var i in arr) { arr[i]++;}// whilevar i = 0, len = arr.length;while (i &lt; len) { arr[i]++; i++;}// do-whilevar i = 0, len = arr.length;do { arr[i] = i; i++;} while (i &lt; len); 결과: for 0.113s / for-in 0.505s / while 0.108s / do-while 0.100s for-in의 성능이 압도적으로 떨어지는 것을 확인할 수 있다. for-in 이외의 반복문은 주어진 배열 객체를 배열의 특성에 맞게 순차적으로 모든 요소를 탐색한다. 반면 for-in 구문은 인자로 주어진 배열을 배열이 아닌 일반 객체로 취급하며, 반복 시점마자 객체의 모든 속성을 무작위로 탐색한다. 이러한 탐색 방법의 차이로 다른 반복문에 비해 배열 탐색에서 현저하게 느리다. 조건문과 성능반복문만큼이나 조건문 또한 자바스크립트를 포함한 프로그래밍 전반에서 필수적으로 사용하는 요소다. 자바스크립트에는 if, if-else, switch, 삼항연산자 등의 조건문이 있다. 조건문의 성능 비교먼저 true와 false만 판단하는 최소한의 조건 분기를 처리하는 코드로 if, switch, 삼항연산자의 성능을 측정했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// if-elsefunction toEnglish(value) { var number = \"zero\"; if (value === 1) { number = \"one\"; } else if (value === 2) { number = \"two\"; } else if (value === 3) { number = \"three\"; } else if (value === 4) { number = \"four\"; } else if (value === 5) { number = \"five\"; } else if (value === 6) { number = \"six\"; } else if (value === 7) { number = \"seven\" } else if (value === 8) { number = \"eight\"; } else if (value === 9) { number = \"nine\"; } else if (value === 10) { number = \"ten\"; } else { number = \"null\"; } return number;}for (var i=0; i &lt; 12; i++) { toEnglish(i);}// switch-casefunction toEnglish(value) { var number = \"zero\"; switch(value) { case 1: number = \"one\" break; case 2: number = \"two\"; break; case 3: number = \"three\"; break; case 4: number = \"four\"; break; case 5: number = \"five\"; break; case 6: number = \"six\"; break; case 7: number = \"seven\" break; case 8: number = \"eight\"; break; case 9: number = \"nine\"; break; case 10: number = \"ten\"; break; default: number = \"null\"; break; } return number;}for (var i=0; i &lt; 12; i++) { toEnglish(i);}// 삼항연산자function toEnglish(value) { var number = false; number = (value === 1) ? \"one\" : (value === 2) ? \"two\" : (value === 3) ? \"three\" : (value === 4) ? \"four\" : (value === 5) ? \"five\" : (value === 6) ? \"six\" : (value === 7) ? \"seven\" : (value === 8) ? \"eight\" : (value === 9) ? \"nine\" : (value === 10) ? \"ten\" : \"null\"; return number;}for (var i=0; i &lt; 12; i++) { toEnglish(i);} 결과: if-else 0.111s / switch 0.111s / 삼항연산자 0.100s 조건의 개수가 많지 않으므로 조건문 사이에 별다른 성능 차이가 없다. 단지, 일반적으로 조건 판단 요소가 많아질수록 switch-case 구문의 성능이 좀 더 좋다는 점은 알아두는 것이 좋다. 문자열 연산과 성능문자열 생성 비교12345// String 객체 이용var str = new String(\"test\");// 리터럴 이용var str = \"test\"; 결과: String 객체 0.103s / 리터럴 이용 0.100s 측정한 시간이 지극히 짧지만 String 객체보다는 리터럴을 사용하는 것이 좋다. 문자열 연산 성능 비교여러가지 데이터를 조합해 긴 문자열을 생성해야 할 때가 많다. 이때 가장 많이 사용하는 방법이 +, += 연산자를 이용하거나 Array.join() 메서드를 이용하는 방법이다. 123456789101112// += 연신자str = \"\";for (var i = 0; i &lt; 100; i++) { str += \"test\";}// Array.joinarr = [];for (var i = 0; i &lt; 100; i++) { arr[i] = \"test\";}arr.join(\"\"); 결과: += 연산자 0.398s / Array.join 0.100s Array.join() 메서드를 이용하는것이 월등한 성능을 낸다는 것을 확인할 수 있다. += 연산자는 두 문자열을 합친 새로운 문자열을 만들고 새로운 메모리 위치에 저장함과 동시에 기존 문자열에 대한 참조를 변경하는 연산을 반복적으로 실행해야 한다. 하지만 Array.join() 메서드로 연산하면 비교적 메모리에 효율적으로 접근할 수 있는 배열을 사용한다. 결론 배열은 리터럴([])방식으로 생성하고 push() 메서드가 아닌 접근자([])로 데이터를 할당하는 코드의 성능이 더 좋다. 객체는 어떤 방식이든지 비슷한 성능을 낸다. 가독성과 유지보수의 편리성을 고려해 적절한 방식으로 사용하면 된다. 반복문 가운데 for-in의 성능이 월등히 낮다. 조건문의 종류에 따른 성능 차이는 거의 없지만 조건이 많아지면 switch-case 성능이 좀 더 좋다. 문자열을 연산할 때는 += 연산자 보다는 Array.join()을 이용하는 방법이 더 좋다. 참조: 자바스크립트 성능 이야기","link":"/2020/02/09/%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%EC%9D%BC/"},{"title":"메모이제이션","text":"메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 메모이제이션은 함수형 프로그래밍 관련 이야기에서는 빠지지 않고 꼭 등장하는 사례이기도 하다. 함수형 자바스크립트에서 메모이제이션의 대표적인 사례로는, 한 번 들어온 인자에 대한 결과를 캐싱하여 함수 본체를 실행하지 않고 결과를 즉시 리턴하는 _.memoize 같은 고차 함수가 있다. 동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수의 콘셉트를 잘 활용한 사례이다. 함수 본체에서 하는 일이 복잡하거나 연산이 많거나 내부에서 생성하는 자원이 많거나 시간이 오래 걸리는 함수일수록 메모이제이션을 통해 얻을 수 있는 성능적 이득도 커진다. memoize 함수메모이제이션 코드로 이해하기메모이제이션에 대해 가장 빠르고 쉽게 이해하는 방법은 역시 코드를 통해 확인 하는 것이다. 간단 버전의 memoize 함수를 구현하여 메모이제이션의 콘셉트에 대해 파악해 보려 한다. 12345678910111213function memoize(func) { var cache = {}; return function (arg) { if (cache[arg]) { // 이미 동일한 인자에 대한 결과가 있으면 리턴 console.log('캐시로 결과 바로 리턴', arg); return cache[arg]; } console.log('본체 실행', arg); // 받아둔 함수를 실행하면서 결과를 cache에 남겨둠 return cache[arg] = func.apply(this, arguments); }} 간단한 memoize 함수를 구현했다. memoize 함수를 이용해 mult5 라는 함수를 만든다. 123456789101112var mult5 = memoize(function (a) { return a * 5;})console.log(mult5(1));// 본체 실행 1 -&gt; 5console.log(mult5(2));// 본체 실행 2 -&gt; 10console.log(mult5(1));// 캐시로 결과 바로 리턴 1 -&gt; 5console.log(mult5(2));// 캐시로 결과 바로 리턴 2 -&gt; 10 매우 간단한 개념이다. memoize는 고차 함수다. 해당 로직을 memoize가 대신하도록 만든 사례이다. 메모이제이션은 인자가 하나일 때 활용성이 높다. 하지만 위의 memoize는 인자를 하나만 사용할 수 있다는 점과 문자열로 식별이 가능한 인자만 사용할 수 있다는 점이 아쉽다. 1234567891011121314151617var add = memoize(function (a, b) { return a + b;})console.log(add(3, 5)); // 본체 실행 3 -&gt; 8console.log(add(3, 10)); // 캐시로 결과 바로 리턴 8 캐시가 동작했지만 3에만 의존하기 때문var keys = memoize(function (obj) { return _.keys(obj);});console.log(keys({ a: 1, b: 2 }));// 본체 실행 Object {a: 1, b: 2} -&gt; ['a','b']console.log(keys({ a: 1, b: 2 }));// 캐시로 결과 바로 리턴 Object {a: 1, b: 2} -&gt; ['a','b']console.log(keys({ a: 10, b: 20 }));// 잘 동작하는 듯 했지만 cache가 {[object Object]: ...} 이런 식으로 되기 때문에 오류 위의 코드를 보면 오류가 발생했다. JSON.stringfy(arguments); 를 활용해서 위와 같은 문제를 해결할 수 있다. 하지만 이 방법은 별도의 연산이 생겨 느리기도 하고 해결할 수 있는 범위가 적다. 이럴때는 역시 함수로 추상화를 하는 것이 좋다. Partial.js의 _.memoize2Partial.js에도 _.memoize가 있다. partial.js의 _.memoize는 Underscore.js의 _.memoize다. partial.js 에는 또 다른 메모이제이션 함수인 _.memoize2가 있다. 이 함수는 인자를 하나만 사용하는 함수에서만 사용할 수 있으며 인자로 객체만 사용할 수 있다. _.memoize가 캐시를 함수에 기록한다면 _.memoize2는 캐시를 인자에 기록한다. _.memoize2는 함수 생성 시 함수의 고유 아이디를 만든 후, 인자로 들어오는 객체에 해당 고유 아이디를 기준으로 arg._memoize 밑에 담아 둔다. _.memoize2는 불변 객체 콘셉트와 함께 사용하기 위해 만든 함수이고 실무에서 사용하기 위해 만든 함수다. 1234567891011121314151617181920/** * _.memoize2 */var f1 = _.memoize2(function (obj) { console.log('함수 본체에 들어옴'); return obj.a + 10;});var obj1 = { a: 1 };var obj2 = { a: 2 };console.log(f1(obj1));// 함수 본체에 들어옴 11console.log(f1(obj1));// 캐시 사용console.log(f1(obj2));// 함수 본체에 들어옴 12console.log(f1(obj2));// 캐시 사용 _.memoize2는 _.memoize와는 다른 특징과 장점을 가지고 있다. 우선 각 함수들에 대한 결과값을 인자로 사용된 객체에 담아두므로 한 번 사용하고 버리는 객체라면, 그 값은 별도의 관리 없이도 메모리에서 비워진다. 이것이 일단 가장 큰 장점이다. _.memoize는 결과 캐시가 함수에 쌓이기 때문에 함수를 없애거나 함수에 달린 캐시를 별도로 관리해야 하지만, _.memoize2는 사용한 인자에 결과 캐시가 쌓이므로 그 값을 계속 사용하느냐 아니냐에 따라 자동으로 메모리가 관리된다. 이것 외에도 값을 불변적으로 다룰 때 얻을 수 있는 실용적인 이점이 있다. 12345678910111213141516var evens = _.memoize2(function (list) { console.log('함수 본체에 들어와서 loop 실행'); return _.filter(list, function (num) { return num % 2 === 0; })});var list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];console.log(evens(list)); // [2,4,6,8,10]console.log(evens(list)); // [2,4,6,8,10] (캐시를 사용하여 loop를 돌지 않음)list.push(11);list.push(12);console.log(list); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]console.log(evens(list)); // 캐시가 사용되어 12가 나오지 않음. 마지막 evens 실행 시에는 원하는 결과를 얻지 못했다. 값을 가변적으로 다뤘기 때문이다. 불변적으로 값을 다루게 되면 캐시도 자동으로 갱신되고, 값이 변경되지 않은 상태에서는 계속해서 캐시를 사용하기 때문에 성능적으로 이득을 얻을 수 있다. 123456789var list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];console.log(evens(list)); // [2,4,6,8,10]console.log(evens(list)); // [2,4,6,8,10] (캐시를 사용하여 loop를 돌지 않음)list2 = list2.concat(11, 12);console.log(list2); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]console.log(evens(list2)); // [2,4,6,8,10, 12]console.log(evens(list2)); // [2,4,6,8,10, 12] (캐시를 사용하여 loop를 돌지 않음) _.memoize2로 만든 함수는 인자를 한 개만 받을 수 있다. 두 개 이상의 인자를 필요로 하는 함수는 _.memoize2를 사용할 수 없다. 참조: 함수형 자바스크립트 프로그래밍","link":"/2020/01/12/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98/"},{"title":"리액트 라이프사이클","text":"React를 사용하기 전 라이프사이클에 대해 확실하게 알고 사용하는 것이 좋다.라이프사이클 이란 DOM이 그려지기 전후, DOM 상태가 변경되기 전후에 따라 실행되는 method 이며 상황에 맞는 action 을 취하게 해준다.github에 예제 코드를 보면서 해당 글을 읽으면 도움이 될 수 있으며 clone 받아 직접 테스트 해볼 수도 있다.code 보기 주요 라이프사이클componentDidMount 렌더가 된 이후 실행되는 라이프사이클로 최초 API 요청 사용에 적합한 라이프 사이클 shouldComponentUpdate component 의 상태값이 변경되었을때 render 직전에 호출되는 라이프 사이클 Boolean 값을 return 해야하며, false 를 return 하면 렌더를 하지 않음. 렌더를 하지 않으므로 이후 라이프사이클도 먹히지 않음. componentWillUnmount component가 DOM 에서 삭제(해당 컴포넌트 미표시)할때 마지막으로 실행되는 메소드 interval 이나 비동기 API 제거에 주로 쓰임. 16.3 이후 변경된 라이프사이클 렌더링 제어에 많은 방법이 있기때문에 라이프사이클 사용에 혼란이 생김. 실제 커뮤니티에서도 어떤 라이프사이클이 좋다 안좋다 성능 이슈가 많음. 대표적으로 componentWillMount 와 componentDidMount 둘중 어떤 라이프사이클에서 API를 호출해야하는지. 향후 componentWillMount, componentWillReceiveProps, componentWillUpdate 라이프사이클이 삭제되고 UNSAFE_ 라이프사이클만 동작할것이라고 예고 이를 대체하기 위해 새로운 라이프사이클 추가 라이프사이클 동작 순서 최초 진입: constructor -&gt; getDerivedStateFromProps -&gt; render -&gt; componentDidMount 순으로 실행. props 변경: getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate 순으로 실행 state 변경: shouldComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate 순으로 실행 getDerivedStateFromProps componentDidMount 보다 먼저 실행 window 객체 접근 가능(storage 사용 가능) props 와 state가 변경되었을때는 최초 실행 파리미터로 변경될 props 와 state가 넘어옴. this.state 접근 불가능 return 되는 객체값으로 state 가 변경된다. (해당 라이프사이클에서는 state 변경만 해주는것이 바람직하다고 판단됨.) state를 변경해주고 싶지 않을때에는 null 을 return 해주면된다. 최초 페이지 진입시 componentDidMount 라이프사이클에서 fetch 실행 react 공식문서에서는 props 가 변경되었을때 fetch가 필요하다면 해당 라이프사이클에서 API(data fetching) 요청 하는것이 아닌 componentDidUpdate 라이프 사이클에서 fetch 하도록 유도하고 있음. getSnapshotBeforeUpdate componentWillUpdate 의 대체 라이프사이클 DOM이 업데이트 되기 직전이 실행 componentDidUpdate 전에 실행되며 해당 라이프사이클의 return 값이 componentDidUpdate 3번째 파라미터로 전달됨. 기존 componentWillUpdate 와 같이 해당 라이프사이클 안에서 this.setState()를 사용하는 경우 무한루프에 빠지게 됨. 자주 사용되지는 않을것으로 판단됨. Error Boundary 렌더 과정에서 에러가 생겼을경우 앱이 죽는것이 아니라 UI 변경과 같은 대안으로 앱이 죽지 않도록 하는 방식 해당 class를 최상단에 두고 라이프사이클을 이용해서 조작할 수 있다. getDerivedStateFromError 16.6 버전에 추가된 라이프 사이클 해당 라이프 사이클은 렌더 중에 호출되며 fallback UI를 렌더링 하기 위한 메소드이다. 렌더 중에 호출되기 때문에 side effect(API call, 함수 호출) 을 사용하지 않는것이 좋다. react 공식 문서에서는 componentDidCatch 라이프 사이클을 추천한다. return 객체는 state 가 해당 객체로 변경된다. componentDidCatch 해당 라이프사이클은 에러를 기록하거나 트래킹하기 위한 작업을 위해 주로 사용된다. (ex Sentry) 해당 라이프 사이클에서도 state 를 변경하여 UI 를 변경해줄수 있지만 추천되지 않는다.","link":"/2019/04/17/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/"},{"title":"함수형 자바스크립트를 위한 기초","text":"함수형 자바스크립트를 잘 익히기 위해서는 무엇보다 함수를 다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데 이를테면 일급 함수, 클로저, 고차 함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드 등이 있다. 일급 함수자바스크립트에서 함수는 일급 객체이자 일급 함수다. 자바스크립트에서 객체는 일급 객체다. 여기서 일급은 값으로 다룰 수 있다는 의미로, 아래와 같은 조건을 만족해야 한다. 변수에 담을 수 있다. 함수나 메서드의 인자로 넘길 수 있다. 함수나 메서드에서 리턴할 수 있다. 자바스크립트에서 모든 값은 일급이다. 자바스크립트에서 모든 객체는 일급 객체이며 함수도 객체이자 일급 객체다.일급 함수는 아래와 같은 추가적인 조건을 더 만족한다. 아무 때나(런타임에서도) 선언이 가능하다. 익명으로 선언할 수 있다. 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다. 12345678910111213function f1() { }var a = typeof f1 === 'function' ? f1 : function () { };function f2() { return function () { };}(function (a, b) { return a + b; })(10, 5);function callAndAdd(a, b) { return a() + b();}callAndAdd(function () { return 10; }, function () { return 5; }) f1은 함수를 값으로 다룰 수 있음을 보여준다. f2는 함수를 리턴한다. a와 b를 더하는 익명 함수를 선언하였으며, a와 b에 각각 10, 5를 전달하여 즉시 실행했다. callAndAdd를 실행하면서 익명 함수들을 선언했고 바로 인자로 사용되었다. callAndAdd는 넘겨받은 함수 둘을 실행하여 결과들을 더한다. 클로저스코프에 대한 개념을 잘 알고 있다면 이 글을 읽는 데 더욱 도움이 될 것 이다. 스코프란 변수를 어디에서 어떻게 찾을지를 정한 규칙으로, 여기에서 다루는 스코프는 함수 단위의 변수 참조에 대한 것이다.함수는 변수 참조 범위를 결정하는 중요한 기준이다. 함수가 중첩되어 있다면 스코프들 역시 중첩되어 생겨난다. 클로저는 자신이 생성될 때의 환경을 기억하는 함수다. 이 말을 보다 실용적으로 표현해 보면 클로저는 자신의 상위 스코프의 변수를 참조할 수 있다고 할 수 있다. 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다. 자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다. 자바스크립트의 모든 함수는 상위 스코프를 가지며 모든 함수는 자신이 정의되는 순간(정의되는 곳)의 실행 컨텍스트 안에 있다. 123456789101112131415function parent() { var a = 5; function myfn() { console.log(a); }}function parent2() { var a = 5; function parent1() { function myfn() { console.log(a); } }} parent와 parent2의 myfn에서는 a라는 변수를 선언하지 않았지만 사용하고 있다. parent의 변수 a는 myfn을 생성하는 스코프에서 정의되었고 parent2의 변수 a는 myfn을 생성하는 스코프의 상위 스코프에 정의되었다. 위와 같은 조건을 충족시키지 않는다면 그 함수가 아무리 함수 안에서 선언되었다고 하더라도 일반 함수와 전혀 다를 바가 없다. 클로저가 기억할 환경이라는 것은 외부의 변수들밖에 없기 때문이다. 또한 자신의 상위 스코프에서 알 수 있는 변수를 자신이 사용하고 있지 않다면 그 환경을 기억해야 할 필요가 없다.글로벌 스코프를 제외한 외부 스코프에 있었던 변수 중 클로저 혹은 다른 누군가가 참조하고 있지 않는 모든 변수는 실행 컨텍스트가 끝난 후 가비지 컬렉션 대상이 된다. 어떤 함수가 외부 스코프의 변수를 사용하지 않았고, 그래서 외부 스코프의 환경이 가비지 컬렉션 대상이 된다면 그렇게 내비려 두는 함수를 클로저라고 보기 어렵다. 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다. 12345var a = 10;var b = 20;function f1() { return a + b;} f1은 클로저처럼 외부 변수를 참조하여 결과를 만든다. 게다가 상위 스코프의 변수를 사용하고 있으므로 앞서 강조했던 조건을 모두 충족시키고 있다. 그런데 왜 클로저가 아닐까?글로벌 스코프에서 선언된 모든 변수는 그 변수를 사용하는 함수가 있는지 없는지와 관계없이 유지된다. a와 b 변수가 f1에 의해 사라지지 못하는 상황이 아니므로 f1은 클로저가 아니다.그렇다면 클로저는 ‘함수 안에서 함수가 생성될 때’만 생성된다고 할 수 있을까? 그렇지 않다. 웹 브라우저에서는 함수 내부가 아니라면 모두 글로벌 스코프지만, 요즘 자바스크립트에서는 함수 내부가 아니면서 글로벌 스코프도 아닌 경우가 있다. 123456789101112function f2() { var a = 10; var b = 20; function f3(c, d) { return c + d; } return f3;}var f4 = f2();console.log(f4(5, 7)); 위 코드에서는 클로저가 있을까? 특히 f3처럼 함수 안에서 함수를 리턴하면 클로저처럼 보인다. 하지만 이 코드의 f4에 담긴 f3도 클로저가 아니다. f3은 f2 안에서 생성되었고 f3 바로 위에는 a, b라는 지역 변수도 있다. 하지만 f3 안에서 사용하고 있는 변수는 c,d이고 두 변수는 모두 f3에서 정의되었다. 자신이 생성될 때의 스코프가 알고 있는 변수 a, b는 사용하지 않았다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 그러므로 f3이 기억해야 할 변수는 하나도 없다. 자신이 스스로 정의한 c, d는 f3이 실행되고 나면 없어진다. 다시 실행되면 c, d를 다시 생성하고 리턴 후에 변수는 사라진다. 1234567891011function f4() { var a = 10; var b = 20; function f5() { return a + b; } return f5();}console.log(f4()); 그렇다면 위 코드에서는 클로저가 있을까? 정확한 표현은 있었다이다. 결과적으로는 클로저는 없다고 볼 수 있다. f4가 실행되고 a, b가 할당된 후 f5가 정의된다. 그리고 f5에서는 a, b가 사용되고 있으므로 f5는 자신이 생성된 환경을 기억하는 클로저가 된다. 그런데 f4의 마지막 라인을 보면 f5를 실행하여 리턴한다. 결국 f5를 참조하고 있는 곳이 어디에도 없기 때문에 f5는 사라지고, f5가 사라지면 a, b도 결국 사라질 수 있기에 클로저는 f4가 실행되는 사이에만 생겼다가 사라진다. 123456789101112function f6() { var a = 10; function f7(b) { return a + b; } return f7;}var f8 = f6();console.log(f8(20));console.log(f8(10)); 드디어 클로저 코드를 사용했다. f7은 진짜 클로저다. 이제 a는 사라지지 않는다. f7이 a를 사용하기에 a를 기억해야 하고 f7이 f8에 담겼기 때문에 클로저가 되었다. 원래대로라면 f6의 지역 변수는 모두 사라져야 하지만 f6 실행이 끝났어도 f7이 a를 기억하는 클로저가 되었기 때문에 a는 사라지지 않으며, f8을 실행할 때마다 새로운 변수인 b와 함께 사용되어 결과를 만든다. 혹시 위 상황에 메모리 누수가 있다고 볼 수 있을까? 그렇지 않다. 메모리가 해제되지 않는 것과 메모리 누수는 다르다. 메모리 누수는 메모리가 해제되지 않을 때 일어나는 것은 맞지만, 위 상황을 메모리 누수라고 할 수는 없다. a는 한 번 생겨날 뿐, 계속해서 생겨나거나 하지 않는다. 메모리 누수란 개발자가 의도하지 않았는데 메모리가 해제되지 않고 계속 남는 것을 말하며, 메모리 누수가 지속적으로 반복될 때는 치명적인 문제를 만든다. f8이 아무리 많이 실행되더라도 이미 할당된 a가 그대로 유지되기 때문에 메모리 누수는 일어나지 않는다. 1234567891011function f9() { var a = 10; var f10 = function (c) { return a + b + c; } var b = 20; return f10;}var f11 = f9();console.log(f11(30)); 위 코드는 에러없이 정상 동작한다. 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수라고 했었는데, 여기서 ‘때’는 생각하는 것보다 조금 길다고 했었다.f10에는 익명 함수를 담았다. f10이 생성되기 딱 이전 시점에는 b가 20으로 초기화되지 않았다. 클로저는 자신이 생성되는 스코프의 모든 라인, 어느곳에서 선언된 변수든지 참조하고 기억할 수 있다. 그리고 그것은 변수이기에 클로저가 생성된 이후 언제라도 그 값은 변경될 수 있다. 클로저는 자바스크립트에서 절차지향 프로그래밍, 객체지향 프로그래밍, 함수형 프로그매일 모두를 지탱하는 매우 중요한 기능이자 개념이다. 분명 클로저는 메모리 누수 같은 위험성을 가지고 있다. 그러나 메모리 누수나 성능 저하의 문제는 클로저의 단점이나 문제가 아니다. 고차 함수고차 함수란, 함수를 다루는 함수를 말한다. 함수를 인자를 받아 대신 실행하는 함수 함수를 리턴하는 함수 함수를 인자를 받아서 또 다른 함수를 리턴하는 함수 고차 함수을 시작하기전 정의를 보고 클로저와의 차이점이 궁금해져 검색해봤다. “Closures are also functions. But when a function captures state upon its creation, we call it a closure.”즉, 클로저 역시 함수지만, 함수가 생성될 때 state를 점유하고 있다면 우리는 그것을 클로저라고 합니다. 출처: https://azsha.tistory.com/100 [Azsha’s Forge] 사실상 함수형 프로그래밍의 절반은 고차 함수를 적극적으로 활용하는 프로그래밍이라고도 할 수 있다. 1234567891011121314function callWith10(val, func) { return func(10, val);}function add(a, b) { return a + b;}function sub(a, b) { return a - b;}console.log(callWith10(20, add));console.log(callWith10(5, sub)); 여기서 add와 sub는 일반 함수다. 함수를 인자로 받거나 함수를 리턴하지 않기 때문이다. callWith10은 고차 함수다. 함수를 받아 내부에서 대신 실행하기 때문이다. 12345678910function constant(val) { return function () { return val; }}var always10 = constant(10);console.log(always10()); // 10console.log(always10()); // 10console.log(always10()); // 10 constant 함수는 실행 당시 받았던 10이라는 값을 받아 내부에서 익명 함수를 클로저로 만들어 val를 기억하게 만든 수 리턴한다. 리턴된 함수에는 always10 이라는 이름을 지어주었다. always10을 실행하면 항상 10을 리턴한다. 12345678910function callWith(val1) { return function (val2, func) { return func(val1, val2); }}var callWith10 = callWith(10);console.log(callWith10(20, add)); // 30var callWith5 = callWith(5);console.log(callWith5(5, sub)); // 0 callWith는 함수를 리턴하는 함수다. val1을 받아서 val1을 기억하는 함수를 리턴했다. 리턴된 함수는 이후에 val2와 func를 받아 대신 func를 실행해 준다. 함수를 리턴하는 함수를 사옹할 경우 다음처럼 변수에 담지 않고 바로 실행해도 된다. 12console.log(callWith(30)(20, add));console.log(callWith(5)(5, sub)); 인자는 숫가자 아닌 값도 활용이 가능하다.123456789101112_.get = function (list, index) { return list[index];}var users = [ { id: 2, name: \"HA\", age: 25 }, { id: 4, name: \"PJ\", age: 28 }, { id: 5, name: \"JE\", age: 27 },];var callWithUsers = callWith(users);console.log(callWithUsers(2, _.get)); 콜백 함수라 잘못 불리는 보조 함수콜백 함수를 받아 자신이 해야 할 일을 모두 끝낸 후 결과를 되돌려 주는 함수도 고차 함수다. 보통은 비동기가 일어나는 상황에서 사용되며 콜백 함수를 통해 다시 원래 위치로 돌아오기 위해 사용되는 패턴이다. 콜백 패턴은 클로저 등과 함께 사용할 수 있는 매우 강력한 표현이자 비동기 프로그래밍에 있어 없어서는 안 될 매우 중요한 패턴이다. 콜백 패턴은 끝이 나면 컨텍스트를 다시 돌려주는 단순한 협업 로직을 가진다. button.click(function() {})과 같은 코드의 익명 함수도 콜백 함수라고 표현되는 것을 많이 보았지만, 이 익명 함수는 ‘이벤트 리스너’라고 칭하는 것이 적합하다. 함수가 고차 함수에서 쓰이는 역할의 이름으로 불러주면 된다. _.each([1,2,3], function() {})에서의 익명 함수는 callback이 아니라 iteratee이며 _.filter(users, function() {})에서의 익명 함수는 predicate다. callback은 종료가 되었을 때 단 한 번 실행되지만 iteratee나 predicate, listener등은 종료될 때 실행되지 않으며 상황에 따라 여러 번 실행되기도 하고 각각 다른 역할을 한다. 함수를 리턴하는 함수와 부분 적용앞서 곳곳에서 미리 필요한 인자를 넘겨 두고 그 인자를 기억하는 클로저를 리턴하는 함수들을 확인했다. 클로저로 만들어진 함수가 추가적으로 인자를 받아 로직을 완성해 나가는 패턴을 갖는다. 이와 유사한 기법들로 bind, curry, partial 등이 있다. 이런 기법들을 통틀어 칭하는 특별한 용어는 없지만 다음과 같은 공통점을 갖는다. 기억하는 인자 혹은 변수가 있는 클로저를 리턴한다. bind는 this와 인자들이 부분적으로 적용된 함수를 리턴한다. bind의 경우 인자보다는 주로 함수 안에서 사용될 this를 적용해 두는데 많이 사용한다. 그 이유는 아마 this 적용을 스킵할 수 없다는 점과 인자의 부분 적용을 왼쪽에서 부터 순서대로 할 수 있는 점 때문일 것이다. 12345function add(a, b) { return a + b;}var add10 = add.bind(null, 10);console.log(add10(20)); // 30 bind는 첫 번째 인자로 bind가 리턴할 함수에서 사용될 this를 받는다. 두 번째 인자부터 함수에 미리 적용될 인자들이다. 인자를 미리 적용해 두기 위해 this로 사용될 첫 번째 인자에 null을 넣은 후 10을 넣었다. add10과 같이 this를 사용하지 않는 함수이면서 왼쪽에서 부터 순서대로만 인자를 적용하면 되는 상황에서는 원하는 결과를 얻을 수 있다. bind의 아쉬운 점은 두 가지다. 인자를 왼쪽에서 부터 순서대로만 적용할 수 있다는 점과 bind를 한 번 실행한 함수의 this는 무엇을 적용해 두었든 앞으로 바꿀 수 없다는 점이다.bind는 왼쪽에서 부터 원하는 만큼의 인자를 지정해 둘 수 있지만 원하는 지점을 비워 두고 적용할 수는 없다. 예를 들어 어떤 함수가 필요로 하는 인자가 3개가 있는데 그 중 두 번째 인자만을 적용해 두고 싶다면 bind로는 이것을 할 수 없다. 이러한 점을 개선한 방식이 있는데 바로 partial 이다. 존 레식의 partial123456789101112131415161718Function.prototype.partial = function () { var fn = this, args = Array.prototype.slice.call(arguments); // 1 return function () { // 2 var arg = 0; for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) // 5 if (args[i] === undefined) args[i] = arguments[arg++]; // 6 return fn.apply(this, args); }}function abc(a, b, c) { console.log(a, b, c);}var ac = abc.partial(undefined, 'b', undefined); // 3 ac('a', 'c'); // 4// a, b, c 우선 partial이 실행되면 fn에 자기 자신인 this를 담는다. 여기서 자기 자신은 abc 같은 함수다. args에는 partial이 실행될 때 넘어온 인자들을 배열로 변경하여 args에 담아 둔다. fn과 args는 리턴된 익명 함수가 기억하게 되므로 지워지지 않는다. abc.partial을 실행할 때 첫 번째 인자와 세 번쩨 인자로 넘긴 undefined 자리는 나중에 ac가 실행될 때 채워질 것이다. ac를 실행하면서 넘긴 ‘a’와 ‘c’는 리턴된 익명 함수의 arguments에 담겨 있다. for를 돌면서 미리 받아 두었던 args에 undefined가 들어 있던 자리를 arguments의 앞에서 부터 꺼내면서 모두 채운다. 다 채우고 나면 미리 받아 두었던 fn을 apply로 실행하면서 인자들을 배열로 넘긴다. 사실 partial은 구현이 잘 된 것은 아니다. 함수의 인자로 undefined를 사용하고 싶을 수도 있는데 undefined가 인자를 비워 두기 우한 구분자로 사용되고 있기 때문에, undefined를 미리 적용하고 싶다면 방법이 없다. 또한 초기에 partial을 실행할 때 나중에 실제로 실행될 함수에서 사용할 인자의 개수만큼 꼭 미리 채워 놓아야만 한다. 이 처럼 partial이 가진 제약은 ‘인자 개수 동적으로 사용하기’나 ‘arguments 객체 활용’과 같은 자바스크립트의 유연함을 반영하지 못한다는 점에서 특히 아쉽다. 123456789101112131415161718function add() { var result = 0; for (var i = 0; i &lt; arguments.length; i++) { result += arguments[i]; } return result;}console.log(add(1, 2, 3, 4, 5));var add2 = add.partial(undefined, 2);console.log(add2(1, 3, 4, 5)); // 3var add3 = add.partial(undefined, undefined, 3, undefined, undefined);console.log(add3(1, 2, 4, 5)); // 15console.log(add3(50, 50, 50, 50)); // 15 (bug)console.log(add3(100, 100, 100, 100)); // 15 (bug) 위 상황에서 add2는 3, 4, 5 인자를 무시하게 된다. add3처럼 하면 1, 2, 4, 5를 모두 사용할 수 있게 되지만 undefined로라도 인자 개수를 채워놔야 해서 코드가 깔끔하지 못하고 partial 이후에는 역시 4개 이상의 인자를 사용할 수 없다는 단점이 생긴다.위 코드에는 치명적인 문제가 있다. 의도한 것인지는 모르겠지만 그가 만든 partial 함수로 만든 함수는 재사용이 사실상 불가능하다. 한번 partial을 통해 만들어진 함수를 실행하고 나면 클로저로 생성된 args의 상태를 직접 변경하기 때문에, 다음번에 다시 실행해도 같은 args를 바라보고 이전에 적용된 인자가 남는다. 결과적으로 partial로 만들어진 함수는 단 한 번만 정상적으로 동작한다. 1234567891011Function.prototype.partial = function () { var fn = this, _args = arguments; return function () { var args = Array.prototype.slice.call(_args); var arg = 0; for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) if (args[i] === undefined) args[i] = arguments[arg++]; return fn.apply(this, args); }} 다음과 같이 두 줄만 변경하면 두 번 이상 실행해도 정상적으로 동작한다. 클로저가 기억할 변수에는 원본을 남기고 리턴된 함수가 실행될 때마다 복사하여 원본을 지키는 방식을 사용한다. Conclusion오늘은 본격적인 함수형 프로그래밍 시작에 앞서 기본이 될 기능들을 확인해 봤다. 일급 함수 같은 처음 듣는 용어도 있었고, 고차 함수 같은 경우는 내가 실무에서도 사용하고 있지만 정확한 용어도 모르고 사용하고 있었다. 또한 클로저, callback의 존재?는 알고 있었지만 정확한 개념이 부족했다는 것을 느꼈다. 오늘 내용의 모든 기능들의 대한 설명이 이 포스트로는 부족하지만 실력 향상에 많은 도움이 될 것같다. 기록해 두고 자주 보면서 내 것으로 만들어야 할 것 같다. partial 같은 함수를 보고 들었던 생각은 함수형 프로그래밍의 끝은 어디 일까가 궁금해졌다. 정말 나는 생각도 못했던 기능이고 저게 그래서 실무에서 필요할까? 라는 생각을 했다. 하지만 partial과 같은 helper 함수들을 구현해 놓고 사용하면 생산성이 눈에 띄게 좋아질 것 같다고 생각한다. 이제 1장의 내용이 끝났는데 다음 장의 내용은 함수형 자바스크립트를 위한 문법 다시보기 이다. 이미 알고 있던 내용일 지더라도 기초를 더 다지기 위해 소홀히 보지 않아야겠다. 참조: 함수형 자바스크립트 프로그래밍","link":"/2019/10/13/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88/"},{"title":"함수 조립하기","text":"함수 조립하기함수형 자바스크립트 기법을 잘 활용하면 소프트웨어의 기능을 변경하거나 추가하기가 쉽다. 작은 단위로 쪼갠 함수들을 조합하여 큰 기능을 만들면 조합된 함수 사이사이에 새로운 함수를 추가하는 식으로 쉽게 확장해 나갈 수 있다. 함수형 자바스크립트 10가지 기법 함수를 되도록 작게 만들기 다형성 높은 함수를 만들기 상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화하기 동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기 복잡한 객체 하나를 인자로 사용하기보다는 되도록 일반적인 값 여러개를 인자로 사용하기 큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기 어느 곳에서든 바로 실행하거나 혹은 미뤄서 실행할 수 있도록 일반 함수이자 순수 함수로 선언하기 모델이나 컬렉션 등의 커스텀 객체보다는 기본 객체를 이용하기 로직의 흐름을 최대한 단방향으로 흐르게 하기 작은 함수를 모아 큰 함수를 만들기 이번 장에서는 작은 함수로 큰 함수를 만드는 방법들을 다룬다. 객체지향에 빗대어 표현하면 클래스와 인스턴스에 대해서 처음 다루는 장이라고 할 수도 있겠다. 고차 함수와 보조 함수이번 장에서는 고차 함수의 다양한 사례를 통해 함수 조립에 대한 생각들을 확장하고자 한다. 함수를 주재료로 다루는 함수들을 다룰 것이다. 한 번만 실행하는 함수1234567891011121314151617_.once = function (func) { var flag, result; return function () { if (flag) return result; flag = true; return result = func.apply(this, arguments); }}var hi = _.once(function () { console.log('hi');})hi();// hihi();// 아무일도 일어나지 않음 _.once는 받아 둔 익명 함수가 한 번만 실행되도록 설정된 함수를 리턴한다. 이런 기능을 구현하기 위해서는 flag 값이 필요하며 flag 값에 따라 실행할 것인지 말 것인지 대해 판단하는 로직이 어딘가에 있어야 한다. 12345678910var a = _.once(function () { console.log('A'); return 'B';})console.log(a());// A// Bconsole.log(a());// B 다시 물어 보지 않는 함수123456function skip(body) { var yes; return function () { return yes || (yes = body.apply(null, arguments)); }} 최초 한번만 실행을 하고 그 이후로는 실행이 되지 않는다. skip은 고차 함수이고 body는 skip이 남겨 놓은 로직을 완성하는 함수다. 함수형 자바스크립트는 함수로 함수를 다루거나 함수로 함수를 만드는 것의 반복이고, 고차 함수 응용의 반복이다.skip은 고차 함수이자 함수를 만드는 함수다. 함수로 함수를 만들 때는 재료로 함수가 사용되기도 하고 일반 값이 사용되기도 한다. 함수로 만들어진 함수는 대부분 클로저다. 앞서 받은 인자 혹은 상황을 변경해 나가는 경우skip같은 함수는 앞서 만든 상황을 변경해 나가는 사례다. 처음에는 false로 시작했지만 true로 변경하여 이후 동작을 다르게 만들기 위해 사용한다. 1234567891011121314151617function idMaker(start) { return function () { return ++start; }}var messageCid = idMaker(0);messageCid();// 1messageCid();// 2var postCid = idMaker(11);postCid()// 12postCid()// 13 idMaker는 원하는 시작점부터 시작해 실행할 때마다 증가한 고유한 아이디 값을 만드는 함수를 만드는 함수다. idMaker는 메신저 등을 만들 때 사용할 수 있다. 사용자가 메시지를 입력하고 엔터 키를 쳤을 때, 임시로 클라이언트 측 고유 아이디를 만들어 메시지에 해당하는 HTML 요소를 즉시 그려 둔 다음, 서버에게 정보를 보내어 DB에 저장하고 응답으로 온 데이터를, 만들어 두었던 클라이언트 측 고유 아이디를 기준으로 매핑한다. 앞서 받은 인자를 잘 유지해야 하는 경우클로저가 기억하고 있는 외부 변수도 일반 변수처럼 언제든지 값이 변경될 수 있다. 앞선 _.once, skip, idMaker 사례는 값이 변경되는 점을 이용한 기법이다. 이번에는 반대로 값을 잘 유지해야 하는 상황을 살펴 볼 텐데, 이런 상황에서 실수가 많이 생긴다. 특히 앞서 받은 인자와 나중에 받은 인자를 조합하여 결과를 만들려고 할 때는 실수하기가 쉽다. 이럴 때는 계속 사용할 객체는 원래 상태를 잘 유지하도록, 한 번만 쓰이고 사라져야 할 값은 사라지도록 잘 관리해 주어야 한다. 앞서 받은 인자의 상태가 변경되지 않도록 concat이나 slice를 이용해 항상 새로운 객체를 만든다거나, _.rest 같은 함수를 이용해 인자의 일부분을 잘 제외시켜야 하는데, 이 것을 어떤 타이밍에 하는지가 중요하다. 부분 적용_.partial로 함수 만들기1234567891011121314151617181920212223var pc = _.partial(console.log, 1);pc(2);// 2가 오른쪽으로 들어감pc(2, 3);// 2, 3이 오른쪽으로 들어감var pc = _.partial(console.log, _, 2);pc(1);// 1, 2 1이 왼쪽의 _ 자리에 들어감pc(1, 3);// 1 2 3 1이 왼쪽의 _자리에 들어가고 3이 오른쪽으로 들어감var pc = _.partial(console.log, _, _, 3);pc(1);// 1 undefined 3 1이 왼쪽 _ 자리에 들어가고 두 번째 _는 들어오지 않아 undefined 가 됨pc(1, 2);// 1 2 3 1과 2가 순서대로 _, _ 를 채움pc(1, 2, 4);// 1 2 3 4 1과 2가 순서대로 _, _를 채우고 3의 오른쪽으로 4가 들어감var pc = _.partial(console.log, _, 2, _, _, 5);pc(1, 3, 4, 6)// 1 2 3 4 5 6 _.partial 함수를 이용하면 원하는 위치에 인자를 부분적으로 적용할 수 있다. _.partial을 활용한 다양한 함수 조립 사례를 확인해보자. 12345var add_all = _.partial(_.reduce, _, function (a, b) { return a + b });console.log(add_all([1, 2, 3, 4]));// 10console.log(add_all([5, 2]));// 7 _.partial은 함수를 다루는 고차 함수다. _.reduce도 고차 함수다. 위 코드 처럼 _.partial을 이용해 _.reduce와 같은 고차 함수에 미리 보조 함수를 적용해 두는식으로 add_all 같은 함수를 구현할 수 있다. _.partial은 정말 강력하다. _.partial을 이용하면, 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있다. 12345678910111213141516var method = function (obj, method) { return obj[method].apply(obj, _.rest(arguments, 2));}var push = _.partial(method, _, 'push');var shift = _.partial(method, _, 'shift');var a = [1, 2];push(a, 3);console.log(a);shift(a);console.log(a);var b = method([1, 2, 3], 'concat', 4, 5);console.log(b); 이번 method 함수로 함수를 만드는 함수가 아닌 혼자서도 실행할 수 있는 일반 함수가 되었다. 이러한 방식의 이점은 method 같은 함수가 혼자서도 활용 가능한 함수가 된다는 점이다. _.partial과 _.compose로 함수 만들기_.partial은 함수를 연속으로 실행해 주는 _.compose 등의 함수와 함께 더 재미있게 사용할 수 있다. _.compose는 오른쪽의 함수를 실행한 결과를 왼쪽의 함수에게 전달하는 것을 반복하는 고차 함수이다. _.compose는 인자로 함수만 받는 함수다. 12345678910111213141516171819202122232425262728293031323334_.compose(console.log, function (a) { return a - 2 }, function (a) { return a + 5 })(0);// console.log &lt;- 5 - 2 &lt;- 0 + 5 &lt;- 0var falsy_values = _.compose( _.partial(_.isEqual, -1), // 1 _.partial(_.findIndex, _, _.identity) // 2);console.log(falsy_values([1, true, {}]));// falseconsole.log(falsy_values([0, 1, false]));// falseconsole.log(falsy_values([0, \"\", false]));// truevar some = _.negate(falsy_values); // 3console.log(some([1, true, {}]));// trueconsole.log(some([0, 1, false]));// trueconsole.log(some(0, \"\", false));// falsevar every = _.compose( _.partial(_.isEqual, -1), _.partial(_.findIndex, _, _.negate(_.identity)) // 4);console.log(every([1, true, {}]));// trueconsole.log(every([0, 1, false]));// falseconsole.log(every([0, \"\", false]));// false _.isEqual 함수에 -1을 부분 적용하여, 앞에서 나온 결과가 -1과 같은지를 검사하는 함수 만들기 -1 과 비교하는 함수가 실행되기 전에는 _.findIndex에 _.identity 를 부분 적용해 둔 함수가 실행된다. _.findIndex는 긍정적인 값을 처음 만났을 때의 index를 리턴한다. _.compose 를 통해 두 함수를 역순으로 나열했고, falsy_values 는 배열에 들어있는 모든 값이 부정적인 값인지를 판단하는 함수가 된다. 받은 함수를 실행한 후, 결과를 반대로 만드는 함수를 리턴하는 함수인 _.negate 와 앞서 조합한 falsy_values를 조합하여 하나라도 긍정적인 값이 있는지를 체크하는 some 함수를 만들었다. falay_values를 조합던 코듸의 _.identity 부분만 _.negate로 감싸서 모두 긍정적인 값이 맞는지를 체크하는 every 함수 더 나은 _.partial 함수_.partial은 인자를 왼쪽에서부터 하나씩 적용하면서 _로 구분하여 인자가 적용될 위치를 지정해 둘 수 있도록 한다. 이런 _.partial에도 한 가지 아쉬움이 있다. 자바스크립트 함수는 인자 개수가 유동적일 수 있고 함수의 마지막 인자를 중요하게 사용할 수도 있는데, 이 같은 함수화 _.partial은 합이 잘 맞지 않는다. 12345678910111213141516171819202122232425262728293031function add(a, b) { return a + b;}function sub(a, b) { return a - b;}function m() { var iter = arguments[arguments.length - 1]; arguments.length--; return _.reduce(arguments, iter);}m(100, 50, add);// 150m(100, 50, 10, add);// 160m(100, 50, sub);// 50m(100, 50, 10, sub);// 40var f1 = _.partial(m, _, _, _, add);// f1 은 3개의 인자만 더할 수 있다.f1(1, 1, 1);// 3f1(1, 1);// NaNf1(1, 1, 1, 1);// _.reduce에 1이 넘어가면서 에러 f1의 상황처럼 인자를 유동적으로 다루는 함수는 _.partial로 다루기 좋지 않다. 맨 왼쪽 인자나 맨 왼쪽에서 두 번째 인자를 적용해 두는 것은 가능하지만 맨 오른쪽 인자나 맨 오른쪽에서 두 번째에만 인자를 적용해 두는것은 불가능 하기 때문이다. Lodash 는 이를 위해 _.partialRight를 구현했지만 양쪽 끝 모두를 부분 적용하고, 가운데 부분을 가변적으로 가져가고 싶을 때도 있기에 아직 아쉽다. 12345678910111213141516171819202122232425262728293031var ___ = {};_.partial = function (fn) { var args1 = [], args3, len = arguments.length, ___idx = len; for (var i = 1; i &lt; len; i++) { var arg = arguments[i]; if (arg == ___ &amp;&amp; (___idx = i) &amp;&amp; (args3 = [])) continue; if (i &lt; ___idx) args1.push(arg); else args3.push(arg); } return function () { return fn.apply(this, mergeArgs(args1, arguments, args3)) };};function _toUndef(args1, args2, args3) { if (args2) args1 = args1.concat(args2); if (args3) args1 = args1.concat(args3); for (var i = 0, len = args1.length; i &lt; len; i++) if (args1[i] == _) args1[i] = undefined; return args1;}function mergeArgs(args1, args2, args3) { if (!args2.length) return args3 ? _toUndef(args1, args3) : _toUndef(args1.slice()); var n_args1 = args1.slice(), args2 = _.toArray(args2), i = -1, len = n_args1.length; while (++i &lt; len) if (n_args1[i] == _) n_args1[i] = args2.shift(); if (!args3) return _toUndef(n_args1, args2.length ? args2 : undefined); var n_arg3 = args3.slice(), i = n_arg3.length; while (i--) if (n_arg3[i] == _) n_arg3[i] = args2.pop(); return args2.length ? _toUndef(n_args1, args2, n_arg3) : _toUndef(n_args1, n_arg3);} 복잡해 보이지만 생각보다 단순하다. 우선 새로운 구분자인 _ 가 추가 되었다. _.partial을 실행하면 _를 기준으로 왼편의 인자들을 왼쪽부터 적용하고 오른편의 인자들을 오른쪽부터 적용할 준비를 해 둔 함수를 리턴한다. 부분 적용된 함수를 나중에 실행하면 그때 받은 인자들로 왼쪽과 오른쪽을 먼저 채운 후, 남은 인자들로 가운데 ___자리를 채운다. 12345678910111213141516171819var pc = _.partial(console.log, ___, 2, 3);pc(1);// 1 2 3pc(1, 4, 5, 6);// 1 4 5 6 2 3var pc = _.partial(console.log, _, 2, ___, 5, _, 7);pc(1);// 1 2 5 undefined 7pc(1, 3, 4);// 1 2 3 5 4 7pc(1, 3, 4, 6, 8);// 1 2 3 4 6 5 8 7var add_all = _.partial(m, ___, add);add_all(1, 2, 3, 4);var sub10 = _.partial(m, ___, 10, sub);sub10(50, 20); _.partial을 이용하면 인자를 조합하기 위해 함수로 함수를 만드는 경우를 모두 대체할 수 있고, 코드에 함수 표현식이 나오는것도 많이 줄일 수 있다. 이렇게 하면 _.chain, _.compose, _.pipeline 등의 함수 합성 패턴과도 잘 어울리고 함수를 조립하는 것도 즐거워 진다. 함수에 인자를 미리 적용해 두는 기법은 비동기 상황에서도 효과적으로 쓰인다. 연속적인 함수 실행체인의 아쉬운점체인은 메서드를 연속적으로 실행하면서 객체의 상태를 변경해 나가는 기법이다. 체인은 표현력이 좋고 실행 순서를 눈으로 따라가기에도 좋다. 체인 방식은 많은 장점을 가지고 있지만 체인 방식으로만 모든 로직을 구현하기에는 다소 불편한 점이 있다. 체인 방식은 체인 객체가 가지고 있는 메서드만 이용할 수 있기 때문에 체인 객체와 연관 없는 로직이나 다른 재료를 중간에 섞어 사용하기 어렵다. 정해진 메서드나 규격에 맞춰서 사용해야 하기 때문에 인자를 자유롭게 사용하기 어렵고 다양한 로직을 만들기도 어렵다. 따라서 결과를 완성해 나가는 과정에서 체인을 끊어야 하는 경우가 많다. 체인 방식은 사용하기는 쉽지만 잘 만들어 두기는 어렵다. this만 리턴하면 되는데 뭐가 어렵냐고 할 수 있지만, 가만히 생각해 보면 잘 쓰이는 체인 API는 그렇게 많지 않다. 잘 쓰이는 체인 API가 되려면 우선 체인 패턴과 잘 어울리는 주제여야 한다. 체인 방식은 객체가 생성되어야만 메서드를 사용할 수 있기 때문에 반드시 생성 단계를 거쳐야 한다. 그리고 this 등의 상태와 흐름과 깊이에 의존하기 때문에 언제 어디서나 아무 때나 사용이 가능한 순수 함수보다는 접근성면에서 좀 불편하다. _.compose의 아쉬운 점_.compose 함수는 디자인 패턴과 같은 특별한 개념이나 지식 없어도, 바로 코딩 및 설계가 가능하다는 장점이 있다. 인자와 결과만을 생각하면서 작은 함수들을 조합하면 된다. 몇 가지 아쉬운 점이 있는데 그중 가장 큰 아쉬움은, 함수 실행의 순서가 오른쪽에서부터 왼쪽이기 때문에 읽기가 어렵다는 점이다. 함수 실행을 중첩해서 하는 것과 코드의 표현력이 크게 다를 바가 없고, 기능적으로도 특별히 나을 점이 없다. 파이프라인파이프라인은 _.compose의 장점을 그대로 가지고 있다. _.compose와 기본적인 사용법은 동일하다. 다만, 함수 실행 방향은 왼쪽에서부터 오른쪽이다. 왼쪽에서부터 오른쪽, 위에서부터 아래로 표현되어 코드를 읽기 쉽다. 또한 체인과 달리 아무 함수나 사용할 수 있어 자유도가 높다. 여기서는 이런 파이프라인의 장점들을 살펴볼 것이다. Michael Fogus의 _.pipeline 123456789101112131415161718192021_.pipeline = function () { var funs = arguments; // 1. 함수들 return function (seed) { // 2. 첫 인자 return _.reduce(funs, function (l, r) { return r(l); }, // 4. 모든 함수를 연속적으로 실행 seed) // 3. 첫 인자 전달 }};var div_square = _.pipeline( function (a) { return a / 2; }, function (a) { return a * a; });console.log(div_square(6));// 9 _.pipeline은 _.reduce를 이용해서 만들어졌다. _.reduce는 정말 강력한 함수다. 위 상황에서 가지고 있는 데이터는 함수들이고 만들고자 하는 데이터는 최초 인자로부터 시작해 모든 함수를 통과한 마지막 결과이다. arguments를 지역 변수 funs에 담았다. funs를 기억하는 함수를 리턴한다. 리턴된 함수가 나중에 실행되면 받은 인자인 seed를 _.reduce 의 마지막 인자로 넘겨주어 seed는 최초의 l이 된다. 예측해 보건대 l 은 left고 r은 right인 듯 하다. 오른쪽 함수를 r을 실행하며 왼쪽 함수의 결과 l을 넘겨주고 있다. funs의 개수만큼 반복되며 마지막 함수의 결과가 곧 _.pipeline으로 만든 함수의 결과가 된다. 클래스를 대신하는 파이프라인_.pipeline은 작은 함수들을 모아 큰 함수를 만드는 함수다. 파이프라인은 클래스와 기능적인 면과 개념적인 면이 다르지만 비슷한 역할을 대신할 수 있다. 작은 함수들을 조합하여 큰 함수들을 만들고 함수 조합을 조금씩 변경하거나 추가하면서 새로운 로직을 만들어 갈 수 있다. 회원가입을 예로 들어 보자. 개인 회원과 기업 회원이 있다고 가정하면, 회원 가입과 관련된 작은 로직들을 작은 함수 단위로 쪼개어 나눈 후 약간 변경하여 조합하거나 더할 수 있고, 뺄 수도 있다. 12345678910111213141516171819202122232425262728293031323334353637var users = [];var companies = [];function joined_at(attrs) { return _.extend(attrs, { joined_at: new Date() })}function greeting(member) { return member.name + \" 회원님은 \" + member.id + \" 번째 회원이십니다. 환영합니다.\";}var join_user = _.pipeline( joined_at, function (member) { users.push(member); member.id = users.length; return member; }, greeting);var join_company = _.pipeline( joined_at, function (member) { companies.push(member); member.id = companies.length; return member; }, greeting);console.log(join_user({ name: \"ID\" }));// ID 회원님은 1 번째 회원이십니다. 환영합니다.console.log(join_user({ name: \"JI\" }));// JI 회원님은 2 번째 회원이십니다. 환영합니다.console.log(join_company({ name: \"MARPPLE\" }));// MARPPLE 회원님은 1 번째 회원이십니다. 환영합니다. join_user와 join_company는 두 번째 함수만 다르고 첫 번째와 세 번째 함수는 동일하게 조합되었다. 위에서 부터 내려오면서 가입 날짜를 만들고 서로 다른 배열에 담은 후 인사말을 남기고 있다._.partial을 함께 이용하면 아래와 같은 표현이 가능하다. 12345678910111213141516171819202122232425function joined_at(attrs) { return _.extend(attrs, { joined_at: new Date() })}function join(table, member) { table.push(member); member.id = table.length; return member;}function greeting(member) { return member.name + \" 회원님은 \" + member.id + \" 번째 회원이십니다. 환영합니다.\";}var join_user = _.pipeline( joined_at, _.partial(join, users), greeting);var join_company = _.pipeline( joined_at, _.partial(join, companies), greeting); 이번에는 _.partial을 이용해 users에 담을지 companies에 담을지를 선택했다. 이런 방식은 로직을 단순하게 한다. 서로 다른 기능을 하지만 조건문이 없다. 각자 자신이 해야 할 일만 순서대로 수행할 뿐이다. 작은 함수는 작성이 쉽고 테스트도 쉬우면 오류도 적기 마련이다. 앞뒤로 받을 인자와 결과만을 생각하면서 문제를 작게 만들면 문제 해결도 쉬워진다. 더 나은 파이프라인, 그리고 Multiple ResultsUnderscore.js의 _.pipeline이나 Lodash의 _.flow에는 아쉬운 점이 있다. 인자를 하나만 받을 수 있다는 점이다. 파이프라인에 사용된 내부 함수들 역시 마찬가지다. 파이프라인 내부에서 function (a, b) { return a + b; } 와 같은 함수는 사용할 수 없다는 얘기다. 물론 객체나 배열에 담아 다음 함수에게 전달할 수도 있겠지만 function(args) { return args[0] + args[1]; } 과 같은 함수는 파이프라인만을 위한 함수라고 봐야 한다. 클로저나 _.partial을 이용해서 인자나 재료를 늘릴 수 있지만 자칫 외부 상황에 의존하는 함수가 될 수 있다. 함수형 자바스크립트는 순수 함수를 많이 사용할수록, 인자들을 적극 활용할수록 강력해진다. 인자는 특히 2~3개 사용할 때도 많고 개수가 가변적인 경우도 많다. 인자를 2개 이상 필요로 하는 함수들을 파이프라인 사이에 끼워 넣지 못한다는 것은, 곧 파이프라인 사이에 정의된 함수들의 재사용성도 낮아진다는 얘기다. 만일 언어가 Go였다면 함수의 결과로 Multiple Results를 리턴할 수 있고 파이프라인 중간중간에 여러 개의 인자를 받는 함수들을 얼마든지 끼워 넣을 수 있을 것이다. Multiple Results는 함수의 결과값을 여러 개로 리턴하는 개념이다. 자바스크립트에는 이러한 기능이 없지만 이것을 대체하는 기능을 구현할 수 있다. 여러 개의 값을 모아 Multiple Results를 뜻하는 객체로 만든 후 파이프라인 안에서 Multiple Results에 담긴 인자를 다시 여러개로 펼쳐서 실행하도록 구현하면 된다. 123456789101112131415161718_.mr = function () { arguments._mr = true; // 인자들이 담긴 arguments 객체에 _mr로 구분자를 만듬 return arguments;}_.pipeline = function () { var funs = arguments; return function (seed) { return _.reduce(funs, function (l, r) { // Multiple Results라면 apply로 인자를 펼침. return l &amp;&amp; l._mr ? r.apply(null, l) : r(l); }, // 인자가 여러개면 첫 번째 함수에게도 Multiple Results로 만들어서 넘기기 arguments.length &lt; 2 ? seed : _.mr.apply(null, arguments) ) }}; apply는 배열이나 arguments 객체를 받아 함수의 인자들로 펼쳐준다. 함수를 실행하기 전 l이 Multiple Results라면 r.apply()를 이용해 r 함수에게 인자를 여러개로 전달할 수 있도록 기능을 추가했다. 1234567891011121314151617181920function add(a, b) { return a + b;}function square(a) { return a * a;}function sub(a, b) { return a - b;}var f1 = _.pipeline( add, square, function (a) { return _.mr(a, a / 5); // Multiple Results }, sub);console.log(f1(3, 2));// 20 이제 add와 sub 같이 인자를 2개 이상 사용하는 일반 함수들도 파이프라인 사이에 넣을 수 있게 되었다. _.pipeline으로 함수를 정의하면 Multiple Results 를 지원하는 함수가 되어, 함수를 중첩하기만 해도 마치 Go 언어 처럼 동작한다. 더 나은 함수 조립함수를 조립하는 데에도 함수가 사용된다. 함수를 재료로 사용하고, 재료를 함수로 실행하면서 로직을 완성한다. 함수로 함수를 만드는 방법들을 더 정교하게 잘 다루면 훨씬 다양하고 재밌게 조합할 수 있다. _.partial이나 _.pipeline의 기능을 높인다거나 그동안 살펴보았던 함수형 스타일의 함수들에게 부분 커링을 내장하도록 한다거나 하면 함수 조립의 효과를 더욱 높일 수 있다. Partial.js의 _.pipe마이클 포거스의 _.pipeline은 Multiple Results를 지원하지 않는 아쉬움이 있었다. 한 가지 아쉬운 점이 더 있는데, 파이프라인의 내부 함수에서 this를 사용할 수 없다는 점이다. 자바스크립트에서의 함수는 메서드든 아니든 this를 사용할 수 있도록 되어있다. 새로운 기능을 만들 때, 기존의 기본 기능을 유지하는 것은 언제나 중요한 일이다. Partial.js의 파이프라인 함수인 _.pipe는 Multiple Results와 this를 모두 지원한다. 그리고 Multiple Results를 사용할 수 있기 때문에 인자를 2개 이상 필요로 하는 함수도 함께 사용할 수 있고, this를 사용할 수 있기 때문에 메서드를 만들거나 this를 사용하는 라이브러리들과 협업이 가능하다. 12345678910111213141516171819202122232425262728_.pipe( function () { return this.a; }, console.log, // 1 function () { this.b = 2; return this; }, console.log, // {a: 1, b: 2}).call({ a: 1 });var obj = { a: 10, method1: _.pipe( function () { return this.a; }, console.log, // 10 function () { this.b = 2; return this; }, console.log // {a: 10, b: 2, method1: ƒ} )}obj.method1(); 즉시 실행 파이프라인 _.go_.go는 _.pipe의 즉시 실행 버전이다. 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 편하기 때문에 첫 번째 인자를 파이프라인에서 사용할 인자로 정했다. 12345_.go(10, function (a) { return a / 2 }, function (a) { return a + 2 }, console.log // 7) 참조: 함수형 자바스크립트 프로그래밍","link":"/2019/11/17/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD%ED%95%98%EA%B8%B0/"},{"title":"함수형 자바스크립트를 위한 문법 다시 보기-2","text":"if else || &amp;&amp; 삼항 연산자 다시 보기if의 괄호if 와 else if 다음에는 괄호가 나온다. 괄호에서는 기본적으로 true와 false를 받으며, true로 해석되는 값과 false로 해석되는 값도 받는다. 그리고 괄호 안에서는 거의 모든 일을 할 수 있다. 코드를 실행할 수 있다는 얘기다. if의 괄호에서 못 하는 일이 있는데 지역 변수를 선언하는 것과 지역 함수를 선언하는 것이다. 괄호에서 할 수 없는 일이 한 가지 더 있는데, 바로 비동기 프로그래밍이다. 자바스크립트에서는 비동기 코드를 if와 함께 사용하기 어렵다.if (expression) { statements } 중 statements 부분에는 비동기 코드를 활용할 여지가 있고 몇 가지 아이디어를 통해 어느정도 제어가 가능하지만 if의 괄호 부분은 비동기 코드와 거리가 좀 있다. 하지만 괄호 안에서 할 수 있는 일들은 많다. 새로운 객체를 생성할 수도 있고 객체의 key에 값을 할당할 수도 있으며 함수를 실행할 수도 있다. 먼저 에러가 발생하는 코드를 확인해보자. 1if (var a = 0) console.log(a); 위 코드는 문법 에러가 난다. 괄호에서는 표현식만 사용할 수 있기 때문이다. 아래 코드는 에러는 나지 않지만 쓸모없는 코드다. 12if (function f1() {}) console.log('hi');f1(); f1을 정의하는 곳에서는 에러가 나지 않았고 hi도 출력했지만 f1은 실행할 수 없다. f1이 값으로 다뤄져서 유명 함수로 선언되었기 때문이다. f1은 어디에서도 참조할 수 없어 위 코드는 사실상 에러가 나지 않지만 아무런 의미가 없는 코드다. 12345678910var a;if (a = 5) console.log(a); // 1if (a = 0) console.log(1); // 2else console.log(a);if (!(a = false)) console.log(a); // 3if (a = 5 - 5); // 4else console.log(a) 미리 선언된 변수에 값을 할당하는 것은 가능하다. 동시에 if의 괄호에는 a가 사용된다. 1에서는 if (5)인 셈이므로 5가 출력된다. 2에서는 if (0) 인 셈이므로 else로 넘어가게 된다. 3에서는 false를 담았고 !으로 반전하여 false가 결과로 나오도록 했다. 4에서는 a에 0이 담기고 else로 넘어간다. 123456789var obj = {};if (obj.a = 5) console.log(obj.a); // 1if (obj.b = false) console.log(obj.b); // 2else console.log('hi');var c;if (c = obj.c = true) console.log(c); // 3 이번에는 if의 괄호 안에서 객체의 key에 값을 할당했다. obj에 값을 할당했고, if의 괄호에서는 obj가 아닌 할당한 값이 쓰인다. 2와 3을 통해 알 수 있다. c에는 obj가 아닌 true가 담긴다. 12345678910function add(a, b) { return a + b;}if (add(1, 2)) console.log('hi1');var a;if (a = add(1, 2)) console.log(a);if (function () { return true; }()) console.log('hi') 함수를 실행할 수도 있고 실행한 결과를 변수에 담으면서 참과 거짓을 판단할 수도 있다. 익명 함수나 유명 함수를 정의하면서 즉시 실행할 수도 있다. 위에서 확인한 모든 코드들은 자바스크립트의 대부분의 괄호에서 동일하게 동작한다. 이를테면 while문의 괄호에서도 동일하게 동작한다. 괄호 안에서 어떤 코드들을 돌릴 수 있는지 잘 알고 있다면 코드를 더 깔끔하게 정리하거나 코드 구조를 크게 변경하지 않고도 기능을 발전시킬 수 있다. || &amp;&amp;1234567891011console.log(0 &amp;&amp; 1) // 0console.log(1 &amp;&amp; 0) // 0console.log([] || {}); // []console.log([] &amp;&amp; {}); // {}console.log([] &amp;&amp; {} || 0); // {}console.log(0 || 0 || 0 || 1 || null); // 1console.log(add(10, -10) || add(10, -10)); // 0console.log(add(10, -10) || add(10, 10)); //20var v;console.log((v = add(10, -10)) || v++ &amp;&amp; 20); // 0console.log((v = add(10, 10)) || ++v &amp;&amp; 20); // 20 ||과 &amp;&amp;의 활용법은 생각보다 다양하다. 오른쪽으로 더 갈 것인가 말 것인가를 한 줄로 만들어 if else를 대체할 수도 있다. 상황에 따라 if else가 가독성이나 효율이 좋을 수 있고 ||, &amp;&amp; 가 좋을 수도 있다. 다양한 도구를 상황에 맞게 잘 사용하면 된다. 삼항 연산자삼항 연산자는 조건이 간단하고 실행 코드도 간단할 때 많이 사용된다. 보통 값을 담을 때 사용된다. 삼항 연산자를 이용해도 여러 줄을 코딩할 수 있다. 익명 함수, 유명 함수, 화살표 함수 등으로 즉시 실행 패턴을 사용하는 것이다. 1234567var a = false;var c = a ? 10 : function f(arr, v) { return arr.length ? f(arr, v + arr.shift()) : v;}([1, 2, 3], 0);console.log(c) 위 코드에서는 a 가 false이므로 삼항 연산자에서 10을 건너뛰고 함수 부분이 실행된다. 함수 정의 끝부분을 보면 알 수 있듯이 즉시 실행했다. 그리고 [1,2,3]과 0을 인자로 받는다. 위와 같이 즉시 실행 함수를 이용하면 어디에서든 한 줄만 작성할 수 있던 곳을 확장할 수 있다. 또한 다른 함수를 실행할 수도 있고 재귀를 돌면서 얼마든지 복잡한 로직도 넣을 수 있다. 함수 실행의 괄호함수 실행을 통해 생기는 새로운 공간이전에 가장 특별한 괄호는 함수를 실행하는 괄호라고 했었다. 함수를 실행하는 괄호와 그렇지 않은 다른 괄호의 차이는 무엇일까? 12(5);(function () { return 10; }); 위 코드의 괄호 두 가지는 모두 일반적인 괄호다. 함수를 실행하는 괄호가 아닌 일반 괄호에서는 코드가 실행되면 해당 지점에 즉시 값을 만들고 끝난다. 해당 지점에서 만들어진 값을 참조할 수는 있지만 여기서 할 일은 바로 모두 끝난다. 1234567891011var add5 = function (a) { // 새로운 공간 return a + 5;}var call = function (f) { // 새로운 공간 return f();}// 함수를 실행하는 괄호add(5);call(function () { return 10; }); 함수를 실행하는 괄호는 일반 괄호와 특성이 모두 같지만 한 가지 특성을 더 가지고 있다. 이 괄호를 통해 새로운 실행 컨텍스트가 열린다는 점이다. 이 점은 매우 중요하다. 함수를 실행하는 괄호에서는 코드가 실행되었을 때 해당 지점에 값을 만든 후 끝나지 않고, 이 값이 실행된 함수의 공간으로 넘어간다. 새롭게 열린 공간이 끝나기 전까지는 이전 공간의 상황들도 끝나지 않는다. 이 공간들을 실행 컨텍스트라고 한다. 새로운 공간이 생긴다는것, 콜 스택에 쌓인다는 것, 태스크 큐와 이벤트 루프에 의해 제어된다는 것, 이것들을 통해 개발자가 시작과 끝을 제어할 수 있다는 점들이 함수를 실행하는 괄호가 가진 가장 특별한 차이다. 함수가 정의되거나 실행되는 지점에서는 클로저도 만들어질 수 있고, 비동기 상황이 생길 수도 있으며 서로 다른 컨택스트가 연결되는 등의 특별한 일들이 생긴다. 이것들은 함수에 대한 매우 실제적이고 중요한 개념이다.for문을 사용할 때 어떤 지점들을 확인하면서 코드 블록을 반복시키는지, 언제 어떻게 끝나는지 정확히 이해하지 않고는 코딩할 수 없듯이 함수도 마찬가지다. 기본적인 비동기 상황123456789console.log(1);setTimeout(function () { console.log(3)}, 1000);console.log(2);// 1// 2// 3 (1초 뒤) 코드 라인 순서와 달리 1, 2, 3 으로 실행 되었다. 123456789var add = function (a, b, callback) { setTimeout(function () { callback(a + b); }, 1000);}add(10, 5, function (r) { console.log(r);}) 비동기 상황이 생기는 함수의 결과는 return 문으로 반환할 수 없다. 비동기 상황이 생기는 함수의 결과를 받는 방법 중 하나는 콜백 함수를 넘겨서 돌려받는 방법이다. add의 마지막 인자로 넘겨진 익명 함수 callback은 add 안에서 모든 상황이 끝날 때 실행된다. 이를 통해 add를 실행한 스코프 내부에서 다시 add의 결과를 받을 수 있게 된다.일반 괄호였다면 10, 5, function등이 그 자리에 정의되고 끝났겠지만 함수를 실행하는 괄호에서는 그 값들이 다른 공간으로 넘어간다. 새롭게 열린 공간에서는 넘겨받은 재료들로 새로우 일을 할 수 있다. 함수 실행 괄호의 마법과 비동기비동기 상황을 제어하는 방법은 함수 실행을 일렬로 나열하는 것이다. add 함수 실행 -&gt; setTimeout 함수 실행 -&gt; setTimeout이 1초 뒤 익명 함수를 실행 -&gt; 받아 둔 callback 실행 위와 같이 함수들의 실행을 일렬로 나열하여 한 가지 일이 순서대로 일어나도록 하는 것이다.이 함수 나열을 숨겨서 비동기 코드가 동기식으로 실행되는 것처럼 보이도록 해볼 것이다. Promise하고 비슷할 것이다. 이 작업을 통해 함수 실행의 괄호에서 다른 공간으로 이동되는 사이에 할 수 있는 일을 확인할 것이다. 이런 기법들을 통해 프로미스의 내부 코드를 예상해 볼 수도 있을 것이다. 12345678910111213141516171819202122232425var add = function (a, b, callback) { setTimeout(function () { callback(a + b); }, 1000);}var sub = function (a, b, callback) { setTimeout(function () { callback(a - b); }, 1000);}var div = function (a, b, callback) { setTimeout(function () { callback(a / b); }, 1000);}add(10, 15, function (a) { sub(a, 5, function (a) { div(a, 10, function (r) { console.log(r); // 약 3초 후에 2가 찍힘 }) })}) 원래 비동기가 일어나는 함수들은 아래처럼 중첩 실행을 할 수 없다. 함수의 몇 가지 특성을 활용해 비동기 함수도 아래처럼 중첩 실행이 가능하도록 해보자. 12console.log(div(sub(add(10, 15), 5), 10));// undefined가 찍히고 callback이 없다는 에러가 남. 우선 함수가 실행되는 사이에 무언가를 할 수 있도록 함수로 한 번 감싸서 공간을 만들 것이다. wrap에게 함수를 전달하여 함수를 리턴 받으면 원래 기능을 유지하면서 코드 사이에 공간이 생긴다. 12345678910111213141516function wrap(func) { // 1. 함수 받기 return function () { // 2. 함수 리턴하기, 이것이 실행됨. // 여기에 새로운 공간이 생김, 나중에 함수를 실행했을 때 이 부분을 거쳐감 return func.apply(arguments); // 3 }}var add = wrap(function (a, b, callback) { setTimeout(function () { callback(a + b); }, 1000);});add(5, 10, function (r) { console.log(r);}) 1에서 받은 함수를 기억하는 2 클로저를 만들어 리턴했고, add는 2가 된다. 나중에 2가 실행되면 1에서 받아 둔 3 함수를 실행하면서 2가 받은 모든 인자를 넘겨준다. 이전 add와 완전히 동일하게 동작하면서도 사이사이에 코드를 끼워 넣을 수 있는 공간들이 더 생겼다. wrap을 조금만 더 고치고 _async 라고 이름을 바꿔보자. 1234567891011121314151617181920212223242526function _async(func) { return function () { arguments[arguments.length++] = function (result) { // 1 _callback(result) // 6 }; func.apply(null, arguments); // 2 var _callback; // 3 function _async_cb_receiver(callback) { // 4 _callback = callback; // 5 } return _async_cb_receiver; }}var add = _async(function (a, b, callback) { setTimeout(function () { callback(a + b); }, 1000);});add(20, 30)(function (r) { // 7 console.log(r);}) 우선 마지막 부분 7을 보면 add를 실행하는 방법이 바뀌었다. 한 번에 인자 3개를 넘기지 않고 마치 커링처럼 add에 필요한 재료를 넘긴 후 한 번 더 실행하면서 callback 함수를 넘기고 있다. add가 실행되면 인자로 20과 30이 넘어온다. 원래는 callback 함수를 받아야 하므로 arguments에 마지막 값으로 함수를 추가한다. 그리고 그 함수는 나중에 개발자가 넘겨준 callback 함수를 실행할 수 있게 준비해 두었다. add를 정의할 때 받아 둔 func를 실행하면서 인자 3개를 넘긴다. _callback 이라는 지역 변수를 만들어서 1과 4가 기억해 두도록 했다. 클로저를 활용하여 서로 다른 컨텍스트가 협업할 수 있도록 이어주었다. _async_cb_receiver라는 이름을 가진 유명 함수이자 클로저를 만들어 리턴한다. _async_cb_receiver가 실행될 때 받은 함수 callback을 _callback에 할당한다. 1초가 지나면 1이 실행될 것이고 add가 callback을 통해 넘긴 결과인 result를 받아 두었던 _callback을 실행하면서 다시 넘겨주고 있다. 이 익명 함수가 _callback 이므로 6에서 넘겨진 r을 받게 되고 로그를 남겼다. 1234567891011121314151617181920212223242526var add = _async(function (a, b, callback) { setTimeout(function () { callback(a + b); }, 1000);});var sub = _async(function (a, b, callback) { setTimeout(function () { callback(a - b); }, 1000);});var div = _async(function (a, b, callback) { setTimeout(function () { callback(a / b); }, 1000);});add(10, 15)(function (a) { sub(a, 5)(function (a) { div(a, 10)(function (r) { console.log(r); // 약 3초 후 2가 찍힘 }) })}) 비동기와 재귀일반 콜백 패턴의 함수를 실행하는 것과 아직 큰 차이는 없지만 연산에 필요한 실행과 결과를 받기 위한 실행이 분리되었다. 함수를 실행하는 괄호에서는 값을 다른 공간으로 넘겨 새로운 일들을 더 할 수 있다. add, sub, div는 async를 통해 본체에 가기 전 새로운 공간을 가지고 있고, 그 공간에서는 시작과 끝을 제어하고 있다. 이 내부 공간을 손보면 좀 더 재밌는 일을 할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function _async(func) { return function () { arguments[arguments.length++] = function (result) { _callback(result) }; // 변경된 부분 (function wait(args) { // 새로운 공간 추가 for (var i = 0; i &lt; args.length; i++) { if (args[i] &amp;&amp; args[i].name === '_async_cb_receiver') { return args[i](function (arg) { args[i] = arg; wait(args) }); } } func.apply(null, args); })(arguments); var _callback; function _async_cb_receiver(callback) { _callback = callback; } return _async_cb_receiver; }}var add = _async(function (a, b, callback) { setTimeout(function () { console.log('add', a, b); callback(a + b); }, 1000);});var sub = _async(function (a, b, callback) { setTimeout(function () { console.log('sub', a, b); callback(a - b); }, 1000);});var div = _async(function (a, b, callback) { setTimeout(function () { console.log('div', a, b); callback(a / b); }, 1000);});var log = _async(function (val) { setTimeout(function () { console.log(val); }, 1000)})log(div(sub(add(10, 15), 5), 10));// 약 4초 뒤 2log(add(add(10, 10), sub(10, 5)));// 약 3초 뒤 25 모두 비동기 함수들 인데도 마치 즉시 완료되는 동기 함수들을 중첩하여 실행한 것처럼 동작하고 있다. 추가된 부분만 다시 자세히 살펴보자. 123456789101112// 변경 전func.apply(null, args);// 변경 후(function wait(args) { for (var i = 0; i &lt; args.length; i++) { if (args[i] &amp;&amp; args[i].name === '_async_cb_receiver') { return args[i](function (arg) { args[i] = arg; wait(args) }); } } func.apply(null, args);})(arguments); 크게 보면 wait라는 유명 함수를 만들었고 내부에서 재귀를 돌다 func를 실행하도록 변경되었다. 재귀는 인자 중에 _async_cb_receiver 가 있다면 모두 결과값으로 치환될 때까지 돌게 된다.add의 실행 결과는 숫자가 아닌 _async_cb_receiver라는 이름을 가진 함수다. 이 함수에 함수를 넣으면 결과를 받을 수 있다. 이를 이용하여 add의 실행 결과를 받은 sub는 자신의 본체(func) 로 가기 전에 wait로 _async_cb_receiver가 있는지 확인하고, 있다면 실행하여 결과값을 받고 재귀를 돌며 해당 번째 args[i]를 결과값으로 변경한다. 앞의 예제는 특정 지점에 함수를 정의하거나 함수로 감싸고, 함수를 즉시 실행하거나 재귀를 하는 식으로 기존 로직 사이에 선행 로직이나 후행 로직을 만들면서 프로그램의 순서를 제어할 수 있음을 보여준다. 위 예제에서는 이런 기법을 통해 비동기 상황을 제어하고, 다른 라이브러리들과의 연결 고리를 만드는 중요한 단위가 된다. 일반 괄호에서는 할 수 없는 일이지만 함수를 실행하는 괄호에서는 새로운 공간들을 레이어처럼 얼마든지 만들 수 있다. 앞의 예제 처럼 본체까지 가기 전 레이어들을 통과하면서 비동기 함수의 결과를 기다렸다가 결과값으로 변형해 넘겨줄 수도 있다. 함수를 실행하는 괄호에서 함수를 실행할 수 있고, 실행한 결과가 함수여서 그 함수를 다시 함수에게 인자로 넘길 수 있고, 그렇게 받은 함수를 실행할 수 있다. 자바스크립트에서 재귀는 충분히 실용적이라는 이야기를 했었다. 앞의 상황에서는 재귀를 통해 비동기 상황을 제어했다. 재귀는 로직들을 함수라는 단위로 일자로 나열하는 것이다. 비동기 제어의 핵심 역시 함수 실행의 나열이다. 비동기가 발생되면 스택이 초기화되므로 재귀에 대한 부담도 없다. 아무리 많은 재귀가 일어나도 ‘Maximum call stack size exceeded’ 에러는 절대로 발생하지 않는다. 참조: 함수형 자바스크립트 프로그래밍","link":"/2019/10/27/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0-2/"},{"title":"함수형 자바스크립트를 위한 문법 다시 보기","text":"함수형 자바스크립트를 잘 다루기 위해서는 숲을 보는 것보다 나무의 결을 들여다 보는 것이 중요하다. 자바스크립트 문법과 기본적인 동작에 집중해보자. 함수 하나가 정의되고 실행되고 참조되는 과정, 인자를 받거나 넘기는 과정, 클로저가 되거나 비동기가 일어나는 과정, 괄호, 대괄호, 점, 쉼표 등을 자세히 들여다 보자. 문법적 감각이 좋아지면 원하는 곳 어디에서나 함수를 열고 실행할 수 있게 된다. 객체와 대괄호 다시 보기객체와 key12345678var obj = { a: 1, \"b\": 2 }; // 1obj.c = 3;obj['d'] = 4; // 2var e = 'e';obj[e] = 5;function f() { return 'f' };obj[f()] = 6;console.log(obj); 일단 객체의 key 와 value에 대한 부분이다. 객체의 key와 value는 {}, . , [] 등을 통해 설정할 수 있다.그중 어떤 문자열이든 key로 정의할 수 있는 곳이 있는데 1과 2 같은 곳이다. 이 두 가지 방식이 가진 공통점이 있다면 띄어쓰기, 특수 문자, 숫자 등을 가리지 않고 어떤 문자열이든 key로 만들 수 있다는 점이다. 1234567891011var obj2 = { \"a a a\": 1 };obj2[\"b b b\"] = 2;console.log(obj2);var obj3 = { \"margin-top\": 5 };obj3[\"padding-bottom\"] = 20;console.log(obj3);var obj4 = { 1: 10 };obj4[2] = 20;console.log(obj4); 그렇다면 {} 안쪽에서 key를 선언하는 것과 [] 안에서 선언하는 것은 차이가 없을까? {}의 문자열 부분에서는 코드를 실행할 수 없고 []의 안쪽에서는 코드를 실행할 수 있다. 1234var obj5 = { (true ? \"a\" : \"b\"): 1}; // Uncaught SyntaxErrorvar obj6 = {};obj6[true ? \"a\" : \"b\"] = 1;console.log(obj6); {} 안쪽의 key 영역에서는 코드를 실행할 수 없다. [] 사이에는 문자열이 담긴 변수도 넣을 수 있고, 연산자도 사용할 수 있으며 함수도 실행할 수 있다. 즉, [] 에서는 코드를 실행할 수 있다. 12var obj5 = { [true ? \"a\" : \"b\"]: 1 }console.log(obj5); 하지만 ES6 의 경우에서는 {} 안에 [] 를 사용하여 코드를 실행할 수 있게됐다. 함수나 배열에 달기12345function obj8() { }obj8.a = 1;obj8.b = 2;console.log(obj8.a); // 1console.log(obj8.b); // 2 자바스크립트에서는 함수도 객체다. 그러므로 함수도 key/value 쌍으로 구성할 수 있다. 1234var obj10 = []obj10.a = 1;console.log(obj10.a); // 1console.log(obj10.length); // 0 배열도 객체이며 배열에도 숫자가 아닌 key를 사용할 수 있다. 단, 숫자가 아닌 key로 값을 할당할 경우 length는 변하지 않는다. 12345var obj11 = [];obj11[0] = 1;obj11[1] = 2;console.log(obj11);console.log(obj11.length) // 2 배열에 숫자로 key를 직접 할당해도 push와 동일하게 동작한다. 자동으로 length도 올라간다. delete자바스크립트에서는 기본 객체의 메서드나 프로퍼티도 지울 수 있다. 123456789var obj = { a: 1, b: 2, c: 3 };delete obj.a;delete obj['b'];delete obj['C'.toLocaleLowerCase()];console.log(obj) // {}delete Array.prototype.push;var arr1 = [1, 2, 3];arr1.push(4); // Uncaught TypeError: arr1.push is not a function 다른 언어를 다루었던 개발자라면 delete로 아무거나 지우기, 배열에 숫자가 아닌 key 사용하기 등을 봤을 때, 자바스크립트의 유연함을 난해하다거나 위험하다고 느낄 수 있다. 하지만 이 특징들을 문제가 아닌 자바스크립트의 특성으로 받아들인 후에 더욱 다양한 기법들이 나오기 시작했고 더 잘 동작하기까지했다. 함수 정의 다시 보기기본 정의자바스크립트에서 함수를 정의하는 방법은 다양하다. 대표적인 방법들은 다음과 같다. 1234567891011function add1(a, b) { return a + b;}var add2 = function(a, b) { return a + b;}var m = { add3: function (a, b) { return a + b; }} 함수를 정의하는 것은 이미 익숙하겠지만 확인해 볼 만한 부분이 있다. 바로 호이스팅인데, 호이스팅에 대해 어느 정도 알고 있더라도 읽어 보기를 권한다. 호이스팅호이스팅(hoisting)이란 변수나 함수가 어디서 선언되든지 해당 스코프 최상단에 위치하게 되어 동일 스코프 어디서든 참조할 수 있는 것을 말한다. 아래의 코드 add1과 add2에는 호이스팅이 적용된다. ‘add2는 실행이 안 될 텐데 호이스팅이 아니지 않나?’하고 생각할 수 있지만 이것은 오해다. 물론 에러가 난 걸로 알 수 있듯이 add2는 선언하기 전 라인에서 실행할 수 없다. 하지만 분명히 add2도 호이스팅이 적용된 것이다. 결론부터 말하면 선언은 되었지만 아직 초기화되지 않은 상태에서 실행했기 때문에 에러가 난 것 이다. 123456789add1(10, 5); // 15add2(10, 5); // Uncaught TypeError: add2 is not a functionfunction add1(a, b) { return a + b;}var add2 = function (a, b) { return a + b;} 예제에서 add2는 실행되지 않았고, ‘add2 is not a function’ 이라는 에러 메시지가 출력되었다. 이번에는 선언한 적 없는 함수를 실행해보자. 12hi();// Uncaught ReferenceError: hi is not defined 에러 메시지가 다르다. 자바스크립트에서는 아예 선언된 적이 없는 것을 참조하려고 할 때 이러한 에러가 난다. 실행하지 않고 참조만 하려고 해도 동일한 에러가 난다. 123456789console.log(add1); // function add1(a, b) { return a + b };console.log(add2); // undefined;function add1(a, b) { return a + b;}var add2 = function (a, b) { return a + b;} 이번엔 에러가 나지 않았고 undefined가 출력되었다. 그렇다면 add1과 add2는 어떤 차이에 의해 실행이 되고 안 되는 것 일까?이는 변수 선언과 함수 선언에서의 차이 떄문이다. 변수는 선언 단계와 초기화 단계가 구분되어 있다. 변수는 선언과 초기화가 동시에 이루어지지 않기 때문에 호이스팅에 의해 참조만 가능하고, 아직 값이 담기지 않아 실행은 불가능하다. 반면에 함수 선언은 선언과 동시에 초기화가 이루어지기 때문에 참조뿐 아니라 실행도 가능하다.add2는 변수를 선언하여 익명 함수를 담았고 add1은 함수로 선언했다. 호이스팅에 의해 add1은 미리 실행할 수 있고 add2는 호이스팅에 의해 미리 참조할 수 있지만 값이 없어 실행할 수는 없다. 호이스팅 활용하기함수 선언과 호이스팅을 이용하면 다음과 같이 코드를 작성할 수 있다. 12345678910function add(a, b) { return valid() ? a + b : new Error(); function valid() { return Number.isInteger(a) &amp;&amp; Number.isInteger(b); }}console.log(add(10, 5)); // 15console.log(add(10, '')); // Error(...) 위와 같이 return 문 아래에 정의한 함수도 실행이 가능하다. 비교적 복잡한 코드를 하단부에 정의하고 실행부 코드는 깔끔하게 유지하는 등으로 활용할 수도 있다. 괄호없이 즉시 실행하기123(function (a) { console.log(a);})(100); 자바스크립트에서는 위와 같이 괄호를 통해 익명 함수를 즉시 실행할 수 있다. 괄호 없이 실행하면 에러가 발생한다. 많은 경우, 참조가 잘못되어 에러가 났다고 생각할 수 있지만 그렇지 않다. 에러가 난 이유는 익명 함수를 잘못 실행한 것이 아니라 익명 함수 선언 자체가 실패했기 떄문이다. 12function() {}// Uncaught SyntaxError: Unexpected token ( 실행 없이 선언만 시도해도 에러가 난다. 그런데 우리는 이와 비슷한데 에러가 나지 않는 코드를 봤었다. 1234567function f1() { return function() { }}f1(); 이 예제는 1장에서 봤었던 함수를 값으로 다루는 패턴 중 하나다. 위 코드는 함수를 괄호로 감싸지 않았는데 문법 에러가 나지 않고 정상적으로 동작한다. 이 상황에서 에러가 나지 않는다면 괄호 없이 즉시 실행도 되지 않을까? 1234567function f1() { return function (a) { console.log(a) }(1)}f1(); 이 코드는 정상적으로 동작한다. f1이라느느 함수 안에 있는 익명 함수는 괄호 없이도 즉시 실행이 되었다. 만일 f1이라는 함수의 return 바로 뒤에서 함수를 즉시 실행하고 싶다면, 그 상황에서는 괄호 없이도 익명 함수를 즉시 실행할 수 있다. 1234567891011121314151617181920212223242526272829303132!function (a) { console.log(a)}(1);true &amp;&amp; function (a) { console.log(a)}(1);1 ? function (a) { console.log(a)}(1) : 5;0, function (a) { console.log(a)}(1);var b = function (a) { console.log(a)}(1);function f2() { }f2(function (a) { console.log(a)}(1));var f3 = function c(a) { console.log(a)}(1);new function () { console.log(1);} 위와 같은 상황들에서는 괄호 없이도 익명 함수를 즉시 실행할 수 있다. 이 중 !를 이용한 방법은 꽤 알려진 편이다. 이 상황에서의 공통점은 무엇일까? 일단 모두 연산자와 함께 있고, 함수가 값으로 다뤄졌다. 그리고 모두 익명 함수 선언에 대한 오류가 나지 않는다. 앞에서 즉시 실행이 실패했던 것은 익명 함수를 잘못 실행한 것이 아니라 익명 함수 선언 자체를 하지 못해서였다. 유명(named) 함수123var f1 = function f() { console.log(f);} 함수를 값으로 다루면서 익명이 아닌 f() 처럼 이름을 지은 함수를 유명 함수라고 한다. 함수를 즉시 실행한다거나 함수를 클로저로 만들어 리턴할 때, 함수를 메서도로 만들 때는 주로 익명 함수를 사용하게 된다. 이와 같은 상황에서 익명 함수 대신 유명 함수로 사용하는 것이 유용할 때가 있다. 12345678910var f1 = function () { console.log(f1);}f1();// 위험 상황var f2 = f1;f1 = 'hi~';f2(); 이렇게 하면 참조가 가능하지만 ‘위험 상황’ 부분처럼 함수 생성 이후 변경이 일어나면 더 이상 자기 자신을 참조하지 못하게 될 수 있다. 123456789101112131415var f1 = function () { console.log(arguments.callee)}f1();// ƒ () {// console.log(arguments.callee)// }var f2 = f1;f1 = null;f2();// ƒ () {// console.log(arguments.callee)// } 위 방법은 이 전 코드의 문제를 해결하지만 arguments.callee는 ES5 Strict mode에서 사용할 수 없다. 유명 함수식을 사용하면 arguments.callee를 대체할 수 있다. 유명 함수는 함수가 값으로 사용되는 상황에서 자신을 참조하기 매우 편하다. 함수의 이름이 바뀌든 메서드 안에서 생성한 함수를 다시 참조하고 싶은 상황이든 어떤 상황에서든 상관없이 자기 자신을 정확히 참조할 수 있다. 12345678var f1 = function f() { console.log(f);}f1();var f2 = f1;f1 = null;f2(); 유명 함수를 이용한 재귀유명 함수는 재귀를 만들 때에도 편리하다. 다음은 깊이를 가진 배열을 펴 주는 flatten 함수다. 아래와 같은 함수를 만들 때 재귀와 유명 함수는 특히 유용하다. 1234567891011121314function flatten(arr) { return function f(arr, new_arr) { // 1 arr.forEach(function (v) { Array.isArray(v) ? f(v, new_arr) : new_arr.push(v); // 2 }); return new_arr; }(arr, []); // 3}console.log(flatten([1, [2], [3, 4]]));// [1,2,3,4]console.log(flatten([1, [2], [[3], 4]]));// [1,2,3,4] flatten 함수가 실행되면 먼저 즉시 실행할 f 라는 이름의 유명 함수로 만든다. 함수 f를 즉시 실행하면서 새로운 배열 객체를 생성하여 넘겨준다. 루프를 돌면서 배열이 아닐 때만 값을 push하고 배열인 경우에는 f를 다시 실행하여 배열을 펴고 있다. 이 코드가 재밌는 점은 즉시 실행과 유명 함수를 이용한 재귀라는 것이다. 만일 재귀로만 이 로직을 구현한다면 함수를 사용하는 개발자가 빈 배열을 항상 직접 넘겨주거나 if문을 체크하는 식으로 재귀를 제어해야 한다. 123456789101112131415161718function flatten2(arr, new_arr) { arr.forEach(function (v) { Array.isArray(v) ? flatten2(v, new_arr) : new_arr.push(v); }); return new_arr;}flatten2([1, [2], [3, 4]], []) // 항상 빈 Array를 추가로 넘겨 줘야함.function flatten3(arr, new_arr) { if (!new_arr) return flatten3(arr, []); // if 문이 생김 arr.forEach(function (v) { Array.isArray(v) ? flatten3(v, new_arr) : new_arr.push(v); }); return new_arr;} 세 가지 방식의 코드 모두 장단점이 있다. flatten2는 if가 없고 가장 빠르지만 함수를 사용할 때 개발자가 직접 배열을 넘겨주어야 한다. flatten3은 사용하기 간단하지만 if가 있다. flatten은 if가 없으면서 사용하기 간단하지만 함수를 한 번 생성한다. 자바스크립트에서 재귀의 아쉬움재귀를 이용하면 복잡한 로직이나 중복되는 로직을 제거할 수 있고 읽기 쉬운 로직을 만들 수 있어 편하다. 그러나 아직까지는 자바스크립트에서 재귀를 사용하는 것에 약간 부담스러운면이 있다. 환경에 따라 다르지만 대략 15,000번 이상 재귀가 일어나면 ‘Maximum call stack exceeded’라는 에러가 발생하고 소프트웨어가 죽는다. 따라서 자바스크립트에서 얼마나 깊은 재귀가 일어날 것인가 유의하며 함수를 작성해야 한다. 아직 자바스크립트의 실제 동작 환경에서는 꼬리 재귀 최적화가 되지 않았다. 그렇다고 자바스크립트에서 성능 때문에 재귀를 사용할 일이 없다는 것은 잘못된 얘기다. 자바스크립트의 실제 동작 환경에서는 비동기 프로그래밍이 많이 쓰이고 비동기가 일어나면 스택이 초기화 된다. 애초에 비동기 상황이었다면 어차피 스택이 초기화 될 것이므로 재귀 사용을 피할 이유가 없다. 함수 실행과 인자 그리고 점 다시 보기() 다시 보기함수를 실행하는 방법에는 (), call, apply가 있고, 함수 안에서는 arguments 객체와 this 키워드를 사용할 수 있다. 각각의 사용법과 용도, 특이사항들을 하나씩 확인해 보자. 12345function test(a, b, c) { console.log('a b c:', a, b, c); console.log(this); console.log(arguments);} 함수 실행 방법에 따른 차이를 정확히 확인하기 위해 test 함수를 만들었다. 1234567891011121314test(10); // 1// a b c: 10 undefined undefined// this: Window {...}// arguments: [10]test(10, undefined); // 2// a b c: 10 undefined undefined// this: Window {...}// arguments: [10, undefined]test(10, 20, 30); // 3// a b c: 10 20 30// this: Window {...}// arguments: [10, 20, 30] arguments는 함수가 실행될 때 넘겨받은 모든 인자를 배열과 비슷한 형태로 담은 객체다. length로 넘겨받은 인자의 수를 확인할 수 있고 index로 순서별 인자를 확인할 수 있다. 2의 경우 1과 거의 유사하지만 arguments 객체가 다르게 생성이 된다. 인자로 undefined를 직접 넘긴 경우와 넘기지 않아 자연히 undefined 상태가 되는 것 사이에는 분명한 차이가 있다. 인자 다시 보기인자는 일반 변수 혹은 객체와 약간 다르게 동작하는 부분이 있다. 123456789function test2(a, b) { b = 10; console.log(arguments);}test2(1); // 1// [1]test2(1, 2) // 2// [1, 10] 인자는 변수와 달리 객체의 값이 바뀐다. 2는 arguments[1]에 해당하는 값이 넘어왔고, 인자인 b와 arguments[1]은 서로 마치 링크가 걸린 것 처럼 연결되어 있다. b를 고치니 arguments[1]도 바뀌었다. 1에서도 b를 고쳤는데 arguments[1]에 영향을 주지 않는다. 이 부분에 대해서 정확히 알고 있지 않은 상태에서 인자를 변경하는 코드를 작성할 경우, 의도와 다른 상황이 일어날 수 있을 것이다. this 다시 보기위의 test 함수 내부의 console.log로 확인 하는 예제에서는 모든 this가 window 객체이다. 어떻게 해야 this에 다른 값이 들어갈 수 있을까? 12345678910111213var o1 = { name: \"obj1\" };o1.test = test;o1.test(3, 2, 1);// a b c: 3 2 1// this: Object {name: \"obj1\", test: f}// arguments: [3,2,1]var a1 = [1, 2, 3];a1.test = test;a1.test(3, 3, 3);// a b c: 3 3 3// this: Array [1, 2, 3, test: f]// arguments: [3,3,3] 기존에 있던 test 함수를 o1에 연결한 후 o1.test를 실행하니 this가 o1이 되었다. a1 역시 연결 후 실행하니 this가 a1이 되었다. 자바스크립트에서는 객체에 함수를 붙인 다음 그 함수를 . 으로 접근하여 실행하면 함수 내부의 this가 . 왼쪽의 객체가 된다. 12345var o1_test = o1.test;o1_test(5, 6, 7);// a b c: 5 6 7// this: Window {...}// arguments: [5, 6, 7] o1.test를 o1_test에 담은 다음 . 없이 o1_test를 실행했더니 this가 다시 window가 되었다. 이런 차이를 알아야 함수를 값으로 잘 다룰 수 있다. 실제로 메서드로 정의된 함수를 일반 함수처럼 사용하는 경우가 있다. o1.test에 붙였기 때문에 o1이 this가 되는 것이 아니라 . 으로 접근하여 실행했기 때문에 o1이 this가 되는 것이다. 어디에 붙어 있는 함수인지보다 어떻게 실행했는지가 중요하다. 123456789(a1.test)(8, 9, 10);// a b c: 8 9 10// this: Array [1, 2, 3, test: f]// arguments: [8, 9, 10]a1['test'](8, 9, 10);// a b c: 8 9 10// this: Array [1, 2, 3, test: f]// arguments: [8, 9, 10] 괄호로 전체를 감쌌지만 여전히 this는 a1이 찍히고 있다. 참조를 어떻게 했느냐가 중요하다. [] 를 이용해 test 메서드를 참조 후 실행해도 . 으로 접근하여 실행한 것과 동일한 결과를 낸다. 자바스크립트에서의 함수는 ‘어떻게 선언했느냐’와 ‘어떻게 실행했느냐’가 모두 중요하다. ‘어떻게 정의했느냐’는 클로저와 스코프와 관련된 부분들을 결정하고 ‘어떻게 실행했느냐’는 this와 arguments를 결정한다. call, apply 다시 보기자바스크립트에서 함수를 실행하는 대표적인 방법이 2개 더 남아 있다. 123test.call(undefined, 1, 2, 3);test.call(null, 1, 2, 3);test.call(void 0, 1, 2, 3); 위 3가지 실행 모두 동일한 결과가 나온다. null 이나 undefined를 call의 첫 번째 인자에 넣으면 this는 windnow가 된다. void 0 의 결과도 undefined 이기 때문에 같은 결과가 나온다. 12345678test.call(o1, 3, 2, 1);// a b c: 3 2 1// this: Object {name: \"obj1\", test: f}// arguments: [3,2,1]test.call(1000, 3, 2, 1);// a b c: 3 2 1// this: Number {1000}// arguments: [3,2,1] 함수의 메서드인 call은 Function.prototype.call 이다. test는 함수이자 객체이고 test 객체의 call은 함수 자신(test)을 실행하면서 첫 번째 인자로 받은 값을 this로 사용한다. 12345678o1.test.call(undefined, 3, 2, 1);// a b c: 3 2 1// this: Window {...}// arguments: [3,2,1]o1.test.call([50], 3, 2, 1);// a b c: 3 2 1// this: Array [50]// arguments: [3,2,1] call을 사용할 경우, 그 앞에서 함수를 .으로 참조했을지라도 call을 통해 넘겨받은 첫 번째 인자에 의해 this가 결정된다. 12345678910111213141516test.apply(o1, [3, 2, 1]);// a b c: 3 2 1// this: Object {name: \"obj1\", test: f}// arguments: [3,2,1]test.apply(1000, [3, 2, 1]);// a b c: 3 2 1// this: Number {1000}// arguments: [3,2,1]o1.test.apply(undefined, [3, 2, 1]);// a b c: 3 2 1// this: Window {...}// arguments: [3,2,1]o1.test.apply([50], [3, 2, 1])// a b c: 3 2 1// this: Array [50]// arguments: [3,2,1] apply는 call과 동일하게 동작하지만 인자 전달 방식이 다르다. 인자들을 배열이나 배열과 비슷한 객체를 통해 전달한다. 여기서 배열과 비슷하다는 것은 다음과 같은 값들을 사용할 수 있다는 말이다. 1234567891011test.apply(o1, { 0: 3, 1: 2, 2: 1, length: 3 });// a b c: 3 2 1// this: Object {name: \"obj1\", test: f}// arguments: [3,2,1](function () { test.apply(1000, arguments)})(3, 2, 1);// a b c: 3 2 1// this: Number {1000}// arguments: [3,2,1] { 0: 3, 1: 2, 2: 1, length: 3 }은 Array도 아니고 Arguments도 아닌 그냥 일반 객체다. 숫자를 키로 사용하고 그에 맞는 length를 가지고 있다. 이와 같이 되어 있는 객체라면 apply를 통해 인자로 전달할 수 있다. 다른 함수를 통해 생성된 arguments도 apply로 전달할 수 있다. call의 실용적 사례계속해서 확인하고 있는, 일반적이지 않은 이런 기법들은 유명한 자바스크립트 개발자들의 코드에서 자주 등장한다. 123456789101112131415161718var slice = Array.prototype.slice;function toArray(data) { return slice.call(data);}function rest(data, n) { return slice.call(data, n || 1);}var arr1 = toArray({ 0: 1, 1: 2, length: 2 });arr1.push(3);console.log(arr1);// [1,2,3]rest([1, 2, 3]);// [2, 3]rest([1, 2, 3], 2);// [3] Array.prototye.slice의 경우, 키를 숫자로 갖고 length를 갖는 객체이기만 하면 Array가 아닌 값이어도 call을 통해 Array.prototype.slice를 동작시킬 수 있다. toArray와 rest 함수는 구현을 Native Helper에게 위임하여 짧은 코드로 성능이 좋은 유틸 함수를 만들었다. 자바스크립트에서는 this 키워드 못지않게 call, apply, arguments 등도 중요하다. call, apply, arguments, bind 등을 알고 자바스크립트를 다루는 것과 그렇지 않은 것은 정말 큰 차이를 만든다. 그리고 이 모든 기능들은 자바스크립트의 함수와 관련되어 있다. 자바스크립트 진영의 객체지향 관련 라이브러리에도 상속이나 메서드 오버라이드 같은 것을 구현하기 위해서는 apply와 arguments 등을 사용해야 한다. 함수형 자바스크립트에서는 특히나 중요하다. apply, arguments는 좋은 도구들이며 실제로 매우 실용적이다. Conclusion오늘은 함수형 프로그래밍을 시작하기 앞서 기본적인 것들을 다시 확인해보는 시간이었다. 이미 알고 있던 내용도 있었지만, 복습하고 확실히 익히고자 하는 마음으로 정리했다. 해당 챕터의 내용이 많아 나머지 내용은 다음 시간에 정리해야겠다. 참조: 함수형 자바스크립트 프로그래밍","link":"/2019/10/20/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0/"},{"title":"함수형 프로그래밍 - 시작","text":"최근 사내에서 함수형 프로그래밍을 사용하여 기존 코드의 리팩토링을 시작했다.함수형 프로그래밍 해야지 해야지 하고 항상 미뤄왔던 스터디인데 실무에서 사용하기에터무니없이 실력이 부족함을 느껴 스터디를 시작하고자 한다. 기본적으로 함수형 자바스크립트 프로그래밍 책을 기반으로 진행하며, 필요한 내용이나 궁금한 내용은 구글링을 통해 진행한다. 도서 링크: 함수형 자바스크립트 프로그래밍 함수형 자바스크립트 소개 함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다. 함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유 오류를 줄이기 위함. 조합성 혹은 모듈화 수준을 높이기 위함. 함수형 프로그래밍을 검색하면 나오는 예제1234567function addMaker(a) { return function(b) { return a + b; }}addMaker(10)(5); 함수형 자바스크립트에 관심을 가져 본 적이 있다면 아마 위 예제와 같은 코드를 봤을 것 이다. 커링 혹은 부분 적용과 관련된 코드들이다.함수를 리턴한다거나 괄호가 많은 코드들을 처음 보면 난해하고 생소하게 느껴진다. addMaker는 함수를 값으로 다루는 함수다. addMaker에서는 단 하나의 값이 선언되며 그 값은 함수다.addMaker(10)의 결과는 function(b) { return 10 + b }; 와 같다.이후 리턴된 함수를 바로 실행해줬기 때문에 결과값은 15가 된다. 123var add5 = addMaker(5);add5(3) // 8add5(4) // 9 위와 같이 변수에 값을 할당해서 사용할 수 도 있다. 값으로써의 함수와 클로저위의 예제들을 보면 함수는 값을 리턴할 수 있고 함수는 값이 될 수 있다. addMaker는 내부에서 함수를 정의하고 리턴했다. addMaker가 리턴한 익명 함수는 클로저가 되었다.리턴된 익명 함수 내부에서 a가 정의된 적은 없지만 a를 참조하고 있고 a는 부모 스코프에 있다. addMaker가 실행된 후, 어디서도 addMaker의 인자인 a 값을 변경시키지 않고 있기 때문에 항상 동일한 값을 갖는다. 때문에 위 상황에서 a는 불변하며 상수로 쓰이게 된다. 이 상황에서의 a는 불변하지만, 모든 경우의 클로저가 그렇지는 않다. 클로저가 기억하는 변수의 값은 변할 수 있다. 함수형 자바스크립트의 실용성절차지향적으로 작성된 코드를 함수형으로 변경하면서 함수형 자바스크립트의 실용성을 알아보고자 한다. 회원 목록 중 여러명 찾기회원 목록 중 특정 나이의 회원들만 뽑거나 특정 조건의 회원 한 명을 찾는 코드들을 함수형 자바스크립트로 리팩토링 한다. 123456789101112131415161718192021222324252627282930313233343536var users = [ { id: 1, name: 'ID', age: 32 }, { id: 2, name: 'HA', age: 25 }, { id: 3, name: 'BJ', age: 32 }, { id: 4, name: 'PJ', age: 28 }, { id: 5, name: 'JE', age: 27 }, { id: 6, name: 'JM', age: 32 }, { id: 7, name: 'HI', age: 24 },];// 1var temp_users = [];for (var i = 0, len = users.length; i &lt; len; i++) { if (users[i].age &lt; 30) temp_users.push(users[i]);}console.log(temp_users.length);// 2var ages = [];for (var i = 0, len = temp_users.length; i &lt; len; i++) { ages.push(temp_users[i].age);}console.log(ages)// 3var temp_users = [];for (var i = 0, len = users.length; i &lt; len; i++) { if (users[i].age &gt;= 30) temp_users.push(users[i])}console.log(temp_users.length);var names = [];for (var i = 0, len = temp_users.length; i &lt; len; i++) { names.push(temp_users[i].name);}console.log(names); 1에서는 users 중에 age가 30 미만인 users[i]만 모아서 몇 명인지를 출력하고 2에서는 그들의 나이만 다시 모아 출력한다. 3에서는 나이가 30 이상인 temp_users가 몇 명인지를 출력하고 4에서는 그들의 이름만 다시 모아 출력한다. 위 코드를 함수형으로 리팩토링 하기 위해 먼저 중복되는 부분을 찾아본다. 1과 3의 for문에서 users를 돌며 특정 조건의 users[i]를 새로운 배열에 담고 있는데, if 문의 조건절 부분을 제외하고는 모두 동일한 코드이다. 30 부분은 변수로 바꿀 수 있겠지만 .age, &lt;, &gt;= 등은 쉽지 않아 보인다. 이때 함수를 활용하면 이런 부분까지도 쉽게 추상화 할 수 있다. for에서 filter로, if에서 predicate로12345678910111213141516// 기존코드var temp_users = [];for (var i = 0, len = users.length; i &lt; len; i++) { if (users[i].age &lt; 30) temp_users.push(users[i]);}console.log(temp_users.length);// refactoringfunction filter(list, predicate) { var new_list = []; for (var i = 0, len = list.length; i &lt; len; i++) { if (predicate(list[i])) new_list.push(list[i]); } return new_list;} filter 함수는 인자로 list와 predicate 함수를 받는다. 루프를 도며 list의 i번째의 값을 predicate에 넘겨준다. predicate 함수는 list.length 만큼 실행되며, predicate 함수의 결과가 참일 때만 new_list.push를 실행한다.filter 함수는 predicate 함수 내부에서 어떤 일을 하는지 모른다. id를 조회할지 age를 조회할지 어떤 조건을 만들지를 filter는 전혀 모른다. 오직 predicate 결과에만 의존한다. 123456789101112131415161718// filter 사용var users_under_30 = filter(users, function (user) { return user.age &lt; 30 });console.log(users_under_30)var ages = [];for (var i = 0, len = users_under_30.length; i &lt; len; i++) { ages.push(users_under_30[i].age);}console.log(ages);var users_over_30 = filter(users, function (user) { return user.age &gt; 30 });console.log(users_over_30);var names = [];for (var i = 0, len = users_over_30.length; i &lt; len; i++) { names.push(users_over_30[i].name)}console.log(names); filter 함수를 실행하면서 predicate 자리에 익명 함수를 정의해서 넘겼다. predicate 익명 함수의 리턴값(boolean)에 따라서 push를 해줄지 안해줄지가 결정된다. 기존 코드와 비교해 코드가 짧아졌고 재사용성 높은 함수 filter를 얻게됐다. 함수형 프로그래밍 관점으로 filter 보기함수형 프로그래밍 관점에서 filter와 predicate 사이에는 많은 이야기가 담겨있다. filter 함수에는 for도 있고 if도 있지만, filter 함수는 항상 동일하게 동작하는 함수다. 동일한 인자가 들어오면 항상 동일하게 동작한다. filter 함수의 로직은 외부나 내부의 어떤 상태 변화에도 의존하지 않는다. new_list의 값을 바꾸고 있지만 그 변화에 의존하는 다른 로직이 없다. new_list가 완성될 떄까지는 외부에서 어떠한 접근도 할 수 없기 때문에 filter의 결과도 달라질 수 없다. new_list가 완성되고 나면 new_list를 리턴해버리고 filter는 완전히 종료된다. filter의 if는 predicate의 결과에만 의존한다. filter를 사용하는 부분을 다시 보면 filter와 users, filter가 사용할 predicate 함수만 있다.1filter(users, function(user) { return user.age &lt; 30 }) 절차지향 프로그래밍과 달리 함수형 프로그래밍 에서는 항상 동일하게 동작하는 함수 를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다. 내부에서 관리하고 있는 상태를 따로 두지않고 넘겨진 인자에만 의존한다. 동일한 인자가 들어오면 항상 동일한 값을 리턴 하도록 한다. map 함수리팩토링의 핵심은 중복을 제거하고 의도를 드러내는 것이다. 기존 코드를 보면 회원 목록을 통해 나이와 이름들을 추출하는데 두 코드에도 중복이 있다. 둘 다 for문에서 사용하는 회원 목록을 활용해 같은 크기의 새로운 배열을 만들고 원재료와 1:1로 매핑되는 다른 값을 만들어 담고 있다. 123456789101112131415161718192021// map 사용function map(list, iteratee) { var new_list = []; for (var i = 0, len = list.length; i &lt; len; i++) { new_list.push(iteratee(list[i])); } return new_list;}var users_under_30 = filter(users, function (user) { return user.age &lt; 30 });console.log(users_under_30.length)var ages = map(users_under_30, function (user) { return user.age });console.log(ages);var users_over_30 = filter(users, function (user) { return user.age &gt; 30 });console.log(users_over_30.length)var names = map(users_over_30, function (user) { return user.name });console.log(names); 코드가 매우 단순해 진것을 확인할 수 있다. for도 없고 if도 없다. new_list에 무엇을 push 할지에 대해 iteratee 함수에게 위임했다. 실행 결과로 바로 실행하기함수의 리턴값을 바로 다른 함수의 인자로 사용하면 변수 할당을 줄일 수 있다.filter 함수의 결과가 배열이므로 map의 첫 번째 인자로 바로 사용 가능하다. 123456789101112131415161718192021222324252627282930313233343536// 함수 중첩var ages = map( filter(users, function (user) { return user.age &lt; 30 }), function (user) { return user.age })console.log(ages);var names = map( filter(users, function (user) { return user.age &gt;= 30 }), function (user) { return user.name })console.log(names);// 함수 중첩 2function log_length(value) { console.log(value.length) return value;}console.log( log_length( map( filter(users, function (user) { return user.age &lt; 30 }), function (user) { return user.age } ) ))console.log( log_length( map( filter(users, function (user) { return user.age &gt;= 30 }), function (user) { return user.name } ) )) filter 함수는 predicate를 통해 값을 필터링하여 map에게 전달하고 map은 받은 iteratee를 통해 새로운 값들을 만들어 log_length에게 전달한다. log_length는 length를 출력한 후 받은 인자를 그대로 console.log에게 전달하고 console.log는 받은 값을 출력한다. 함수를 값으로 다룬 예제의 실용성위에 만들었던 addMaker 와 비슷한 패턴의 함수가 실제로도 많이 사용된다.addMaker와 비슷한 패턴의 함수인 bvalue 함수를 만들어 보려고한다. 1234567function bvalue(key) { return function (obj) { return obj[key] }}console.log(bvalue('a')({ a: 'hi', b: 'hello' })); // hi bvalue를 실행할 때 넘겨준 인자 key를 나중에 obj를 받을 익명 함수가 기억한다.1234567891011121314151617181920/** * bvalue로 map의 iteratee 만들기 */console.log( log_length( map( filter(users, function (user) { return user.age &lt; 30 }), bvalue('age') ) ))console.log( log_length( map( filter(users, function (user) { return user.age &gt;= 30 }), bvalue('name') ) )) map이 사용할 iteratee 함수를 bvalue가 리턴한 함수로 대체했다. 익명 함수 선언이 사라져 코드가 더욱 짧아졌다. 화살표 함수로 사용하기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152console.log( log_length( map( filter(users, user =&gt; user.age &lt; 30), user =&gt; user.age ) ))console.log( log_length( map( filter(users, user =&gt; user.age &gt;= 30), user =&gt; user.name ) ))var under_30 = user =&gt; user.age &lt; 30;var over_30 = user =&gt; user.age &gt;= 30;var ages = list =&gt; map(list, user =&gt; user.age);var names = list =&gt; map(list, user =&gt; user.name);console.log(log_length(ages(filter(users, under_30))));console.log(log_length(names(filter(users, over_30))));function bvalues(key) { return function (list) { return map(list, function (user) { return user[key] }) }}var ages = bvalues('age');var names = bvalues('name');var under_30 = function (user) { return user.age &lt; 30 };var over_30 = function (user) { return user.age &gt;= 30 };console.log(log_length(ages(filter(users, under_30))));console.log(log_length(names(filter(users, over_30))));function bvalues(key) { var value = bvalue(key); return function (list) { return map(list, value) }}// 화살표 함수 사용var bvalues = key =&gt; list =&gt; { var value = bvalue(key) return map(list, value);} Conclusion어려운 점이 공부를 하면 할수록 많이 생기겠지만, 새로운 관점에서의 프로그래밍인 것 같아 흥미롭게 느껴진다.본인은 아직 주니어라 절차지향적 사고 방식이 강한데 함수형 프로그래밍 공부하면서 새로운 사고 방식에 대해서도 생각해 봐야할 것 같다. 이번 챕터의 첫 코드(절차지향적 코드)는 쉽다고 느껴졌지만, 함수형으로 리팩토링 해 나가는 과정에서는 이게 정확히 어떤 방식으로 동작하는가, 인자값은 어떻게 넘겨 주는가에 대한 고민이 생기는것을 느끼면서 함수형 프로그래밍에 더 알고 싶어졌다. 처음에는 함수형 프로그래밍 방식이 “그래서 왜 좋은건데?”에 대한 의문이 있었는데 마지막 코드를 보고 재새용성이 뛰어나다는것을 느꼈다. 프로젝트를 시작할때 잘 구현해 놓은 함수는 계속 재사용하면서 코딩의 속도와 편리함을 제공해 줄 것 같다고 생각했다.","link":"/2019/09/28/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%91/"},{"title":"함수형 프로그래밍 - 시작2","text":"이전 포스트에서 함수형 프로그래밍의 간략한 소개와 몇가지 예제 코드를 구현했었다. 오늘은 이전 포스트에 이어 다음 내용을 진행하려고 한다. 회원 목록 중 한명 찾기회원 목록 중 id 값으로 해당 id 값을 가진 회원 한 명을 찾고자 한다. 1234console.log( filter(users, function (user) { return user.id === 3 })[0])// {id: 3, name: \"BJ\", age: 32} filter를 통해 걸러낸 후 [0]으로 user를 얻어냈고 원하는 결과를 얻어냈기는 했다. 위 처럼 filter를 사용하여 찾을 수 있지만 filter 함수는 무조건 list.length 만큼 predicate가 실행되기 때문에 효율적이지 못하고, 동일 조건에 값이 두 개 이상이라면 두 개 이상의 값을 찾는다. 123456789var user;for (var i = 0, len = users.length; i &lt; len; i++) { if (users[i].id === 3) { user = users[i]; break; }}console.log(user); 원하는 user를 찾은 후 break로 for문을 빠져나왔다. 앞선 filter를 통해 찾은 것보다 훨씬 효율적이다.하지만 위 코드는 재사용이 불가능 하므로 위 코드를 함수로 만들어서 재사용 가능하도록 만들어 보려고한다. 12345678910function findById(list, id) { for (var i = 0, len = list.length; i &lt; len; i++) { if (list[i].id === id) { return list[i]; } }}console.log(findById(users, 3));console.log(findById(users, 5)); findById는 list와 id를 받아 루프를 돌다가 id가 동일한 객체를 만나면 그 값을 리턴한다.만약 동일한 객체를 찾지 못한다면 기본 리턴 값인 undefined 가 리턴된다. 123456789101112131415161718192021222324252627/** * findByName */function findByName(list, name) { for (var i = 0, len = list.length; i &lt; len; i++) { if (list[i].name === name) { return list[i]; } }}console.log(findByName(users, 'BJ'));console.log(findByName(users, 'JE'));/** * findByAge */function findByAge(list, age) { for (var i = 0, len = list.length; i &lt; len; i++) { if (list[i].age === age) { return list[i]; } }}console.log(findByAge(users, 28));console.log(findByAge(users, 25)); findById 와 동일하게 이름과 나이로도 찾을 수 있는 함수를 만들었다. 하지만 위의 세 함수 사이에 중복이 있다는 점이 아쉽다. 1234567891011/** * findBy */function findBy(key, list, val) { for (var i = 0, len = list.length; i &lt; len; i++) { if (list[i][key] === val) return list[i]; }}console.log(findBy('name', users, 'BJ'));console.log(findBy('id', users, 2));console.log(findBy('age', users, 28)); 위와 같이 함수에 key 라는 인자를 하나 추가함으로써 세 함수를 공통으로 사용할 수 있게됐다. 위 함수는 key로 value를 얻을 수 있는 객체들을 가진 배열이라면 무엇이든 받을 수 있다. 객체의 key 값이 무엇이든지 간에 찾아줄 수 있으므로 훨씬 많은 경우를 대응할 수 있는 함수가 되었다.하지만 위 함수에서도 아직 아쉬운 점이 존재한다. key가 아닌 메서드를 통해 값을 얻어야 할 때 두 가지 이상의 조건이 필요할 때 ===이 아닌 다른 조건으로 찾고자 할 때 123456789101112131415161718192021222324function User(id, name, age) { this.getId = function () { return id; } this.getName = function () { return name; } this.getAge = function () { return age; }}var users2 = [ new User(1, \"ID\", 32), new User(2, \"HA\", 25), new User(3, \"BJ\", 32), new User(4, \"PJ\", 28), new User(5, \"JE\", 27), new User(6, \"JM\", 32), new User(7, \"HI\", 24),]console.log(findBy('age', users2, 25));// undefined user의 나이를 .getAge() 로 얻어내야 하기 때문에 findBy 함수로는 위 상황을 대응할 수 없을을 알 수 있다. 이름에 ‘P’ 가 포함된 user를 찾고 싶다거나 아니가 32이면서 이름이 ‘JM’인 user를 찾고 싶다거나 하는 것도 불가능하다. 값에서 함수로앞서 만들었던 filter나 map처럼, 인자로 키와 값 대신 함수를 사용해 보려고 한다. 그렇게 하면 모든 상황에 대응 가능한 find 함수를 만들 수 있다. 123456789101112131415161718function find(list, predicate) { for (var i = 0, len = list.length; i &lt; len; i++) { if (predicate(list[i])) return list[i]; }}console.log( find(users2, function (u) { return u.getAge() === 25 }).getName());console.log( find(users, function (u) { return u.name.indexOf('P') !== -1 }));console.log( find(users, function (u) { return u.age === 32 &amp;&amp; u.name === 'JM' }));console.log( find(users2, function (u) { return u.getAge() &lt; 30 }).getName()); find의 인자로 key와 val 대신 predicate 함수 하나를 받았다. 값 대신 함수를 받았다. 덕분에 if 안쪽에서 할 수 있는 일이 정말 많아졌다. 메서드를 사용하거나 두가지 이상의 조건을 사용하는 것도 잘 동작한다.find는 이제 배열에 어떤 값이 들어 있든 사용할 수 있게 되었다. 함수형 자바스크립트는 이처럼 다형성이 높은 기법을 많이 사용하며 이러한 기법은 정말 실용적이다 filter, map, find 함수들은 들어온 데이터가 무엇이든지 루프들 돌리거나 분기를 만들거나 push를 하거나 predicate를 실행하거나 등의 자기 할 일을 한다. find는 전달 받을 데이터와 데이터의 특성에 맞는 보조 함수(predicate)도 함께 전달받는다. 들어온 데이터의 특성은 보조 함수가 대응해 주기 때문에 find 함수는 데이터의 특성에서 완전히 분리될 수 있다. 이러한 방식은 다형성을 높이며 동시에 안정성도 높인다. 12345678910111213141516/** * 다형성 */console.log( map( filter(users, function (u) { return u.age &gt;= 30 }), function (u) { return u.name } ));console.log( map( filter(users2, function (u) { return u.getAge() &gt; 30 }), // 메서드 실행으로 변경 function (u) { return u.getName() } // 메서드 실행으로 변경 )); 함수를 만드는 함수와 find, filter 조합하기User등의 커스텀 객체가 아닌 자바스크립트 기본 객체로 만들어진 users를 사용한 예제로 다시 돌아가 보자. 함수로 함수를 만들어 find 함수와 함께 사용하면 코드를 더욱 간결하게 만들 수 있다. 123456789function bmatch1(key, val) { return function (obj) { return obj[key] === val; }}console.log(find(users, bmatch1('id', 1)));console.log(find(users, bmatch1('name', 'BJ')));console.log(find(users, bmatch1('age', 28))); bmatch1의 실행 결과는 함수다. key와 val을 미리 받아서 나중에 들어올 obj와 비교하는 익명 함수 클로저로 만들어 리턴한다. bmatch1을 통해 id, name, age를 비교하는 predicate 3개를 만들어 find에 넘겼다.bmatch1은 함수를 리턴하기 때문에 filter나 map과도 조합이 가능하다. 12console.log(filter(users, bmatch1('age', 32)));console.log(map(users, bmatch1('age', 32))); bmatch1은 하나의 key에 대한 value만 비교할 수 있다. 여러 개의 key에 해당하는 value들을 비교하는 함수를 만들어보자. 1234567891011121314151617181920212223242526272829function object(key, val) { var obj = {}; obj[key] = val; return obj;}function match(obj, obj2) { for (var key in obj2) { if (obj[key] !== obj2[key]) return false; } return true;}function bmatch(obj2, val) { if (arguments.length == 2) obj2 = object(obj2, val); return function (obj) { return match(obj, obj2); }}console.log( match(find(users, bmatch('id', 3)), find(users, bmatch('name', 'BJ'))));console.log( find(users, function (u) { return u.age === 32 &amp;&amp; u.name === 'JM' }));console.log( find(users, bmatch({ name: 'JM', age: 32 }))); 이제는 (key, val)와 ({key: val}) 두 가지 방식으로 사용할 수 있다. ({key: val}) 방식을 사용하면 두 가지 이상의 값이 모두 동일한지도 확인할 수 있다. bmatch1을 bmatch로 발전시키면서 유용한 함수인 match와 object도 만들어졌다. 이처럼 작은 기능을 하는 함수로 쪼개거나 재조합하는 식으로 코드를 발전시키는것도 좋은 방법이다. find를 조금만 고치면 값 비교만 하는 Array.prototype.indexOf보다 활용도가 훨씬 높은 findIndex를 만들 수 있다. 1234567891011121314/** * findIndex */function findIndex(list, predicate) { for (var i = 0, len = list.length; i &lt; len; i++) { if (predicate(list[i])) return i; } return -1;}console.log(findIndex(users, bmatch({ name: 'JM', age: 32 }))) // 5console.log(findIndex(users, bmatch({ age: 36 }))) // -1console.log(findIndex(users, bmatch('id', 2))); // 1 고차함수앞서 구현했던 filter, map, find, findIndex, bvalue, bmatch 같은 함수들은 모두 고차 함수다.고차 함수란, 함수를 인자로 받거나 함수를 리턴하는 함수를 말한다. 당연히 둘 다 하는 경우도 고차 함수다. 보통 고차 함수는 함수를 인자로 받아 필요한 때에 실행하거나 클로저를 만들어 리턴한다. Underscore.js는 유명한 함수형 자바스크립트 라이브러리다. Underscore.js 의 _.map, _.filter, _.find, _.findIndex는 iteratee와 predicate가 사용할 인자를 몇 가지 더 제공한다. 재료가 많으면 더 다양한 로직을 만들 수 있다. 앞서 구현했던 고차 함수들을 Underscore.js에 가깝게 고쳐 보자. 12345678910111213141516171819202122232425262728_.map = function (list, iteratee) { var new_list = []; for (var i = 0, len = list.length; i &lt; len; i++) { new_list.push(iteratee(list[i], i, list)) } return new_list;}_.filter = function (list, predicate) { var new_list = []; for (var i = 0, len = list.length; i &lt; len; i++) { if (predicate(list[i], i, list)) new_list.push(list[i]) } return new_list;}_.find = function (list, predicate) { for (var i = 0, len = list.length; i &lt; len; i++) { if (predicate(list[i], i, list)) return list[i] }}_.findIndex = function (list, predicate) { for (var i = 0, len = list.length; i &lt; len; i++) { if (predicate(list[i], i, list)) return i } return -1;} 원래는 iteratee(list[i])처럼 한 개의 인자를 넘겼지만, 이제는 iteratee(list[i], i, list) 처럼 두 개의 인자를 추가했다. 이제 iteratee와 predicate 함수가 받는 인자가 많아져 좀 더 다양한 일을 할 수 있게 되었다. predicate도 iteratee와 동일하다. 12345678910console.log( _.filter([1, 2, 3, 4], function (val, idx) { return idx &gt; 1; })) // [3, 4]console.log( _.filter([1, 2, 3, 4], function (val, idx) { return idx % 2 === 0; })) // [1,3] function identity정말 쓸모 없어 보이는 이상한 함수 하나를 소개한다. 이것은 Underscore.js에 있는 함수이기도 하다. 123_.identity = function (v) { return v };var a = 10;console.log(_.identity(10)) // 10 받은 인자를 그냥 그대로 뱉는 함수다. _.identity 같은 아무런 기능이 없는 함수는 대체 언제 사용해야 하는 걸까? 12console.log(_.filter([true, 0, 10, 'a', false, null], _.identity));// [true, 10, 'a'] _.filter를 _.identity와 함께 사용했더니 Truthy Values만 남았다. 이렇게 놓고 보니 _.identity가 생각보다 실용적으로 보인다. _.identity를 다른 고차 함수와 조합하는 식으로 아래와 같은 유용한 함수들을 만들 수 있다. 12345678910111213_.some = function (list) { return !!_.find(list, _.identity);}_.every = function (list) { return _.filter(list, _.identity).length === list.length;}console.log(_.some([0, null, 2])); // trueconsole.log(_.some([0, null, false])); // falseconsole.log(_.every([0, null, true])); // falseconsole.log(_.every([{}, true, 2])); // true _.some은 배열에 들어 있는 값 중 하나라도 긍정적인 값이 있으면 true, 하나도 없다면 false를 리턴한다._.every는 모두 긍정적인 값이어야 true를 리턴한다. _.some, _.every는 if나 predicate 등과 함께 사용할 때 매우 유용하다._.every는 filter를 사용했기 때문에 항상 루프를 끝까지 돌게 된다. 정말 쓸모 없어 보이지만 함수 두 개를 더 만들면 로직을 개선할 수 있다. 연산자 대신 함수로123456function not(v) { return !v; }function beq(a) { return function (b) { return a === b; }} !를 써도 되는데 not이 왜 필요할까? ===로 비교하면 되는데 beq는 왜 필요할까? 굳이 not과 beq를 함수로 만들 필요가 있을까? 12345678910111213_.some = function (list) { return !!_.find(list, _.identity);}_.every = function (list) { return beq(-1)(_.findIndex(list, not));}console.log(_.some([0, null, 2, 0])); // trueconsole.log(_.some([0, null, false])); // falseconsole.log(_.every([0, null, true])); // falseconsole.log(_.every([{}, true, 2])); // true not은 연산자 !가 아닌 함수이기 때문에 _.findIndex와 함께 사용할 수 있다. list의 값 중 하나라도 부정적인 값을 만나면 predicate가 not이므로 true를 리턴하여 해당번째 i 값을 리턴하게 된다. 중간에 부정적인 값을 한 번이라고 만나면 루프가 중단된다. 만일 부정적인 값이 하나도 없다면 -1을 리턴한다._.every는 쓸모 없어 보이는 정말 작은 함수 not 덕분에 로직이 개선되었다. 좀 더 함수를 쪼개보다. 함수가 가능하면 한 가지 일만 하게끔 말이다. 123456789101112131415function positive(list) { return _.find(list, _.identity);}function negetiveIndex(list) { return _.findIndex(list, not);}_.some = function (list) { return not(not(positive(list)));}_.every = function (list) { return beq(-1)(negetiveIndex(list));} 함수 합성함수를 쪼갤수록 함수 합성은 쉬워진다. 다음은 다양한 함수 합성 기법 중 하나인 Underscore.js의 _.compose다. _.compose는 오른쪽의 함수의 결과를 바로 왼쪽의 함수에게 전달한다. 그리고 해당 함수의 결과를 다시 자신의 왼쪽의 함수에게 전달하는 고차 함수다. 123456789101112131415_.compose = function () { var args = arguments; var start = args.length - 1; return function () { var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; }}var greet = function (name) { return 'hi: ' + name; };var exclaim = function (statement) { return statement.toUpperCase() + '!'; };var welcome = _.compose(greet, exclaim);console.log(welcome('moe')); welcome을 실행하면 먼저 exclaim을 실행하면서 “moe”를 인자로 넘겨준다. exclaim 의 결과는 대문자로 변환된 “MOE!”이고 그 결과는 다시 greet의 인자로 넘어가 최종 결과로 “hi: MOE!”를 리턴한다. 12_.some = _.compose(not, not, positive);_.every = _.compose(beq(-1), negetiveIndex); _.compose로 _.some과 _.every를 더 간결하게 표현했다. 맨 오른쪽의 함수가 인자를 받아 결과를 만들고 결과는 다시 그 왼쪽의 함수에게 인자로 전달된다. 오른쪽에서 부터 왼쪽으로 연속적으로 실행되어 최종 결과를 만든다. 값 대신 함수로, for와 if 대신 고차 함수와 보조 함수로, 연산자 대신 함수로, 함수 합성 등 앞서 설명한 함수적 기법들을 사용하면 코드도 간결해지고 함수명을 통해 로직을 더 명확히 전달할 수 있어 읽기 좋은 코드가 된다. Conclusion저번 포스트에서는 함수를 조합해서 사용한다는 것에 정확한 이해가 부족했는데, 이번 포스트를 통해 어느정도의 이해는 된것같다. 이번 포스트에서 제일 크게 느낀점은 “기능 단위로 최대한 작게 함수를 쪼개 놓고 이 함수들을 조합하여 하나의 고차 함수를 사용한다.” 이다.if나 for 같은 로직도 함수 단위로 쪼개면서 재사용성을 고려해서 만들어 놓는 다면 코드의 품질 뿐만 아니라 가독성도 좋아지고 유지 보수도 좋아질 것이라는 생각이 들었다. 운영되고 있는 프로젝트에서 에러가 발생해서 고쳐야 하는 경우나 리팩토링을 해야하는 경우 복잡한 로직이라면 이해하기 쉽지 않은 경우가 있다.내가 짜놓은 코드라도 그때 당시의 고려했던 점이나 여러 경우를 전부 기억하지 못해 수정에 어려움이 있을때가 많다. 이때 만약 함수 단위로 구현해 놓았으면 에러가 발생한 부분이나 고쳐야 할 부분을 함수만 파악하고 고치면 되기때문에 편할 것 같다는 생각이 들었다. 합성함수 (_.compose)의 arguments 부분이 아직 정확하게 이해 되지는 않지만 뒤에서 arguments에 대해 다시 다뤄준다고 했으니 합성함수의 동작방식만 이해하고 넘어가야겠다. 참조: 함수형 자바스크립트 프로그래밍","link":"/2019/09/29/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%912/"},{"title":"Storybook 마크다운으로 작성하기","text":"우선 이 글에서는 리액트, 타입스크립트를 사용하는 스토리북 세팅이 다 갖춰졌다는 것을 가정하고 써보려고 한다.스토리북은 단위 컴포넌트 테스트를 가능하게 해주고 협업에 있어 엄청난 장점을 갖는다고 생각한다.하지만, 스토리북에서 제공해 주는 Canvas 만 사용했었다. 이로 인해 디테일한 설명, Props 의 type 등 불편한 점이많았다. 이 문제를 어떻게 해결할 수 있을까 라는 고민을 하며 찾아보니 마크다운 문법으로 스토리북을 작성할 수 있다는것을 알게 되었다. addon-docs우선 .storybook 폴더에 main.js 파일이 존재한다. 이 파일은 스토리북에 대한 설정을 잡아주는 파일이라고 생각하면 된다. addons, webpack 등의 설정을 해줄 수 있다. 12345678910111213141516171819202122232425262728293031const path = require('path');module.exports = { addons: [ '@storybook/addon-knobs/register', '@storybook/addon-actions/register' ], webpackFinal: (config) =&gt; { config.module.rules.push({ test: /\\.(ts|tsx)$/, use: [ { loader: require.resolve('babel-loader'), options: { presets: [['react-app', { flow: false, typescript: true }]], }, }, { loader: require.resolve(\"react-docgen-typescript-loader\"), options: { tsconfigPath: path.join(__dirname, \"../tsconfig.json\"), }, }, ], }); config.resolve.extensions.push('.js', '.ts', '.tsx'); return config; }}; 기존 main.js 의 설정이었다. 사실 스토리북에서 마크다운으로 작성하기 위한 설정은 쉬웠다. @storybook/addon-docs 를 install 해주고 addons 에 넣어주면 거의 끝났다고 보면 된다. script1npm i -D @storybook/addon-docs 12345678module.exports = { addons: [ '@storybook/addon-docs/preset', '@storybook/addon-knobs/register', '@storybook/addon-actions/register' ], // ...}; 이제 마지막 한가지만 더 추가해주면 된다. 본인은 .storybook 폴더 내부에 config.js 파일이 존재하고 해당 파일에서path 와 filter 를 설정해준다. 이때 mdx 도 filter 파일 조건에 추가만 해주면 된다. 1configure(require.context('../`stories`', true, /\\.stories\\.(mdx|tsx)$/), module); mdx 작성이제 기존 storybook 파일을 .jsx 또는 .tsx 에서 .mdx 로 바꾸면 된다.addon-docs 문서를 보면 다른 좋은 기능들이 많지만 본인은 거의 아래의 것들만 사용했다. Meta Title Subtitle Story Preview Props Metaharmony1&lt;Meta title=\"components/Button\" component={Button} decorators={[withKnobs]} /&gt; title 은 스토리북 상의 경로에 해당한다. component 라는 폴더 밑에 Button 을 생성한다. component 는 import 한 리액트 컴포넌트를 전달해주면 된다. decorators 는 여러개 넘겨줄 수 있는데 addon-knobs 를 사용하기 때문에 withKnobs 만 넘겨주었다. Titleharmony1&lt;Title&gt;Button&lt;/Title&gt; Title 은 해당 문서의 제목 즉, h1 태그가 된다. (#) Subtitleharmony1&lt;Subtitle&gt;Button Component&lt;/Subtitle&gt; Subtitle 은 h2 태그에 해당한다. (##) Preview, StoryPreview 와 Story 는 거의 세트로 사용했다. Preview 를 사용하면 문서에 영역이 생기는데 이 영역에Story가 들어가게 된다. harmony12345&lt;Preview&gt; &lt;Story name=\"default\"&gt; &lt;Button/&gt; &lt;/Story&gt;&lt;/Preview&gt; Props마지막으로 Props 는 컴포넌트에 defaultProps 가 존재하거나 interface 가 정의되어 있다면 해당 컴포넌트의타입과 필수값들을 테이블로 나열해 준다. harmony1&lt;Props of={Button}/&gt; 스토리북에서 리액트 문법 사용하기추가로 스토리북에서 리액트의 기능 useState, useEffect 또는 함수를 만들어서 사용할 수 없을까에 대한고민을 하게 되었고 역시나 사용할 수 있었다. Story 태그에 js 문법을 이용하여 함수를 사용하고 컴포넌트를 리턴해주면 된다. harmony123456789101112131415&lt;Preview&gt; &lt;Story name=\"default\"&gt; {() =&gt; { const [state, setState] = useState([]); const handleClick = (e) =&gt; { //... } return ( &lt;Button handleClick={handleClick} /&gt; ) }} &lt;/Story&gt;&lt;/Preview&gt; 아직 풀리지 않는 이상한 점도 있다. Story 태그에 함수를 사용할때 공백줄이 있으면 에러가 발생한다.이 문제에 대해 구글링 해본 결과 이슈로 올라오고 있는데 아직까지 해결되지는 않은것 같다. 즉 이 코드는 동작하지만,1234const [state, setState] = useState([]);const handleClick = (e) =&gt; { //...} 이 코드에서는 에러가 발생한다.12345const [state, setState] = useState([]);const handleClick = (e) =&gt; { //...} @storybook/addon-docs","link":"/2020/05/17/Storybook-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"title":"React recoiljs 알아보기","text":"최근 react 에서 새로운 상태관리 라이브러리를 발표했다. 주요 컨셉으로는 atom,selector 라는 단위를 통해derived state 를 효과적으로 처리하고 상태의 코드 분할이 가능하게 한다고 한다. 리액트의 기본 설정은 create-react-app 을 사용하려고 한다. react-app 생성 후 recoiljs 를 설치해주면사용 준비가 끝난것이다. script1npm i recoil 구조아직 나온지 얼마 되지 않은 라이브러리라서 구조화에 대한 내용이 많이 없다. 현재는 src 내부에recoil 이라는 폴더를 만들고 component 단위 별로 파일을 생성하려고 한다. RecoilRootredux, mobx 등 다른 상태관리 라이브러리에도 provider 가 있듯이 recoil 도 RecoilRoot 라는 hoc 가 존재한다.props 로 initializeState 를 전달해 줄 수 있지만 지금은 일단 넘어가려 한다. create-react-app 으로 생성한 app 기준 index.js 에 App 을 RecoilRoot 로 감싸주면 된다. harmony12345678910import {RecoilRoot} from 'recoil';ReactDOM.render( &lt;React.StrictMode&gt; &lt;RecoilRoot&gt; &lt;App /&gt; &lt;/RecoilRoot&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); RecoilRoot 공식 문서 atom리액트의 state 와 같다라고 생각해도 된다. 즉, 상태 값이라는 것이다. 기본적으로 atom 함수를 실행하고이때 인자로 option 을 넘겨준다. option 중 key 와 default 는 필수 값이다. key 는 unique 한 id 여야 하고 default 는 이름에서 유추할 수 있듯이 해당 상태 값의 초기값이다. count component 를 만들면서 확인해 보자. 우선 recoil 폴더에 count.js 파일을 만든 후 아래와 같이 atom state 를 생성해 줬다. 123456import {atom} from \"recoil\";export const countState = atom({ key: \"countState\", default: 0}); 이후 Count Component 를 아래와 같이 생성했다. harmony123456789101112131415161718import React from \"react\";import {useRecoilState} from \"recoil\";import {countState} from \"../recoil/count\";function Counter() { const [count, setCount] = useRecoilState(countState); const incrementByOne = () =&gt; setCount(count + 1); return ( &lt;div&gt; Count: {count} &lt;br /&gt; &lt;button onClick={incrementByOne}&gt;Increment&lt;/button&gt; &lt;/div&gt; );}export default Counter; 위의 useRecoilState 훅은 밑에서 자세히 설명하도록 하겠다. selectorselector 도 atom 과 마찬가지로 값으로 쓰인다. 차이점은 atom 은 오로지 현재 값만 가져오고setState 할때도 넘겨주는 값만을 사용할 수 있다. 하지만 selector 는 option 에 get 과 set 을 넘겨줘서사용할 수 있다. option 에 역시 key 는 필수이며 unique 해야한다. get 또한 필수로 넘겨줘야 하며 set 은 optional 이다. 12345export const countEvenState = selector({ key: \"countEvenState\", get: ({get}) =&gt; get(countState) % 2 === 0, set: ({set}, newValue) =&gt; set(countState, newValue)}); 먼저 selector recoil state 를 생성했다. 위 값을 불러올때 짝수면 true, 홀수면 false 를 가져온다. get 은 함수를 전달해줘야한다. 이때 인자 객체에 get 이라는 함수가 있는데, 이 함수를 사용하여 상태값을불러와 사용한다. 이때 get 에 전달해줘야 하는 값은 recoil state 여야 한다. 위의 예제에서는 set 이 필요 없을 수 있으나, 어떤 식으로 사용해야 하는지 알 수 있게 추가한 것이다.set 은 첫번째 인자로 객체, 두번째 인자로 새로운 값이 넘어오고, 첫번째 인자 객체의 set 을 사용하여state 값을 바꾼다. 이때 첫번째 인자는 역시 recoil state 여야 하고 두번째 인자로 바뀔 값을 넘겨준다. harmony123456789101112131415161718function Counter() { const [count, setCount] = useRecoilState(countState); const [evenCount, setEvenCount] = useRecoilState(countEvenState); const incrementByOne = () =&gt; setCount(count + 1); const incrementByOneEvenCount = () =&gt; setEvenCount(count + 1); return ( &lt;div&gt; Count: {count} &lt;br /&gt; &lt;button onClick={incrementByOne}&gt;Increment&lt;/button&gt; &lt;br /&gt; Even Count: {evenCount ? '짝수' : '홀수'} &lt;br /&gt; &lt;button onClick={incrementByOneEvenCount}&gt;Even Increment&lt;/button&gt; &lt;/div&gt; );} Count component 를 위와 같이 변경하였다. Even Increment 버튼을 클릭하면 count 의 값도 같이 바뀌는 것을확인할 수 있다. set 에서 count 의 값을 변경해 주기 때문이다. recoil hooksrecoil state 값 사용recoil state 는 훅을 이용하여 사용해야 한다. 위 예제의 useRecoilState 같은 훅이다. 현재까지 세가지 방법의recoil state 사용법이 있다. useRecoilValue: 값만을 불러올 수 있다. 즉 이 훅은 set 함수를 반환하지 않는다. useSetRecoilState: set 함수만을 불러올 수 있다. useRecoilState: 값, set 함수 두가지 다 불러올 수 있다. 위 예제에서는 useRecoilState 만을 사용하였는데 현재 setCount 는 사용하지 않으므로 useRecoilValue 로 리팩토링하는 것이 좋을 것 같다. harmony123456789101112131415function Counter() { const count = useRecoilValue(countState); const [evenCount, setEvenCount] = useRecoilState(countEvenState); const incrementByOneEvenCount = () =&gt; setEvenCount(count + 1); return ( &lt;div&gt; Count: {count} &lt;br /&gt; Even Count: {evenCount ? '짝수' : '홀수'} &lt;br /&gt; &lt;button onClick={incrementByOneEvenCount}&gt;Even Increment&lt;/button&gt; &lt;/div&gt; );} useResetRecoilStaterecoil state 를 default 값으로 초기화 시킬때 사용한다. harmony12const resetCount = useResetRecoilState(countState);&lt;button onClick={resetCount}&gt;reset&lt;/button&gt; useRecoilValueLoadable밑에서 다시 언급하겠지만 이 훅은 주로 비동기 selector 를 쓸때 사용된다. React.Suspense 로 loading 처리를 할 수 있지만위 훅을 사용하면 현재 상태(state) 와 값(contents)을 반환해준다. 12const countLoadable = useRecoilValueLoadable(countEvenState);console.log(countLoadable); useRecoilCallbackrecoil state 를 불러오지 않았을때도 callback 함수를 전달해주어 해당 callback 에서 recoil state 에 접근 가능하도록해준다. 아래는 공식 문서의 예제이다. harmony12345678910111213141516171819import {atom, useRecoilCallback} from 'recoil';const itemsInCart = atom({ key: 'itemsInCart', default: 0,});function CartInfoDebug() { const logCartItems = useRecoilCallback(async ({getPromise}) =&gt; { const numItemsInCart = await getPromise(itemsInCart); console.log('Items in cart: ', numItemsInCart); }); return ( &lt;div&gt; &lt;button onClick={logCartItems}&gt;Log Cart Items&lt;/button&gt; &lt;/div&gt; );} 비동기 처리프로젝트를 진행함에 있어 API 호출과 같은 비동기 처리가 중요하다. recoil 에서도 역시 비동기 처리에 대한가이드를 전달해준다. recoil 폴더에 name.js 라는 파일을 추가한 후 아래와 같이 recoil state 를 생성했다. 1234567891011121314151617181920import {atom, selector} from \"recoil\";const getName = name =&gt; new Promise(resolve =&gt; { window.setTimeout(() =&gt; { resolve({name}); }, 1000);});export const currentUserNameState = atom({ key: 'currentUserNameState', default: \"Kkangil\",});export const currentUserName = selector({ key: 'currentUserName', get: async ({get}) =&gt; { const response = await getName(get(currentUserNameState)); return response.name; },}); selector 의 get option 에서 async/await 처리가 가능하다. 이후 UserName 이라는 Component 를 생성해줬다. harmony12345678910import React from \"react\";import {useRecoilValue} from \"recoil\";import {currentUserName} from \"../recoil/name\";function UserName() { const userName = useRecoilValue(currentUserName); return &lt;div&gt;{userName}&lt;/div&gt;;}export default UserName; 이렇게 Component 를 생성해 준 후 확인해보면 React.Suspense 를 사용해야 한다는 에러가 발생한다.index.js 에 React.Suspense 를 추가해주자. harmony12345678910ReactDOM.render( &lt;React.StrictMode&gt; &lt;RecoilRoot&gt; &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;App /&gt; &lt;/React.Suspense&gt; &lt;/RecoilRoot&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 유틸리티아쉽지만 현재 버전 0.0.7 에서는 제공하고 있지 않은것 같다. 추후 버전 업이 됐을때 기대해봐도 좋을것 같다. atomFamilyatom 을 사용하다가 한가지 의문이 들었다. 초기값을 설정해 주는것은 알겠는데 동적으로 초기값을 설정해 줄 수는없을까? 역시 존재했다. 1234567891011function atomFamily&lt;T, Parameter&gt;({ key: string, default: | RecoilValue&lt;T&gt; | Promise&lt;T&gt; | T | (Parameter =&gt; T | RecoilValue&lt;T&gt; | Promise&lt;T&gt;), dangerouslyAllowMutability?: boolean,}): RecoilState&lt;T&gt; 공식 문서에서 제공해주고 있는 atomFamily 의 type 정의이다. default 부분을 보면 RecoilValue, Promise 그리고 함수로정의되어 있는것을 확인할 수 있다. harmony12345678910111213export const countStateByFamily = atomFamily({ key: \"countState\", default: defaultValue =&gt; defaultValue});function Count2({number}) { const count = useRecoilValue(countStateByFamily(number)); return ( &lt;div&gt; Count: {count} &lt;/div&gt; );} selectorFamilyatom 과 마찬가지로 selector 도 값을 넘겨주어 사용할 수 있다. atom 과 다른점은 selector 의 get 과 set 은이미 함수를 사용하고 있었다. 값을 넘겨주기 위해 함수가 함수를 리턴해주는 형식이 된다. harmony12345678910111213141516171819202122const myNumberState = atom({ key: 'MyNumber', default: 2,});const myMultipliedState = selectorFamily({ key: 'MyMultipliedNumber', get: (multiplier) =&gt; ({get}) =&gt; { return get(myNumberState) * multiplier; }, set: (multiplier) =&gt; ({set}, newValue) =&gt; { set(myNumberState, newValue / multiplier); },});function MyComponent() { const number = useRecoilValue(myNumberState); const multipliedNumber = useRecoilValue(myMultipliedState(100)); return &lt;div&gt;{number} / {multipliedNumber}&lt;/div&gt;;} 결론아직 버전이 0.0.7 이고 개발이 더 필요해 보인다. 언제 정식 출시 될지도 모르곘지만 기존에 주로 사용되던redux, mobx 와 비교를 해보자면 훨씬 더 간단하고 간결하게 사용할 수 있을것 같다. redux 에서의 action, reducer,middleware 등 작업에 걸리는 시간을 줄일 수 있을것 같다. 그리고 함수형 컴포넌트와 잘 어울릴것 같다. 참고: RecoilRoot 공식 문서Github: kkangil","link":"/2020/05/24/React-recoiljs-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"},{"title":"Canvas의 기초 - 1","text":"HTML 에서는 태그를 중심으로 화면에 글자, 그림 등을 배치하고 CSS 를 이용하여 레이아웃을 그리지만, 캔버스는하나의 화면에 자바스크립트에서 지원하는 캔버스 함수를 이용하여 그린다. 캔버스의 기본적인 사용법은 소스와 같이 html 태그 안에 넣으면 된다. 캔버스 내에서는 css 가 제어되지 않기 때문에자바스크립트를 이용하여 코드를 구성해야 한다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;title&gt;Canvas 01&lt;/title&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=\"myCanvas\" width=\"400\" height=\"300\"&gt;CANVAS를 지원하지 않습니다.&lt;/canvas&gt; &lt;script&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 만약 캔버스가 지원되지 않는 브라우저이면, 캔버스 태그 안의 문구가 표시된다. script 태그에 캔버스 코드를 넣는다. 1234&lt;script&gt; var canvas = document.getElementById('myCanvas'); var ctx = canvas.getContext('2d');&lt;/script&gt; getContext 함수에 2d를 그린다고 선언하여, ctx 변수에 적용한다. 3d는 캔버스가 아닌 WebGL 과 같은 기능을 사용해야한다. 선 그리기선 그리기123456var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.beginPath();ctx.moveTo(100, 50);ctx.lineTo(300, 50);ctx.stroke(); 3: 선 그리기를 시작한다.4: 시작점으로 이동한다.5: 선의 끝점으로 이동한다.6: 선을 그린다. 사각형 그리기123456789var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.beginPath();ctx.moveTo(100, 50);ctx.lineTo(300, 50);ctx.lineTo(300, 200);ctx.lineTo(100, 200);ctx.lineTo(100, 50);ctx.stroke(); 내부에 색 채우기1234// ...ctx.stroke();ctx.fillStyle = \"red\";ctx.fill(); fillStyle 을 사용해 내부의 색을 지정해 줄 수 있다. fillStyle 없이 fill 함수만 실행할 경우 검정색으로 채워진다. 선의 색을 다른 색으로 채우고 두께 변경하기12345678// 선의 색 변경ctx.lineWidth = 20;ctx.strokeStyle = \"#0000ff\";ctx.stroke();// 색 채우기ctx.fillStyle = \"red\";ctx.fill(); 선의 끝 부분 처리하기12345678910111213141516171819202122var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.lineWidth = 20;ctx.strokeStyle = \"#0000ff\";ctx.beginPath();ctx.moveTo(100, 50);ctx.lineTo(300, 50);ctx.lineCap = \"butt\";ctx.stroke();ctx.beginPath();ctx.moveTo(100, 100);ctx.lineTo(300, 100);ctx.lineCap = \"round\";ctx.stroke();ctx.beginPath();ctx.moveTo(100, 150);ctx.lineTo(300, 150);ctx.lineCap = \"square\";ctx.stroke(); lineCap 을 사용하면 선의 끝 부분을 처리할 수 있다. butt: 선의 끝 부분을 좌표에 맞추어 마무리한다. 기본값 round: 선의 끝을 둥글린다. 선 두께를 반지름으로 한다. square: 선의 끝을 사각형으로 처리한다. 선 두께만큼 길어진다. 선의 꺾인 부분 처리하기12345678910111213141516171819202122232425var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.lineWidth = 20;ctx.strokeStyle = \"#0000ff\";ctx.beginPath();ctx.moveTo(100, 50);ctx.lineTo(300, 50);ctx.lineTo(300, 100);ctx.lineJoin = 'miter';ctx.stroke();ctx.beginPath();ctx.moveTo(100, 150);ctx.lineTo(300, 150);ctx.lineTo(300, 200);ctx.lineJoin = \"round\";ctx.stroke();ctx.beginPath();ctx.moveTo(100, 250);ctx.lineTo(300, 250);ctx.lineTo(300, 290);ctx.lineJoin = \"bevel\";ctx.stroke(); lineJoin 를 사용하면 꺾인 부분을 처리할 수 있다. miter: 각진 모서리 형태로 기본값이다. round: 둥근 모서리 형태 bevel: 잘려나간 모서리 형태 선의 간격을 조정하여 점선 만들기12345678910111213141516171819202122232425var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.lineWidth = 20;ctx.strokeStyle = \"#0000ff\";ctx.beginPath();ctx.moveTo(100, 50);ctx.lineTo(300, 50);ctx.lineTo(300, 100);ctx.setLineDash([20]);ctx.stroke();ctx.beginPath();ctx.moveTo(100, 150);ctx.lineTo(300, 150);ctx.lineTo(300, 200);ctx.setLineDash([20, 10]);ctx.stroke();ctx.beginPath();ctx.moveTo(100, 250);ctx.lineTo(300, 250);ctx.lineTo(300, 290);ctx.setLineDash([20, 10, 50, 10]);ctx.stroke(); setLineDash 를 사용하여 점선을 만든다. 선의 간격이 20씩 벌어져 있다. 선의 길이: 20, 간격: 10 만큼 벌어져 있다. 선의 길이: 20, 간격: 10 과 선의 길이: 50, 간격: 10 이 번갈아 가면서 그려진다. 사각형 그리기이전에는 선(line)을 이용하여 사각형을 그렸었는데 Rect 함수를 이용하여 사각형을 그릴 수 있다. 사각형 그리기1234var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.strokeRect(20, 20, 100, 100);ctx.strokeRect(150, 150, 50, 50); strokeRect 함수를 사용하면 사각형을 쉽게 그릴 수 있다. strokeRect(x, y, width, height); 사각형 색 채우기123456789var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = \"magenta\";ctx.fillRect(20, 20, 100, 100);ctx.strokeRect(20, 20, 100, 100);ctx.fillStyle = \"green\";ctx.fillRect(150, 150, 50, 50);ctx.strokeRect(150, 150, 50, 50); 내부를 사각형으로 지우기12345678var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.lineWidth = 10;ctx.strokeStyle = 'red';ctx.fillStyle = 'blue';ctx.fillRect(50, 50, 200, 200);ctx.strokeRect(50, 50, 200, 200);ctx.clearRect(70, 70, 100, 50); 원 그리기기본 원 그리기1234var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.arc(150, 150, 100,0, Math.PI*2);ctx.stroke(); arc 함수를 실행하여 원을 그릴 수 있다. context.arc(x, y, r, sAngle, eAngle, counterclockwise);x: x 좌표y: y 좌표r: 반지름sAngle: 시작하는 각도eAngle: 끝나는 각도counterclockwise: 시계 방향으로 회전 선과 호를 연결하여 라운드 코너 그리기12345678var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.beginPath();ctx.moveTo(50, 50);ctx.lineTo(300, 50);ctx.arcTo(350, 50, 350, 100, 50);ctx.lineTo(350, 200);ctx.stroke(); arcTo 함수를 사용하여 호를 그릴 수 있다. context.arcTo(x1, y1, x2, y2, r)x1: 시작하는 점의 x 좌표y1: 시작하는 점의 y 좌표x2: 끝나는 점의 x 좌표y2: 끝나는 점의 y 좌표r: 호의 반지름 quadraticCurve 그리기12345678var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.beginPath();ctx.moveTo(50, 50);ctx.lineTo(300, 50);ctx.quadraticCurveTo(200, 100, 350, 100);ctx.lineTo(350, 200);ctx.stroke(); quadraticCurveTo 함수를 이용하여 하나의 조절점의 커브를 그린다. context.quadraticCurve(cpx, cpy, x, y)cpx: 조절하는 점의 x 좌표cpy: 조절하는 점의 y 좌표x: 끝나는 점의 x 좌표y: 끝나는 점의 y 좌표 bezierCurve 그리기12345678var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.beginPath();ctx.moveTo(50, 50);ctx.lineTo(300, 50);ctx.bezierCurveTo(200,70, 100,150, 350,100);ctx.lineTo(350, 200);ctx.stroke(); bezierCurveTo 함수를 이용하여 두 조절점의 커브를 그린다. context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)cp1x: 조절하는 점 1번째의 x 좌표cp1y: 조절하는 점 1번째의 y 좌표cp2x: 조절하는 점 2번째의 x 좌표cp2y: 조절하는 점 2번째의 y 좌표x: 끝나는 점의 x 좌표y: 끝나는 점의 y 좌표 내부 채우기Gradient 로 내부 채우기1234567891011121314var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var grad = ctx.createLinearGradient(50, 50, 250, 50);grad.addColorStop(0, 'red');grad.addColorStop(1/6, 'orange');grad.addColorStop(2/6, 'yellow');grad.addColorStop(3/6, 'green');grad.addColorStop(4/6, 'aqua');grad.addColorStop(5/6, 'blue');grad.addColorStop(1, 'purple');ctx.lineWidth = 5;ctx.fillStyle = grad;ctx.fillRect(50, 50, 200, 200);ctx.strokeRect(50, 50, 200, 200); 그라데이션으로 색을 채우기 위해 createLinearGradient 함수를 사용했다. ctx.createLinearGradient(x0, y0, x1, y1);x0: 시작하는 점의 x 좌표y0: 시작하는 점의 y 좌표x1: 끝나는 점의 x 좌표y1: 끝나는 점의 y 좌표 radial gradient12345678910var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var grad = ctx.createRadialGradient(0, 0, 0, 100, 100, 300);grad.addColorStop(0, 'red');grad.addColorStop(0.5, 'yellow');grad.addColorStop(1, 'black');ctx.lineWidth = 5;ctx.fillStyle = grad;ctx.fillRect(0, 0, 300, 300);ctx.strokeRect(0, 0, 300, 300); ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);x0: 시작하는 점의 x 좌표y0: 시작하는 점의 y 좌표r0: 시작하는 곳의 반지름x1: 끝나는 점의 x 좌표y1: 끝나는 점의 y 좌표r1: 끝 나는 곳의 반지름 패턴으로 사각형 채우기123456789var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var flower = new Image();flower.src = \"images/flower.png\";flower.onload = function () { var pattern = ctx.createPattern(flower, \"repeat\"); ctx.fillStyle = pattern; ctx.fillRect(0, 0, canvas.width, canvas.height);} createPattern 를 이미지를 넘겨주어 실행한다. context.createPattern(image, “repeat”); repeat: 패턴을 반복하여 채운다. repeat-x: x축으로 반복하여 채운다. repeat-y: y축으로 반복하여 채운다. no-repeat: 반복하지 않는다. 이미지 그리기이미지를 원래 크기대로 그리기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var myPic = new Image();myPic.src = 'images/duck.jpg';myPic.onload = function () { ctx.drawImage(myPic, 10, 10);} context.drawImage(img, x, y) 이미지의 크기를 변형하여 그리기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var myPic = new Image();myPic.src = 'images/duck.jpg';myPic.onload = function () { ctx.drawImage(myPic, 10, 10, 150, 150);} context.drawImage(img, x, y, width, height) 이미지를 잘라 일부만 그리기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var myPic = new Image();myPic.src = 'images/duck.jpg';myPic.onload = function () { ctx.drawImage(myPic, 20, 20, 200, 200, 10, 10, 300, 200);} context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height)sx: 소스 이미지에서 잘라 가져올 시작점의 x 좌표sy: 소스 이미지에서 잘라 가져올 시작점의 y 좌표swidth: 소스 이미지에서 잘라 가져올 시작점 기준의 이미지 폭sheight: 소스 이미지에서 잘라 가져올 시작점 기준의 이미지 높이 참조: HTML5 캔버스github","link":"/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88/"},{"title":"Canvas의 기초-2","text":"이전 포스트에 이어 Canvas의 기초에 대해 더 알아보려 한다. 글씨 쓰기글씨 그리기 123456var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillText('The fillText() method draws filled text on the canvas.', 50, 100);ctx.fillText('The fillText() method draws filled text on the canvas.', 50, 120, 100);ctx.fillText('The fillText() method draws filled text on the canvas.', 50, 140, 200);ctx.fillText('The fillText() method draws filled text on the canvas.', 50, 160, 300); context.fillText(text, x, y, maxWidth)text: 화면에 표시될 글씨x: x 좌표y: y 좌표maxWidth: 화면에 표시될 최대 폭(선택 사항) 글씨 크기를 크게 변경하기12345var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = '#6495ED';ctx.font = 'italic bold 28px Arial, sans-serif';ctx.fillText(\"Hello Canvas World!\", 50, 100); 글씨의 외곽선 그리기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = '#6495ED';ctx.font = 'italic bold 40px Arial, sans-serif';ctx.fillText(\"Hello Canvas World!\", 10, 100);ctx.lineWidth = 2;ctx.strokeText(\"Hello Canvas World!\", 10, 100); strokeText 함수로 외곽선만 있는 글씨를 표시한다. 글씨의 좌우 정렬 알아보기123456789101112131415161718192021222324var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = '#6495ED';ctx.font = 'italic bold 30px Arial, sans-serif';ctx.textAlign = \"start\";ctx.fillText(\"Hello World!\", 200, 50);ctx.textAlign = \"end\";ctx.fillText(\"Hello World!\", 200, 50);ctx.textAlign = \"left\";ctx.fillText(\"Hello World!\", 200, 50);ctx.textAlign = \"right\";ctx.fillText(\"Hello World!\", 200, 50);ctx.textAlign = \"center\";ctx.fillText(\"Hello World!\", 200, 50);ctx.strokeStyle = 'red';ctx.moveTo(200, 20);ctx.lineTo(200, 370);ctx.stroke(); textAlign start: 시작점 기준(기본) end: 끝점 기준 left: 글씨의 왼쪽 기준 right: 글씨의 오른쪽 기준 center: 중심 기준 글씨의 상하정렬123456789101112131415161718192021222324var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = '#6495ED';ctx.font = 'italic bold 22px Arial, sans-serif';ctx.textBaseline = \"top\";ctx.fillText(\"top!\", 10, 150);ctx.textBaseline = \"bottom\";ctx.fillText(\"bottom!\", 50, 150);ctx.textBaseline = \"middle\";ctx.fillText(\"middle!\", 130, 150);ctx.textBaseline = \"alphabetic\";ctx.fillText(\"alphabetic!\", 220, 150);ctx.textBaseline = \"hanging\";ctx.fillText(\"hanging!\", 300, 150);ctx.strokeStyle = 'red';ctx.moveTo(0, 150);ctx.lineTo(400, 150);ctx.stroke(); textBaseline (베이스 라인 기준) top: 글씨의 위에 정렬 bottom: 글씨의 바닥에 정렬 center: 글씨의 중간에 정렬 alphabetic: 기본값 hanging: 글씨의 바로 위에 정렬 그림자 그리기사각형의 그림자12345678var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';ctx.shadowOffsetX = 5;ctx.shadowOffsetY = 5;ctx.shadowBlur = 3;ctx.fillStyle = 'red';ctx.fillRect(50, 50, 100, 100); shadowColor: 그림자의 색상 shadowOffsetX: 그림자의 간격을 x: 5 만큼 이동 shadowOffsetY: 그림자의 간격을 y: 5 만큼 이동 shadowBlur: 그림자의 흐림도 이동, 회전, 스케일, 변형하기위치 이동시키기123456var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'green';ctx.fillRect(50, 50, 100, 100);ctx.translate(100, 100);ctx.fillRect(50, 50, 100, 100); translate 를 사용하여 다음에 나오는 객체를 이동시킨다. css 의 translate 같다. 크기 변형하기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'green';ctx.fillRect(50, 50, 100, 100);ctx.scale(100, 100);ctx.fillStyle = 'red';ctx.fillRect(50, 50, 100, 100); 위의 예제에서는 크기를 절반으로 줄였다. 기준점(0,0)으로 하여 크기를 줄이기 때문에 제자리에서 크기가 줄지 않고,위치가 상단(25,25)으로 이동한다. 회전시키기123456789101112131415var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'yellow';ctx.strokeStyle = 'blue';ctx.lineWidth = 3;ctx.strokeRect(100, 100, 100, 100);ctx.fillRect(100, 100, 100, 100);ctx.rotate(5 * Math.PI / 180);ctx.strokeRect(100, 100, 100, 100);ctx.fillRect(100, 100, 100, 100);ctx.rotate(5 * Math.PI / 180);ctx.strokeRect(100, 100, 100, 100);ctx.fillRect(100, 100, 100, 100); 사각형 형태 변형하기1234567891011var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'yellow';ctx.strokeStyle = 'blue';ctx.lineWidth = 3;ctx.strokeRect(0, 0, 100, 100);ctx.fillRect(0, 0, 100, 100);ctx.transform(1.5, 0, 0, 1.5, 100, 100);ctx.strokeRect(0, 0, 100, 100);ctx.fillRect(0, 0, 100, 100); context.transform(s1, sk1, sk2, s2, m1, m2)s1: 수평으로 확대sk1: 수평으로 기울임sk2: 수직으로 기울임s2: 수직으로 확대m1: 수평으로 이동m2: 수직으로 이동 기울기123// ...ctx.transform(1, 0.2, 0.2, 1, 100, 100);// ... transform vs setTransform123456789101112131415var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'yellow';ctx.strokeStyle = 'blue';ctx.lineWidth = 3;ctx.strokeRect(0, 0, 100, 100);ctx.fillRect(0, 0, 100, 100);ctx.transform(1, 0.2, 0.2, 1, 100, 100);ctx.fillStyle = 'green';ctx.fillRect(0, 0, 100, 100);ctx.setTransform(1, 0, 0, 1, 100, 100);ctx.fillStyle = 'red';ctx.fillRect(0, 0, 100, 100); 색상 보정하기캔버스에서 일부분을 가져와서 색상을 바꾸어 그린다. 1234567891011var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'red';ctx.fillRect(20, 30, 100, 100);ctx.fillStyle = 'green';ctx.fillRect(50, 50, 100, 100);var src = ctx.getImageData(0, 0, 100, 100);ctx.putImageData(src, 200, 50);ctx.strokeRect(0, 0, 100, 100);ctx.strokeRect(200, 50, 100, 100); getImageDatacontext.getImageData(x, y, width, height) x: 왼쪽 상단의 x 좌표 y: 왼쪽 상단의 y 좌표 width: 사각형 영역의 폭 height: 사각형 영역의 높이 putImageDatacontext.putImageData(imgData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) imgData: getImageData 로 가져온 이미지 값 x: 왼쪽 상단의 X 좌표 y: 왼쪽 상단의 y 좌표 dirtyX: 가져올 이미지의 x 좌표 dirtyY: 가져올 이미지의 y 좌표 dirtyWidth: 가져와서 그릴 사각형 영역의 폭 dirtyHeight: 가져와서 그릴 사각형 영역의 높이 지정한 부분의 색상을 흑백으로 바꾸어 출력하기12345678910111213141516171819202122var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'red';ctx.fillRect(20, 30, 100, 100);ctx.fillStyle = 'green';ctx.fillRect(50, 50, 100, 100);var src = ctx.getImageData(0, 0, 100, 100);var pixels = src.data;var numPixels = pixels.length;for (var i=0; i &lt; numPixels; i++) { var avg = (pixels[i*4] + pixels[i*4+1] + pixels[i*4+2]) / 3; pixels[i*4] = avg; // Red; pixels[i*4+1] = avg; // Green; pixels[i*4+2] = avg; // Blue}ctx.putImageData(src, 200, 50);ctx.strokeRect(0, 0, 100, 100);ctx.strokeRect(200, 50, 100, 100); 이미지를 data 로 가져와 확인해보면 rgba 배열로 되어 있다. 각 픽셀의 색상 값을 흑백으로 변경하여 다시 저장한다. 합성하기두 개 이상의 이미지를 합성하여 새로운 이미지를 만들거나 효과를 주는 방법을 알아본다. 합성에는 다양한 방법이 있는데, 대표적인 방법은 알파값을 이용하여 투명한 이미지를 기존 이미지 위에 올려서색상에 간섭하여 그리는 것이다. 알파값 적용하기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'rgba(63, 169, 245, 1)';ctx.fillRect(20, 20, 100, 100);ctx.globalAlpha = 0.5;ctx.fillStyle = 'blue';ctx.fillRect(50, 50, 100, 100); globalAlpha 값이 0.5 적용된 파란색 사각형을 겹쳐서 그리게 적용한다. 두 개의 이미지를 합성하여 그리기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');ctx.fillStyle = 'red';ctx.fillRect(20, 20, 100, 100);ctx.globalCompositeOperation = 'source-over';ctx.fillStyle = 'blue';ctx.fillRect(50, 50, 100, 100); globalCompositeOperation source-over: 이미지 위에 겹쳐 그린다. (기본) source-atop: 첫 번째 이미지를 그리고 두 번째 이미지의 겹치는 부분만 그린다. source-in: 첫 번째 이미지를 그리지 않고 두 번째 이미지의 겹치지 않는 부분만 그린다. source-out: 첫 번째 이미지를 그리지 않고 그 영역 안에 두 번째 이미지만 그린다. destination-atop: 첫 번째 이미지를 위로 올리고 두 번째 이미지 전체를 그린다. destination-in: 첫 번째 이미지를 위로 올리고 두 번째와 겹치는 부분만 그린다. destination-out: 첫 번째 이미지만 그리고 두 번째 이미지와 겹치는 부분을 지운다. destination-over: 첫 번째 이미지를 위로 올려 그리고 두 번째 이미지를 아래로 그린다. lighter: 전체를 그리고 겹친 부분을 가산 혼합한다. copy: 두 번째 이미지만 남기고 다른 부분은 제거한다. xor: 전체를 그리고 겹친 부분을 지운다. 참조: HTML5 캔버스github","link":"/2020/05/31/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-2/"},{"title":"Canvas의 기초-3","text":"이전 글에 이어서 canvas 의 기초에 대해 더 알아보려한다. 이번 포스트에는 애니메이션, 이벤트에 대해서 알아본다. 애니메이션 만들기캔버스 화면에서 이미지가 움직이는 애니메이션을 만드는 방법을 알아보려한다. setInterval 함수를 사용해서 구현해본다. 사각형을 x 축으로 왼쪽에서 오른쪽으로 움직이기12345678910111213var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var ctxWidth = canvas.width;var ctxHeight = canvas.height;var x = 0;function animate() { ctx.clearRect(0, 0, ctxWidth, ctxHeight); ctx.fillStyle = 'red'; ctx.fillRect(x, 10, 50, 50); x++;}var animateInterval = setInterval(animate, 30); interval 에서 제일 먼저 clearRect 를 사용하여 캔버스를 깨끗이 지워줘야 한다. 이 부분이 없으면 빨간색 선이그려진다. 두개의 사각형을 만들고 애니메이션을 멈추게 하기1234567891011121314151617181920212223242526272829var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var ctxWidth = canvas.width;var ctxHeight = canvas.height;var x = 0;var y = 0;function animate() { ctx.clearRect(0, 0, ctxWidth, ctxHeight); ctx.fillStyle = 'red'; ctx.fillRect(x, 10, 50, 50); ctx.fillStyle = 'blue'; ctx.fillRect(10, y, 50, 50); x++; y++; // 영역 제한 if (x &gt; ctxWidth) { x = 0; } if (y &gt; ctxHeight) { y = 0; }}var animateInterval = setInterval(animate, 30);canvas.addEventListener('click', function () { clearInterval(animateInterval);}) 조건을 추가하여 x,y 값이 canvas 의 넓이, 높이값 보다 클 경우 0 으로 초기화 시켜준다. canvas 에 이벤트를 추가하여 클릭했을때 애니메이션이 멈추게 했다. 클릭한 곳에 사각형 그리기여기서부터는 게임을 만드는 것의 기본을 간단한 소스를 통해 확인해 본다. 마우스를 클릭한 곳으로 이동한다든지, 마우스를 클릭한 곳에 건물을 지을때 자주 볼 수 있다. 먼저 캔버스 위에마우스로 클릭한 곳의 좌표를 얻어, 그 곳에 사각형을 그리는 것을 확인해 보자. 마우스로 클릭한 곳의 좌표 얻기1234567var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');canvas.addEventListener('click', function (e) { var mouseX = e.clientX; var mouseY = e.clientY; console.log(`x: ${mouseX} / y: ${mouseY}`);}) 123456789var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');canvas.addEventListener('click', function (e) { var mouseX = e.clientX - ctx.canvas.offsetLeft; var mouseY = e.clientY - ctx.canvas.offsetTop; ctx.fillStyle = 'red'; // 마우스 클릭한 곳에서 사각형의 중심이 되어 생성 ctx.fillRect(mouseX - 10, mouseY - 10, 20, 20);}) 백그라운드 이미지 애니메이션 만들기이미지 애니메이션을 만들어보자. 스크롤 게임이나 기타 여러 게임에서 배경의 움직임은 공간을 넓게 쓰는 효과를주기 위해 사용하는 방법이다. 이미지 애니메이션 만들기12345678910111213var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var bgImages = new Image();bgImages.src = 'images/space.png';var x = 0;function animate() { ctx.drawImage(bgImages, x-- ,0); if (x &lt;= -600) { x = 0; }}var animateInterval = setInterval(animate, 30); 위 이미지는 넓이가 1200px 이다. 이미지가 절반 지나갔을 때 x 좌표값을 초기화 한다. 이미지를 키보드로 움직이기위 배경에 이어서 비행기 만들어보기12345678910111213141516171819202122232425262728293031323334353637383940414243var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var bgImage = new Image();bgImage.src = 'images/space.png';var fighterImage = new Image();fighterImage.src = 'images/fighter.png';var x = 0;function Background() { this.x = 0; this.y = 0; this.w = bgImage.width; this.h = bgImage.height; this.render = function () { ctx.drawImage(bgImage, this.x--, 0); if (this.x &lt; -600) { this.x = 0; } }}function Player() { this.x = 0; this.y = 0; this.w = fighterImage.width; this.h = fighterImage.height; this.render = function () { ctx.drawImage(fighterImage, this.x, this.y); }}var background = new Background();var player = new Player();player.x = 30;player.y = 150;function animate() { background.render(); player.render();}var animateInterval = setInterval(animate, 30); 배경 움직이는 소스(Background) 비행기 그리는 소스(Player) 로 만들어 render 함수로 그려준다. 키보드를 눌렀을 때 비행기가 움직이도록 하기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var bgImage = new Image();bgImage.src = 'images/space.png';var fighterImage = new Image();fighterImage.src = 'images/fighter.png';var speed = 5;var keyCodeValue;function Background() { this.x = 0; this.y = 0; this.w = bgImage.width; this.h = bgImage.height; this.render = function () { ctx.drawImage(bgImage, this.x--, 0); if (this.x &lt; -600) { this.x = 0; } }}function Player() { this.x = 0; this.y = 0; this.w = fighterImage.width; this.h = fighterImage.height; this.render = function () { ctx.drawImage(fighterImage, this.x, this.y); }}var background = new Background();var player = new Player();player.x = 30;player.y = 150;// animate 함수에서 매 시간당 업데이트 되는 것을 체크한다.function update() { switch (keyCodeValue) { case 'W': player.y -= speed; break; case 'S': player.y += speed; break; case 'A': player.x -= speed; break; case 'D': player.x += speed; break; }}function animate() { background.render(); player.render(); update();}var animateInterval = setInterval(animate, 30);// 키보드를 클릭하였을때 반응document.addEventListener('keydown', function (e) { // 키보드의 키값을 가져온다. keyCodeValue = String.fromCharCode(e.keyCode);});// 키보드 해제document.addEventListener('keyup', function () { keyCodeValue = ''}); 비행기가 화면에서 움직일 속도를 speed 변수로 선언한다. update 함수를 실행하는 동안에 키보드를 누르면 wasd 키를 확인하여 비행기의 좌표값에 속도를 더해서 변경한다. JSON 객체와 배열 처리하기JSON 객체를 배열로 처리하여 사각형을 캔버스에 그리기123456789101112var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var buildings = [ {id: \"house\", x: 50, y:100, w:50, h:50, bg: 'magenta'}, {id: \"hospital\", x: 150, y:100, w:50, h:50, bg: 'green'}, {id: \"firestation\", x: 250, y:100, w:50, h:50, bg: 'orange'},];for (var i = 0; i &lt; buildings.length; i++) { var b = buildings[i]; ctx.fillStyle = b.bg; ctx.fillRect(b.x, b.y, b.w, b.h); JSON 객체를 배열로 처리하여 이미지 그리기1234567891011121314151617181920var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var buildings = [ {id: \"Airport\", x: 50, y:50, w:64, h:64, sx:0, sy:0}, {id: \"Bank\", x: 150, y:50, w:64, h:64, sx:100, sy:0}, {id: \"CarRepair\", x: 250, y:50, w:64, h:64, sx:200, sy:0}, {id: \"GasStation\", x: 50, y:150, w:64, h:64, sx:300, sy:0}, {id: \"Hospital\", x: 150, y:150, w:64, h:64, sx:400, sy:0}, {id: \"Temple\", x: 250, y:150, w:64, h:64, sx:500, sy:0},];var buildingImage = new Image();buildingImage.src = 'images/buildings.png';buildingImage.onload = function () { for (var i = 0; i &lt; buildings.length; i++) { var b = buildings[i]; ctx.drawImage(buildingImage, b.sx, b.sy, b.w, b.h, b.x, b.y, b.w, b.h); }} 마우스 충돌 체크하기위의 빌딩 소스를 이어서 진행한다. 결과 화면에서 빌딩의 위치를 가지고 있는 json 객체 데이터의 좌표를 체크하여 마우스를 클릭한 좌표와 비교하고빌딩의 이름을 가져와 화면에 출력한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var buildings = [ {id: \"Airport\", x: 50, y:50, w:64, h:64, sx:0, sy:0}, {id: \"Bank\", x: 150, y:50, w:64, h:64, sx:100, sy:0}, {id: \"CarRepair\", x: 250, y:50, w:64, h:64, sx:200, sy:0}, {id: \"GasStation\", x: 50, y:150, w:64, h:64, sx:300, sy:0}, {id: \"Hospital\", x: 150, y:150, w:64, h:64, sx:400, sy:0}, {id: \"Temple\", x: 250, y:150, w:64, h:64, sx:500, sy:0},];// 배경 이미지var bgImage = new Image();bgImage.src = 'images/background.png';// 빌딩 이미지var buildingImage = new Image();buildingImage.src = 'images/buildings.png';buildingImage.onload = function () { ctx.drawImage(bgImage, 0, 0); for (var i = 0; i &lt; buildings.length; i++) { var b = buildings[i]; ctx.drawImage(buildingImage, b.sx, b.sy, b.w, b.h, b.x, b.y, b.w, b.h); }};document.addEventListener('click', function (e) { var mouseX = e.clientX - ctx.canvas.offsetLeft; var mouseY = e.clientY - ctx.canvas.offsetTop; for (var i = 0; i &lt; buildings.length; i++) { var bData = buildings[i]; // 마우스 좌표를 체크하여 빌딩의 이름을 가져온다. if ( mouseX &gt;= bData.x &amp;&amp; mouseX &lt; bData.x + bData.w &amp;&amp; mouseY &gt;= bData.y &amp;&amp; mouseY &lt; bData.y + bData.h ) { ctx.clearRect(100, 260, 200, 30); ctx.fillStyle = 'yellow'; ctx.fillRect(100, 260, 200, 30); ctx.fillStyle = '#6495ED'; ctx.textAlign = 'center'; ctx.font = 'bold 20px Arial, sans-serif'; ctx.fillText(bData.id, 200, 280); } }}) 참조: HTML5 캔버스github","link":"/2020/06/07/Canvas%EC%9D%98-%EA%B8%B0%EC%B4%88-3/"},{"title":"Deno 스탠다드 라이브러리 사용해보기","text":"최근 Node 의 단점들을 보완한 Deno 가 정식 릴리즈 되었다. 아직 1 버전 으로 실제 회사나 프로젝트에서 쓰기는무리가 있겠지만, 버전이 올라가면서 안정적으로 되면 Node 를 대체할 수도 있을거라고 생각한다. Deno 가 왜 좋은지, 어떤 장점과 이점이 있는지는 검색해보면 많이 있다. 나는 이런 이론 말고 직접 한번 써보고 싶었다. Deno 는 standard Library(이하 std) 라고 직접 몇몇 기능을 가진 함수들을 제공한다. 예를 들면 date 관련 utils,uuid 관련 utils 함수를 제공해준다. 오늘은 이 std 기능들 중 유용한 것들을 직접 구현해보려 한다. 들어가기 앞서 Deno 는 기본적으로 ts 를 쓸 수 있으며 top-level-await 를 제공해 주므로 async 없이 await 쓰는걸많이 볼 것이다. top-level-await 참고 PermissionNode 와 비교하여 가장 큰 특징으로 꼽히는 것이 바로 이 Permission 이다. Node 는 파일 실행시 모든 권한이 허용 되어있다. 하지만 Deno 는 상황에 맞는 권한을 항상 허용해 주어야 한다. deno 는 deno run [flag] [파일명] 으로 실행한다. flag description –allow-read 읽기 권한 허용 –allow-write 쓰기 권한 허용 –allow-net network 권한 허용(ex. port 열기) –allow-env 환경 접근 권한 허용 –allow-run 실행 중인 하위 프로세스 허용 –allow-all(-A) 모든 권한 허용 file 생성, 복사std 말고 Deno 가 기본적으로 내장하고 있는 기능이다. 1234const encoder = new TextEncoder();const text = encoder.encode(\"hello deno!\");await Deno.writeFile(\"hello.txt\", text); Deno 의 writeFile 을 사용하여 file 을 생성한다. Deno 함수는 기본적으로 promise 로 이루어져 있다. script1deno run --allow-write createFile.ts 123let file = await Deno.open(\"hello.txt\");await Deno.copy(file, Deno.stdout);file.close(); 위에서 생성한 file 을 복사한다. 실행해보면 console 에 hello deno! 가 찍힌다. script1deno run --allow-read copyFile.ts archivearchive 는 tar 와 untar 기능을 갖고있다. tar123456789101112import { Tar } from \"https://deno.land/std/archive/tar.ts\";const tar = new Tar();const content = new TextEncoder().encode(\"Deno.land\");await tar.append(\"deno.txt\", { reader: new Deno.Buffer(content), contentSize: content.byteLength,});const writer = await Deno.open(\"./out.tar\", { write: true, create: true });await Deno.copy(tar.getReader(), writer);writer.close(); Deno.land 라는 text 파일을 생성 후 같은 경로에 이 파일을 포함하고 있는 out.tar 를 생성한다. writer open 을 한 후 마지막에 close 를 해줘야한다. 위 코드에서는 파일을 생성해 주기 때문에 --allow-write 를 해주어야 한다.script1deno run --allow-write tar.ts untar1234567891011121314151617181920212223242526272829303132import { Untar } from \"https://deno.land/std/archive/tar.ts\";import { ensureFile } from \"https://deno.land/std/fs/ensure_file.ts\";import { ensureDir } from \"https://deno.land/std/fs/ensure_dir.ts\";const reader = await Deno.open(\"./out.tar\", { read: true });const untar = new Untar(reader);for await (const entry of untar) { console.log(entry); // metadata /* TarEntry { fileName: \"deno.txt\", fileMode: 511, mtime: 1593911999, uid: 0, gid: 0, type: \"file\", fileSize: 9 } */ if (entry.type === \"directory\") { await ensureDir(entry.fileName); continue; } await ensureFile(entry.fileName); const file = await Deno.open(entry.fileName, { write: true }); // &lt;entry&gt; is a reader await Deno.copy(entry, file);}reader.close(); tar.ts 에서 생성한 out.tar 를 압축 해제하는 기능이다. untar 과정은 out.tar untar -&gt; 파일들을 읽어옴 -&gt; 파일을 같은 경로에 생성 순으로 이루어 진다. 이 순으로 인해읽기와 쓰기 권한을 허용해 주어야 한다. script1deno run --allow-read --allow-write untar.ts datetimestring data 를 Date 객체로 변환해주는 간단한 날짜 관련 기능이다. 123456789101112131415import { parseDate, parseDateTime, dayOfYear, currentDayOfYear,} from \"https://deno.land/std/datetime/mod.ts\";console.log(parseDate(\"20-01-2019\", \"dd-mm-yyyy\")); // output : new Date(2019, 0, 20)console.log(parseDate(\"2019-01-20\", \"yyyy-mm-dd\")); // output : new Date(2019, 0, 20)console.log(parseDateTime(\"01-20-2019 16:34\", \"mm-dd-yyyy hh:mm\")); // output : new Date(2019, 0, 20, 16, 34)console.log(parseDateTime(\"16:34 01-20-2019\", \"hh:mm mm-dd-yyyy\")); // output : new Date(2019, 0, 20, 16, 34)console.log(dayOfYear(new Date(\"2020-05-05T10:24:00\"))); // output: 126console.log(currentDayOfYear()); // output: ** depends on when you run it :) ** parseDate: 날짜까지만 Date 객체로 변환한다. (DateFormat) parseDateTime: 시간까지 Date 객체로 변환한다. (DateTimeFormat) dayOfYear: 1월 1일을 기준으로 넘겨준 날짜가 몇일이 지났는지 리턴해준다. currentDayOfYear: 1월 1일을 기준으로 현재 몇일이 지났는지 리턴해준다. httpport 를 사용하여 server 를 실행시켜주거나, cookie 등 http 와 관련된 함수들을 제공한다. serve12345678import { serve } from \"https://deno.land/std/http/server.ts\";const server = serve({ port: 8000 });console.log(\"http://localhost:8000/\");for await (const req of server) { req.respond({ body: \"Hello World\\n\" });} script1deno run --allow-net serve.ts serve 함수를 실행하여 server 를 시작한다. 현재는 option 으로 port 만 넘겨주었지만, hostname, HTTPS 를 위한certFile, keyFile 도 제공해 준다. server 의 req 를 잡아와 respond 함수를 실행해 줌으로써 8000 번 port 에 접속해보면 해당 문구가 찍히는 것을확인할 수 있다. UUIDuuid (v1, v4, v5) 생성 함수를 제공한다. 123456789import { v4 } from \"https://deno.land/std/uuid/mod.ts\";// Generate a v4 uuidconst myUUID = v4.generate();console.log(myUUID);// Validate a v4 uuidconst isValid = v4.validate(myUUID);console.log(isValid); // output: true script1deno run uuid.ts ws웹 소켓 기능도 제공해준다. std 의 코드 양이 많으므로 std 에서 제공해주는 코드를 실행해보는것으로 대체해 보려한다.deno 는 현재 경로의 파일 뿐만 아니라 http 요청을 통해서도 실행이 가능하다. 우선 ws server 를 실행시켜보자. script1234567deno run --allow-net https://deno.land/std/ws/example_server.ts``` 실행시켜보면 socket connected! 라는 문구가 뜨면 성공이다. 이 후 터미널을 새로 열어 client server 를 실행해준다.```shell scriptdeno run --allow-net https://deno.land/std/ws/example_client.ts ws connected! 가 뜨면 성공이다. 이제 client 에서 text 를 입력하고 엔터를 눌러보면 server console 에 해당 문구가찍히는것을 확인할 수 있다. conclusion위의 스탠다드 라이브러리는 deno 에서 제공해주는것에 일부분에 불과하다. 자주 사용될 것만 우선 정리해둔 것이다.직접 공식문서를 확인해 보는것을 추천한다.","link":"/2020/07/05/Deno-%EC%8A%A4%ED%83%A0%EB%8B%A4%EB%93%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/"},{"title":"deno oak framework","text":"Deno 의 framework 를 사용하여 API 서버를 구축해보려한다. 현재 기준(2020/07/05) 수 많은 framework 가 있지만oak 가 제일 인기 많고 잘 만들어져 있다고 한다. 사용법이 express 와 비슷해서 인기가 많아진 것 같지만oak 에서 제공해주는 example 을 직접 구현해 보려 한다. server12345678import { Application,} from \"https://deno.land/x/oak/mod.ts\";const app = new Application();console.log(`Server is listening on port 8000`);await app.listen({ port: 8000 }); oak 에서 제공해주는 Application 을 사용하여 서버를 실행한다. 이때 listen 함수는 promise 기 때문에await 을 붙여줘서 실행하면 된다. script1deno run --allow-net server.ts 이렇게 서버를 실행해보면 에러가 발생한다. 이 에러는 현재 request 에 대한 처리나 route 가 없어서 발생하는에러이므로 일단 다음 단계로 넘어가서 추가해주면 된다. routes123456789101112import { Router,} from \"https://deno.land/x/oak/mod.ts\";const router = new Router();app.use(router.routes());app.use(router.allowedMethods());router.get(\"/\", (context) =&gt; { context.response.body = \"Hello deno, oak\";}); oak 에서 Router 를 가져와 router 를 생성해준다. 이후 app middleware 에 등록해 주는것이다.이때 app.use 를 사용해서 등록하는데 express 와 동일하다. router.routes() 는 router 의 path 를 등록해주는 것이고, allowedMethods() 는 해당 path 의 모든 http method 를허용해 주는 것이다. 이후 express 의 router 와 동일하게 router.get 함수를 이용하여 router 를 등록해 줄 수 있다.차이점은 두번째 parameter 함수다. 기존에는 (req, res, next) 형식의 parameter 를 사용했었는데, oak 는 이것을context 하나의 객체로 사용한다. destructuring 을 사용하여 쓸 수도 있어 더 편해진것 같다. 이제 다시 서버를 시작해보면 에러가 사라지고 8000번에 접속해보면 정상 작동하는것을 확인할 수 있다. route 와 server 분리를 위해 routes.ts 파일을 생성해준다. 1234567891011import { Router,} from \"https://deno.land/x/oak/mod.ts\";const router = new Router();router.get(\"/\", (context) =&gt; { context.response.body = \"Hello deno, oak\";});export default router; 이후 server.ts 에서 해당 router 를 import 해준다. 12345678910111213import { Application,} from \"https://deno.land/x/oak/mod.ts\";import router from \"./routes.ts\";const app = new Application();app.use(router.routes());app.use(router.allowedMethods());console.log(`Server is listening on port 8000`);await app.listen({ port: 8000 }); route method1234567891011121314151617181920212223interface Book { id: string; title: string; author: string;}let books: Book[] = [ { id: \"1\", title: \"Book 1\", author: \"one\", }, { id: \"2\", title: \"Book 2\", author: \"two\", }, { id: \"3\", title: \"Book 3\", author: \"three\", },]; 위 interface 구조를 가진 책 데이터를 사용하여 진행하려고 한다. 12345678910111213141516router .get(\"/\", ({ response }) =&gt; { response.body = \"Hello deno, oak\"; }) .get(\"/books\", ({ response }) =&gt; { response.body = books; }) .get(\"/books/:id\", ({ params, response }) =&gt; { const book: Book | undefined = books.find((book) =&gt; book.id === params.id); if (book) { response.body = book; } else { response.body = \"존재하지 않는 책\"; response.status = 404; } }); /books 로 get 요청이 들어오면 전체 책을 return 해준다. body 에 담아주면 된다. /books/:id 로 get 요청이 들어오면 params 의 id 에 맞는 책을 찾아 return 해준다.이때 express 와 다른점은 request 에 params 정보가 들어있는 것이 아니라 context 에서 따로 제공해주기 때문에request 를 사용할 필요가 없다. id 에 맞는 책을 찾아 리턴해주는데 존재하지 않은 책이면 status 를 404 로 리턴해준다. post1234567891011121314.post(\"/books\", async ({ request, response }) =&gt; { const body = await request.body(); if (!request.hasBody) { response.status = 400; response.body = \"데이터 없음\"; } else { const book: Book = body.value; book.id = v4.generate(); books.push(book); response.status = 201; response.body = book; } }) express 에서는 body-parser 를 사용하여 request.body 로 body 데이터를 받아오지만, oak 는 request.body promise로 제공해준다. 또한 request.hasBody 를 사용하여 body 데이터가 있는지 확인할 수 있다. DB 를 사용하는 경우 id 생성을 자동으로 해줄 수 있지만 지금은 std 의 uuid 를 사용하여 id 를 생성해줬다. postman 으로 테스트해보면 정상 동작 하는것을 확인할 수 있다. put12345678910111213141516171819.put(\"/books/:id\", async ({ params, request, response }) =&gt; { const bookIndex: number = books.findIndex((book) =&gt; book.id === params.id); if (bookIndex &lt; 0) { response.body = \"존재하지 않는 책\"; response.status = 404; } else { if (!request.hasBody) { response.status = 400; response.body = \"데이터 없음\"; } else { const body = await request.body(); const book: Book = body.value; const preBook: Book = books[bookIndex]; books.splice(bookIndex, 1, { ...preBook, ...book }); response.status = 201; response.body = books[bookIndex]; } } }) Array.findIndex 를 사용하여 책을 찾아주고 수정해 주었다. delete12345678910.delete(\"/books/:id\", async ({ params, response }) =&gt; { const bookIndex: number = books.findIndex((book) =&gt; book.id === params.id); if (bookIndex &lt; 0) { response.body = \"존재하지 않는 책\"; response.status = 404; } else { books.splice(bookIndex, 1); response.status = 200; } }) delete method 도 express 와 동일한 방식으로 사용가능 하다. middlewarelogger123456789101112131415161718192021222324import { green, cyan, bold,} from \"https://deno.land/std@0.60.0/fmt/colors.ts\";import { Context,} from \"https://deno.land/x/oak/mod.ts\";const logger = async (context: Context, next: () =&gt; Promise&lt;void&gt;) =&gt; { await next(); const rt = context.response.headers.get(\"X-Response-Time\"); console.log( `${green(context.request.method)} ${ cyan(decodeURIComponent(context.request.url.pathname)) } - ${ bold( String(rt), ) }`, );};export default logger; 123456789101112import { Context,} from \"https://deno.land/x/oak/mod.ts\";const responseTime = async (context: Context, next: () =&gt; Promise&lt;void&gt;) =&gt; { const start = Date.now(); await next(); const ms = Date.now() - start; context.response.headers.set(\"X-Response-Time\", `${ms}ms`);};export default responseTime; console 에 기록을 남기는 Logger 함수와 응답시간을 추적하는 ResponseTime 함수를 생성해 준 후express middleware 등록과 같이 app.use 를 사용해서 등록해준다. 12app.use(logger);app.use(responseTime); 404 (not found)123456789101112import { Status, Context,} from \"https://deno.land/x/oak/mod.ts\";const notFound = ({ request, response }: Context) =&gt; { response.status = Status.NotFound; response.body = `&lt;html&gt;&lt;body&gt;&lt;h1&gt;404 - Not Found&lt;/h1&gt;&lt;p&gt;Path &lt;code&gt;${request.url}&lt;/code&gt; not found.`;};export default notFound; 존재하지 않는 페이지에 접근했을때 실행되는 함수이다. route middleware 밑에 등록해주면 된다. 1234app.use(router.routes());app.use(router.allowedMethods());// A basic 404 pageapp.use(notFound); error handler123456789101112131415161718192021222324252627282930import { isHttpError, Context,} from \"https://deno.land/x/oak/mod.ts\";const errorHandler = async ( { request, response }: Context, next: () =&gt; Promise&lt;void&gt;,) =&gt; { try { await next(); } catch (err) { if (isHttpError(err)) { response.status = err.status; const { message, status, stack } = err; if (request.accepts(\"json\")) { response.body = { message, status, stack }; response.type = \"json\"; } else { response.body = `${status} ${message}\\n\\n${stack ?? \"\"}`; response.type = \"text/plain\"; } } else { console.log(err); throw err; } }};export default errorHandler; errorHandler 함수를 만들어서 middleware 에 등록시켜준다.추가로 router context 에 throw 라는 함수를 제공해준다. 이 함수를 실행하여 에러를 발생 시킬 수 있다. 1context.throw(Status.NotFound, \"존재하지 않는 책\"); Github code 보기oak routing server","link":"/2020/07/05/deno-oak-framework/"},{"title":"함수형 프로그래밍","text":"함수형 프로그래밍이란 무엇이고, 왜 중요한가?수학에서 함수란 무엇인가? 수학에서 함수는 다음과 같이 나타낼 수 있다. f(X) = Y 이 수식은 “X 를 인자로 하는 함수 f 가 있으며, 출력 Y 를 반환한다” 라고 할 수 있다. X 와 Y 에는 모든 수가 가능하다.매우 간단한 정의지만 다음과 같은 중요한 점이 있다. 함수는 인자를 가져야 한다. 함수는 값을 반환해야 한다. 함수는 외부가 아닌 자체 인자를 받아서만 동작한다. 주어진 X 하나에 Y 는 오직 하나다. 함수형 프로그래밍 기술은 수학에서의 함수와 그 아이디어에서 발생했다. 위 정의를 가져와 자바스크립트 함수 예제를살펴본다. 123// 세금 계산 함수var percentValue = 5;var calculateTax = value =&gt; value / 100 * (100 + percentValue); calculateTax 함수의 경우 원하는 계산을 정확히 수행한다. 즉, 값을 통해 이 함수를 호출할 수 있고, 계산된 값을 반환한다.수학에서 함수의 핵심 정의는 함수 논리가 외부에 의존하지 않는다는 점이다. 하지만 calculateTax 함수는 전역 변수인percentValue 에 의존한다. 따라서 이 함수는 수학적으로는 실제 함수라고 할 수 없다. percentValue 변수를 함수 인자로 이동시킨다. 1var calculateTax = (value, percentValue) =&gt; value / 100 * (100 + percentValue); 이제 calculateTax 함수를 실제 함수라 할 수 있다. 수정해서 얻은 것은 calculateTax 함수 안에 있는 전역 변수의 접근을막을 수 있다. 즉, 함수 안에 있는 전역 변수의 접근을 없애 테스팅을 좀 더 쉽게 할 수 있다. 함수형 프로그래밍이란 각 함수의 입력에 의존해 동작하는 함수를 생성하는 형태다. 이는 함수를 여러 번 호출했을 때도 동일한 결과를 반환할 수 있게 한다.또한 함수 외부의 데이터 변경이 불가하므로 캐시할 수 있고, 테스트할 수 있는 코드를 작성할 수 있게 한다. 참조 투명성함수의 정의에서 모든 함수가 동일한 입력에 대해 동일한 값을 반환받도록 선언했다. 함수의 이러한 속성을 참조 투명성 이라 한다. 참조 투명성 예제1var identity = i =&gt; i; 간단한 identity 함수를 정의헀다. 이 함수는 무조건 입력한 값을 전달받아 반환한다. 이 함수는 입력 인자 i에 의해서만 동작하며, 함수 내의 전역 참조는 없다.이 함수는 참조 투명성 조건을 충족한다. 명령형, 선언형, 추상화함수형 프로그래밍은 선언 가능하고, 추상화된 코드 작성에 관한 것이다. 이 두 개념을 이해해야 한다. 리스트와 배열이 있으며, 배열을 통해 반복적으로 콘솔에 값을 출력한다고 해보자.1234var array = [1,2,3];for(i=0; i&lt;array.length; i++) { console.log(array[i]);} 정상적으로 동작하지만 문제에 접근하려고 구현했는지 정확히 알아야 한다. 예를 들어 배열 길이의 인덱스를 계산하고 내용을 출력하고자 for 문을 암묵적으로 작성했다.여기서 작업은 배열 요소를 출력하는 것이다. 하지만 컴파일러에게 어떤 작업을 해야하는지 알려주는 것처럼 보인다. 이 경우 컴파일러에게 “배열의 길이를 가져온 후 배열을반복하면서 인덱스를 사용해 배열의 각 요소를 얻어오라” 라고 알려주고 있다. 이를 명령형 방법이라 한다. 명령형(imperative) 프로그래밍이란 컴파일러에게 특정 작업을어떻게 해야 하는지 알려주는 것이다. 선언형(declartive) 프로그래밍에서는 컴파일러가 어떻게 작업해야 하는지보다 어떤 것이 필요한지가 중요하다. “어떻게” 라는 부분은 일반적인 함수내에 추상화된다. 12var array = [1,2,3];array.forEach(element =&gt; console.log(element)); 위의 코드는 명령형 코드와 동일한 출력을 보여준다. 하지만 여기서 “배열의 길이를 가져온 후 배열을 반복하면서 인덱스를 사용해 배열의 각 요소를 얻어오라”에서 “어떻게”부분이 생략됐다. 추상화된 함수를 사용해서 개발자가 “어떻게” 라는 부분을 다루고, 직접 문제를 걱정할 필요가 없게 됐다. 함수형 프로그래밍은 코드의 다른 부분을 재사용하는 추상적인 방법으로 함수를 생성하는 것이다. 순수 함수순수 함수(pure function) 란 주어진 입력에 대해 동일한 출력을 반환하는 함수다. 1var double = value =&gt; value * 2; double 함수는 주어진 입력에 대해 항상 동일한 출력을 반환하므로 순수 함수다. 순수 함수는 참조 투명성을 만족한다. 따라서 망설임 없이 double(5) 를 10으로 바꿀 수 있다. 순수 함수는 테스트하기 편한 코드다.순수하지 않은 함수는 문제를 일으킬 수 있다. 123// 세금 계산 함수var percentValue = 5;var calculateTax = value =&gt; value / 100 * (100 + percentValue); 외부 환경에 의존해 논리를 계산하므로, calculateTax 함수는 순수하지 않은 함수다. 함수는 동작하지만 테스트하기는 어렵다.percentValue 에 의존하기 때문에 이 값이 변경되면 테스트를 통과할 수 없게 될 수 있다. 1var calculateTax = (value, percentValue) =&gt; value / 100 * (100 + percentValue); 위의 함수처럼 외부 환경 종속성을 제거해서 이 문제를 해결할 수 있다. 순수 함수는 외부 환경 변수를 바꿔서는 안 된다. 순수 함수는 외부 변수에 의존해서는 안 되고 외부 변수도 변경해서는 안된다. 12345var global = \"globalValue\";var badFunction = value =&gt; { global = \"changed\"; return value * 2;} badFunction 함수가 전역 변수 global 값을 changed 로 바꿔서 호출하면 문제가 생길 수 있다. global 변수에 의존하는다른 함수가 있다고 하면, badFunction 호출은 다른 함수의 동작에 영향을 줄 수 있다. 이러한 함수는 코드 테스트를 힘들게 한다.테스트 외에도 시스템에 영향을 주어 디버깅을 어렵게 한다. 이상적인 코드순수 함수를 사용하면 이상적인 코드를 간단히 만들 수 있다. 1var double = value =&gt; value * 2; 함수 이름에서 알 수 있듯이 주어진 수를 두 배로 하는 함수다. 사실상 참조 투명성 개념을 사용해 double 함수 호출을 동일한 결과로 대체할 수 있다.코드상 부수 효과가 있는 함수라면 다른 개발자가 이해하기 어렵다. 순수 함수 기반 코드는 읽고, 이해하고 테스트하기 쉽다.순수 함수든 어떤 함수든 항상 의미 있는 이름이어야 한다. 병렬 코드순수 함수는 병렬로 코드를 실행할 수 있게 한다. 순수 함수는 해당 환경을 전혀 변동시키지 않으므로 동기화를 걱정할 필요가 없다. 123456789let global = \"something\";let function1 = input =&gt; { global = \"somethingFalse\";}let function2 = () =&gt; { if (global === \"something\") { // ... }} function1 과 function2 를 병렬로 실행하게 된다면 두 함수 모두 전역 변수인 global 에 의존하므로, 병렬로 이 함수를 실행하면문제가 발생할 수 있다. 12345678let function1 = (input, global) =&gt; { global = \"somethingFalse\";}let function2 = global =&gt; { if (global === \"something\") { // ... }} 두 함수의 global 변수를 인자로 옮겨 순수 함수로 만들었다. 이제 아무 문제 없이 두 함수를 동시에 실행할 수 있다. 캐시순수 함수는 항상 주어지니 입력에 대해 동일한 출력을 반환하므로, 함수 출력을 캐시할 수 있다. 시간이 많이 소요되는 연산을 처리하는함수가 있다고 해보자. 123var longRunningFunction = ip =&gt; {} 다음과 같이 longRunningFunction 함수의 호출 결과를 모두 유지하는 저장 객체를 갖고 있다고 가정해보자. 1var longRunningFnBookKeeper = {2: 3, 4: 5 ...} longRunningFnBookKeeper 는 간단한 자바스크립트 객체로, longRunningFunction 함수를 호출해 입력과 출력 값을 모두 보유하게 된다.이제 기존 함수를 실행하기 전에 longRunningFnBookKeeper 에 키가 있는지 확인할 수 있다. 12var longRunningFnBookKeeper = {2: 3, 4: 5};longRunningFnBookKeeper.hasOwnProperty(ip) ? longRunningFnBookKeeper[ip] : longRunningFnBookKeeper[ip] = longRunningFunction(ip); 실제 함수를 호출하기 전에 해당 ip 와 함께 함수의 결과가 저장 객체에 있는지 확인한다. 함수 결과가 저장 객체에 있다면 반환하고, 그렇지 않으면 기존 함수를 호출해 저장 객체에서도결과를 갱신한다. 적은 코드로도 쉽게 캐시할 수 있는 함수 호출을 만들 수 있다는 것을 살펴봤다. 이것이 바로 순수 함수의 역할이다. 참조: 함수형 자바스크립트 입문 2/e","link":"/2020/08/23/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"고차 함수","text":"언어로서의 자바스크르빝는 함수를 데이터로 다룬다. 데이터 영역에서 함수를 전달할 수 있는 강력한 개념도 있다.인자로 다른 함수를 전달받는 함수를 고차 함수라고 한다. 데이터의 이해프로그래머로서 데이터로 동작되는 프로그램을 알아야한다. 데이터는 실행할 프로그램을 작성하는 과정에 있어 중요하다.따라서 모든 프로그래밍 언어는 프로그래머가 작업할 데이터를 제공한다. 자바스크립트 데이터형 이해자바스크립트는 다음과 같은 데이터형을 지원한다. 숫자 number 문자열 string 불리언 boolean 객체 object 널 null 정의되지 않은 undefined 자바스크립트에서는 함수군의 데이터형도 있다. function 데이터형의 경우 string 과 유사하므로, 변수를 전달하고저장 등을 할 수 있다. 함수는 프로그래밍 언어가 다른 데이터형으로 사용하게 허용하게 하는 경우 중요하므로, 변수로 지정되고,인자를 전달하고, 문자열 및 숫자 데이터와 유사하게 다른 함수에서 반환될 수 있다. 함수 저장함수는 데이터다. 즉 변수로 저장할 수 있다. 1let fn = () =&gt; {}; fn 은 함수 데이터형을 가리키는 변수다. 다음 코드를 실행해서 fn 이 function 형인 것을 확인할 수 있다. 12typeof fn=&gt; \"function\" 함수 전달인자의 데이터형을 콘솔에 출력하는 함수를 만들어 본다. 1let tellType = arg =&gt; console.log(typeof arg); tellType 함수에 인자를 하나 전달해본다. 123let data = 1;tellType(data);=&gt; number 이번에는 함수에 대한 참조를 변수로 전달해본다. 123let dataFn = () =&gt; console.log('function');tellType(dataFn);=&gt; function 마지막으로 tellType 이 전달된 인자를 실행하게 변경해본다. 1234567let tellType = arg =&gt; { if(typeof arg === 'function') { arg(); } else { console.log('data: ', arg); } } 전달된 arg 변수가 function 형인지 확인해서 function 형이라면 호출한다. 함수 반환자바스크립트에서 함수는 간단한 데이터이므로, 다른 함수로도 반환이 가능하다. 문자열을 반환하는 crazy 함수1let crazy = () =&gt; { return String; } crazy 함수는 String 함수를 가리키는 함수 참조를 반환한다. 12crazy();=&gt; String() { [native code] } crazy 함수 호출은 String 함수를 반환한다. 단순히 함수 참조를 반환하며, 함수를 실행하지는 않는다.반환된 함수 참조로 다음과 같이 호출할 수 있다. 12345678// 1.let fn = crazy();fn(\"HOC\");=&gt; \"HOC\"// 2.crazy()(\"HOC\");=&gt; \"HOC\" 추상화와 고차 함수일반적으로, 고차 함수는 일반적인 문제를 추출하고자 작성된다. 다시 말해 고차 함수는 추상화를 정의하는 것이다. 고차 함수를 통한 추상화forEach 를 고차 함수를 사용하여 만든 예제 코드를 살펴본다. 12345const forEach = (array, fn) =&gt; { for(let i=0; i &lt; array.length; i++) { fn(array[i]); }} 위의 forEach 함수는 배열을 순회하는 문제를 추상화했다. forEach API 사용자는 forEach 함수에서 순회 부분이어떻게 구현됐는지 이해할 필요가 없으므로, 이 문제를 추상화했다. forEach 는 기본적으로 배열을 순회한다.배열 말고 객체를 순회하는 단계는 다음과 같다. 주어진 객체의 모든 키를 반복 키에 해당하는 각 객체를 확인 2단계가 확인되면 키의 값을 얻음. forEachObject 추상화1234567const forEachObject = (obj, fn) =&gt; { for (var property in obj) { if (obj.hasOwnProperty(property)) { fn(property, obj[property]); } }} forEachObject 실행1234let object = {a:1, b:2};forEachObject(object, (k,v) =&gt; console.log(k + \":\" + v));=&gt; a:1=&gt; b:2 forEach 와 forEachObject 함수 모두 고차 함수이므로, 개발자가 순회 부분을 추상화해 함수를 전달받아 작업할 수 있다.이러한 순회 함수를 추상화했으므로, 간결한 코드로 철저히 테스트할 수 있다.이번에는 제어 흐름을 다루는 추상화 방법을 구현해본다. unless 함수는 참이나 거짓인 논리형을 취하는 간단한 함수다. unless123const unless = (predicate, fn) =&gt; { if (!predicate) fn();} unless 함수를 활용하여 배열에서 짝수를 찾고자 간단한 코드를 작성할 수 있다. 123456const array = [1,2,3,4,5,6,7];forEach(array, number =&gt; { unless((number % 2), () =&gt; { console.log(number, ' is even'); });}); 데이터를 저장하는 모든 곳에서 함수를 이용할 수 있다. 다시 말해 함수는 저장할 수도, 전달될 수도, 다른 데이터형처럼 재할당될 수도 있다.자바스크립트의 이 강력한 특징은 함수가 다른 함수에 전달되는 고차 함수를 가능케한다. 고차 함수란 다른 함수를 인자로 취하고함수를 반환하는 함수라는 것을 기억해야 한다. 참조: 함수형 자바스크립트 입문 2/e","link":"/2020/08/30/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/"},{"title":"클로저와 고차 함수","text":"함수형 프로그래밍 개념을 알기 전에 자바스크립트에서 클로저를 이해해야 한다. 클로저의 이해클로저간단히 얘기해 클로저는 내부 함수다. 내부 함수란 간단히 다음과 같이 다른 함수 내에 있는 함수다. 12345function outer() { function inner() { }} 이것이 클로저다. inner 함수를 클로저 함수라고 부른다. 클로저는 스코프 사슬(scope chain) 에 접근할 수 있어 유용하다.기술적으로 클로저는 세 개의 스코프를 갖고 있다. 자체 선언 내에서 선언된 변수 전역 변수에 접근 외부 함수의 변수에 접근 간단한 예제를 통해 세 부분을 각각 알아본다. 12345678function outer() { function inner() { let a = 5; console.log(a); } inner();} inner 함수가 호출되면 콘솔에 5가 출력된다. 이는 첫 번째에 살펴본 관점 때문이다. 클로저 함수는 각기 선언된 변수에모두 접근할 수 있다. 123456789let global = \"global\";function outer() { function inner() { let a = 5; console.log(global); } inner();} inner 함수가 실행되면 global 변수가 출력된다. 따라서 클로저는 전역 변수에 접근할 수 있다. 12345678910let global = \"global\";function outer() { let outer = \"outer\"; function inner() { let a = 5; console.log(outer); } inner();} inner 함수가 실행되면 outer 값을 출력한다. 적절한 결과인 것 같지만, 클로저의 중요한 속성이다.클로저는 외부 함수의 변수에 접근했다. 여기서 외부 함수는 클로저 함수를 감싸는 함수다. 어디서부터 생겨났을까?123456789var fn = (arg) =&gt; { let outer = \"Visible\"; let innerFn = () =&gt; { console.log(outer); console.log(arg); } return innerFn;} 코드는 간단하다. innerFn 은 fn 에 대한 클로저 함수이고, fn 이 호출되면 innerFn 울 반환한다. 1234var closureFn = fn(5);closureFn();// Visible// 5 동작되는 과정을 살펴보면 다음과 같다. var closureFn = fn(5); 코드가 호출되면 fn 은 인자 5를 받고 호출된다. fn 정의가 이뤄지면 innerFn 을 반환한다. innerFn 이 반환되면 자바스크립트 실행 엔진은 innerFn 을 클로저로 보며, 그에 따라 스코프를 지정한다. 앞에서 살펴 봤듯이 클로저는 세 개의 스코프 레벨에 접근할 수 있다. 반환된 함수 참조는 closureFn 내에 저장된다. sortBy 함수 살펴보기sortBy1234567891011121314151617181920212223const sortBy = (property) =&gt; { return (a, b) =&gt; { const result = (a[property] &lt; b[property]) ? -1 : (a[property] &gt; b[property]) ? 1 : 0; return result; }}const people = [ {firstname: \"lee\"}, {firstname: \"park\"}, {firstname: \"kim\"}];console.log(people.sort(sortBy(\"firstname\")));/**[ {firstname: \"kim\"}, {firstname: \"lee\"}, {firstname: \"park\"}]*/ 참조: 함수형 자바스크립트 입문 2/e","link":"/2020/08/30/%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/"},{"title":"커링과 부분 적용","text":"커링(currying)이 어떤 의미이며 어디서 사용되는지 이해한 후 부분 적용(partial application) 이라는또 다른 함수형 프로그래밍 개념을 살펴본다. 커링과 부분 적용 모두 함수 합성을 사용할 때 이해해야 한다. 용어 정리단항 함수함수 인자를 하나만 취하는 함수를 단항 함수(unary function) 라 한다. 1const identity = x =&gt; x; 이항 함수두 개의 인자를 취하는 함수를 이항 함수(binary function) 라 한다. 1const add = (x,y) =&gt; x + y; 가변 인자 함수가변 인자 함수란 다양한 개수의 인자를 취하는 함수다. 이전 자바스크립트 버전에서는arguments 를 사용해 인자의 가변 개수를 알 수 있었다. 1234function variadic(a) { console.log(a); console.log(arguments);} arguments 를 사용해 추가적인 인자를 알아서 함수로 호출할 수 있다. 이 기술을 사용해 ES5 버전에서가변 인자 함수를 사용할 수 있다. 하지만 ES6 를 사용하면 동일한 결과를 얻는데 전개 연산자(spread operator) 를사용해야 한다. 1234const variadic = (a, ...variadic) =&gt; { console.log(a); console.log(variadic);} 커링커링을 간단하게 얘기하자면 n개 인자의 함수를 중첩된 단항 함수로 변화시키는 과정이다. 1const add = (x,y) =&gt; x + y; 간단한 add 함수다. 이 함수를 add(1,1) 처럼 사용해 2라는 결과를 도출할 수 있다.아래는 커링된 add 함수 형태이다. 1const addCurried = x =&gt; y =&gt; x + y; addCurried 함수는 add 의 커링 버전이다. addCurried 를 단일 인자로 호출하면 다음과 같다. 12addCurried(4)=&gt; fn = y =&gt; 4 + y 클로저 개념으로 x 값을 가져와 함수를 반환한다. 원하는 결과를 얻으려면 다음과 같이 addCurried 함수를 호출할 수 있다. 12addCurrried(4)(4);// 8 일부러 add 함수를 변경해 addCurried 함수로 두 개의 인자를 받고 중첩된 단항 함수로 만들었다.두 인자를 취하는 함수에서 하나의 인자를 취하는 함수로 바꾸는 과정을 커링이라고 한다. 1234567const curry = binaryFn =&gt; { return function (firstArg) { return function (secondArg) { return binaryFn(firstArg, secondArg); } }} 이제 curry 함수를 사용해 add 함수를 다음과 같은 형태로 변환할 수 있다. 1234const add = (x, y) =&gt; x + y;const autoCurriedAdd = curry(add);autoCurriedAdd(2)(2);// 4 커링은 n 개 인자의 함수를 중첩된 단항 함수로 변환하는 과정이다. curry 함수 정의를 살펴보면 이항 함수를 중첩된 함수로 변환해 하나의 인자만 취하므로, 중첩된 단항 함수를 반환한다. 커링을 사용하는 경우테이블을 만드는 함수를 생성한다고 해본다. 예를 들어 tableOf2, tableOf3, tableOf4 를 생성한다. 커링이 없는 테이블 함수1234567const tableOf2 = y =&gt; 2 * y;const tableOf3 = y =&gt; 3 * y;const tableOf4 = y =&gt; 4 * y;tableOf2(4) // 8tableOf3(4) // 12tableOf4(4) // 16 이제 테이블의 개념을 다음과 같이 단일 함수로 일반화 할 수 있다. 1const genericTable = (x,y) =&gt; x * y; 다음과 같이 tableOf2 를 얻고자 genericTable 을 사용할 수 있다. 123genericTable(2, 2); // 4genericTable(2, 3); // 6genericTable(2, 4); // 8 tableOf3 과 tableOf4 도 동일하다. 패턴을 인식했으면 tableOf2 에는 첫 번째 인자로 2,tableOf3 에는 3처럼 계속 채운다. 커링을 이용해 문제를 해결한다고 생각할 수 있다. 커링을 이용한 테이블 함수123const tableOf2 = curry(genericTable)(2);const tableOf3 = curry(genericTable)(3);const tableOf4 = curry(genericTable)(4); 커링 다시 살펴보기앞에서 정의했던 curry 는 함수 하나에만 적용했다. 여러 개의 함수에 적용하는 방법은 간단하지만curry 를 구현하는 데 있어 중요하다. 우선 아래의 코드처럼 첫 번째 규칙을 추가한다. 12345let curry = fn =&gt; { if (typeof fn !== \"function\") { throw Error(\"No function provided\"); }} 이 코드에서 2와 같은 정수를 가진 curry 함수를 호출하면 에러가 발생한다.커링된 함수에 다음으로 필요한 것은 커링된 함수에 모든 인자를 제공받았다면전달된 인자로 실제 함수를 호출하는 기능이다. 123456789let curry = fn =&gt; { if (typeof fn !== \"function\") { throw Error(\"No function provided\"); } return function curriedFn(...args) { return fn.apply(null, args); }} 이제 다음과 같은 multiply 라는 하무가 있다면 다음과 같이 새로운 curry 함수를 사용할 수 있다. 12345const multiply = (x,y,z) =&gt; x * y * z;curry(multiply)(1,2,3);// 6curry(multiply)(1,2,0);// 0 curry(multiply)(1,2,3) 에서 args 는 [1,2,3] 을 기라키며, fn 에서 apply를 호출하므로결과는 다음 호출과 동등하다. 1multiply(1,2,3); 이제 n개 인자 함수를 중첩된 단항 함수로 변환한다. 1234567891011121314let curry = fn =&gt; { if (typeof fn !== \"function\") { throw Error(\"No function provided\"); } return function curriedFn(...args) { if (args.length &lt; fn.length) { return function(...curryArgs) { return curriedFn.apply(null, args.concat(curryArgs)); }; } return fn.apply(null, args); }} 1234567if (args.length &lt; fn.length) { // 1 return function(...curryArgs) { return curriedFn.apply( null, args.concat(curryArgs) // 3 ); // 2 };} 이 코드 어떻게 동작하는지 살펴본다. …args 를 통해 전달된 인자 길이가 함수 인자 리스트 length 보다 작은지 확인한다. 작다면 if 블록으로 진입하며그렇지 않다면 이전과 같이 전체 함수 호출로 돌아간다. if 블록에 들어가면 apply 함수를 사용해 curriedFn 을 재귀적으로 호출한다. concat 함수를 사용해 전달된 인자를 한 번에 연결시키고 curriedFn 을 재귀적으로 호출한다. 전달된 모든 인자가연결돼 있고 재귀적으로 호출되므로 1번 조건문에 도달하지 못한다. 이를 이해하면 curry 함수를 사용해 multiply 함수를 실행할 수 있다. 12345curry(multiply)(1)(2)(3);// 6let curriedMul3 = curry(multiply)(3);let curriedMul2 = curriedMul3(2);let curriedMul1 = curriedMul2(1); 주의할 부분은 curry 함수가 n개 인자의 함수를 예제에서 보듯이 단항 함수로 호출되는 함수로 변환한다는 점이다. 커링의 실제 사용일상적으로 커링을 어떻게 사용하는지 알아본다. 배열 요소에서 숫자 검색숫자를 요소로 갖는 배열을 검색해본다. 123let match = curry(function(expr, str) { return str.match(expr);}) 반환된 match 함수는 커링된 함수다. 첫 번째 인자 expr 을 요소가 숫자를 갖고 있는지 확인하는정규 표현식인 /[0-9]+/ 로 나타낼 수 있다. 1let hasNumber = match(/[0-9]+/); 다음으로 커링된 filter 함수를 생성한다. 123let filter = curry(function(f, arr) { return arr.filter(f);}); hasNumber 와 filter 를 사용해 findNumbersInArray 라는 새로운 함수를 만들 수 있다. 123let findNumbersInArray = filter(hasNumber);findNumbersInArray([\"js\", \"number1\"]);// [\"number1\"] 배열 제곱배열의 요소를 제곱하는 함수를 curry 를 사용해 만들어 본다. 1234567let map = curry(function (f, arr) { return arr.map(f);});let squareAll = map(x =&gt; x * x);squareAll([1,2,3]);// [1, 4, 9] 데이터 플로우배열 같은 자료 구조를 다루면서 최종 인자가 squareAll, findNumbersInArray 와 같은 코드전체에 사용할 수 있는 재사용 가능한 함수를 생성할 수 있게 해야한다. 부분 적용함수 인자를 부분적으로 적용할 수 있는 partial 이라는 다른 함수를 살펴본다. 10ms 마다 일련의 연산을 처리한다고 가정해본다. 다음과 같이 setTimeout 함수를 사용한다. 12setTimeout(() =&gt; console.log(\"Do X task\"), 10);setTimeout(() =&gt; console.log(\"Do Y task\"), 10); 보다시피 setTimeout 함수가 호출될 때마다 10을 전달한다. curry 함수는 가장 왼쪽에서 가장 오른쪽의 리스트로인자를 적용하기 때문에 이 문제에 curry 를 사용할 수 없다. 다른 해결 방법은 setTimeout 함수를 감싸 함수 인자의오른쪽이 최우선으로 되게 하는것이다. 123456const setTimeoutWrapper = (time, fn) =&gt; { setTimeout(fn, time);}const delayTenMs = curry(setTimeoutWrapper)(1000);delayTenMs(() =&gt; console.log(\"Do X task\"));delayTenMs(() =&gt; console.log(\"Do Y task\")); 이는 필요에 따라 적용된다. 하지만 이 문제는 setTimeoutWrapper 라는 래퍼를 한 단계 위에 작성해야 한다.여기가 부분 적용 기술이 사용되는 곳이다. 부분 함수 구현부분 적용 기술이 어떻게 작동되는지 완전히 이해하기 위해 partial 함수를 작성해본다. 123456789101112const partial = function (fn, ...partialArgs) { let args = partialArgs; return function(...fullArgs) { let arg = 0; for (let i=0; i &lt; args.length &amp;&amp; arg &lt; fullArgs.length; i++) { if (args[i] === undefined) { args[i] = fullArgs[arg++]; } } return fn.apply(null, args); }} setTimeout 문제에 partial을 적용해본다. 12let delayTenMs = partial(setTimeout, undefined, 10);delayTenMs(() =&gt; console.log(\"Do Y task\")); 12345partial(setTimeout, undefined, 10);// 다음let args = partialArgs=&gt; args = [undefined, 10]; args 값을 기억하는 클로저 함수를 반환한다. 반환된 함수는fullArgs 라는 인자를 받고 이 인자를 전달해서 delayTenMs 와 같은 함수를 호출한다. 1234567delayTenMs(() =&gt; console.log(\"Do Y task\"));// fullArgs 는 다음을 가리킨다.// [() =&gt; console.log(\"Do Y task\")]// 클로저를 사용하는 args 는 다음을 가진다.// args = [undefined, 10] 이제 for 루프 안에서는 함수에 필요한 인자 배열을 생성하고 반복한다. 1234567891011121314for (let i=0; i &lt; args.length &amp;&amp; arg &lt; fullArgs.length; i++) { if (args[i] === undefined) { args[i] = fullArgs[arg++]; }}// args = [undefined, 10]// fullArgs = [() =&gt; console.log(\"Do Y task\")]args[0] =&gt; undefined === undefined // true// if 루프 내부args[0] = fullArgs[0]=&gt; args[0] = () =&gt; console.log(\"Do Y task\")=&gt; args = [() =&gt; console.log(\"Do Y task\"), 10] args 안에 필요한 인자가 있으면 fn.apply(null, args) 로 함수를 호출한다.n개 인자의 모든 함수에 partial 을 적용할 수 있다. 참조: 함수형 자바스크립트 입문 2/e","link":"/2020/09/06/%EC%BB%A4%EB%A7%81%EA%B3%BC-%EB%B6%80%EB%B6%84-%EC%A0%81%EC%9A%A9/"},{"title":"컴포지션과 파이프라인","text":"함수형 컴포지션(functional composition) 이란 간단히 함수형 프로그래밍에서 컴포지션이라 일컫는다.컴포지션 아이디어의 이론과 간단한 예제를 살펴본 후 compose 함수를 작성해본다. 함수형 컴포지션map, filter 다시 살펴보기123456let addressBooks = [ {id: 111, title: \"C# 6.0\", author: \"ANDREW TROELSEN\", rating: [4.7], reviews: [{good: 4, excellent: 12}]}, {id: 222, title: \"Efficient Learning Machines\", author: \"Rahul Khanna\", rating: [4.5], reviews: []}, {id: 333, title: \"Pro Angular JS\", author: \"Adam Freeman\", rating: [4.0], reviews: []}, {id: 444, title: \"Pro ASP.NET\", author: \"Adam Freeman\", rating: [4.2], reviews: [{good: 14, excellent: 12}]},] 위와 같은 구조의 배열 객체가 있을때 review 값이 4.5 이상인 addressBooks 객체에서 title 과 author 를 뽑아내려고 한다. 12345678910111213141516171819202122232425262728const map = (array, fn) =&gt; { let results = []; for (const value of array) { results.push(fn(value)); } return results;}const filter = (array, fn) =&gt; { let results = []; for (const value of array) { if (fn(value)) results.push(value); } return results;}map(filter(addressBooks, book =&gt; book.rating[0] &gt; 4.5), book =&gt; { return {title: book.title, author: book.author}})/**[ { title: \"C# 6.0\", author: \"ANDREW TROELSEN\" }]*/ filter 함수에서 온 데이터는 map 함수에 입력 인자로 전달된다.compose 함수를 사용하여 함수의 출력을 다른 함수의 입력으로 전달해 두 함수를 연결하는 함수를 만들 수 있다. compose 함수compose 함수의 생성은 쉽고 직관적이다. compose 함수는 함수의 출력을 받아 다른 함수에 입력한다. 간단한 compopse 함수 정의1const compose = (a, b) =&gt; c =&gt; a(b(c)) compose 함수는 간단하고 필요한 처리를 한다. 두 함수 a와 b를 받아 하나의 인자 c를 갖는 함수를 반환한다.c에 값을 넣어 compose 함수를 호출하면 c의 입력을 갖는 함수 b를 호출하고, 함수 b의 출력은 함수 a의 입력으로 간다.이것이 바로 compose 함수의 정의다. compose 함수 다루기주어진 수를 반올림한다고 해보자. 이 수는 실수이므로, 수를 실수형으로 변환한 후 Math.rorund 를 호출한다.compose 없이 다음과 같이 할 수 있다. 12let data = parseFloat(\"3.56\");let number = Math.round(data); 위에서 보듯이 data 는 Math.round 에 입력으로 전달된다. 이를 compose 함수를 사용하면 다음과 같다. 12let number = compose(Math.round, parseFloat);// number = c =&gt; Math.round(parseFloat(c)) 이것이 바로 함수형 컴포지션이다. 두 함수를 구성해 새로운 함수를 구현했다.여기서 중요한 것은 Math.round 와 parseFloat 함수는 number 함수가 호출되기 전까지 실행되지 않는다. 구원자: curry와 partial함수가 하나의 인자를 입력으로 취할 때 두 함수를 합성할 수 있다. 하지만 여러 인자를 갖는 함수가 있으므로 항상 그렇지는 않다.이러한 함수는 curry와 partial 함수 중 하나를 사용해 합성할 수 있다. 위에서 addressBooks 의 평점 코드를 다시 확인해보자. 123map(filter(addressBooks, book =&gt; book.rating[0] &gt; 4.5), book =&gt; { return {title: book.title, author: book.author}}) map 과 filter 함수 모두 두 인자를 취하는 함수다. 첫 번째 인자는 배열이고 두 번째 인자는 이 배열을 연산하는 함수다.따라서 이 두 함수를 직접 합성할 수는 없다. 하지만 partial 함수에서 도움을 받을 수 있다. 1234567891011121314let addressBooks = [ {id: 111, title: \"C# 6.0\", author: \"ANDREW TROELSEN\", rating: [4.7], reviews: [{good: 4, excellent: 12}]}, {id: 222, title: \"Efficient Learning Machines\", author: \"Rahul Khanna\", rating: [4.5], reviews: []}, {id: 333, title: \"Pro Angular JS\", author: \"Adam Freeman\", rating: [4.0], reviews: []}, {id: 444, title: \"Pro ASP.NET\", author: \"Adam Freeman\", rating: [4.2], reviews: [{good: 14, excellent: 12}]},]let filterOutStandingBooks = book =&gt; book.rating[0] === 5;let filterGoodBooks = book =&gt; book.rating[0] &gt; 4.5;let filterBadBooks = book =&gt; book.rating[0] &lt; 3.5;let projectTitleAndAuthor = book =&gt; ({title: book.title, author: book.author});let projectAuthor = book =&gt; ({author: book.author});let projectTitle = book =&gt; ({title: book.title}); 위 코드와 같이 rating 을 기반으로 도서를 필터링하는 여러 작은 함수와 결과를 도출해내는 함수를 만들었다.이제 문제를 해결하는 데 다음과 같이 compose 와 partial 을 사용할 수 있다. 123let queryGoodBooks = partial(filter, undefined, filterGoodBooks);let mapTitleAndAuthor = partial(map, undefined, projectTitleAndAuthor);let titleAndAuthorForGoodBooks = compose(mapTitleAndAuthor, queryGoodBooks); compose 함수는 하나의 인자를 갖는 함수를 합성한다. 하지만 filter 와 map 둘 다 인자 두 개를 취하고, 직접적으로 이를 합성할 수 없다. 여기서 보듯이 이것이 바로 map 과 filter 의 두 번째 인자에 부분적으로 적용하고자 partial 함수를 사용한 이유다.이제 compose 함수를 사용하여 반환된 함수를 실행하여 결과를 확인한다. 123456789titleAndAuthorForGoodBooks(addressBooks);/**[ { title: \"C# 6.0\", author: \"ANDREW TROELSEN\" }]*/ compose 함수 없이도 원하는 것을 정확히 얻을 수 있었다. 하지만 최종 합성된 버전인 titleAndAuthorForGoodBooks 는 훨씬 가독성이 높고 간결하다.필요에 따라 compose 를 사용해 재구성할 수 있는 작은 함수 단위를 생성하는 것이 중요하다. 여러 함수 합성현재 compose 함수 형태는 주어진 두 함수만 합성한다. compose 를 다시 작성하여 함수가 세 개, 네 개 이상 합성해보려 한다. 각 함수의 출력을 다른 함수의 입력으로 전달해야 한다고 해보자. n개의 함수 호출을 한 번으로 축소하는 reduce 함수를 사용해 compose 함수를 작성해본다. 1234567891011121314151617181920const reduce = (array, fn, initialValue) =&gt; { let accumlator; if (initialValue !== undefined) accumlator = initialValue; else accumlator = array[0]; if (initialValue === undefined) { for (let i = 1; i &lt; array.length; i++) { accumlator = fn(accumlator, array[i]); } } else { for (const value of array) { accumlator = fn(accumlator, value); } } return accumlator;};const _compose = (...fns) =&gt; value =&gt; reduce(fns.reverse(), (acc, fn) =&gt; fn(acc), value); fns.reverse() 를 통해 함수 배열을 뒤집고, acc 값을 인자로 전달하면 각 함수에서 다른 함수로 호출하는(acc, fn) =&gt; fn(acc) 로 함수를 전달한다. 123456789let splitIntoSpaces = str =&gt; str.split(\" \");let count = array =&gt; array.length;const countWords = _compose(count, splitIntoSpaces);console.log(countWords(\"hello your reading about composition\")) // 5let oddOrEven = ip =&gt; ip % 2 === 0 ? \"even\" : \"odd\";const oddOrEvenWords = _compose(oddOrEven, count, splitIntoSpaces);console.log(oddOrEvenWords(\"hello your reading about composition\")); // \"odd\" 파이프라인과 시퀀스함수가 오른쪽부터 먼저 실행돼 가장 왼쪽의 함수가 마지막으로 실행될 때까지 다음 함수에 데이터를 전달하므로,compose 의 데이터 플로우가 오른쪽에서 왼쪽임을 살펴봤다. 일부 사람은 가장 왼쪽의 함수가 먼저 실행되고 오른쪽 함수가 마지막에 실행되는 방법을 선호한다.compose 함수와 동일한 동작을 하지만 데이터 플로우가 반대인 pipe 라는 새로운 함수를 구현할 것이다. 데이터를 왼쪽에서 오른쪽으로 이동하는 과정을 파이프라인 또는 짝수 시퀀스(even sequences) 라 부른다.파이프 라인이나 시퀀스라고 편하게 부를 수도 있다. 파이프 구현pipe 함수는 compose 함수의 복제 형태다. 변경된 부분은 데이터 플로우 뿐이다. 1const pipe = (...fns) =&gt; value =&gt; reduce(fns, (acc,fn) =&gt; fn(acc), value); compose 와의 차이는 reverse 함수를 쓰지 않는다는 것이다. 123const pipe = (...fns) =&gt; value =&gt; reduce(fns, (acc,fn) =&gt; fn(acc), value);const oddOrEvenWords = pipe(splitIntoSpaces, count, oddOrEven);console.log(oddOrEvenWords(\"hello your reading about composition\")); // \"odd\" 컴포지션은 결합 법칙이 성립한다.함수형 컴포짓션은 항상 결합 법칙을 따른다. 예를 들어 일반적으로 결합 법칙은 표현의 결과를괄호 순서에 상관없이 동일하게 한다. 12x * (y * z) = (x * y) * z = xyzcompose(f, compose(g, h)) == compose(compose(f, g), h) 함수형 컴포지션은 결합이 가능하다. 따라서 compose 를 결합해 함수를 그룹화할 수 있다. 12345let countWords = compose(count, splitIntoSpaces);let oddOrEvenWords = compose(oddOrEven, countWords);let countOddOrEven = compose(oddOrEven, count);let oddOrEvenWords = compose(countOddOrEven, splitIntoSpaces); 작은 함수를 생성하는 것은 컴포지션의 핵심이다. compose 는 결합할 수 있으므로 동일한 결과로 걱정 없이컴포지션을 통해 작은 함수를 생성할 수 있다. 파이프라인 연산자기본 함수를 합성하고 연결하는 또 다른 방법은 파이프라인 연산자를 사용하는 것이다.새로운 파이프라인 연산자는 자바스크립트 함수 코드의 가독성과 확장성을 높인다. 단일 문자열 인자를 연산하는 다음 수학 함수를 살펴보자. 123const double = n =&gt; n * 2;const increment = n =&gt; n + 1;const ntimes = n =&gt; n * n; 모든 숫자로 이 함수를 호출하려면 일반적으로 다음 문장을 작성해야 한다. 1ntimes(double(increment(double(double(5))))); 위의 결과 값은 1764 이다. 이 문장의 문제는 가독성인데, 연산자의 시퀀스와 연산자의 개수는 가독성을 떨어뜨린다.코드 가독성을 높이고자 유사한 연산자가 추가됐다. 이 연산자의 이름은 파이프라인(또는 이항 연산자) 이며 |&gt; 이다. 15 |&gt; double |&gt; double |&gt; increment |&gt; double |&gt; ntimes 파이프라인 연산자가 단항 함수에서만 동작하지만, 다항 인자 함수에서도 사용할 수 있는 방법이 있다. 12345678let add = (x,y) =&gt; x + y;let double = x =&gt; x + x;// 파이프 연산자 없이add(10, double(7));// 파이프 연산자 사용7 |&gt; double |&gt; (_ =&gt; add(10, _)); compose 디버깅identity 라는 간단한 함수를 만들어 인자를 받고 동일한 인자를 반환한다. 1234const identity = it =&gt; { console.log(it); return it;} 간단하게 console.log을 추가해 값을 출력하고 이를 다시 반환한다. 1compose(oddOrEven, count, splitIntoSpaces)(\"Test string\"); 위와 같은 compose 함수가 있다고 했을때 identity 를 플로우 내에 추가하여 디버깅할 수 있다. 1compose(oddOrEven, count, identity, splitIntoSpaces)(\"Test string\"); 참조: 함수형 자바스크립트 입문 2/e","link":"/2020/09/13/%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EA%B3%BC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/"},{"title":"함수자","text":"프로그래밍에서 에러 핸들링이라는 또 다른 중요한 개념을 살펴본다. 함수자(functor) 라는 새로운 개념을 살펴본다. 이 개념은 순수하게 함수형 방법으로 에러를 다룰 수 있도록 도와준다.함수자의 아이디어를 이해한 후 두 가지의 실제 함수자(MayBe, Either) 를 구현해본다. 함수자 함수자란 기본적인 객체로, 객체 내의 각 값을 실행할 때 새로운 객체를 실행하는 map 함수를 구현한다. 함수자는 컨테이너다.간단하게 함수자는 값을 갖고 있는 컨테이너다. 함수자가 기본적인 객체라는 정의에서 이를 살펴봤다. 값을 갖는간단한 컨테이너를 생성해보며, Container 를 호출해본다. 123456789101112const Container = function (val) { this.value = val;}let testValue = new Container(3);=&gt; Container(value: 3)let testObj = new Container({a: 1});=&gt; Container(value: {a: 1})let testArray = new Container([1, 2]);=&gt; Container(value: [1, 2]) Container는 값을 내부에 저장하기만 한다. 자바스크립트의 모든 데이터형을 전달할 수 있으며, Container 는 이를 저장한다.Container 프로토타입에서 of 라고 불리는 유용한 메서드를 생성할 수 있는데, new 키워드를 사용하지 않아도새로운 Container 를 생성할 수 있게 해준다. 123456789101112131415161718192021Container.of = function(value) { return new Container(value);}let testValue = Container.of(3);=&gt; Container(value: 3)let testObj = Container.of({a: 1});=&gt; Container(value: {a: 1})let testArray = Container.of([1, 2]);=&gt; Container(value: [1, 2])Container.of(Container.of(3))/** Container { value: Container { value: 3 } }*/ map 구현map 함수가 필요한 이유는 현재 Container에 저장된 값에 대한 함수를 호출할 수 있다. map 함수는 Container 의 값을 받고 해당 값에 전달된 함수를 적용한 후 결과를 다시 Container 에 넣는다. 123456Container.prototype.map = function(fn) { return Container.of(fn(this.value));}let double = x =&gt; x + x;console.log(Container.of(3).map(double)) // 6 map 함수는 Container 에 전달된 함수의 결과를 다시 반환하며, 이는 결합 연산을 가능케한다. 123Container.of(3).map(double) .map(double) .map(double) MayBe 함수자MayBe 함수자는 좀 더 함수적인 방법으로 코드의 에러를 핸들링할 수 있다. MayBe 구현MayBe는 함수자의 한 형태로, map 함수를 다른 방식으로 구현한다. 1234567const MayBe = function(val) { this.value = val;}MayBe.of = function(val) { return new MayBe(val);} Container 구현과 유사하다. map 을 구현해본다. 1234567MayBe.prototype.isNothing = function() { return (this.value === null || this.value === undefined);}MayBe.prototype.map = function(fn) { return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this.value));} map 함수는 Container 의 map 함수와 유사하다. MayBe 의 map 은 전달된 함수에 isNothing 함수를적용해 컨테이너 값이 null 인지 undefined 인지 먼저 확인한다. 간단한 사용자 케이스MayBe 는 map 에 전달된 함수를 적용하기 전에 null 과 undefined 를 확인한다.이는 에러 핸들링을 다루는 가장 강력한 추상화다. 1MayBe.of(\"string\").map(x =&gt; x.toUpperCase()); 위 코드에서 x 가 null 또는 undefined 일때 에러가 발생한다. 하지만 MayBe 에서 래핑하므로, 에러가 발생하지 않는다. 1234567891011MayBe.of(\"George\") .map(x =&gt; x.toUpperCase()) .map(x =&gt; `Mr. ${x}`);// MayBe { value: \"Mr. GEORGE\" }MayBe.of(\"George\") .map(() =&gt; undefined) .map(x =&gt; `Mr. ${x}`);// MayBe { value: null } 모든 map 함수가 null/undefined 를 받는 것과 상관없이 호출된다. 이 처럼 MayBe 는 모든 undefined, null 에러를 쉽게 다룰 수 있게 도와준다. Either 함수자Either 함수자를 만들어 분기 문제를 해결한다. 12345MayBe.of(\"George\") .map(() =&gt; undefined) .map(x =&gt; `Mr. ${x}`);// MayBe { value: null } 원하는 결과가 출력됐다. 하지만 어떤 분기 (map 호출 두개) 가 undefined 및 null 값에 부합하지 않는지 알 수 없다.어떤 분기에서 발생된 문제 인지 찾으려면 MayBe 의 분기를 일일이 파고 들어야 한다. 이것이 Either 가 필요한 이유다. Either 구현Either 함수자 부분 정의1234567891011121314151617181920212223const Nothing = function(val) { this.value = val;}Nothing.of = function(val) { return new Nothing(val);}Nothing.prototype.map = function(f) { return this;}const Some = function(val) { this.value = val;}Some.of = function(val) { return new Some(val);}Some.prototype.map = function(fn) { return Some.of(fn(this.value));} 위 구현에는 Some 과 Nothing 이라는 두 함수가 있다. Some 함수는 Container 를 이름만 바꿔 복사한 것이다.Nothing 의 map 은 주어진 함수를 실행하지 않고 오히려 반환한다. 다시 말해 Some 에서는 함수를 실행하는데,Nothing 에서는 실행하지 않는다. 1234Some.of(\"test\").map(x =&gt; x.toUpperCase());// Some {value: \"TEST\"}Nothing.of(\"test\").map(x =&gt; x.toUpperCase());// Nothing {value: \"test\"} Some 과 Nothing 두 객체를 Either 객체로 감싼다. 1234567const Either = { Some, Nothing}Either.Some.of(\"Super\").map(x =&gt; `${x}star`)Either.Nothing.of(\"Super\").map(x =&gt; `${x}star`) Either 는 MayBe 와 다르게 예외 상황이 발생한 경우 null 값이 반환되지 않는다. 1234const books = [ { id: 'book1', title: 'coding with javascript', author: 'Chris Minnick, Eva Holland' }, { id: 'book2', title: 'speaking javaScript', author: 'Axel Rauschmayer' },]; 위와 같이 데이터가 있다고 할때, author 가 Axel 을 포함하고 있을 경우 console.log, 포함하고 있지 않을 경우 console.error 를 실행하고자 한다.console.error 를 실행할때 MayBe 같은 경우 null 값이 반환되기 때문에 어떤 값에서 에러가 발생하는지 알 수 없다.이 문제를 Either 를 사용하여 해결하고자 한다. 우선 Some 과 Nothing 에 다음과 같은 프로토타입을 추가해준다. 12345678910111213Some.prototype.isNothing = function() { return false}Some.prototype.isSome = function() { return true}Nothing.prototype.isNothing = function() { return true}Nothing.prototype.isSome = function() { return false} 123456789101112131415161718192021222324252627const findBookById = curry((id, books) =&gt; { return books.find((book) =&gt; book.id === id);});const validateBookAuthor = (book) =&gt; { return book.author.indexOf('Axel') === -1 ? Either.Nothing.of(book) : Either.Some.of(book);}const logByEitherStatus = (eitherBook) =&gt; { return eitherBook.isNothing ? console.error(`Author: ${eitherBook.value.author}`) : console.log(`Author: ${eitherBook.value.author}`)}const logBookAuthor = (bookId, books) =&gt; { return pipe( findBookById(bookId), validateBookAuthor, logByEitherStatus )(books)};logBookAuthor('book1', books);logBookAuthor('book2', books); validateBookAuthor 함수 부분에서 Axel 이 포함되어 있지 않은 경우 Nothing.of 를 실행하여 분기 처리를 해준다. 모나드 모나드(Monad) chain 메소드를 구현한 객체다. chain 메소드는 모나드가 가진 값에 함수를 적용해서 새로운 모나드(chain 을 갖고 있는)를 반환해야 한다. 모나드는 chain 메서드를 갖는 함수자다. 즉 이것이 모나드다. 1234567Maybe.prototype.join = function() { return this.isNothing() ? MayBe.of(null) : this.value;}MayBe.prototype.chain = function(f){ return this.map(f).join()} MayBe 함수자를 chain 을 추가해 모나드로 만들었다. 반복적인 map 이 중첩된 값에 매우 효율적이다. 참조: 함수형 자바스크립트 입문 2/e참조: nakta.log","link":"/2020/09/20/%ED%95%A8%EC%88%98%EC%9E%90/"}],"tags":[{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"syntax","slug":"syntax","link":"/tags/syntax/"},{"name":"deep-clone","slug":"deep-clone","link":"/tags/deep-clone/"},{"name":"Next.js","slug":"Next-js","link":"/tags/Next-js/"},{"name":"deploy Next.js","slug":"deploy-Next-js","link":"/tags/deploy-Next-js/"},{"name":"pm2","slug":"pm2","link":"/tags/pm2/"},{"name":"pm2-ecosystem","slug":"pm2-ecosystem","link":"/tags/pm2-ecosystem/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","link":"/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"파이프라인","slug":"파이프라인","link":"/tags/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8/"},{"name":"go 함수","slug":"go-함수","link":"/tags/go-%ED%95%A8%EC%88%98/"},{"name":"비동기와 _.go","slug":"비동기와-go","link":"/tags/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%99%80-go/"},{"name":"_.indent","slug":"indent","link":"/tags/indent/"},{"name":"Sequelize","slug":"Sequelize","link":"/tags/Sequelize/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"model 정의","slug":"model-정의","link":"/tags/model-%EC%A0%95%EC%9D%98/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"hexo 시작","slug":"hexo-시작","link":"/tags/hexo-%EC%8B%9C%EC%9E%91/"},{"name":"toBe","slug":"toBe","link":"/tags/toBe/"},{"name":"toEqual","slug":"toEqual","link":"/tags/toEqual/"},{"name":"toHaveBeenCalled","slug":"toHaveBeenCalled","link":"/tags/toHaveBeenCalled/"},{"name":"toHaveReturned","slug":"toHaveReturned","link":"/tags/toHaveReturned/"},{"name":"toError","slug":"toError","link":"/tags/toError/"},{"name":"jest globals 메서드","slug":"jest-globals-메서드","link":"/tags/jest-globals-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"describe","slug":"describe","link":"/tags/describe/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"jest 메서드","slug":"jest-메서드","link":"/tags/jest-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"expect","slug":"expect","link":"/tags/expect/"},{"name":"테스트 코드","slug":"테스트-코드","link":"/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"},{"name":"jasmine","slug":"jasmine","link":"/tags/jasmine/"},{"name":"BDD","slug":"BDD","link":"/tags/BDD/"},{"name":"spy","slug":"spy","link":"/tags/spy/"},{"name":"웹 사이트 최적화","slug":"웹-사이트-최적화","link":"/tags/%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"HTTP 요청 최소화","slug":"HTTP-요청-최소화","link":"/tags/HTTP-%EC%9A%94%EC%B2%AD-%EC%B5%9C%EC%86%8C%ED%99%94/"},{"name":"렌더링 성능 향상","slug":"렌더링-성능-향상","link":"/tags/%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81/"},{"name":"순수 함수","slug":"순수-함수","link":"/tags/%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98/"},{"name":"부수 효과","slug":"부수-효과","link":"/tags/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC/"},{"name":"변경 최소화","slug":"변경-최소화","link":"/tags/%EB%B3%80%EA%B2%BD-%EC%B5%9C%EC%86%8C%ED%99%94/"},{"name":"의존성 주입","slug":"의존성-주입","link":"/tags/%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/"},{"name":"TDD","slug":"TDD","link":"/tags/TDD/"},{"name":"렌더링","slug":"렌더링","link":"/tags/%EB%A0%8C%EB%8D%94%EB%A7%81/"},{"name":"리플로우","slug":"리플로우","link":"/tags/%EB%A6%AC%ED%94%8C%EB%A1%9C%EC%9A%B0/"},{"name":"리페인트","slug":"리페인트","link":"/tags/%EB%A6%AC%ED%8E%98%EC%9D%B8%ED%8A%B8/"},{"name":"React-Hooks","slug":"React-Hooks","link":"/tags/React-Hooks/"},{"name":"Hooks","slug":"Hooks","link":"/tags/Hooks/"},{"name":"hooks 사용방법","slug":"hooks-사용방법","link":"/tags/hooks-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95/"},{"name":"useReducer","slug":"useReducer","link":"/tags/useReducer/"},{"name":"useMemo","slug":"useMemo","link":"/tags/useMemo/"},{"name":"useCallback","slug":"useCallback","link":"/tags/useCallback/"},{"name":"useRef","slug":"useRef","link":"/tags/useRef/"},{"name":"useState","slug":"useState","link":"/tags/useState/"},{"name":"useEffect","slug":"useEffect","link":"/tags/useEffect/"},{"name":"useContext","slug":"useContext","link":"/tags/useContext/"},{"name":"네비게이션 타이밍","slug":"네비게이션-타이밍","link":"/tags/%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98-%ED%83%80%EC%9D%B4%EB%B0%8D/"},{"name":"프로세싱 모델","slug":"프로세싱-모델","link":"/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1-%EB%AA%A8%EB%8D%B8/"},{"name":"hooks 정의","slug":"hooks-정의","link":"/tags/hooks-%EC%A0%95%EC%9D%98/"},{"name":"성능 테스트","slug":"성능-테스트","link":"/tags/%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"memoization","slug":"memoization","link":"/tags/memoization/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"lifecycle","slug":"lifecycle","link":"/tags/lifecycle/"},{"name":"일급 함수","slug":"일급-함수","link":"/tags/%EC%9D%BC%EA%B8%89-%ED%95%A8%EC%88%98/"},{"name":"클로저","slug":"클로저","link":"/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"},{"name":"고차 함수","slug":"고차-함수","link":"/tags/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/"},{"name":"partial function","slug":"partial-function","link":"/tags/partial-function/"},{"name":"함수 조립","slug":"함수-조립","link":"/tags/%ED%95%A8%EC%88%98-%EC%A1%B0%EB%A6%BD/"},{"name":"once","slug":"once","link":"/tags/once/"},{"name":"skip","slug":"skip","link":"/tags/skip/"},{"name":"partial","slug":"partial","link":"/tags/partial/"},{"name":"compose","slug":"compose","link":"/tags/compose/"},{"name":"pipeline","slug":"pipeline","link":"/tags/pipeline/"},{"name":"pipe","slug":"pipe","link":"/tags/pipe/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"객체","slug":"객체","link":"/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"함수의 호이스팅","slug":"함수의-호이스팅","link":"/tags/%ED%95%A8%EC%88%98%EC%9D%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/"},{"name":"named function","slug":"named-function","link":"/tags/named-function/"},{"name":"call, apply, arguments, this","slug":"call-apply-arguments-this","link":"/tags/call-apply-arguments-this/"},{"name":"함수형 자바스크립트의 실용성 2","slug":"함수형-자바스크립트의-실용성-2","link":"/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%8B%A4%EC%9A%A9%EC%84%B1-2/"},{"name":"filter","slug":"filter","link":"/tags/filter/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"Storybook","slug":"Storybook","link":"/tags/Storybook/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"mdx","slug":"mdx","link":"/tags/mdx/"},{"name":"addon-docs","slug":"addon-docs","link":"/tags/addon-docs/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"recoil","slug":"recoil","link":"/tags/recoil/"},{"name":"atom","slug":"atom","link":"/tags/atom/"},{"name":"selector","slug":"selector","link":"/tags/selector/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"선 그리기","slug":"선-그리기","link":"/tags/%EC%84%A0-%EA%B7%B8%EB%A6%AC%EA%B8%B0/"},{"name":"사각형 그리기","slug":"사각형-그리기","link":"/tags/%EC%82%AC%EA%B0%81%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0/"},{"name":"원 그리기","slug":"원-그리기","link":"/tags/%EC%9B%90-%EA%B7%B8%EB%A6%AC%EA%B8%B0/"},{"name":"gradient","slug":"gradient","link":"/tags/gradient/"},{"name":"pattern","slug":"pattern","link":"/tags/pattern/"},{"name":"drawImage","slug":"drawImage","link":"/tags/drawImage/"},{"name":"fillText","slug":"fillText","link":"/tags/fillText/"},{"name":"strokeText","slug":"strokeText","link":"/tags/strokeText/"},{"name":"textAlign","slug":"textAlign","link":"/tags/textAlign/"},{"name":"textBaseline","slug":"textBaseline","link":"/tags/textBaseline/"},{"name":"shadow","slug":"shadow","link":"/tags/shadow/"},{"name":"translate","slug":"translate","link":"/tags/translate/"},{"name":"scale","slug":"scale","link":"/tags/scale/"},{"name":"rotate","slug":"rotate","link":"/tags/rotate/"},{"name":"transform","slug":"transform","link":"/tags/transform/"},{"name":"setTransform","slug":"setTransform","link":"/tags/setTransform/"},{"name":"getImageData","slug":"getImageData","link":"/tags/getImageData/"},{"name":"putImageData","slug":"putImageData","link":"/tags/putImageData/"},{"name":"animation","slug":"animation","link":"/tags/animation/"},{"name":"canvas event","slug":"canvas-event","link":"/tags/canvas-event/"},{"name":"canvas json","slug":"canvas-json","link":"/tags/canvas-json/"},{"name":"Deno std library","slug":"Deno-std-library","link":"/tags/Deno-std-library/"},{"name":"Deno REST API","slug":"Deno-REST-API","link":"/tags/Deno-REST-API/"},{"name":"oak","slug":"oak","link":"/tags/oak/"},{"name":"oak middleware","slug":"oak-middleware","link":"/tags/oak-middleware/"},{"name":"currying","slug":"currying","link":"/tags/currying/"},{"name":"sequence","slug":"sequence","link":"/tags/sequence/"},{"name":"functor","slug":"functor","link":"/tags/functor/"},{"name":"MayBe","slug":"MayBe","link":"/tags/MayBe/"},{"name":"Either","slug":"Either","link":"/tags/Either/"},{"name":"모나드","slug":"모나드","link":"/tags/%EB%AA%A8%EB%82%98%EB%93%9C/"}],"categories":[{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Deploy","slug":"Deploy","link":"/categories/Deploy/"},{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","link":"/categories/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"Sequelize","slug":"Sequelize","link":"/categories/Sequelize/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Jest","slug":"Jest","link":"/categories/Jest/"},{"name":"테스트 코드","slug":"테스트-코드","link":"/categories/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"},{"name":"웹 성능 이야기","slug":"웹-성능-이야기","link":"/categories/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%95%BC%EA%B8%B0/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Storybook","slug":"Storybook","link":"/categories/Storybook/"},{"name":"canvas","slug":"canvas","link":"/categories/canvas/"},{"name":"Deno","slug":"Deno","link":"/categories/Deno/"}]}